{
  "Title": "[08] Contracts cannot be upgraded",
  "Content": "\n### Lines of code\n\nhttps://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/bd6ee47162368e1999a0a5b8b17b701347cf9a7d/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L50C1-L54C41<br>\nhttps://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/bd6ee47162368e1999a0a5b8b17b701347cf9a7d/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L4C1-L12C1\n\n### Impact\n\nThe `LiquidInfrastructureERC20` has a version and judging by the comment, it seems the contracts are intended to be upgradeable, so as to seamlessly make updates to the contract while introducing a new version. \n\n```\n    /**\n     * @notice This is the current version of the contract. Every update to the contract will introduce a new\n     * version, regardless of anticipated compatibility.\n     */\n    uint256 public constant Version = 1;\n```\n\nBut the contract doesn't inherit any upgradeable OZ contracts, nor storage gaps:\n\n```\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./LiquidInfrastructureNFT.sol\";\n```\n\n### Recommended Mitigation Steps\n\nIf upgradeability is truly desired, inherit the upgradeable OZ contracts, and add storage gaps.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-02-althea-liquid-infrastructure",
  "Code": [
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.12; // Force solidity compliance\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./LiquidInfrastructureNFT.sol\";\n\n/**\n * @title Liquid Infrastructure ERC20\n * @author Christian Borst <christian@althea.systems>\n *\n * @dev An ERC20 contract used to earn rewards from managed LiquidInfrastructreNFTs.\n *\n * A LiquidInfrastructureNFT typically represents some form of infrastructure involved in an Althea pay-per-forward network\n * which frequently receives payments from peers on the network for performing an automated service (e.g. providing internet).\n * This LiquidInfrastructureERC20 acts as a convenient aggregation layer to enable dead-simple investment in real-world assets\n * with automatic revenue accrual. Simply by holding this ERC20 owners are entitled to revenue from the network represented by the token.\n *\n * Revenue is gathered from managed LiquidInfrastructureNFTs by the protocol and distributed to token holders on a semi-regular basis,\n * where there is a minimum number of blocks required to elapse before a new payout to token holders.\n *\n * Minting and burning of this ERC20 is restricted if the minimum distribution period has elapsed, and it is reenabled once a new distribution is complete.\n */\ncontract LiquidInfrastructureERC20 is\n    ERC20,\n    ERC20Burnable,\n    Ownable,\n    ERC721Holder,\n    ReentrancyGuard\n{\n    event Deployed();\n    event DistributionStarted();\n    event Distribution(address recipient, address[] tokens, uint256[] amounts);\n    event DistributionFinished();\n    event WithdrawalStarted();\n    event Withdrawal(address source);\n    event WithdrawalFinished();\n    event AddManagedNFT(address nft);\n    event ReleaseManagedNFT(address nft, address to);\n\n    address[] private distributableERC20s;\n    uint256[] private erc20EntitlementPerUnit;\n    address[] private holders;\n\n    /**\n     * @notice This is the current version of the contract. Every update to the contract will introduce a new\n     * version, regardless of anticipated compatibility.\n     */\n    uint256 public constant Version = 1;\n\n    /**\n     * @notice This collection holds the managed LiquidInfrastructureNFTs which periodically generate revenue and deliver\n     * the balances to this contract.\n     */\n    address[] public ManagedNFTs;\n\n    /**\n     * @notice This collection holds the whitelist for accounts approved to hold the LiquidInfrastructureERC20\n     */\n    mapping(address => bool) public HolderAllowlist;\n\n    /**\n     * @notice Holds the block of the last distribution, used for limiting distribution lock ups\n     */\n    uint256 public LastDistribution;\n\n    /**\n     * @notice Holds the minimum number of blocks required to elapse before a new distribution can begin\n     */\n    uint256 public MinDistributionPeriod;\n\n    /**\n     * @notice When true, locks all transfers, mints, and burns until the current distribution has completed\n     */\n    bool public LockedForDistribution;\n\n    /**\n     * @dev Holds the index into `holders` of the next account owed the current distribution\n     */\n    uint256 internal nextDistributionRecipient;\n\n    /**\n     * @dev Holds the index into `ManagedNFTs` of the next contract to withdraw funds from\n     */\n    uint256 private nextWithdrawal;\n\n    /**\n     * Indicates if the account is approved to hold the ERC20 token or not\n     * @param account the potential holder of the token\n     */\n    function isApprovedHolder(address account) public view returns (bool) {\n        return HolderAllowlist[account];\n    }\n\n    /**\n     * Adds `holder` to the list of approved token holders. This is necessary before `holder` may receive any of the underlying ERC20.\n     * @notice this call will fail if `holder` is already approved. Call isApprovedHolder() first to avoid mistakes.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function approveHolder(address holder) public onlyOwner {\n        require(!isApprovedHolder(holder), \"holder already approved\");\n        HolderAllowlist[holder] = true;\n    }\n\n    /**\n     * Marks `holder` as NOT approved to hold the token, preventing them from receiving any more of the underlying ERC20.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function disapproveHolder(address holder) public onlyOwner {\n        require(isApprovedHolder(holder), \"holder not approved\");\n        HolderAllowlist[holder] = false;\n    }\n\n    /**\n     * Implements the lock during distributions, adds `to` to the list of holders when needed\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        require(!LockedForDistribution, \"distribution in progress\");\n        if (!(to == address(0))) {\n            require(\n                isApprovedHolder(to),\n                \"receiver not approved to hold the token\"\n            );\n        }\n        if (from == address(0) || to == address(0)) {\n            _beforeMintOrBurn();\n        }\n        bool exists = (this.balanceOf(to) != 0);\n        if (!exists) {\n            holders.push(to);\n        }\n    }\n\n    /**\n     * Implements an additional lock on minting and burning, ensuring that supply changes happen after any potential distributions\n     */\n    function _beforeMintOrBurn() internal view {\n        require(\n            !_isPastMinDistributionPeriod(),\n            \"must distribute before minting or burning\"\n        );\n    }\n\n    /**\n     * Removes `from` from the list of holders when they no longer hold any balance\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        bool stillHolding = (this.balanceOf(from) != 0);\n        if (!stillHolding) {\n            for (uint i = 0; i < holders.length; i++) {\n                if (holders[i] == from) {\n                    // Remove the element at i by copying the last one into its place and removing the last element\n                    holders[i] = holders[holders.length - 1];\n                    holders.pop();\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a distribution to all of the current holders, which may trigger out of gas errors if there are too many holders\n     */\n    function distributeToAllHolders() public {\n        uint256 num = holders.length;\n        if (num > 0) {\n            distribute(holders.length);\n        }\n    }\n\n    /**\n     * Begins or continues a distribution, preventing transfers, mints, and burns of the token until all rewards have been paid out\n     *\n     * @notice distributions may only begin once every MinDistributionPeriod.\n     *\n     * @param numDistributions the number of distributions to process in this execution\n     */\n    function distribute(uint256 numDistributions) public nonReentrant {\n        require(numDistributions > 0, \"must process at least 1 distribution\");\n        if (!LockedForDistribution) {\n            require(\n                _isPastMinDistributionPeriod(),\n                \"MinDistributionPeriod not met\"\n            );\n            _beginDistribution();\n        }\n\n        uint256 limit = Math.min(\n            nextDistributionRecipient + numDistributions,\n            holders.length\n        );\n\n        uint i;\n        for (i = nextDistributionRecipient; i < limit; i++) {\n            address recipient = holders[i];\n            if (isApprovedHolder(recipient)) {\n                uint256[] memory receipts = new uint256[](\n                    distributableERC20s.length\n                );\n                for (uint j = 0; j < distributableERC20s.length; j++) {\n                    IERC20 toDistribute = IERC20(distributableERC20s[j]);\n                    uint256 entitlement = erc20EntitlementPerUnit[j] *\n                        this.balanceOf(recipient);\n                    if (toDistribute.transfer(recipient, entitlement)) {\n                        receipts[j] = entitlement;\n                    }\n                }\n\n                emit Distribution(recipient, distributableERC20s, receipts);\n            }\n        }\n        nextDistributionRecipient = i;\n\n        if (nextDistributionRecipient == holders.length) {\n            _endDistribution();\n        }\n    }\n\n    /**\n     * Determines if the minimum distribution period has elapsed, which is used for restricting\n     * minting and burning operations\n     */\n    function _isPastMinDistributionPeriod() internal view returns (bool) {\n        // Do not force a distribution with no holders or supply\n        if (totalSupply() == 0 || holders.length == 0) {\n            return false;\n        }\n\n        return (block.number - LastDistribution) >= MinDistributionPeriod;\n    }\n\n    /**\n     * Prepares this contract for distribution:\n     * - Locks the contract\n     * - Calculates the entitlement to protocol-held ERC20s per unit of the LiquidInfrastructureERC20 held\n     */\n    function _beginDistribution() internal {\n        require(\n            !LockedForDistribution,\n            \"cannot begin distribution when already locked\"\n        );\n        LockedForDistribution = true;\n\n        // clear the previous entitlements, if any\n        if (erc20EntitlementPerUnit.length > 0) {\n            delete erc20EntitlementPerUnit;\n        }\n\n        // Calculate the entitlement per token held\n        uint256 supply = this.totalSupply();\n        for (uint i = 0; i < distributableERC20s.length; i++) {\n            uint256 balance = IERC20(distributableERC20s[i]).balanceOf(\n                address(this)\n            );\n            uint256 entitlement = balance / supply;\n            erc20EntitlementPerUnit.push(entitlement);\n        }\n\n        nextDistributionRecipient = 0;\n        emit DistributionStarted();\n    }\n\n    /**\n     * Unlocks this contract at the end of a distribution\n     */\n    function _endDistribution() internal {\n        require(\n            LockedForDistribution,\n            \"cannot end distribution when not locked\"\n        );\n        delete erc20EntitlementPerUnit;\n        LockedForDistribution = false;\n        LastDistribution = block.number;\n        emit DistributionFinished();\n    }\n\n    /**\n     * Convenience function that allows the contract owner to distribute when necessary and then mint right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute\n     */\n    function mintAndDistribute(\n        address account,\n        uint256 amount\n    ) public onlyOwner {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        mint(account, amount);\n    }\n\n    /**\n     * Allows the contract owner to mint tokens for an address\n     *\n     * @notice minting may only occur when a distribution has happened within MinDistributionPeriod blocks\n     */\n    function mint(\n        address account,\n        uint256 amount\n    ) public onlyOwner nonReentrant {\n        _mint(account, amount);\n    }\n\n    /**\n     * Convenience function that allows a token holder to distribute when necessary and then burn their tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burn()\n     */\n    function burnAndDistribute(uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burn(amount);\n    }\n\n    /**\n     * Convenience function that allows an approved sender to distribute when necessary and then burn the approved tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burnFrom()\n     */\n    function burnFromAndDistribute(address account, uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burnFrom(account, amount);\n    }\n\n    function withdrawFromAllManagedNFTs() public {\n        withdrawFromManagedNFTs(ManagedNFTs.length);\n    }\n\n    /**\n     * Performs withdrawals from the ManagedNFTs collection, depositing all token balances into the custody of this contract\n     * @param numWithdrawals the number of withdrawals to perform\n     */\n    function withdrawFromManagedNFTs(uint256 numWithdrawals) public {\n        require(!LockedForDistribution, \"cannot withdraw during distribution\");\n\n        if (nextWithdrawal == 0) {\n            emit WithdrawalStarted();\n        }\n\n        uint256 limit = Math.min(\n            numWithdrawals + nextWithdrawal,\n            ManagedNFTs.length\n        );\n        uint256 i;\n        for (i = nextWithdrawal; i < limit; i++) {\n            LiquidInfrastructureNFT withdrawFrom = LiquidInfrastructureNFT(\n                ManagedNFTs[i]\n            );\n\n            (address[] memory withdrawERC20s, ) = withdrawFrom.getThresholds();\n            withdrawFrom.withdrawBalancesTo(withdrawERC20s, address(this));\n            emit Withdrawal(address(withdrawFrom));\n        }\n        nextWithdrawal = i;\n\n        if (nextWithdrawal == ManagedNFTs.length) {\n            nextWithdrawal = 0;\n            emit WithdrawalFinished();\n        }\n    }\n\n    /**\n     * Adds a LiquidInfrastructureNFT contract to the ManagedNFTs collection\n     * @notice this contract must already be the owner of the `nftContract` before this function is called\n     *\n     * @param nftContract the LiquidInfrastructureNFT contract to add to ManagedNFTs\n     */\n    function addManagedNFT(address nftContract) public onlyOwner {\n        LiquidInfrastructureNFT nft = LiquidInfrastructureNFT(nftContract);\n        address nftOwner = nft.ownerOf(nft.AccountId());\n        require(\n            nftOwner == address(this),\n            \"this contract does not own the new ManagedNFT\"\n        );\n        ManagedNFTs.push(nftContract);\n        emit AddManagedNFT(nftContract);\n    }\n\n    /**\n     * Transfers a LiquidInfrastructureNFT contract out of the control of this contract\n     * @notice LiquidInfrastructureNFTs only hold a single token with a specific id (AccountId), this function\n     * only transfers the token with that specific id\n     *\n     * @param nftContract the NFT to release\n     * @param to the new owner of the NFT\n     */\n    function releaseManagedNFT(\n        address nftContract,\n        address to\n    ) public onlyOwner nonReentrant {\n        LiquidInfrastructureNFT nft = LiquidInfrastructureNFT(nftContract);\n        nft.transferFrom(address(this), to, nft.AccountId());\n\n        // Remove the released NFT from the collection\n        for (uint i = 0; i < ManagedNFTs.length; i++) {\n            address managed = ManagedNFTs[i];\n            if (managed == nftContract) {\n                // Delete by copying in the last element and then pop the end\n                ManagedNFTs[i] = ManagedNFTs[ManagedNFTs.length - 1];\n                ManagedNFTs.pop();\n                break;\n            }\n        }\n        // By this point the NFT should have been found and removed from ManagedNFTs\n        require(true, \"unable to find released NFT in ManagedNFTs\");\n\n        emit ReleaseManagedNFT(nftContract, to);\n    }\n\n    /**\n     * Allows the owner to overwrite the list of ERC20s which may be distributed from ManagedNFTs to the holders\n     *\n     * @param _distributableERC20s  The new list value to set\n     */\n    function setDistributableERC20s(\n        address[] memory _distributableERC20s\n    ) public onlyOwner {\n        distributableERC20s = _distributableERC20s;\n    }\n\n    /**\n     * Constructs the underlying ERC20 and initializes critical variables\n     *\n     * @param _name The name of the underlying ERC20\n     * @param _symbol The symbol of the underlying ERC20\n     * @param _managedNFTs The addresses of the controlled LiquidInfrastructureNFT contracts\n     * @param _approvedHolders The addresses of the initial allowed holders\n     * @param _distributableErc20s The addresses of ERC20s which should be distributed from ManagedNFTs to holders\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address[] memory _managedNFTs,\n        address[] memory _approvedHolders,\n        uint256 _minDistributionPeriod,\n        address[] memory _distributableErc20s\n    ) ERC20(_name, _symbol) Ownable() {\n        ManagedNFTs = _managedNFTs;\n        LastDistribution = block.number;\n\n        for (uint i = 0; i < _approvedHolders.length; i++) {\n            HolderAllowlist[_approvedHolders[i]] = true;\n        }\n\n        MinDistributionPeriod = _minDistributionPeriod;\n\n        distributableERC20s = _distributableErc20s;\n\n        emit Deployed();\n    }\n}"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.12; // Force solidity compliance\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./LiquidInfrastructureNFT.sol\";\n\n/**\n * @title Liquid Infrastructure ERC20\n * @author Christian Borst <christian@althea.systems>\n *\n * @dev An ERC20 contract used to earn rewards from managed LiquidInfrastructreNFTs.\n *\n * A LiquidInfrastructureNFT typically represents some form of infrastructure involved in an Althea pay-per-forward network\n * which frequently receives payments from peers on the network for performing an automated service (e.g. providing internet).\n * This LiquidInfrastructureERC20 acts as a convenient aggregation layer to enable dead-simple investment in real-world assets\n * with automatic revenue accrual. Simply by holding this ERC20 owners are entitled to revenue from the network represented by the token.\n *\n * Revenue is gathered from managed LiquidInfrastructureNFTs by the protocol and distributed to token holders on a semi-regular basis,\n * where there is a minimum number of blocks required to elapse before a new payout to token holders.\n *\n * Minting and burning of this ERC20 is restricted if the minimum distribution period has elapsed, and it is reenabled once a new distribution is complete.\n */\ncontract LiquidInfrastructureERC20 is\n    ERC20,\n    ERC20Burnable,\n    Ownable,\n    ERC721Holder,\n    ReentrancyGuard\n{\n    event Deployed();\n    event DistributionStarted();\n    event Distribution(address recipient, address[] tokens, uint256[] amounts);\n    event DistributionFinished();\n    event WithdrawalStarted();\n    event Withdrawal(address source);\n    event WithdrawalFinished();\n    event AddManagedNFT(address nft);\n    event ReleaseManagedNFT(address nft, address to);\n\n    address[] private distributableERC20s;\n    uint256[] private erc20EntitlementPerUnit;\n    address[] private holders;\n\n    /**\n     * @notice This is the current version of the contract. Every update to the contract will introduce a new\n     * version, regardless of anticipated compatibility.\n     */\n    uint256 public constant Version = 1;\n\n    /**\n     * @notice This collection holds the managed LiquidInfrastructureNFTs which periodically generate revenue and deliver\n     * the balances to this contract.\n     */\n    address[] public ManagedNFTs;\n\n    /**\n     * @notice This collection holds the whitelist for accounts approved to hold the LiquidInfrastructureERC20\n     */\n    mapping(address => bool) public HolderAllowlist;\n\n    /**\n     * @notice Holds the block of the last distribution, used for limiting distribution lock ups\n     */\n    uint256 public LastDistribution;\n\n    /**\n     * @notice Holds the minimum number of blocks required to elapse before a new distribution can begin\n     */\n    uint256 public MinDistributionPeriod;\n\n    /**\n     * @notice When true, locks all transfers, mints, and burns until the current distribution has completed\n     */\n    bool public LockedForDistribution;\n\n    /**\n     * @dev Holds the index into `holders` of the next account owed the current distribution\n     */\n    uint256 internal nextDistributionRecipient;\n\n    /**\n     * @dev Holds the index into `ManagedNFTs` of the next contract to withdraw funds from\n     */\n    uint256 private nextWithdrawal;\n\n    /**\n     * Indicates if the account is approved to hold the ERC20 token or not\n     * @param account the potential holder of the token\n     */\n    function isApprovedHolder(address account) public view returns (bool) {\n        return HolderAllowlist[account];\n    }\n\n    /**\n     * Adds `holder` to the list of approved token holders. This is necessary before `holder` may receive any of the underlying ERC20.\n     * @notice this call will fail if `holder` is already approved. Call isApprovedHolder() first to avoid mistakes.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function approveHolder(address holder) public onlyOwner {\n        require(!isApprovedHolder(holder), \"holder already approved\");\n        HolderAllowlist[holder] = true;\n    }\n\n    /**\n     * Marks `holder` as NOT approved to hold the token, preventing them from receiving any more of the underlying ERC20.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function disapproveHolder(address holder) public onlyOwner {\n        require(isApprovedHolder(holder), \"holder not approved\");\n        HolderAllowlist[holder] = false;\n    }\n\n    /**\n     * Implements the lock during distributions, adds `to` to the list of holders when needed\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        require(!LockedForDistribution, \"distribution in progress\");\n        if (!(to == address(0))) {\n            require(\n                isApprovedHolder(to),\n                \"receiver not approved to hold the token\"\n            );\n        }\n        if (from == address(0) || to == address(0)) {\n            _beforeMintOrBurn();\n        }\n        bool exists = (this.balanceOf(to) != 0);\n        if (!exists) {\n            holders.push(to);\n        }\n    }\n\n    /**\n     * Implements an additional lock on minting and burning, ensuring that supply changes happen after any potential distributions\n     */\n    function _beforeMintOrBurn() internal view {\n        require(\n            !_isPastMinDistributionPeriod(),\n            \"must distribute before minting or burning\"\n        );\n    }\n\n    /**\n     * Removes `from` from the list of holders when they no longer hold any balance\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        bool stillHolding = (this.balanceOf(from) != 0);\n        if (!stillHolding) {\n            for (uint i = 0; i < holders.length; i++) {\n                if (holders[i] == from) {\n                    // Remove the element at i by copying the last one into its place and removing the last element\n                    holders[i] = holders[holders.length - 1];\n                    holders.pop();\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a distribution to all of the current holders, which may trigger out of gas errors if there are too many holders\n     */\n    function distributeToAllHolders() public {\n        uint256 num = holders.length;\n        if (num > 0) {\n            distribute(holders.length);\n        }\n    }\n\n    /**\n     * Begins or continues a distribution, preventing transfers, mints, and burns of the token until all rewards have been paid out\n     *\n     * @notice distributions may only begin once every MinDistributionPeriod.\n     *\n     * @param numDistributions the number of distributions to process in this execution\n     */\n    function distribute(uint256 numDistributions) public nonReentrant {\n        require(numDistributions > 0, \"must process at least 1 distribution\");\n        if (!LockedForDistribution) {\n            require(\n                _isPastMinDistributionPeriod(),\n                \"MinDistributionPeriod not met\"\n            );\n            _beginDistribution();\n        }\n\n        uint256 limit = Math.min(\n            nextDistributionRecipient + numDistributions,\n            holders.length\n        );\n\n        uint i;\n        for (i = nextDistributionRecipient; i < limit; i++) {\n            address recipient = holders[i];\n            if (isApprovedHolder(recipient)) {\n                uint256[] memory receipts = new uint256[](\n                    distributableERC20s.length\n                );\n                for (uint j = 0; j < distributableERC20s.length; j++) {\n                    IERC20 toDistribute = IERC20(distributableERC20s[j]);\n                    uint256 entitlement = erc20EntitlementPerUnit[j] *\n                        this.balanceOf(recipient);\n                    if (toDistribute.transfer(recipient, entitlement)) {\n                        receipts[j] = entitlement;\n                    }\n                }\n\n                emit Distribution(recipient, distributableERC20s, receipts);\n            }\n        }\n        nextDistributionRecipient = i;\n\n        if (nextDistributionRecipient == holders.length) {\n            _endDistribution();\n        }\n    }\n\n    /**\n     * Determines if the minimum distribution period has elapsed, which is used for restricting\n     * minting and burning operations\n     */\n    function _isPastMinDistributionPeriod() internal view returns (bool) {\n        // Do not force a distribution with no holders or supply\n        if (totalSupply() == 0 || holders.length == 0) {\n            return false;\n        }\n\n        return (block.number - LastDistribution) >= MinDistributionPeriod;\n    }\n\n    /**\n     * Prepares this contract for distribution:\n     * - Locks the contract\n     * - Calculates the entitlement to protocol-held ERC20s per unit of the LiquidInfrastructureERC20 held\n     */\n    function _beginDistribution() internal {\n        require(\n            !LockedForDistribution,\n            \"cannot begin distribution when already locked\"\n        );\n        LockedForDistribution = true;\n\n        // clear the previous entitlements, if any\n        if (erc20EntitlementPerUnit.length > 0) {\n            delete erc20EntitlementPerUnit;\n        }\n\n        // Calculate the entitlement per token held\n        uint256 supply = this.totalSupply();\n        for (uint i = 0; i < distributableERC20s.length; i++) {\n            uint256 balance = IERC20(distributableERC20s[i]).balanceOf(\n                address(this)\n            );\n            uint256 entitlement = balance / supply;\n            erc20EntitlementPerUnit.push(entitlement);\n        }\n\n        nextDistributionRecipient = 0;\n        emit DistributionStarted();\n    }\n\n    /**\n     * Unlocks this contract at the end of a distribution\n     */\n    function _endDistribution() internal {\n        require(\n            LockedForDistribution,\n            \"cannot end distribution when not locked\"\n        );\n        delete erc20EntitlementPerUnit;\n        LockedForDistribution = false;\n        LastDistribution = block.number;\n        emit DistributionFinished();\n    }\n\n    /**\n     * Convenience function that allows the contract owner to distribute when necessary and then mint right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute\n     */\n    function mintAndDistribute(\n        address account,\n        uint256 amount\n    ) public onlyOwner {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        mint(account, amount);\n    }\n\n    /**\n     * Allows the contract owner to mint tokens for an address\n     *\n     * @notice minting may only occur when a distribution has happened within MinDistributionPeriod blocks\n     */\n    function mint(\n        address account,\n        uint256 amount\n    ) public onlyOwner nonReentrant {\n        _mint(account, amount);\n    }\n\n    /**\n     * Convenience function that allows a token holder to distribute when necessary and then burn their tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burn()\n     */\n    function burnAndDistribute(uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burn(amount);\n    }\n\n    /**\n     * Convenience function that allows an approved sender to distribute when necessary and then burn the approved tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burnFrom()\n     */\n    function burnFromAndDistribute(address account, uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burnFrom(account, amount);\n    }\n\n    function withdrawFromAllManagedNFTs() public {\n        withdrawFromManagedNFTs(ManagedNFTs.length);\n    }\n\n    /**\n     * Performs withdrawals from the ManagedNFTs collection, depositing all token balances into the custody of this contract\n     * @param numWithdrawals the number of withdrawals to perform\n     */\n    function withdrawFromManagedNFTs(uint256 numWithdrawals) public {\n        require(!LockedForDistribution, \"cannot withdraw during distribution\");\n\n        if (nextWithdrawal == 0) {\n            emit WithdrawalStarted();\n        }\n\n        uint256 limit = Math.min(\n            numWithdrawals + nextWithdrawal,\n            ManagedNFTs.length\n        );\n        uint256 i;\n        for (i = nextWithdrawal; i < limit; i++) {\n            LiquidInfrastructureNFT withdrawFrom = LiquidInfrastructureNFT(\n                ManagedNFTs[i]\n            );\n\n            (address[] memory withdrawERC20s, ) = withdrawFrom.getThresholds();\n            withdrawFrom.withdrawBalancesTo(withdrawERC20s, address(this));\n            emit Withdrawal(address(withdrawFrom));\n        }\n        nextWithdrawal = i;\n\n        if (nextWithdrawal == ManagedNFTs.length) {\n            nextWithdrawal = 0;\n            emit WithdrawalFinished();\n        }\n    }\n\n    /**\n     * Adds a LiquidInfrastructureNFT contract to the ManagedNFTs collection\n     * @notice this contract must already be the owner of the `nftContract` before this function is called\n     *\n     * @param nftContract the LiquidInfrastructureNFT contract to add to ManagedNFTs\n     */\n    function addManagedNFT(address nftContract) public onlyOwner {\n        LiquidInfrastructureNFT nft = LiquidInfrastructureNFT(nftContract);\n        address nftOwner = nft.ownerOf(nft.AccountId());\n        require(\n            nftOwner == address(this),\n            \"this contract does not own the new ManagedNFT\"\n        );\n        ManagedNFTs.push(nftContract);\n        emit AddManagedNFT(nftContract);\n    }\n\n    /**\n     * Transfers a LiquidInfrastructureNFT contract out of the control of this contract\n     * @notice LiquidInfrastructureNFTs only hold a single token with a specific id (AccountId), this function\n     * only transfers the token with that specific id\n     *\n     * @param nftContract the NFT to release\n     * @param to the new owner of the NFT\n     */\n    function releaseManagedNFT(\n        address nftContract,\n        addr"
    }
  ]
}