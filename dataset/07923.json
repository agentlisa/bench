{
  "Title": "[N-06] Function && Variable Naming Convention",
  "Content": "\n### Context\n[`AlgebraPoolFactory.sol#L116`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/AlgebraFactory.sol#L116), [`AlgebraPoolFactory.sol#L122`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/AlgebraFactory.sol#L122), [`AlgebraPool.sol#L70`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/AlgebraPool.sol#L70), [`AlgebraPool.sol#L74`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/AlgebraPool.sol#L74), [`AlgebraPool.sol#L403`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/AlgebraPool.sol#L403), [`AlgebraPoolDeployer.sol#L18-L19`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/AlgebraPoolDeployer.sol#L18-L19), [`DataStorageOperator.sol#L23-L24`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/DataStorageOperator.sol#L23-L24), [`DataStorageOperator.sol#L115`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/DataStorageOperator.sol#L115), [`Constants.sol#L5-L17`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/libraries/Constants.sol#L5-L17), [`DataStorage.sol#L13`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/libraries/DataStorage.sol#L13), [`DataStorage.sol#L32`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/libraries/DataStorage.sol#L32), [`DataStorage.sol#L49-L50`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/libraries/DataStorage.sol#L49-L50), [`DataStorage.sol#L66`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/libraries/DataStorage.sol#L66), [`DataStorage.sol#L94`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/libraries/DataStorage.sol#L94), [`DataStorage.sol#L105`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/libraries/DataStorage.sol#L105), [`DataStorage.sol#L148`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/libraries/DataStorage.sol#L148), [`TickTable.sol#L121`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/libraries/TickTable.sol#L121), [`PoolState.sol#L27`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/base/PoolState.sol#L27)\n\n### Description\nThe linked variables do not conform to the standard naming convention of Solidity whereby functions and variable names(local and state) utilize the `mixedCase` format unless variables are declared as `constant` in which case they utilize the `UPPER_CASE_WITH_UNDERSCORES` format. Private variables and functions should lead with an `_underscore`.\n\n### Recommendation\nConsider naming conventions utilized by the linked statements are adjusted to reflect the correct type of declaration according to the [Solidity style guide](https://docs.soliditylang.org/en/latest/style-guide.html).\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-09-quickswap",
  "Code": [
    {
      "filename": "src/core/contracts/AlgebraFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IAlgebraPoolDeployer.sol';\nimport './interfaces/IDataStorageOperator.sol';\nimport './libraries/AdaptiveFee.sol';\nimport './DataStorageOperator.sol';\n\n/**\n * @title Algebra factory\n * @notice Is used to deploy pools and its dataStorages\n */\ncontract AlgebraFactory is IAlgebraFactory {\n  /// @inheritdoc IAlgebraFactory\n  address public override owner;\n\n  /// @inheritdoc IAlgebraFactory\n  address public immutable override poolDeployer;\n\n  /// @inheritdoc IAlgebraFactory\n  address public override farmingAddress;\n\n  /// @inheritdoc IAlgebraFactory\n  address public override vaultAddress;\n\n  // values of constants for sigmoids in fee calculation formula\n  AdaptiveFee.Configuration public baseFeeConfiguration =\n    AdaptiveFee.Configuration(\n      3000 - Constants.BASE_FEE, // alpha1\n      15000 - 3000, // alpha2\n      360, // beta1\n      60000, // beta2\n      59, // gamma1\n      8500, // gamma2\n      0, // volumeBeta\n      10, // volumeGamma\n      Constants.BASE_FEE // baseFee\n    );\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  mapping(address => mapping(address => address)) public override poolByPair;\n\n  constructor(address _poolDeployer, address _vaultAddress) {\n    owner = msg.sender;\n    emit Owner(msg.sender);\n\n    poolDeployer = _poolDeployer;\n    vaultAddress = _vaultAddress;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function createPool(address tokenA, address tokenB) external override returns (address pool) {\n    require(tokenA != tokenB);\n    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0));\n    require(poolByPair[token0][token1] == address(0));\n\n    IDataStorageOperator dataStorage = new DataStorageOperator(computeAddress(token0, token1));\n\n    dataStorage.changeFeeConfiguration(baseFeeConfiguration);\n\n    pool = IAlgebraPoolDeployer(poolDeployer).deploy(address(dataStorage), address(this), token0, token1);\n\n    poolByPair[token0][token1] = pool; // to avoid future addresses comparing we are populating the mapping twice\n    poolByPair[token1][token0] = pool;\n    emit Pool(token0, token1, pool);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setOwner(address _owner) external override onlyOwner {\n    require(owner != _owner);\n    emit Owner(_owner);\n    owner = _owner;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setFarmingAddress(address _farmingAddress) external override onlyOwner {\n    require(farmingAddress != _farmingAddress);\n    emit FarmingAddress(_farmingAddress);\n    farmingAddress = _farmingAddress;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setVaultAddress(address _vaultAddress) external override onlyOwner {\n    require(vaultAddress != _vaultAddress);\n    emit VaultAddress(_vaultAddress);\n    vaultAddress = _vaultAddress;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setBaseFeeConfiguration(\n    uint16 alpha1,\n    uint16 alpha2,\n    uint32 beta1,\n    uint32 beta2,\n    uint16 gamma1,\n    uint16 gamma2,\n    uint32 volumeBeta,\n    uint16 volumeGamma,\n    uint16 baseFee\n  ) external override onlyOwner {\n    require(uint256(alpha1) + uint256(alpha2) + uint256(baseFee) <= type(uint16).max, 'Max fee exceeded');\n    require(gamma1 != 0 && gamma2 != 0 && volumeGamma != 0, 'Gammas must be > 0');\n\n    baseFeeConfiguration = AdaptiveFee.Configuration(alpha1, alpha2, beta1, beta2, gamma1, gamma2, volumeBeta, volumeGamma, baseFee);\n    emit FeeConfiguration(alpha1, alpha2, beta1, beta2, gamma1, gamma2, volumeBeta, volumeGamma, baseFee);\n  }\n\n  bytes32 internal constant POOL_INIT_CODE_HASH = 0x6ec6c9c8091d160c0aa74b2b14ba9c1717e95093bd3ac085cee99a49aab294a4;\n\n  /// @notice Deterministically computes the pool address given the factory and PoolKey\n  /// @param token0 first token\n  /// @param token1 second token\n  /// @return pool The contract address of the Algebra pool\n  function computeAddress(address token0, address token1) internal view returns (address pool) {\n    pool = address(uint256(keccak256(abi.encodePacked(hex'ff', poolDeployer, keccak256(abi.encode(token0, token1)), POOL_INIT_CODE_HASH))));\n  }\n}"
    }
  ]
}