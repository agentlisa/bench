{
  "Title": "M-7: Adversary can abuse hanging approvals left by PSwapLib.swap to bypass reward fees",
  "Content": "# Issue M-7: Adversary can abuse hanging approvals left by PSwapLib.swap to bypass reward fees \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/104 \n\n## Found by \n0x52\n\nPSwapLib.swap can be manipulated to leave hanging allowances via the expectedRewards input. These can then be abused to swap reward tokens out of order allowing them to bypass fees.\n\n## Vulnerability Detail\n\n[AuraSpell.sol#L247-L257](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L247-L257)\n\n            _doCutRewardsFee(sellToken);\n            if (\n                expectedRewards[i] != 0 &&\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    sellToken,\n                    expectedRewards[i],\n                    swapDatas[i]\n                )\n            ) revert Errors.SWAP_FAILED(sellToken);\n\nAuraSpell#closePositionFarm allows the user to specify any expectedRewards they wish. This allows the user to approve any amount, even if the amount is much larger than they would otherwise use. The can abuse these hanging approvals to swap tokens out of order and avoid paying reward fees.\n\nExample:\nAssume there are two rewards, token A and token B. Over time a user's position accumulates 100 rewards for each token. Normally the user would have to pay fees on those rewards. However they can bypass it by first creating hanging approvals. The user would start by redeeming a very small amount of LP and setting expectedRewards to uint256.max. They wouldn't sell the small amount leaving a very large approval left for both tokens. Now the user withdraws the rest of their position. This time they specify the swap data to swap token B first. The user still has to pay fees on token A but now they have traded token B before any fees can be taken on it. \n\n## Impact\n\nUser can bypass reward fees\n\n## Code Snippet\n\n[AuraSpell.sol#L184-L286](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L184-L286)\n\n[ConvexSpell.sol#L179-L229](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L179-L229)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAfter the swap reset allowances to 0\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because fees are cut before the supplied check in _doCutFees function\n\n**Kral01** commented:\n> Not how approval works\n\n\n\n**IAm0x52**\n\nEscalate\n\nThis was wrongly excluded. The judging comments above are incorrect. The code allows the user to make any swap in whatever order they want. This is what allows the user to bypass the fees. The user is meant to swap in the order that the tokens are listed but by swapping in a different order they can bypass the cut. Assume we have two tokens to claim. Normally the flow would be:\n\nRewardCut A > Swap A > RewardCut B > Swap B\n\nUsing the methodology I've shown above the user can instead:\n\nRewardCut A > Swap B > RewardCutB > Swap A\n\nHere we see that B can be swapped before the reward cut allowing the fee to be bypassed.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This was wrongly excluded. The judging comments above are incorrect. The code allows the user to make any swap in whatever order they want. This is what allows the user to bypass the fees. The user is meant to swap in the order that the tokens are listed but by swapping in a different order they can bypass the cut. Assume we have two tokens to claim. Normally the flow would be:\n> \n> RewardCut A > Swap A > RewardCut B > Swap B\n> \n> Using the methodology I've shown above the user can instead:\n> \n> RewardCut A > Swap B > RewardCutB > Swap A\n> \n> Here we see that B can be swapped before the reward cut allowing the fee to be bypassed.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\n> Escalate\n> \n> This was wrongly excluded. The judging comments above are incorrect. The code allows the user to make any swap in whatever order they want. This is what allows the user to bypass the fees. The user is meant to swap in the order that the tokens are listed but by swapping in a different order they can bypass the cut. Assume we have two tokens to claim. Normally the flow would be:\n> \n> RewardCut A > Swap A > RewardCut B > Swap B\n> \n> Using the methodology I've shown above the user can instead:\n> \n> RewardCut A > Swap B > RewardCutB > Swap A\n> \n> Here we see that B can be swapped before the reward cut allowing the fee to be bypassed.\n\nAgree with escalation. As the user can specify any `expectedRewards` and any `callData` in any order, this is a valid attack vector.\n\n**hrishibhat**\n\n@Gornutz \n\n**Gornutz**\n\nThe paraswap lib is already resetting the token approval to zero prior to allocating the allowance for each swap - https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/libraries/Paraswap/PSwapLib.sol#L15 \n\n\n**Shogoki**\n\n> The paraswap lib is already resetting the token approval to zero prior to allocating the allowance for each swap - https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/libraries/Paraswap/PSwapLib.sol#L15\n\nI do not think this helps preventing this issue. As the approval is resetted before the swap, there still can be a hanging approval.\nIssue is that the approval is set/reset for the specified sellToken, but the user can swap any other token by specifying different calldatas. Therefore, i think the stated attack path is still possible\n\n**Gornutz**\n\nGotcha, then yes seems valid \n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nThis is a valid medium issue\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/104/#issuecomment-1694746004): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/spell/AuraSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/// @title AuraSpell\n/// @author BlueberryProtocol\n/// @notice AuraSpell is the factory contract that\n///         defines how Blueberry Protocol interacts with Aura pools\ncontract AuraSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Wrapped Aura Pools\n    IWAuraPools public wAuraPools;\n    /// @dev Address of AURA token\n    address public AURA;\n    /// @dev Address of Stash AURA token\n    address public STASH_AURA;\n\n    /// @dev paraswap AugustusSwapper Address\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy Address\n    address public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract with required parameters.\n    /// @param bank_ Reference to the Bank contract.\n    /// @param werc20_ Reference to the WERC20 contract.\n    /// @param weth_ Address of the wrapped Ether token.\n    /// @param wAuraPools_ Address of the wrapped Aura Pools contract.\n    /// @param augustusSwapper_ Address of the paraswap AugustusSwapper.\n    /// @param tokenTransferProxy_ Address of the paraswap TokenTransferProxy.\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wAuraPools_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wAuraPools_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        wAuraPools = IWAuraPools(wAuraPools_);\n        AURA = address(wAuraPools.AURA());\n        STASH_AURA = wAuraPools.STASH_AURA();\n        IWAuraPools(wAuraPools_).setApprovalForAll(address(bank_), true);\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n    }\n\n    /// @notice Allows the owner to add a new strategy.\n    /// @param bpt Address of the Balancer Pool Token.\n    /// @param minPosSize, USD price of minimum position size for given strategy, based 1e18\n    /// @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n    function addStrategy(\n        address bpt,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(bpt, minPosSize, maxPosSize);\n    }\n\n    /// @notice Adds liquidity to a Balancer pool and stakes the resultant tokens in Aura.\n    /// @param param Configuration for opening a position.\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minimumBPT\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        /// Extract strategy details for the given strategy ID.\n        Strategy memory strategy = strategies[param.strategyId];\n        /// Fetch pool information based on provided farming pool ID.\n        (address lpToken, , , , , ) = wAuraPools.getPoolInfoFromPoolId(\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        /// 2. Borrow funds based on specified amount\n        _doBorrow(param.borrowToken, param.borrowAmount);\n\n        /// 3. Add liquidity to the Balancer pool and receive BPT in return.\n        {\n            uint256 _minimumBPT = minimumBPT;\n            IBalancerVault vault = wAuraPools.getVault(lpToken);\n\n            (address[] memory tokens, uint256[] memory balances, ) = wAuraPools\n                .getPoolTokens(lpToken);\n            (\n                uint256[] memory maxAmountsIn,\n                uint256[] memory amountsIn,\n                uint256 poolAmountOut\n            ) = _getJoinPoolParamsAndApprove(\n                    address(vault),\n                    tokens,\n                    balances,\n                    lpToken\n                );\n\n            if (poolAmountOut != 0) {\n                vault.joinPool(\n                    wAuraPools.getBPTPoolId(lpToken),\n                    address(this),\n                    address(this),\n                    IBalancerVault.JoinPoolRequest({\n                        assets: tokens,\n                        maxAmountsIn: maxAmountsIn,\n                        userData: abi.encode(1, amountsIn, _minimumBPT),\n                        fromInternalBalance: false\n                    })\n                );\n            }\n        }\n        /// 4. Ensure that the resulting LTV does not exceed maximum allowed value.\n        _validateMaxLTV(param.strategyId);\n\n        /// 5. Ensure position size is within permissible limits.\n        _validatePosSize(param.strategyId);\n\n        /// 6. Withdraw existing collaterals and burn the associated tokens.\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            (address[] memory rewardTokens, ) = wAuraPools.burn(\n                pos.collId,\n                pos.collateralSize\n            );\n            /// Distribute the multiple rewards to users.\n            uint256 rewardTokensLength = rewardTokens.length;\n            for (uint256 i; i != rewardTokensLength; ) {\n                _doRefundRewards(\n                    rewardTokens[i] == STASH_AURA ? AURA : rewardTokens[i]\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        /// 7. Deposit the tokens in the Aura pool and place the wrapped collateral tokens in the Blueberry Bank.\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wAuraPools), lpAmount);\n        uint256 id = wAuraPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wAuraPools), id, lpAmount);\n    }\n\n    /// @notice Closes a position from Balancer pool and exits the Aura farming.\n    /// @param param Parameters for closing the position\n    /// @param expectedRewards Expected reward amounts for each reward token\n    /// @param swapDatas Data required for swapping reward tokens to the debt token\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        uint256[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        /// Information about the position from Blueberry Bank\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address[] memory rewardTokens;\n        /// Ensure the position's collateral token matches the expected one\n        {\n            address lpToken = strategies[param.strategyId].vault;\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            if (wAuraPools.getUnderlyingToken(pos.collId) != lpToken)\n                revert Errors.INCORRECT_UNDERLYING(lpToken);\n\n            /// 1. Burn the wrapped tokens, retrieve the BPT tokens, and claim the AURA rewards\n            bank.takeCollateral(param.amountPosRemove);\n            (rewardTokens, ) = wAuraPools.burn(\n                pos.collId,\n                param.amountPosRemove\n            );\n\n            {\n                /// 2. Determine the exact amount of position to remove\n                uint256 amountPosRemove = param.amountPosRemove;\n                if (amountPosRemove == type(uint256).max) {\n                    amountPosRemove = IERC20Upgradeable(lpToken).balanceOf(\n                        address(this)\n                    );\n                }\n\n                /// 3. Parameters for removing liquidity\n                (\n                    uint256[] memory minAmountsOut,\n                    address[] memory tokens,\n                    uint256 borrowTokenIndex\n                ) = _getExitPoolParams(param.borrowToken, lpToken);\n\n                wAuraPools.getVault(lpToken).exitPool(\n                    IBalancerPool(lpToken).getPoolId(),\n                    address(this),\n                    address(this),\n                    IBalancerVault.ExitPoolRequest(\n                        tokens,\n                        minAmountsOut,\n                        abi.encode(0, amountPosRemove, borrowTokenIndex),\n                        false\n                    )\n                );\n            }\n        }\n\n        /// 4. Swap each reward token for the debt token\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i != rewardTokensLength; ) {\n            address sellToken = rewardTokens[i];\n            if (sellToken == STASH_AURA) sellToken = AURA;\n\n            _doCutRewardsFee(sellToken);\n            if (\n                expectedRewards[i] != 0 &&\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    sellToken,\n                    expectedRewards[i],\n                    swapDatas[i]\n                )\n            ) revert Errors.SWAP_FAILED(sellToken);\n\n            /// Refund rest (dust) amount to owner\n            _doRefund(sellToken);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        /// 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        /// 6. Withdraw collateral from the bank and repay the borrowed amount\n        {\n            /// Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        /// Ensure that the Loan to Value (LTV) ratio remains within accepted boundaries\n        _validateMaxLTV(param.strategyId);\n\n        /// 7. Refund any remaining tokens to the owner\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /// @dev Calculate the parameters required for joining a Balancer pool.\n    /// @param vault Address of the Balancer vault\n    /// @param tokens List of tokens in the Balancer pool\n    /// @param balances Balances of tokens in the Balancer pool\n    /// @param lpToken The LP token for the Balancer pool\n    /// @return maxAmountsIn Maximum amounts to deposit for each token\n    /// @return amountsIn Amounts of each token to deposit\n    /// @return poolAmountOut Amount of LP tokens to be received\n    function _getJoinPoolParamsAndApprove(\n        address vault,\n        address[] memory tokens,\n        uint256[] memory balances,\n        address lpToken\n    ) internal returns (uint256[] memory, uint256[] memory, uint256) {\n        uint256 i;\n        uint256 j;\n        uint256 length = tokens.length;\n        uint256[] memory maxAmountsIn = new uint256[](length);\n        uint256[] memory amountsIn = new uint256[](length);\n        bool isLPIncluded;\n\n        for (i; i != length; ) {\n            if (tokens[i] != lpToken) {\n                amountsIn[j] = IERC20(tokens[i]).balanceOf(address(this));\n                if (amountsIn[j] > 0) {\n                    _ensureApprove(tokens[i], vault, amountsIn[j]);\n                }\n                ++j;\n            } else isLPIncluded = true;\n\n            maxAmountsIn[i] = IERC20(tokens[i]).balanceOf(address(this));\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (isLPIncluded) {\n            assembly {\n                mstore(amountsIn, sub(mload(amountsIn), 1))\n            }\n        }\n\n        uint256 totalLPSupply = IBalancerPool(lpToken).getActualSupply();\n        /// compute in reverse order of how Balancer's `joinPool` computes tokenAmountIn\n        uint256 poolAmountOut;\n        for (i = 0; i != length; ) {\n            if ((maxAmountsIn[i] * totalLPSupply) / balances[i] != 0) {\n                poolAmountOut = type(uint256).max;\n                break;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (maxAmountsIn, amountsIn, poolAmountOut);\n    }\n\n    /// @dev Calculate the parameters required for exiting a Balancer pool.\n    /// @param borrowToken The token to be borrowed\n    /// @param lpToken The LP token for the Balancer pool\n    /// @return minAmountsOut Minimum amounts to receive for each token upon exiting\n    /// @return tokens List of tokens in the Balancer pool\n    /// @return exitTokenIndex Index of the borrowToken in the tokens list\n    function _getExitPoolParams(\n        address borrowToken,\n        address lpToken\n    ) internal view returns (uint256[] memory, address[] memory, uint256) {\n        (address[] memory tokens, , ) = wAuraPools.getPoolTokens(lpToken);\n\n        uint256 length = tokens.length;\n        uint256[] memory minAmountsOut = new uint256[](length);\n        uint256 exitTokenIndex;\n\n        for (uint256 i; i != length; ) {\n            if (tokens[i] == borrowToken) break;\n\n            if (tokens[i] != lpToken) ++exitTokenIndex;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (minAmountsOut, tokens, exitTokenIndex);\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/AuraSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/// @title AuraSpell\n/// @author BlueberryProtocol\n/// @notice AuraSpell is the factory contract that\n///         defines how Blueberry Protocol interacts with Aura pools\ncontract AuraSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Wrapped Aura Pools\n    IWAuraPools public wAuraPools;\n    /// @dev Address of AURA token\n    address public AURA;\n    /// @dev Address of Stash AURA token\n    address public STASH_AURA;\n\n    /// @dev paraswap AugustusSwapper Address\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy Address\n    address public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract with required parameters.\n    /// @param bank_ Reference to the Bank contract.\n    /// @param werc20_ Reference to the WERC20 contract.\n    /// @param weth_ Address of the wrapped Ether token.\n    /// @param wAuraPools_ Address of the wrapped Aura Pools contract.\n    /// @param augustusSwapper_ Address of the paraswap AugustusSwapper.\n    /// @param tokenTransferProxy_ Address of the paraswap TokenTransferProxy.\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wAuraPools_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wAuraPools_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        wAuraPools = IWAuraPools(wAuraPools_);\n        AURA = address(wAuraPools.AURA());\n        STASH_AURA = wAuraPools.STASH_AURA();\n        IWAuraPools(wAuraPools_).setApprovalForAll(address(bank_), true);\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n    }\n\n    /// @notice Allows the owner to add a new strategy.\n    /// @param bpt Address of the Balancer Pool Token.\n    /// @param minPosSize, USD price of minimum position size for given strategy, based 1e18\n    /// @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n    function addStrategy(\n        address bpt,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(bpt, minPosSize, maxPosSize);\n    }\n\n    /// @notice Adds liquidity to a Balancer pool and stakes the resultant tokens in Aura.\n    /// @param param Configuration for opening a position.\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minimumBPT\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        /// Extract strategy details for the given strategy ID.\n        Strategy memory strategy = strategies[param.strategyId];\n        /// Fetch pool information based on provided farming pool ID.\n        (address lpToken, , , , , ) = wAuraPools.getPoolInfoFromPoolId(\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        /// 2. Borrow funds based on specified amount\n        _doBorrow(param.borrowToken, param.borrowAmount);\n\n        /// 3. Add liquidity to the Balancer pool and receive BPT in return.\n        {\n            uint256 _minimumBPT = minimumBPT;\n            IBalancerVault vault = wAuraPools.getVault(lpToken);\n\n            (address[] memory tokens, uint256[] memory balances, ) = wAuraPools\n                .getPoolTokens(lpToken);\n            (\n                uint256[] memory maxAmountsIn,\n                uint256[] memory amountsIn,\n                uint256 poolAmountOut\n            ) = _getJoinPoolParamsAndApprove(\n                    address(vault),\n                    tokens,\n                    balances,\n                    lpToken\n                );\n\n            if (poolAmountOut != 0) {\n                vault.joinPool(\n                    wAuraPools.getBPTPoolId(lpToken),\n                    address(this),\n                    address(this),\n                    IBalancerVault.JoinPoolRequest({\n                        assets: tokens,\n                        maxAmountsIn: maxAmountsIn,\n                        userData: abi.encode(1, amountsIn, _minimumBPT),\n                        fromInternalBalance: false\n                    })\n                );\n            }\n        }\n        /// 4. Ensure that the resulting LTV does not exceed maximum allowed value.\n        _validateMaxLTV(param.strategyId);\n\n        /// 5. Ensure position size is within permissible limits.\n        _validatePosSize(param.strategyId);\n\n        /// 6. Withdraw existing collaterals and burn the associated tokens.\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            (address[] memory rewardTokens, ) = wAuraPools.burn(\n                pos.collId,\n                pos.collateralSize\n            );\n            /// Distribute the multiple rewards to users.\n            uint256 rewardTokensLength = rewardTokens.length;\n            for (uint256 i; i != rewardTokensLength; ) {\n                _doRefundRewards(\n                    rewardTokens[i] == STASH_AURA ? AURA : rewardTokens[i]\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        /// 7. Deposit the tokens in the Aura pool and place the wrapped collateral tokens in the Blueberry Bank.\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wAuraPools), lpAmount);\n        uint256 id = wAuraPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wAuraPools), id, lpAmount);\n    }\n\n    /// @notice Closes a position from Balancer pool and exits the Aura farming.\n    /// @param param Parameters for closing the position\n    /// @param expectedRewards Expected reward amounts for each reward token\n    /// @param swapDatas Data required for swapping reward tokens to the debt token\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        uint256[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        /// Information about the position from Blueberry Bank\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address[] memory rewardTokens;\n        /// Ensure the position's collateral token matches the expected one\n        {\n            address lpToken = strategies[param.strategyId].vault;\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            if (wAuraPools.getUnderlyingToken(pos.collId) != lpToken)\n                revert Errors.INCORRECT_UNDERLYING(lpToken);\n\n            /// 1. Burn the wrapped tokens, retrieve the BPT tokens, and claim the AURA rewards\n            bank.takeCollateral(param.amountPosRemove);\n            (rewardTokens, ) = wAuraPools.burn(\n                pos.collId,\n                param.amountPosRemove\n            );\n\n            {\n                /// 2. Determine the exact amount of position to remove\n                uint256 amountPosRemove = param.amountPosRemove;\n                if (amountPosRemove == type(uint256).max) {\n                    amountPosRemove = IERC20Upgradeable(lpToken).balanceOf(\n                        address(this)\n                    );\n                }\n\n                /// 3. Parameters for removing liquidity\n                (\n                    uint256[] memory minAmountsOut,\n                    address[] memory tokens,\n                    uint256 borrowTokenIndex\n                ) = _getExitPoolParams(param.borrowToken, lpToken);\n\n                wAuraPools.getVault(lpToken).exitPool(\n                    IBalancerPool(lpToken).getPoolId(),\n                    address(this),\n                    address(this),\n                    IBalancerVault.ExitPoolRequest(\n                        tokens,\n                        minAmountsOut,\n                        abi.encode(0, amountPosRemove, borrowTokenIndex),\n                        false\n                    )\n                );\n            }\n        }\n\n        /// 4. Swap each reward token for the debt token\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i != rewardTokensLength; ) {\n            address sellToken = rewardTokens[i];\n            if (sellToken == STASH_AURA) sellToken = AURA;\n\n            _doCutRewardsFee(sellToken);\n            if (\n                expectedRewards[i] != 0 &&\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    sellToken,\n                    expectedRewards[i],\n                    swapDatas[i]\n                )\n            ) revert Errors.SWAP_FAILED(sellToken);\n\n            /// Refund rest (dust) amount to owner\n            _doRefund(sellToken);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        /// 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        /// 6. Withdraw collateral from the bank and repay the borrowed amount\n        {\n            /// Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        /// Ensure that the Loan to Value (LTV) ratio remains within accepted boundaries\n        _validateMaxLTV(param.strategyId);\n\n        /// 7. Refund any remaining tokens to the owner\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /// @dev Calculate the parameters required for joining a Balancer pool.\n    /// @param vault Address of the Balancer vault\n    /// @param tokens List of tokens in the Balancer pool\n    /// @param balances Balances of tokens in the Balancer pool\n    /// @param lpToken The LP token for the Balancer pool\n    /// @return maxAmountsIn Maximum amounts to deposit for each token\n    /// @return amountsIn Amounts of each token to deposit\n    /// @return poolAmountOut Amount of LP tokens to be received\n    function _getJoinPoolParamsAndApprove(\n        address vault,\n        address[] memory tokens,\n        uint256[] memory balances,\n        address lpToken\n    ) internal returns (uint256[] memory, uint256[] memory, uint256) {\n        uint256 i;\n        uint256 j;\n        uint256 length = tokens.length;\n        uint256[] memory maxAmountsIn = new uint256[](length);\n        uint256[] memory amountsIn = new uint256[](length);\n        bool isLPIncluded;\n\n        for (i; i != length; ) {\n            if (tokens[i] != lpToken) {\n                amountsIn[j] = IERC20(tokens[i]).balanceOf(address(this));\n                if (amountsIn[j] > 0) {\n                    _ensureApprove(tokens[i], vault, amountsIn[j]);\n                }\n                ++j;\n            } else isLPIncluded = true;\n\n            maxAmountsIn[i] = IERC20(tokens[i]).balanceOf(address(this));\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (isLPIncluded) {\n            assembly {\n                mstore(amountsIn, sub(mload(amountsIn), 1))\n            }\n        }\n\n        uint256 totalLPSupply = IBalancerPool(lpToken).getActualSupply();\n        /// compute in reverse order of how Balancer's `joinPool` computes tokenAmountIn\n        uint256 poolAmountOut;\n        for (i = 0; i != length; ) {\n            if ((maxAmountsIn[i] * totalLPSupply) / balances[i] != 0) {\n                poolAmountOut = type(uint256).max;\n                break;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (maxAmountsIn, amountsIn, poolAmountOut);\n    }\n\n    /// @dev Calculate the parameters required for exiting a Balancer pool.\n    /// @param borrowToken The token to be borrowed\n    /// @param lpToken The LP token for the Balancer pool\n    /// @return minAmountsOut Minimum amounts to receive for each token upon exiting\n    /// @return tokens List of tokens in the Balancer pool\n    /// @return exitTokenIndex Index of the borrowToken in the tokens list\n    function _getExitPoolParams(\n        address borrowToken,\n        address lpToken\n    ) internal view returns (uint256[] memory, address[] memory, uint256) {\n        (address[] memory tokens, , ) = wAuraPools.getPoolTokens(lpToken);\n\n        uint256 length = tokens.length;\n        uint256[] memory minAmountsOut = new uint256[](length);\n        uint256 exitTokenIndex;\n\n        for (uint256 i; i != length; ) {\n            if (tokens[i] == borrowToken) break;\n\n            if (tokens[i] != lpToken) ++exitTokenIndex;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (minAmountsOut, tokens, exitTokenIndex);\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/ConvexSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWConvexPools.sol\";\nimport \"../interfaces/curve/ICurvePool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/// @title ConvexSpell\n/// @author BlueberryProtocol\n/// @notice This contract serves as the factory for defining how the Blueberry Protocol \n///         interacts with Convex pools. It handles strategies, interactions with external contracts, \n///         and facilitates operations related to liquidity provision.\ncontract ConvexSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address of the Wrapped Convex Pools\n    IWConvexPools public wConvexPools;\n    /// @dev address of CurveOracle to retrieve pool information\n    ICurveOracle public crvOracle;\n    /// @dev address of CVX token\n    address public CVX;\n\n    /// @dev paraswap AugustusSwapper address for token swaps\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy address for efficient token transfers\n    address public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n        \n    /// @notice Initializes the ConvexSpell contract with required parameters.\n    /// @param bank_ Address of the bank contract.\n    /// @param werc20_ Address of the wrapped ERC20 contract.\n    /// @param weth_ Address of the wrapped Ethereum contract.\n    /// @param wConvexPools_ Address of the wrapped Convex pools contract.\n    /// @param crvOracle_ Address of the Curve Oracle contract.\n    /// @param augustusSwapper_ Address of the paraswap AugustusSwapper.\n    /// @param tokenTransferProxy_ Address of the paraswap TokenTransferProxy.\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wConvexPools_,\n        address crvOracle_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wConvexPools_ == address(0) || crvOracle_ == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        wConvexPools = IWConvexPools(wConvexPools_);\n        CVX = address(wConvexPools.CVX());\n        crvOracle = ICurveOracle(crvOracle_);\n        IWConvexPools(wConvexPools_).setApprovalForAll(address(ba"
    }
  ]
}