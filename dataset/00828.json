{
  "Title": "The `redeemObligation` will always be reverted",
  "Content": "##### Description\n`redeemObligation` is designed to be called when the state is `Outcome.ONGOING`. However, it utilizes [`Battle.withdrawObligation`](https://github.com/DivergenceProtocol/diver-contracts/blob/b094ef8a453f4e0c688f36f8ef7743e7f40a36cb/src/periphery/Manager.sol#L204) which will invariably be reverted under such conditions.\n##### Recommendation\nIt is recommended to either modify `Battle.withdrawObligation` or use an alternative function instead in order to enable the withdrawal of obligations during the `Outcome.ONGOING` state.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/periphery/Manager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC721Enumerable, ERC721 } from \"@oz/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { IERC20 } from \"@oz/token/ERC20/IERC20.sol\";\nimport { ERC20Burnable } from \"@oz/token/ERC20/extensions/ERC20Burnable.sol\";\nimport { Multicall } from \"@oz/utils/Multicall.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\nimport { FullMath } from \"@uniswap/v3-core/contracts/libraries/FullMath.sol\";\nimport { FixedPoint128 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint128.sol\";\nimport { FullMath } from \"@uniswap/v3-core/contracts/libraries/FullMath.sol\";\nimport { FixedPoint128 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint128.sol\";\nimport { BattleInitializer } from \"./base/BattleInitializer.sol\";\nimport { LiquidityManagement } from \"./base/LiquidityManagement.sol\";\nimport { PeripheryImmutableState } from \"./base/PeripheryImmutableState.sol\";\nimport { IBattleActions } from \"../core/interfaces/battle/IBattleActions.sol\";\nimport { BattleTradeParams } from \"../core/params/BattleTradeParams.sol\";\nimport { TradeType } from \"../core/types/enums.sol\";\nimport { TickMath } from \"../core/libs/TickMath.sol\";\nimport { Errors } from \"../core/errors/Errors.sol\";\nimport { BattleBurnParams } from \"../core/params/BattleBurnParams.sol\";\nimport { IBattleState } from \"../core/interfaces/battle/IBattleState.sol\";\nimport { PositionInfo, BattleKey, GrowthX128, Owed, LiquidityType, Outcome } from \"../core/types/common.sol\";\nimport { IArenaCreation } from \"../core/interfaces/IArena.sol\";\nimport { IBattleState } from \"../core/interfaces/battle/IBattleState.sol\";\nimport { IManagerState } from \"./interfaces/IManagerState.sol\";\nimport { IManager } from \"./interfaces/IManager.sol\";\nimport { IManagerLiquidity } from \"./interfaces/IManagerActions.sol\";\nimport { AddLiqParams } from \"./params/Params.sol\";\nimport { TradeParams } from \"./params/Params.sol\";\nimport { PositionState, Position } from \"./types/common.sol\";\n\n/// @title Manager\ncontract Manager is IManager, Multicall, ERC721Enumerable, PeripheryImmutableState, BattleInitializer, LiquidityManagement {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    uint256 public nextId;\n    mapping(uint256 => Position) private _positions;\n\n    constructor(address _arena, address _weth) ERC721(\"Divergence Protocol Positions NFT\", \"DIVER-POS\") PeripheryImmutableState(_arena, _weth) { }\n\n    /// @inheritdoc IManagerLiquidity\n    function addLiquidity(AddLiqParams calldata params) external override returns (uint256 tokenId, uint128 liquidity, uint256 seed) {\n        if (block.timestamp > params.deadline) {\n            revert Errors.Deadline();\n        }\n        AddLiqParams memory p1 = params;\n        p1.recipient = address(this);\n        address battleAddr;\n        (liquidity, seed, battleAddr) = _addLiquidity(p1);\n\n        _mint(params.recipient, (tokenId = nextId++));\n        bytes32 pk = keccak256(abi.encodePacked(address(this), params.tickLower, params.tickUpper));\n        _positions[tokenId] = Position({\n            tokenId: tokenId,\n            battleAddr: battleAddr,\n            tickLower: params.tickLower,\n            tickUpper: params.tickUpper,\n            liquidity: liquidity,\n            liquidityType: params.liquidityType,\n            seed: seed,\n            insideLast: IBattleState(battleAddr).positions(pk).insideLast,\n            owed: Owed(0, 0, 0, 0),\n            state: PositionState.LiquidityAdded,\n            spearObligation: 0,\n            shieldObligation: 0\n        });\n        emit LiquidityAdded(battleAddr, params.recipient, tokenId, liquidity, params.liquidityType, seed);\n    }\n\n    function updateInsideLast(PositionInfo memory pb, Position storage pm) private {\n        unchecked {\n            pm.owed.fee += uint128(FullMath.mulDiv(pb.insideLast.fee - pm.insideLast.fee, pm.liquidity, FixedPoint128.Q128));\n            pm.owed.collateralIn +=\n                uint128(FullMath.mulDiv(pb.insideLast.collateralIn - pm.insideLast.collateralIn, pm.liquidity, FixedPoint128.Q128));\n            pm.owed.spearOut += uint128(FullMath.mulDiv(pb.insideLast.spearOut - pm.insideLast.spearOut, pm.liquidity, FixedPoint128.Q128));\n            pm.owed.shieldOut += uint128(FullMath.mulDiv(pb.insideLast.shieldOut - pm.insideLast.shieldOut, pm.liquidity, FixedPoint128.Q128));\n            pm.insideLast = pb.insideLast;\n        }\n    }\n\n    /// @inheritdoc IManagerLiquidity\n    function removeLiquidity(uint256 tokenId)\n        external\n        override\n        returns (uint256 collateral, uint256 spear, uint256 shield, uint256 spearObligation, uint256 shieldObligation)\n    {\n        if (_ownerOf(tokenId) != msg.sender) {\n            revert Errors.OnlyOwner();\n        }\n        // pm => position in manager\n        Position memory pmMemory = _positions[tokenId];\n        if (pmMemory.state != PositionState.LiquidityAdded) {\n            revert Errors.LiquidityNotAdded();\n        }\n\n        BattleBurnParams memory bp;\n        bp.recipient = msg.sender;\n        bp.tickLower = pmMemory.tickLower;\n        bp.tickUpper = pmMemory.tickUpper;\n        bp.liquidityType = pmMemory.liquidityType == LiquidityType.COLLATERAL\n            ? LiquidityType.COLLATERAL\n            : (pmMemory.liquidityType == LiquidityType.SPEAR ? LiquidityType.SPEAR : LiquidityType.SHIELD);\n        bp.liquidityAmount = pmMemory.liquidity;\n\n        IBattleActions(pmMemory.battleAddr).burn(bp);\n\n        // pb => position in battle\n        PositionInfo memory pb =\n            IBattleState(pmMemory.battleAddr).positions(keccak256(abi.encodePacked(address(this), pmMemory.tickLower, pmMemory.tickUpper)));\n\n        Position storage pmStorage = _positions[tokenId];\n        updateInsideLast(pb, pmStorage);\n        (collateral, spear, shield, spearObligation, shieldObligation) = getObligation(pmStorage);\n        collateral += pmStorage.owed.fee;\n        pmStorage.state = PositionState.LiquidityRemoved;\n        pmStorage.spearObligation = spearObligation;\n        pmStorage.shieldObligation = shieldObligation;\n\n        IBattleActions(pmMemory.battleAddr).collect(msg.sender, collateral, spear, shield);\n\n        emit LiquidityRemoved(tokenId, collateral, spear > shield ? spear : shield);\n    }\n\n    function getObligation(Position memory pm)\n        private\n        pure\n        returns (uint256 collateral, uint256 spear, uint256 shield, uint256 spearObligation, uint256 shieldObligation)\n    {\n        if (pm.liquidityType == LiquidityType.COLLATERAL) {\n            spearObligation = pm.owed.spearOut;\n            shieldObligation = pm.owed.shieldOut;\n            uint256 obligation = spearObligation > shieldObligation ? spearObligation : shieldObligation;\n            // minus 1 to avoid rounding error, insure the collateral is enough\n            // to pay the obligation\n            collateral = pm.owed.collateralIn + pm.seed == obligation ? 0 : pm.owed.collateralIn + pm.seed - obligation - 1;\n        } else if (pm.liquidityType == LiquidityType.SPEAR) {\n            spearObligation = pm.owed.spearOut > pm.seed ? pm.owed.spearOut - pm.seed : 0;\n            shieldObligation = pm.owed.shieldOut;\n            uint256 obligation = spearObligation > shieldObligation ? spearObligation : shieldObligation;\n            // minus 1 to avoid rounding error, insure the collateral is enough\n            // to pay the obligation\n            collateral = pm.owed.collateralIn == obligation ? 0 : pm.owed.collateralIn - obligation - 1;\n            if (pm.seed > pm.owed.spearOut) {\n                spear = pm.seed - pm.owed.spearOut;\n            }\n        } else {\n            spearObligation = pm.owed.spearOut;\n            shieldObligation = pm.owed.shieldOut > pm.seed ? pm.owed.shieldOut - pm.seed : 0;\n            uint256 obligation = spearObligation > shieldObligation ? spearObligation : shieldObligation;\n            // minus 1 to avoid rounding error, insure the collateral is enough\n            // to pay the obligation\n            collateral = pm.owed.collateralIn == obligation ? 0 : pm.owed.collateralIn - obligation - 1;\n            if (pm.seed > pm.owed.shieldOut) {\n                shield = pm.seed - pm.owed.shieldOut;\n            }\n        }\n    }\n\n    /// @inheritdoc IManagerLiquidity\n    function withdrawObligation(uint256 tokenId) external override {\n        Position memory pm = _positions[tokenId];\n\n        if (pm.state != PositionState.LiquidityRemoved) {\n            revert Errors.LiquidityNotRemoved();\n        }\n        Outcome rr = IBattleState(pm.battleAddr).battleOutcome();\n        bool isSpearLess = pm.spearObligation < pm.shieldObligation;\n        uint256 toLp;\n        if (rr == Outcome.ONGOING) {\n            revert Errors.BattleNotEnd();\n        } else if (rr == Outcome.SPEAR_WIN) {\n            if (isSpearLess) {\n                toLp = pm.shieldObligation - pm.spearObligation;\n            }\n        } else {\n            if (!isSpearLess) {\n                toLp = pm.spearObligation - pm.shieldObligation;\n            }\n        }\n        if (toLp > 0) {\n            IBattleActions(pm.battleAddr).withdrawObligation(_ownerOf(tokenId), toLp);\n        }\n        _positions[tokenId].state = PositionState.ObligationWithdrawn;\n        emit ObligationWithdrawn(pm.battleAddr, tokenId, toLp);\n    }\n\n    function redeemObligation(uint256 tokenId) external override {\n        Position memory pm = _positions[tokenId];\n        if (pm.state != PositionState.LiquidityRemoved) {\n            revert Errors.LiquidityNotRemoved();\n        }\n        Outcome rr = IBattleState(pm.battleAddr).battleOutcome();\n        if (rr != Outcome.ONGOING) {\n            revert Errors.BattleEnd();\n        }\n        if (pm.spearObligation != pm.shieldObligation) {\n            (uint256 diff, address stoken, uint256 obli) = pm.spearObligation > pm.shieldObligation\n                ? (pm.spearObligation - pm.shieldObligation, IBattleState(pm.battleAddr).spear(), pm.shieldObligation)\n                : (pm.shieldObligation - pm.spearObligation, IBattleState(pm.battleAddr).shield(), pm.spearObligation);\n            ERC20Burnable(stoken).burnFrom(msg.sender, diff);\n            IBattleActions(pm.battleAddr).withdrawObligation(_ownerOf(tokenId), obli);\n            emit ObligationRedeemed(pm.battleAddr, tokenId, obli);\n        }\n    }\n\n    function trade(TradeParams calldata p) external override returns (uint256 amountIn, uint256 amountOut) {\n        if (block.timestamp > p.deadline) {\n            revert Errors.Deadline();\n        }\n\n        address battle = IArenaCreation(arena).getBattle(p.battleKey);\n        if (battle == address(0)) {\n            revert Errors.BattleNotExist();\n        }\n\n        BattleTradeParams memory tps;\n        tps.recipient = p.recipient;\n        tps.tradeType = p.tradeType;\n        tps.amountSpecified = p.amountSpecified;\n        tps.data = abi.encode(TradeCallbackData({ battleKey: p.battleKey, payer: msg.sender }));\n        if (p.sqrtPriceLimitX96 == 0) {\n            if (p.tradeType == TradeType.BUY_SPEAR) {\n                tps.sqrtPriceLimitX96 = TickMath.MIN_SQRT_RATIO + 1;\n            } else {\n                tps.sqrtPriceLimitX96 = TickMath.MAX_SQRT_RATIO - 1;\n            }\n        } else {\n            tps.sqrtPriceLimitX96 = p.sqrtPriceLimitX96;\n        }\n\n        // call battle\n        (amountIn, amountOut) = IBattleActions(battle).trade(tps);\n        if (amountOut < p.amountOutMin) {\n            revert Errors.Slippage();\n        }\n        emit Traded(p.recipient, p.tradeType, amountIn, amountOut);\n    }\n\n    function tradeCallback(uint256 cAmount, uint256 sAmount, bytes calldata _data) external override {\n        TradeCallbackData memory data = abi.decode(_data, (TradeCallbackData));\n        address battle = IArenaCreation(arena).getBattle(data.battleKey);\n        if (battle == address(0)) {\n            revert Errors.BattleNotExist();\n        }\n        if (msg.sender != battle) {\n            revert Errors.CallerNotBattle();\n        }\n        pay(data.battleKey.collateral, data.payer, msg.sender, cAmount);\n    }\n\n    // ====view====\n\n    /// @inheritdoc IManagerState\n    function positions(uint256 tokenId) external view override returns (Position memory) {\n        return _positions[tokenId];\n        // return handlePosition(tokenId);\n    }\n\n    // function handlePosition(uint256 tokenId) private view returns (Position memory p) {\n    //     p = _positions[tokenId];\n    //     if (p.state == PositionState.LiquidityAdded) {\n    //         unchecked {\n    //             GrowthX128 memory insideLast = IBattleState(p.battleAddr).getInsideLast(p.tickLower, p.tickUpper);\n    //             p.owed.fee += uint128(FullMath.mulDiv(insideLast.fee - p.insideLast.fee, p.liquidity, FixedPoint128.Q128));\n    //             p.owed.collateralIn += uint128(FullMath.mulDiv(insideLast.collateralIn - p.insideLast.collateralIn, p.liquidity,\n    // FixedPoint128.Q128));\n    //             p.owed.spearOut += uint128(FullMath.mulDiv(insideLast.spearOut - p.insideLast.spearOut, p.liquidity, FixedPoint128.Q128));\n    //             p.owed.shieldOut += uint128(FullMath.mulDiv(insideLast.shieldOut - p.insideLast.shieldOut, p.liquidity, FixedPoint128.Q128));\n    //             p.insideLast = insideLast;\n    //         }\n    //     }\n    // }\n\n    /// @inheritdoc IManagerState\n    // function accountPositions(address account) external view override returns (Position[] memory) {\n    //     uint256 balance = balanceOf(account);\n    //     Position[] memory p = new Position[](balance);\n    //     for (uint256 i = 0; i < balance; i++) {\n    //         p[i] = handlePosition(tokenOfOwnerByIndex(account, i));\n    //     }\n    //     return p;\n    // }\n}"
    }
  ]
}