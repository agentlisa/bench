{
  "Title": "[M07] Elements with equal value within a Sorted List can be arbitrary ordered",
  "Content": "When using the [`SortedLinkedList` library](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedList.sol#L9), the [`update` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedList.sol#L64) makes use of the `remove` and the [`insert` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedList.sol#L25). After [some validations](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedList.sol#L32-L41) , the `insert` function uses the [`isValueBetween` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedList.sol#L198), which will return true if the [`lesserKey` is 0 or if the value associated with `lesserKey` is less or equal than `value`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedList.sol#L203) or if the [`greaterKey` equals 0 or the value associated with `greaterKey` is greater than or equal to `value`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedList.sol#L204)\n\n\nThis will allow any `update` operation to move a specific item in the list to the spot directly before or after an item if the `value` is the same for both.\n\n\nThroughout the code there are two specific places in which this behavior can be used to manipulate the Celo protocol. Both the [`queue`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L97) variable in the `Governance` contract and the [`eligible`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L73) variable in the `Election` contract belong to the `SortedLinkedList.List` type. The first one saves the proposals [in the order they will be dequeued](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L965) and the second one holds the eligible validator groups ordered by number of votes, [establishing the winners of an election](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L826). By using the [`upvote`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L458-L497) or the [`revokeUpvote`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L523-L549) functions in the first case, or using the [`vote`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L211-L237),[`revokePending`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L281-L303) or [`revokeActive`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L317-L340) functions in the second case, a participant of the Celo protocol can order themselves at any position as a selected proposal or validator by matching the amount of votes of the selected element in the list and by using specially crafted `lesser` and `greater` parameters.\n\n\nConsider reviewing if this is the intended case of the library and documenting it, explaining the risk and attack vectors that may arise from this behavior.\n\n\n****Update:*** Not Fixed. cLabs’ statement for this issue:*\n\n\n\n> \n> There are four such examples of sorted lists:  \n> \n> 1. The list of election eligible validator groups, ordered by vote total. Here, ties are very unlikely, as votes are denominated in wei. Furthermore, ties would only have an effect if the groups that are tied spanned the boundary defined by ​maxElectableValidators​. Otherwise, the ordering of groups that are tied in the number of votes does not affect election results, even if those groups happen to elect validators.  \n> \n> 2. The list of governance proposals, ordered by upvote total. Here, ties are very unlikely, as votes are denominated in wei. Furthermore, ties would only have an effect if the tied proposals spanned the boundary defined by concurrentProposals​. Even if this was the case, the ramifications would be minor, as the tied proposal(s) that didn’t get dequeued would become the proposal(s) with the highest number of upvotes, making it extremely likely the proposal would get dequeued next.  \n> \n> 3. The list of oracle reports for a given token, ordered by price. Here, the unstable sorting doesn’t matter, as the same median value will be returned regardless of how ties are ordered.  \n> \n> 4. The list of oracle reports for a given token, ordered by timestamp. Here, the unstable sorting doesn’t matter, as the same median value will be returned regardless of how ties are ordered.\n> \n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/linkedlists/SortedLinkedList.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./LinkedList.sol\";\n\n/**\n * @title Maintains a sorted list of unsigned ints keyed by bytes32.\n */\nlibrary SortedLinkedList {\n  using SafeMath for uint256;\n  using LinkedList for LinkedList.List;\n\n  struct List {\n    LinkedList.List list;\n    mapping(bytes32 => uint256) values;\n  }\n\n  /**\n   * @notice Inserts an element into a doubly linked list.\n   * @param key The key of the element to insert.\n   * @param value The element value.\n   * @param lesserKey The key of the element less than the element to insert.\n   * @param greaterKey The key of the element greater than the element to insert.\n   */\n  function insert(\n    List storage list,\n    bytes32 key,\n    uint256 value,\n    bytes32 lesserKey,\n    bytes32 greaterKey\n  ) public {\n    require(\n      key != bytes32(0) && key != lesserKey && key != greaterKey && !contains(list, key),\n      \"invalid key\"\n    );\n    require(\n      (lesserKey != bytes32(0) || greaterKey != bytes32(0)) || list.list.numElements == 0,\n      \"greater and lesser key zero\"\n    );\n    require(contains(list, lesserKey) || lesserKey == bytes32(0), \"invalid lesser key\");\n    require(contains(list, greaterKey) || greaterKey == bytes32(0), \"invalid greater key\");\n    (lesserKey, greaterKey) = getLesserAndGreater(list, value, lesserKey, greaterKey);\n    list.list.insert(key, lesserKey, greaterKey);\n    list.values[key] = value;\n  }\n\n  /**\n   * @notice Removes an element from the doubly linked list.\n   * @param key The key of the element to remove.\n   */\n  function remove(List storage list, bytes32 key) public {\n    list.list.remove(key);\n    list.values[key] = 0;\n  }\n\n  /**\n   * @notice Updates an element in the list.\n   * @param key The element key.\n   * @param value The element value.\n   * @param lesserKey The key of the element will be just left of `key` after the update.\n   * @param greaterKey The key of the element will be just right of `key` after the update.\n   * @dev Note that only one of \"lesserKey\" or \"greaterKey\" needs to be correct to reduce friction.\n   */\n  function update(\n    List storage list,\n    bytes32 key,\n    uint256 value,\n    bytes32 lesserKey,\n    bytes32 greaterKey\n  ) public {\n    // TODO(asa): Optimize by not making any changes other than value if lesserKey and greaterKey\n    // don't change.\n    // TODO(asa): Optimize by not updating lesserKey/greaterKey for key\n    remove(list, key);\n    insert(list, key, value, lesserKey, greaterKey);\n  }\n\n  /**\n   * @notice Inserts an element at the tail of the doubly linked list.\n   * @param key The key of the element to insert.\n   */\n  function push(List storage list, bytes32 key) public {\n    insert(list, key, 0, bytes32(0), list.list.tail);\n  }\n\n  /**\n   * @notice Removes N elements from the head of the list and returns their keys.\n   * @param n The number of elements to pop.\n   * @return The keys of the popped elements.\n   */\n  function popN(List storage list, uint256 n) public returns (bytes32[] memory) {\n    require(n <= list.list.numElements, \"not enough elements\");\n    bytes32[] memory keys = new bytes32[](n);\n    for (uint256 i = 0; i < n; i++) {\n      bytes32 key = list.list.head;\n      keys[i] = key;\n      remove(list, key);\n    }\n    return keys;\n  }\n\n  /**\n   * @notice Returns whether or not a particular key is present in the sorted list.\n   * @param key The element key.\n   * @return Whether or not the key is in the sorted list.\n   */\n  function contains(List storage list, bytes32 key) public view returns (bool) {\n    return list.list.contains(key);\n  }\n\n  /**\n   * @notice Returns the value for a particular key in the sorted list.\n   * @param key The element key.\n   * @return The element value.\n   */\n  function getValue(List storage list, bytes32 key) public view returns (uint256) {\n    return list.values[key];\n  }\n\n  /**\n   * @notice Gets all elements from the doubly linked list.\n   * @return An unpacked list of elements from largest to smallest.\n   */\n  function getElements(List storage list) public view returns (bytes32[] memory, uint256[] memory) {\n    bytes32[] memory keys = getKeys(list);\n    uint256[] memory values = new uint256[](keys.length);\n    for (uint256 i = 0; i < keys.length; i = i.add(1)) {\n      values[i] = list.values[keys[i]];\n    }\n    return (keys, values);\n  }\n\n  /**\n   * @notice Gets all element keys from the doubly linked list.\n   * @return All element keys from head to tail.\n   */\n  function getKeys(List storage list) public view returns (bytes32[] memory) {\n    return list.list.getKeys();\n  }\n\n  /**\n   * @notice Returns first N greatest elements of the list.\n   * @param n The number of elements to return.\n   * @return The keys of the first n elements.\n   * @dev Reverts if n is greater than the number of elements in the list.\n   */\n  function headN(List storage list, uint256 n) public view returns (bytes32[] memory) {\n    return list.list.headN(n);\n  }\n\n  // TODO(asa): Gas optimizations by passing in elements to isValueBetween\n  /**\n   * @notice Returns the keys of the elements greaterKey than and less than the provided value.\n   * @param value The element value.\n   * @param lesserKey The key of the element which could be just left of the new value.\n   * @param greaterKey The key of the element which could be just right of the new value.\n   * @return The correct lesserKey/greaterKey keys.\n   */\n  function getLesserAndGreater(\n    List storage list,\n    uint256 value,\n    bytes32 lesserKey,\n    bytes32 greaterKey\n  ) private view returns (bytes32, bytes32) {\n    // Check for one of the following conditions and fail if none are met:\n    //   1. The value is less than the current lowest value\n    //   2. The value is greater than the current greatest value\n    //   3. The value is just greater than the value for `lesserKey`\n    //   4. The value is just less than the value for `greaerKey`\n    if (lesserKey == bytes32(0) && isValueBetween(list, value, lesserKey, list.list.tail)) {\n      return (lesserKey, list.list.tail);\n    } else if (\n      greaterKey == bytes32(0) && isValueBetween(list, value, list.list.head, greaterKey)\n    ) {\n      return (list.list.head, greaterKey);\n    } else if (\n      lesserKey != bytes32(0) &&\n      isValueBetween(list, value, lesserKey, list.list.elements[lesserKey].nextKey)\n    ) {\n      return (lesserKey, list.list.elements[lesserKey].nextKey);\n    } else if (\n      greaterKey != bytes32(0) &&\n      isValueBetween(list, value, list.list.elements[greaterKey].previousKey, greaterKey)\n    ) {\n      return (list.list.elements[greaterKey].previousKey, greaterKey);\n    } else {\n      require(false, \"get lesser and greater failure\");\n    }\n  }\n\n  /**\n   * @notice Returns whether or not a given element is between two other elements.\n   * @param value The element value.\n   * @param lesserKey The key of the element whose value should be lesserKey.\n   * @param greaterKey The key of the element whose value should be greaterKey.\n   * @return True if the given element is between the two other elements.\n   */\n  function isValueBetween(List storage list, uint256 value, bytes32 lesserKey, bytes32 greaterKey)\n    private\n    view\n    returns (bool)\n  {\n    bool isLesser = lesserKey == bytes32(0) || list.values[lesserKey] <= value;\n    bool isGreater = greaterKey == bytes32(0) || list.values[greaterKey] >= value;\n    return isLesser && isGreater;\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/governance/Governance.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IGovernance.sol\";\nimport \"./Proposals.sol\";\nimport \"../common/ExtractFunctionSignature.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/linkedlists/IntegerSortedLinkedList.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n// TODO(asa): Hardcode minimum times for queueExpiry, etc.\n/**\n * @title A contract for making, passing, and executing on-chain governance proposals.\n */\ncontract Governance is\n  IGovernance,\n  Ownable,\n  Initializable,\n  ReentrancyGuard,\n  UsingRegistry,\n  UsingPrecompiles\n{\n  using Proposals for Proposals.Proposal;\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n  using IntegerSortedLinkedList for SortedLinkedList.List;\n  using BytesLib for bytes;\n\n  uint256 private constant FIXED_HALF = 500000000000000000000000;\n\n  enum VoteValue { None, Abstain, No, Yes }\n\n  struct UpvoteRecord {\n    uint256 proposalId;\n    uint256 weight;\n  }\n\n  struct VoteRecord {\n    Proposals.VoteValue value;\n    uint256 proposalId;\n    uint256 weight;\n  }\n\n  struct Voter {\n    // Key of the proposal voted for in the proposal queue\n    UpvoteRecord upvote;\n    uint256 mostRecentReferendumProposal;\n    // Maps a `dequeued` index to a voter's vote record.\n    mapping(uint256 => VoteRecord) referendumVotes;\n  }\n\n  struct ContractConstitution {\n    FixidityLib.Fraction defaultThreshold;\n    // Maps a function ID to a corresponding threshold, overriding the default.\n    mapping(bytes4 => FixidityLib.Fraction) functionThresholds;\n  }\n\n  struct HotfixRecord {\n    bool executed;\n    bool approved;\n    uint256 preparedEpoch;\n    mapping(address => bool) whitelisted;\n  }\n\n  // The baseline is updated as\n  // max{floor, (1 - baselineUpdateFactor) * baseline + baselineUpdateFactor * participation}\n  struct ParticipationParameters {\n    // The average network participation in governance, weighted toward recent proposals.\n    FixidityLib.Fraction baseline;\n    // The lower bound on the participation baseline.\n    FixidityLib.Fraction baselineFloor;\n    // The weight of the most recent proposal's participation on the baseline.\n    FixidityLib.Fraction baselineUpdateFactor;\n    // The proportion of the baseline that constitutes quorum.\n    FixidityLib.Fraction baselineQuorumFactor;\n  }\n\n  Proposals.StageDurations public stageDurations;\n  uint256 public queueExpiry;\n  uint256 public dequeueFrequency;\n  address public approver;\n  uint256 public lastDequeue;\n  uint256 public concurrentProposals;\n  uint256 public proposalCount;\n  uint256 public minDeposit;\n  mapping(address => uint256) public refundedDeposits;\n  mapping(address => ContractConstitution) private constitution;\n  mapping(uint256 => Proposals.Proposal) private proposals;\n  mapping(address => Voter) private voters;\n  mapping(bytes32 => HotfixRecord) public hotfixes;\n  SortedLinkedList.List private queue;\n  uint256[] public dequeued;\n  uint256[] public emptyIndices;\n  ParticipationParameters private participationParameters;\n\n  event ApproverSet(address approver);\n\n  event ConcurrentProposalsSet(uint256 concurrentProposals);\n\n  event MinDepositSet(uint256 minDeposit);\n\n  event QueueExpirySet(uint256 queueExpiry);\n\n  event DequeueFrequencySet(uint256 dequeueFrequency);\n\n  event ApprovalStageDurationSet(uint256 approvalStageDuration);\n\n  event ReferendumStageDurationSet(uint256 referendumStageDuration);\n\n  event ExecutionStageDurationSet(uint256 executionStageDuration);\n\n  event ConstitutionSet(address indexed destination, bytes4 indexed functionId, uint256 threshold);\n\n  event ProposalQueued(\n    uint256 indexed proposalId,\n    address indexed proposer,\n    uint256 transactionCount,\n    uint256 deposit,\n    uint256 timestamp\n  );\n\n  event ProposalUpvoted(uint256 indexed proposalId, address indexed account, uint256 upvotes);\n\n  event ProposalUpvoteRevoked(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 revokedUpvotes\n  );\n\n  event ProposalDequeued(uint256 indexed proposalId, uint256 timestamp);\n\n  event ProposalApproved(uint256 indexed proposalId);\n\n  event ProposalVoted(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 value,\n    uint256 weight\n  );\n\n  event ProposalExecuted(uint256 indexed proposalId);\n\n  event ProposalExpired(uint256 proposalId);\n\n  event ParticipationBaselineUpdated(uint256 participationBaseline);\n\n  event ParticipationFloorSet(uint256 participationFloor);\n\n  event ParticipationBaselineUpdateFactorSet(uint256 baselineUpdateFactor);\n\n  event ParticipationBaselineQuorumFactorSet(uint256 baselineQuorumFactor);\n\n  event HotfixWhitelisted(bytes32 indexed hash, address whitelister);\n\n  event HotfixApproved(bytes32 indexed hash);\n\n  event HotfixPrepared(bytes32 indexed hash, uint256 indexed epoch);\n\n  event HotfixExecuted(bytes32 indexed hash);\n\n  function() external payable {} // solhint-disable no-empty-blocks\n\n  /**\n   * @notice Initializes critical variables.\n   * @param registryAddress The address of the registry contract.\n   * @param _approver The address that needs to approve proposals to move to the referendum stage.\n   * @param _concurrentProposals The number of proposals to dequeue at once.\n   * @param _minDeposit The minimum Celo Gold deposit needed to make a proposal.\n   * @param _queueExpiry The number of seconds a proposal can stay in the queue before expiring.\n   * @param _dequeueFrequency The number of seconds before the next batch of proposals can be\n   *   dequeued.\n   * @param approvalStageDuration The number of seconds the approver has to approve a proposal\n   *   after it is dequeued.\n   * @param referendumStageDuration The number of seconds users have to vote on a dequeued proposal\n   *   after the approval stage ends.\n   * @param executionStageDuration The number of seconds users have to execute a passed proposal\n   *   after the referendum stage ends.\n   * @param participationBaseline The initial value of the participation baseline.\n   * @param participationFloor The participation floor.\n   * @param baselineUpdateFactor The weight of the new participation in the baseline update rule.\n   * @param baselineQuorumFactor The proportion of the baseline that constitutes quorum.\n   * @dev Should be called only once.\n   */\n  function initialize(\n    address registryAddress,\n    address _approver,\n    uint256 _concurrentProposals,\n    uint256 _minDeposit,\n    uint256 _queueExpiry,\n    uint256 _dequeueFrequency,\n    uint256 approvalStageDuration,\n    uint256 referendumStageDuration,\n    uint256 executionStageDuration,\n    uint256 participationBaseline,\n    uint256 participationFloor,\n    uint256 baselineUpdateFactor,\n    uint256 baselineQuorumFactor\n  ) external initializer {\n    require(\n      _approver != address(0) &&\n        _concurrentProposals != 0 &&\n        _minDeposit != 0 &&\n        _queueExpiry != 0 &&\n        _dequeueFrequency != 0 &&\n        approvalStageDuration != 0 &&\n        referendumStageDuration != 0 &&\n        executionStageDuration != 0,\n      \"Bad input\"\n    );\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    approver = _approver;\n    concurrentProposals = _concurrentProposals;\n    minDeposit = _minDeposit;\n    queueExpiry = _queueExpiry;\n    dequeueFrequency = _dequeueFrequency;\n    stageDurations.approval = approvalStageDuration;\n    stageDurations.referendum = referendumStageDuration;\n    stageDurations.execution = executionStageDuration;\n    setParticipationBaseline(participationBaseline);\n    setParticipationFloor(participationFloor);\n    setBaselineUpdateFactor(baselineUpdateFactor);\n    setBaselineQuorumFactor(baselineQuorumFactor);\n    // solhint-disable-next-line not-rely-on-time\n    lastDequeue = now;\n  }\n\n  /**\n   * @notice Updates the address that has permission to approve proposals in the approval stage.\n   * @param _approver The address that has permission to approve proposals in the approval stage.\n   */\n  function setApprover(address _approver) external onlyOwner {\n    require(_approver != address(0), \"Approver cannot be 0\");\n    require(_approver != approver, \"Approver unchanged\");\n    approver = _approver;\n    emit ApproverSet(_approver);\n  }\n\n  /**\n   * @notice Updates the number of proposals to dequeue at a time.\n   * @param _concurrentProposals The number of proposals to dequeue at at a time.\n   */\n  function setConcurrentProposals(uint256 _concurrentProposals) external onlyOwner {\n    require(_concurrentProposals > 0, \"Number of proposals must be larger than zero\");\n    require(_concurrentProposals != concurrentProposals, \"Number of proposals unchanged\");\n    concurrentProposals = _concurrentProposals;\n    emit ConcurrentProposalsSet(_concurrentProposals);\n  }\n\n  /**\n   * @notice Updates the minimum deposit needed to make a proposal.\n   * @param _minDeposit The minimum Celo Gold deposit needed to make a proposal.\n   */\n  function setMinDeposit(uint256 _minDeposit) external onlyOwner {\n    require(_minDeposit != minDeposit, \"Minimum deposit unchanged\");\n    minDeposit = _minDeposit;\n    emit MinDepositSet(_minDeposit);\n  }\n\n  /**\n   * @notice Updates the number of seconds before a queued proposal expires.\n   * @param _queueExpiry The number of seconds a proposal can stay in the queue before expiring.\n   */\n  function setQueueExpiry(uint256 _queueExpiry) external onlyOwner {\n    require(_queueExpiry > 0, \"QueueExpiry must be larger than 0\");\n    require(_queueExpiry != queueExpiry, \"QueueExpiry unchanged\");\n    queueExpiry = _queueExpiry;\n    emit QueueExpirySet(_queueExpiry);\n  }\n\n  /**\n   * @notice Updates the minimum number of seconds before the next batch of proposals can be\n   *   dequeued.\n   * @param _dequeueFrequency The number of seconds before the next batch of proposals can be\n   *   dequeued.\n   */\n  function setDequeueFrequency(uint256 _dequeueFrequency) external onlyOwner {\n    require(_dequeueFrequency > 0, \"dequeueFrequency must be larger than 0\");\n    require(_dequeueFrequency != dequeueFrequency, \"dequeueFrequency unchanged\");\n    dequeueFrequency = _dequeueFrequency;\n    emit DequeueFrequencySet(_dequeueFrequency);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the approval stage.\n   * @param approvalStageDuration The number of seconds proposals stay in the approval stage.\n   */\n  function setApprovalStageDuration(uint256 approvalStageDuration) external onlyOwner {\n    require(approvalStageDuration > 0, \"Duration must be larger than 0\");\n    require(approvalStageDuration != stageDurations.approval, \"Duration unchanged\");\n    stageDurations.approval = approvalStageDuration;\n    emit ApprovalStageDurationSet(approvalStageDuration);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the referendum stage.\n   * @param referendumStageDuration The number of seconds proposals stay in the referendum stage.\n   */\n  function setReferendumStageDuration(uint256 referendumStageDuration) external onlyOwner {\n    require(referendumStageDuration > 0, \"Duration must be larger than 0\");\n    require(referendumStageDuration != stageDurations.referendum, \"Duration unchanged\");\n    stageDurations.referendum = referendumStageDuration;\n    emit ReferendumStageDurationSet(referendumStageDuration);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the execution stage.\n   * @param executionStageDuration The number of seconds proposals stay in the execution stage.\n   */\n  function setExecutionStageDuration(uint256 executionStageDuration) external onlyOwner {\n    require(executionStageDuration > 0, \"Duration must be larger than 0\");\n    require(executionStageDuration != stageDurations.execution, \"Duration unchanged\");\n    stageDurations.execution = executionStageDuration;\n    emit ExecutionStageDurationSet(executionStageDuration);\n  }\n\n  /**\n   * @notice Updates the participation baseline.\n   * @param participationBaseline The value of the baseline.\n   */\n  function setParticipationBaseline(uint256 participationBaseline) public onlyOwner {\n    FixidityLib.Fraction memory participationBaselineFrac = FixidityLib.wrap(participationBaseline);\n    require(\n      FixidityLib.isProperFraction(participationBaselineFrac),\n      \"Participation baseline greater than one\"\n    );\n    require(\n      !participationBaselineFrac.equals(participationParameters.baseline),\n      \"Participation baseline unchanged\"\n    );\n    participationParameters.baseline = participationBaselineFrac;\n    emit ParticipationBaselineUpdated(participationBaseline);\n  }\n\n  /**\n   * @notice Updates the floor of the participation baseline.\n   * @param participationFloor The value at which the baseline is floored.\n   */\n  function setParticipationFloor(uint256 participationFloor) public onlyOwner {\n    FixidityLib.Fraction memory participationFloorFrac = FixidityLib.wrap(participationFloor);\n    require(\n      FixidityLib.isProperFraction(participationFloorFrac),\n      \"Participation floor greater than one\"\n    );\n    require(\n      !participationFloorFrac.equals(participationParameters.baselineFloor),\n      \"Participation baseline floor unchanged\"\n    );\n    participationParameters.baselineFloor = participationFloorFrac;\n    emit ParticipationFloorSet(participationFloor);\n  }\n\n  /**\n   * @notice Updates the weight of the new participation in the baseline update rule.\n   * @param baselineUpdateFactor The new baseline update factor.\n   */\n  function setBaselineUpdateFactor(uint256 baselineUpdateFactor) public onlyOwner {\n    FixidityLib.Fraction memory baselineUpdateFactorFrac = FixidityLib.wrap(baselineUpdateFactor);\n    require(\n      FixidityLib.isProperFraction(baselineUpdateFactorFrac),\n      \"Baseline update factor greater than one\"\n    );\n    require(\n      !baselineUpdateFactorFrac.equals(participationParameters.baselineUpdateFactor),\n      \"Baseline update factor unchanged\"\n    );\n    participationParameters.baselineUpdateFactor = baselineUpdateFactorFrac;\n    emit ParticipationBaselineUpdateFactorSet(baselineUpdateFactor);\n  }\n\n  /**\n   * @notice Updates the proportion of the baseline that constitutes quorum.\n   * @param baselineQuorumFactor The new baseline quorum factor.\n   */\n  function setBaselineQuorumFactor(uint256 baselineQuorumFactor) public onlyOwner {\n    FixidityLib.Fraction memory baselineQuorumFactorFrac = FixidityLib.wrap(baselineQuorumFactor);\n    require(\n      FixidityLib.isProperFraction(baselineQuorumFactorFrac),\n      \"Baseline quorum factor greater than one\"\n    );\n    require(\n      !baselineQuorumFactorFrac.equals(participationParameters.baselineQuorumFactor),\n      \"Baseline quorum factor unchanged\"\n    );\n    participationParameters.baselineQuorumFactor = baselineQuorumFactorFrac;\n    emit ParticipationBaselineQuorumFactorSet(baselineQuorumFactor);\n  }\n\n  /**\n   * @notice Updates the ratio of yes:yes+no votes needed for a specific class of proposals to pass.\n   * @param destination The destination of proposals for which this threshold should apply.\n   * @param functionId The function ID of proposals for which this threshold should apply. Zero\n   *   will set the default.\n   * @param threshold The threshold.\n   * @dev If no constitution is explicitly set the default is a simple majority, i.e. 1:2.\n   */\n  function setConstitution(address destination, bytes4 functionId, uint256 threshold)\n    external\n    onlyOwner\n  {\n    // TODO(asa): https://github.com/celo-org/celo-monorepo/pull/3414#discussion_r283588332\n    require(destination != address(0), \"Destination cannot be zero\");\n    require(\n      threshold > FIXED_HALF && threshold <= FixidityLib.fixed1().unwrap(),\n      \"Threshold has to be greater than majority and not greater than unanimity\"\n    );\n    if (functionId == 0) {\n      constitution[destination].defaultThreshold = FixidityLib.wrap(threshold);\n    } else {\n      constitution[destination].functionThresholds[functionId] = FixidityLib.wrap(threshold);\n    }\n    emit ConstitutionSet(destination, functionId, threshold);\n  }\n\n  /**\n   * @notice Creates a new proposal and adds it to end of the queue with no upvotes.\n   * @param values The values of Celo Gold to be sent in the proposed transactions.\n   * @param destinations The destination addresses of the proposed transactions.\n   * @param data The concatenated data to be included in the proposed transactions.\n   * @param dataLengths The lengths of each transaction's data.\n   * @return The ID of the newly proposed proposal.\n   * @dev The minimum deposit must be included with the proposal, returned if/when the proposal is\n   *   dequeued.\n   */\n  function propose(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths\n  ) external payable returns (uint256) {\n    dequeueProposalsIfReady();\n    require(msg.value >= minDeposit, \"Too small deposit\");\n\n    proposalCount = proposalCount.add(1);\n    Proposals.Proposal storage proposal = proposals[proposalCount];\n    proposal.make(values, destinations, data, dataLengths, msg.sender, msg.value);\n    queue.push(proposalCount);\n    // solhint-disable-next-line not-rely-on-time\n    emit ProposalQueued(proposalCount, msg.sender, proposal.transactions.length, msg.value, now);\n    return proposalCount;\n  }\n\n  /**\n   * @notice Upvotes a queued proposal.\n   * @param proposalId The ID of the proposal to upvote.\n   * @param lesser The ID of the proposal that will be just behind `proposalId` in the queue.\n   * @param greater The ID of the proposal that will be just ahead `proposalId` in the queue.\n   * @return Whether or not the upvote was made successfully.\n   * @dev Provide 0 for `lesser`/`greater` when the proposal will be at the tail/head of the queue.\n   * @dev Reverts if the account has already upvoted a proposal in the queue.\n   */\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    // TODO(asa): When upvoting a proposal that will get dequeued, should we let the tx succeed\n    // and return false?\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    // solhint-disable-next-line not-rely-on-time\n    if (queue.contains(proposalId) && now >= proposals[proposalId].timestamp.add(queueExpiry)) {\n      queue.remove(proposalId);\n      emit ProposalExpired(proposalId);\n      return false;\n    }\n    Voter storage voter = voters[account];\n    // If the previously upvoted proposal is still in the queue but has expired, expire the\n    // proposal from the queue.\n    if (\n      queue.contains(voter.upvote.proposalId) &&\n      now >= proposals[voter.upvote.proposalId].timestamp.add(queueExpiry)\n    ) {\n      queue.remove(voter.upvote.proposalId);\n      emit ProposalExpired(voter.upvote.proposalId);\n    }\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(isQueued(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n  /**\n   * @notice Returns stage of governance process given proposal is in\n   * @param proposalId The ID of the proposal to query.\n   * @return proposal stage\n   */\n  function getProposalStage(uint256 proposalId) external view returns (Proposals.Stage) {\n    if (proposalId == 0 || proposalId > proposalCount) {\n      return Proposals.Stage.None;\n    } else if (isQueued(proposalId)) {\n      return Proposals.Stage.Queued;\n    } else {\n      return proposals[proposalId].getDequeuedStage(stageDurations);\n    }\n  }\n\n  /**\n   * @notice Revokes an upvote on a queued proposal.\n   * @param lesser The ID of the proposal that will be just behind the previously upvoted proposal\n   *   in the queue.\n   * @param greater The ID of the proposal that will be just ahead of the previously upvoted\n   *   proposal in the queue.\n   * @return Whether or not the upvote was revoked successfully.\n   * @dev Provide 0 for `lesser`/`greater` when the proposal will be at the tail/head of the queue.\n   */\n  function revokeUpvote(uint256 lesser, uint256 greater) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    uint256 proposalId = voter.upvote.proposalId;\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    require(proposal.exists(), \"Proposal doesn't exist\");\n    // If acting on an expired proposal, expire the proposal.\n    // TODO(asa): Break this out into a separate function.\n    if (queue.contains(proposalId)) {\n      // solhint-disable-next-line not-rely-on-time\n      if (now >= proposal.timestamp.add(queueExpiry)) {\n        queue.remove(proposalId);\n        emit ProposalExpired(proposalId);\n      } else {\n        queue.update(\n          proposalId,\n          queue.getValue(proposalId).sub(voter.upvote.weight),\n          lesser,\n          greater\n        );\n        emit ProposalUpvoteRevoked(proposalId, account, voter.upvote.weight);\n      }\n    }\n    voter.upvote = UpvoteRecord(0, 0);\n    return true;\n  }\n\n  // TODO(asa): Consider allowing approval to be revoked.\n  // TODO(asa): Everywhere we use an index, require it's less than the array length\n  /**\n   * @notice Approves a proposal in the approval stage.\n   * @param proposalId The ID of the proposal to approve.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether or not the approval was made successfully.\n   */\n  function approve(uint256 proposalId, uint256 index) external returns (bool) {\n    dequeueProposalsIfReady();\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    require(isDequeuedProposal(proposal, proposalId, index), \"Proposal not dequeued\");\n    Proposals.Stage stage = proposal.getDequeuedStage(stageDurations);\n    if (isDequeuedProposalExpired(proposal, stage)) {\n      deleteDequeuedProposal(proposal, proposalId, index);\n      return false;\n    }\n    require(msg.sender == approver, \"Only approver can approve\");\n    require(!proposal.isApproved(), \"Proposal already approved\");\n    require(stage == Proposals.Stage.Approval, \"Proposal not in approval stage\");\n    proposal.approved = true;\n    // Ensures networkWeight is set by the end of the Referendum stage, even if 0 votes are cast.\n    proposal.networkWeight = getLockedGold().getTotalLockedGold();\n    emit ProposalApproved(proposalId);\n    return true;\n  }\n\n  /**\n   * @notice Votes on a proposal in the referendum stage.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @param value Whether to vote yes, no, or abstain.\n   * @return Whether or not the vote was cast successfully.\n   */\n  /* solhint-disable code-complexity */\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    dequeueProposalsIfReady();\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    require(isDequeuedProposal(proposal, proposalId, index), \"Proposal not dequeued\");\n    Proposals.Stage stage = proposal.getDequeuedStage(stageDurations);\n    if (isDequeuedProposalExpired(proposal, stage)) {\n      deleteDequeuedProposal(proposal, proposalId, index);\n      return false;\n    }\n    Voter storage voter = voters[account];\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(proposal.isApproved(), \"Proposal not approved\");\n    require(\n      stage == Proposals.Stage.Referendum && value != Proposals.VoteValue.None && weight > 0,\n      \"Incorrect proposal state\"\n    );\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n    require(weight > 0, \"Voter weight zero\");\n    VoteRecord storage voteRecord = voter.referendumVotes[index];\n    proposal.updateVote(\n      voteRecord.weight,\n      weight,\n      (voteRecord.proposalId == proposalId) ? voteRecord.value : Proposals.VoteValue.None,\n      value\n    );\n    proposal.networkWeight = getLockedGold().getTotalLockedGold();\n    voter.referendumVotes[index] = VoteRecord(value, proposalId, weight);\n    if (proposal.timestamp > voter.mostRecentReferendumProposal) {\n      voter.mostRecentReferendumProposal = proposalId;\n    }\n    emit ProposalVoted(proposalId, account, uint256(value), weight);"
    }
  ]
}