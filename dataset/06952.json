{
  "Title": "[L-03] Limits in `getMinimumEligibleReferralsFactorCalculation` should be inclusive",
  "Content": "\nhttps://github.com/code-423n4/2023-03-wenwin/blob/main/src/ReferralSystem.sol#L111-L130\n\n```solidity\nfunction getMinimumEligibleReferralsFactorCalculation(uint256 totalTicketsSoldPrevDraw)\n    internal\n    view\n    virtual\n    returns (uint256 minimumEligible)\n{\n    if (totalTicketsSoldPrevDraw < 10_000) {\n        // 1%\n        return totalTicketsSoldPrevDraw.getPercentage(PercentageMath.ONE_PERCENT);\n    }\n    if (totalTicketsSoldPrevDraw < 100_000) {\n        // 0.75%\n        return totalTicketsSoldPrevDraw.getPercentage(PercentageMath.ONE_PERCENT * 75 / 100);\n    }\n    if (totalTicketsSoldPrevDraw < 1_000_000) {\n        // 0.5%\n        return totalTicketsSoldPrevDraw.getPercentage(PercentageMath.ONE_PERCENT * 50 / 100);\n    }\n    return 5000;\n}\n```\n\nThe [protocol documentation](https://docs.wenwin.com/wenwin-lottery/protocol-architecture/token/rewards/referrals#referrers-allocation) specifies that the total ticket sold limits should be inclusive during the calculation of the minimum referral eligibility. However, the different conditions in the if statements use a strict inequality to define the bounds to calculate the eligibility factor.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2023-03-wenwin-contest",
  "Code": [
    {
      "filename": "src/ReferralSystem.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"src/interfaces/IReferralSystem.sol\";\nimport \"src/PercentageMath.sol\";\n\nabstract contract ReferralSystem is IReferralSystem {\n    using PercentageMath for uint256;\n\n    uint256 public immutable override playerRewardFirstDraw;\n    uint256 public immutable override playerRewardDecreasePerDraw;\n\n    uint256[] public override rewardsToReferrersPerDraw;\n\n    mapping(uint128 => mapping(address => UnclaimedTicketsData)) public override unclaimedTickets;\n\n    mapping(uint128 => uint256) public override totalTicketsForReferrersPerDraw;\n\n    mapping(uint128 => uint256) public override referrerRewardPerDrawForOneTicket;\n\n    mapping(uint128 => uint256) public override playerRewardsPerDrawForOneTicket;\n\n    mapping(uint128 => uint256) public override minimumEligibleReferrals;\n\n    constructor(\n        uint256 _playerRewardFirstDraw,\n        uint256 _playerRewardDecreasePerDraw,\n        uint256[] memory _rewardsToReferrersPerDraw\n    ) {\n        if (_rewardsToReferrersPerDraw.length == 0) {\n            revert ReferrerRewardsInvalid();\n        }\n        for (uint256 i = 0; i < _rewardsToReferrersPerDraw.length; ++i) {\n            if (_rewardsToReferrersPerDraw[i] == 0) {\n                revert ReferrerRewardsInvalid();\n            }\n        }\n\n        rewardsToReferrersPerDraw = _rewardsToReferrersPerDraw;\n\n        playerRewardFirstDraw = _playerRewardFirstDraw;\n        playerRewardDecreasePerDraw = _playerRewardDecreasePerDraw;\n    }\n\n    /// @dev Registers tickets for player and referrer (if an address is not zero)\n    /// @param currentDraw Currently active draw\n    /// @param referrer The address of the referrer\n    /// @param player The address of the player\n    /// @param numberOfTickets Number of tickets we are registering\n    function referralRegisterTickets(\n        uint128 currentDraw,\n        address referrer,\n        address player,\n        uint256 numberOfTickets\n    )\n        internal\n    {\n        if (referrer != address(0)) {\n            uint256 minimumEligible = minimumEligibleReferrals[currentDraw];\n            if (unclaimedTickets[currentDraw][referrer].referrerTicketCount + numberOfTickets >= minimumEligible) {\n                if (unclaimedTickets[currentDraw][referrer].referrerTicketCount < minimumEligible) {\n                    totalTicketsForReferrersPerDraw[currentDraw] +=\n                        unclaimedTickets[currentDraw][referrer].referrerTicketCount;\n                }\n                totalTicketsForReferrersPerDraw[currentDraw] += numberOfTickets;\n            }\n            unclaimedTickets[currentDraw][referrer].referrerTicketCount += uint128(numberOfTickets);\n        }\n        unclaimedTickets[currentDraw][player].playerTicketCount += uint128(numberOfTickets);\n    }\n\n    function mintNativeTokens(address mintTo, uint256 amount) internal virtual;\n\n    function claimReferralReward(uint128[] memory drawIds) external override returns (uint256 claimedReward) {\n        for (uint256 counter = 0; counter < drawIds.length; ++counter) {\n            claimedReward += claimPerDraw(drawIds[counter]);\n        }\n\n        mintNativeTokens(msg.sender, claimedReward);\n    }\n\n    /// @dev Draw is being finalized, does the rewards calculations for the draw\n    /// @param drawFinalized Draw being finalized\n    /// @param ticketsSoldDuringDraw Number of tickets sold during the draw that is finalized\n    function referralDrawFinalize(uint128 drawFinalized, uint256 ticketsSoldDuringDraw) internal {\n        // if no tickets sold there is no incentives, so no rewards to be set\n        if (ticketsSoldDuringDraw == 0) {\n            return;\n        }\n\n        minimumEligibleReferrals[drawFinalized + 1] =\n            getMinimumEligibleReferralsFactorCalculation(ticketsSoldDuringDraw);\n\n        uint256 referrerRewardForDraw = referrerRewardsPerDraw(drawFinalized);\n        uint256 totalTicketsForReferrersPerCurrentDraw = totalTicketsForReferrersPerDraw[drawFinalized];\n        if (totalTicketsForReferrersPerCurrentDraw > 0) {\n            referrerRewardPerDrawForOneTicket[drawFinalized] =\n                referrerRewardForDraw / totalTicketsForReferrersPerCurrentDraw;\n        }\n\n        uint256 playerRewardForDraw = playerRewardsPerDraw(drawFinalized);\n        if (playerRewardForDraw > 0) {\n            playerRewardsPerDrawForOneTicket[drawFinalized] = playerRewardForDraw / ticketsSoldDuringDraw;\n        }\n\n        emit CalculatedRewardsForDraw(drawFinalized, referrerRewardForDraw, playerRewardForDraw);\n    }\n\n    function getMinimumEligibleReferralsFactorCalculation(uint256 totalTicketsSoldPrevDraw)\n        internal\n        view\n        virtual\n        returns (uint256 minimumEligible)\n    {\n        if (totalTicketsSoldPrevDraw < 10_000) {\n            // 1%\n            return totalTicketsSoldPrevDraw.getPercentage(PercentageMath.ONE_PERCENT);\n        }\n        if (totalTicketsSoldPrevDraw < 100_000) {\n            // 0.75%\n            return totalTicketsSoldPrevDraw.getPercentage(PercentageMath.ONE_PERCENT * 75 / 100);\n        }\n        if (totalTicketsSoldPrevDraw < 1_000_000) {\n            // 0.5%\n            return totalTicketsSoldPrevDraw.getPercentage(PercentageMath.ONE_PERCENT * 50 / 100);\n        }\n        return 5000;\n    }\n\n    /// @dev Reverts if draw is not yet finalized\n    /// @param drawId Draw identifier we are checking\n    function requireFinishedDraw(uint128 drawId) internal view virtual;\n\n    function claimPerDraw(uint128 drawId) private returns (uint256 claimedReward) {\n        requireFinishedDraw(drawId);\n\n        UnclaimedTicketsData memory _unclaimedTickets = unclaimedTickets[drawId][msg.sender];\n        if (_unclaimedTickets.referrerTicketCount >= minimumEligibleReferrals[drawId]) {\n            claimedReward = referrerRewardPerDrawForOneTicket[drawId] * _unclaimedTickets.referrerTicketCount;\n            unclaimedTickets[drawId][msg.sender].referrerTicketCount = 0;\n        }\n\n        _unclaimedTickets = unclaimedTickets[drawId][msg.sender];\n        if (_unclaimedTickets.playerTicketCount > 0) {\n            claimedReward += playerRewardsPerDrawForOneTicket[drawId] * _unclaimedTickets.playerTicketCount;\n            unclaimedTickets[drawId][msg.sender].playerTicketCount = 0;\n        }\n\n        if (claimedReward > 0) {\n            emit ClaimedReferralReward(drawId, msg.sender, claimedReward);\n        }\n    }\n\n    function playerRewardsPerDraw(uint128 drawId) internal view returns (uint256 rewards) {\n        uint256 decrease = uint256(drawId) * playerRewardDecreasePerDraw;\n        return playerRewardFirstDraw > decrease ? (playerRewardFirstDraw - decrease) : 0;\n    }\n\n    function referrerRewardsPerDraw(uint128 drawId) internal view returns (uint256 rewards) {\n        return rewardsToReferrersPerDraw[Math.min(rewardsToReferrersPerDraw.length - 1, drawId)];\n    }\n}"
    }
  ]
}