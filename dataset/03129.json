{
  "Title": "Non-registered scanners default to non-disabled states",
  "Content": "The [`ScannerRegistryEnable` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L9) implements the functionality for enabling and disabling scanners, among other actions, and it uses bit maps to keep track of their states.\n\n\nHowever, when [enabling a scanner](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L65), the [`_scannerEnable` internal function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L85) uses the inverse assignment, meaning that a `1` flag accounts as a disabled state and a `0` state as an enabled one. Although this will not be sufficient to mark a random scanner ID as enabled, as it must be [registered as a ERC721](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L31) and have [enough stake on top of it](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L33), its default un-registered behavior resembles a non-disabled scanner.\n\n\nEven though this does not possess a security risk per se, in order to improve the readability of the code and reduce the attack surface, consider using a different state from the default one when enabling new scanners.\n\n\n***Update:** Acknowledged, will not fix. Forta team’s statement for this issue:*\n\n\n\n> It is true that the logic is inverted, and in a chain without min stake, an Agent/Scanner will be enabled (not disabled) on creation. This is acceptable to us because of several reasons: Registries are deployed in production, so we can’t invert the logic of `_disableFlags` without downtime. `_disableFlag` at 1 does not just mean disabled, it is the permission of the wallet that disabled the scanner (`uint8`, or rather `Permission` enum) so having a value that means “scanner registered the first time but not enabled yet” might complicate things further.\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/components/scanners/ScannerRegistryEnable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\n\nimport \"./ScannerRegistryManaged.sol\";\nimport \"../utils/StakeAware.sol\";\n\nabstract contract ScannerRegistryEnable is ScannerRegistryManaged, StakeAwareUpgradeable {\n    using BitMaps for BitMaps.BitMap;\n\n    enum Permission {\n        ADMIN,\n        SELF,\n        OWNER,\n        MANAGER,\n        length\n    }\n\n    mapping(uint256 => BitMaps.BitMap) private _disabled;\n\n    event ScannerEnabled(uint256 indexed scannerId, bool indexed enabled, Permission permission, bool value);\n\n    /**\n    * Check if scanner is enabled\n    * @param scannerId token Id\n    * @return true if the scanner is registered, has not been disabled, and is staked over minimum value.\n    * Returns false if otherwise\n    */\n    function isEnabled(uint256 scannerId) public view virtual returns (bool) {\n        return isRegistered(scannerId) &&\n            _getDisableFlags(scannerId) == 0 &&\n            _isStakedOverMin(SCANNER_SUBJECT, scannerId); \n    }\n\n    function register(address owner, uint256 chainId, string calldata metadata) virtual override public {\n        require(_getMinStake(SCANNER_SUBJECT) > 0, \"ScannerRegistryEnable: public registration available if staking activated\");\n        super.register(owner, chainId, metadata);\n    }\n\n    /**\n     * @dev Enable/Disable scaner\n     */\n    function enableScanner(uint256 scannerId, Permission permission) public virtual {\n        require(_isStakedOverMin(SCANNER_SUBJECT, scannerId), \"ScannerRegistryEnable: scanner staked under minimum\");\n        require(_hasPermission(scannerId, permission), \"ScannerRegistryEnable: invalid permission\");\n        _enable(scannerId, permission, true);\n    }\n\n    function disableScanner(uint256 scannerId, Permission permission) public virtual {\n        require(_hasPermission(scannerId, permission), \"ScannerRegistryEnable: invalid permission\");\n        _enable(scannerId, permission, false);\n    }\n\n    function _hasPermission(uint256 scannerId, Permission permission) internal view returns (bool) {\n        if (permission == Permission.ADMIN)   { return hasRole(SCANNER_ADMIN_ROLE, _msgSender()); }\n        if (permission == Permission.SELF)    { return uint256(uint160(_msgSender())) == scannerId; }\n        if (permission == Permission.OWNER)   { return _msgSender() == ownerOf(scannerId); }\n        if (permission == Permission.MANAGER) { return isManager(scannerId, _msgSender()); }\n        return false;\n    }\n\n    function _enable(uint256 scannerId, Permission permission, bool enable) internal {\n        _beforeScannerEnable(scannerId, permission, enable);\n        _scannerEnable(scannerId, permission, enable);\n        _afterScannerEnable(scannerId, permission, enable);\n    }\n\n    /**\n     * Get the disabled flags for an agentId. Permission (uint8) is used for indexing, so we don't\n     * need to loop. \n     * If not disabled, all flags will be 0\n     */\n    function _getDisableFlags(uint256 scannerId) internal view returns (uint256) {\n        return _disabled[scannerId]._data[0];\n    }\n\n    /**\n     * Hook: Scanner is enabled/disabled\n     */\n    function _beforeScannerEnable(uint256 scannerId, Permission permission, bool value) internal virtual {\n    }\n\n    function _scannerEnable(uint256 scannerId, Permission permission, bool value) internal virtual {\n        _disabled[scannerId].setTo(uint8(permission), !value);\n        emit ScannerEnabled(scannerId, isEnabled(scannerId), permission, value);\n    }\n\n    function _afterScannerEnable(uint256 scannerId, Permission permission, bool value) internal virtual {\n        _emitHook(abi.encodeWithSignature(\"hook_afterScannerEnable(uint256)\", scannerId));\n    }\n\n    function _msgSender() internal view virtual override(ContextUpgradeable, ScannerRegistryCore) returns (address sender) {\n        return super._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ContextUpgradeable, ScannerRegistryCore) returns (bytes calldata) {\n        return super._msgData();\n    }\n\n    uint256[49] private __gap;\n}"
    },
    {
      "filename": "contracts/components/scanners/ScannerRegistryEnable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\n\nimport \"./ScannerRegistryManaged.sol\";\nimport \"../utils/StakeAware.sol\";\n\nabstract contract ScannerRegistryEnable is ScannerRegistryManaged, StakeAwareUpgradeable {\n    using BitMaps for BitMaps.BitMap;\n\n    enum Permission {\n        ADMIN,\n        SELF,\n        OWNER,\n        MANAGER,\n        length\n    }\n\n    mapping(uint256 => BitMaps.BitMap) private _disabled;\n\n    event ScannerEnabled(uint256 indexed scannerId, bool indexed enabled, Permission permission, bool value);\n\n    /**\n    * Check if scanner is enabled\n    * @param scannerId token Id\n    * @return true if the scanner is registered, has not been disabled, and is staked over minimum value.\n    * Returns false if otherwise\n    */\n    function isEnabled(uint256 scannerId) public view virtual returns (bool) {\n        return isRegistered(scannerId) &&\n            _getDisableFlags(scannerId) == 0 &&\n            _isStakedOverMin(SCANNER_SUBJECT, scannerId); \n    }\n\n    function register(address owner, uint256 chainId, string calldata metadata) virtual override public {\n        require(_getMinStake(SCANNER_SUBJECT) > 0, \"ScannerRegistryEnable: public registration available if staking activated\");\n        super.register(owner, chainId, metadata);\n    }\n\n    /**\n     * @dev Enable/Disable scaner\n     */\n    function enableScanner(uint256 scannerId, Permission permission) public virtual {\n        require(_isStakedOverMin(SCANNER_SUBJECT, scannerId), \"ScannerRegistryEnable: scanner staked under minimum\");\n        require(_hasPermission(scannerId, permission), \"ScannerRegistryEnable: invalid permission\");\n        _enable(scannerId, permission, true);\n    }\n\n    function disableScanner(uint256 scannerId, Permission permission) public virtual {\n        require(_hasPermission(scannerId, permission), \"ScannerRegistryEnable: invalid permission\");\n        _enable(scannerId, permission, false);\n    }\n\n    function _hasPermission(uint256 scannerId, Permission permission) internal view returns (bool) {\n        if (permission == Permission.ADMIN)   { return hasRole(SCANNER_ADMIN_ROLE, _msgSender()); }\n        if (permission == Permission.SELF)    { return uint256(uint160(_msgSender())) == scannerId; }\n        if (permission == Permission.OWNER)   { return _msgSender() == ownerOf(scannerId); }\n        if (permission == Permission.MANAGER) { return isManager(scannerId, _msgSender()); }\n        return false;\n    }\n\n    function _enable(uint256 scannerId, Permission permission, bool enable) internal {\n        _beforeScannerEnable(scannerId, permission, enable);\n        _scannerEnable(scannerId, permission, enable);\n        _afterScannerEnable(scannerId, permission, enable);\n    }\n\n    /**\n     * Get the disabled flags for an agentId. Permission (uint8) is used for indexing, so we don't\n     * need to loop. \n     * If not disabled, all flags will be 0\n     */\n    function _getDisableFlags(uint256 scannerId) internal view returns (uint256) {\n        return _disabled[scannerId]._data[0];\n    }\n\n    /**\n     * Hook: Scanner is enabled/disabled\n     */\n    function _beforeScannerEnable(uint256 scannerId, Permission permission, bool value) internal virtual {\n    }\n\n    function _scannerEnable(uint256 scannerId, Permission permission, bool value) internal virtual {\n        _disabled[scannerId].setTo(uint8(permission), !value);\n        emit ScannerEnabled(scannerId, isEnabled(scannerId), permission, value);\n    }\n\n    function _afterScannerEnable(uint256 scannerId, Permission permission, bool value) internal virtual {\n        _emitHook(abi.encodeWithSignature(\"hook_afterScannerEnable(uint256)\", scannerId));\n    }\n\n    function _msgSender() internal view virtual override(ContextUpgradeable, ScannerRegistryCore) returns (address sender) {\n        return super._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ContextUpgradeable, ScannerRegistryCore) returns (bytes calldata) {\n        return super._msgData();\n    }\n\n    uint256[49] private __gap;\n}"
    }
  ]
}