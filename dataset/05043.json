{
  "Title": "[H-09] Funds can be stolen through remote transfer functionality",
  "Content": "\nUser can send LZ message through any `Oft` token using the `TapiocaOmnichainSender.sendPacket `function. User provides params that should be used and also provides [composed message](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainSender.sol#L57C75-L57C86) if he needs to send it.\n\nWhat is important for composed message is [during crafting message](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/BaseTapiocaOmnichainEngine.sol#L166-L172), `msg.sender` is stored as `srcChainSender_`. In this way we know who have triggered composed call.\n\n```solidity\nfunction encode(\n        bytes32 _sendTo,\n        uint64 _amountShared,\n        bytes memory _composeMsg\n    ) internal view returns (bytes memory _msg, bool hasCompose) {\n        hasCompose = _composeMsg.length > 0;\n        // @dev Remote chains will want to know the composed function caller ie. msg.sender on the src.\n        _msg = hasCompose\n            ? abi.encodePacked(_sendTo, _amountShared, addressToBytes32(msg.sender), _composeMsg)\n            : abi.encodePacked(_sendTo, _amountShared);\n    }\n```\n\nThe amount that should be sent to other chain is burnt (if any) and LZ call [is sent](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainSender.sol#L73-L74). On another chain, the call will be handled [by `TapiocaOmnichainReceiver._lzReceive` function](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L72C14-L72C24). This function [will mint tokens to recipient](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L85). If the composed message was included, then it will [sent it to endpoint](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L93-L98), so it can be triggered later.\n\nWhen composed message is triggered, then [`lzCompose` function](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L120C14-L120C23) handles it. As you can see, the function retrieves `srcChainSender_` to know who was initiator of compose call on source chain. Then [`_lzCompose` function](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L139) continue processing of message.\n\nUsing [`msgType`](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L148C17-L148C25) user can provide operation he wants to execute on target chain. One of operations [is `MSG_REMOTE_TRANSFER`](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L154) that allows to remotely send tokens to another chain. The flow is next: on chain A user initiates compose call to chain B, that will send his tokens on chain B to chain A, or will use allowance to send tokens of other user on chain B to chain A. Let's check how it works.\n\nFirst, the function should [transfer tokens from owner to `address(this)`](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L218-L220). This function receives owner of funds and `_srcChainSender` as inputs [to check allowance](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L287-L289). As you can see, in the case of if `_srcChainSender` is owner then we don't need any approve.\n\nAfter transfer is done to `address(this)` then the [contract can send them back to chain A](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L223C9-L225). So the function [burns tokens](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L250) and crafts message to another chain and it can have composed call again; which means that [it will include `_srcChainSender`](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L266C96-L266C111), so the contract on chain A knows who initiated the call.\n\nThe problem is that `_srcChainSender` that will be included is [owner of funds on chain B](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L224C13-L224C37), which is incorrect.\n\nHere's the described attack flow:\n\n1. Victim has funds on chain A, that attacker is going to steal to chain B.\n2. Attacker on chain A initiates compose call with victim as owner of funds and provides amount `0` as amount to transfer of chain B.\n3. Compose call succeed on chain B as it is possible to transfer `0` tokens and then another compose message was included, which transfers all tokens from victim to attacker on chain B.\n4. Because `_srcChainSender` was set to victim on first compose call. Then the next compose call on chain A will think that victim is initiator of remote transfer, which means that no allowance will be checked.\n5. Funds are stolen to attacker address on chain B.\n\n### Impact\n\nPossible to steal funds.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nProvide `_srcChainSender` as initiator of compose call.\n\n    _internalRemoteTransferSendPacket(\n                _srcChainSender, remoteTransferMsg_.lzSendParam, remoteTransferMsg_.composeMsg\n            );\n\n### Assessed type\n\nError\n\n**[0xWeiss (Tapioca) confirmed](https://github.com/code-423n4/2024-02-tapioca-findings/issues/76#issuecomment-2125592960)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/tapiocaOmnichainEngine/TapiocaOmnichainSender.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    MessagingReceipt, OFTReceipt, SendParam\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\n\n// Tapioca\nimport {BaseTapiocaOmnichainEngine} from \"./BaseTapiocaOmnichainEngine.sol\";\nimport {LZSendParam} from \"tapioca-periph/interfaces/periph/ITapiocaOmnichainEngine.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract TapiocaOmnichainSender is BaseTapiocaOmnichainEngine {\n    /**\n     * @notice Sends TapToken messages.\n     *\n     * @dev Slightly modified version of the OFT send() operation. Includes a `_msgType` parameter.\n     * The `_buildMsgAndOptionsByType()` appends the packet type to the message.\n     * @dev !!! IMPORTANT !!! Use it externally only. Do not use it on a compose receive operation as the `msg.sender` will be the LZ executor.\n     * @dev !!! IMPORTANT !!! If you want to send a message without sending amounts, set both `amountToSendLD` and `minAmountToCreditLD` to 0.\n     *\n     * @param _lzSendParam The parameters for the send operation.\n     *      - _sendParam: The parameters for the send operation.\n     *          - dstEid::uint32: Destination endpoint ID.\n     *          - to::bytes32: Recipient address.\n     *          - amountToSendLD::uint256: Amount to send in local decimals.\n     *          - minAmountToCreditLD::uint256: Minimum amount to credit in local decimals.\n     *      - _fee: The calculated fee for the send() operation.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     *      - _extraOptions::bytes: Additional options for the send() operation.\n     *      - refundAddress::address: The address to refund the native fee to.\n     * @param _composeMsg The composed message for the send() operation. Is a combination of 1 or more TAP specific messages.\n     *\n     * @return msgReceipt The receipt for the send operation.\n     *      - guid::bytes32: The unique identifier for the sent message.\n     *      - nonce::uint64: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     * @return oftReceipt The OFT receipt information.\n     *      - amountDebitLD::uint256: Amount of tokens ACTUALLY debited in local decimals.\n     *      - amountCreditLD::uint256: Amount of tokens to be credited on the remote side.\n     */\n    // TODO parse and enforce composed options here.\n    function sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n        external\n        payable\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        // @dev Applies the token transfers regarding this send() operation.\n        // - amountDebitedLD is the amount in local decimals that was ACTUALLY debited from the sender.\n        // - amountToCreditLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.\n        (uint256 amountDebitedLD, uint256 amountToCreditLD) =\n            _debit(_lzSendParam.sendParam.amountLD, _lzSendParam.sendParam.minAmountLD, _lzSendParam.sendParam.dstEid);\n\n        // @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) =\n            _buildOFTMsgAndOptions(_lzSendParam.sendParam, _lzSendParam.extraOptions, _composeMsg, amountToCreditLD);\n\n        // @dev Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt =\n            _lzSend(_lzSendParam.sendParam.dstEid, message, options, _lzSendParam.fee, _lzSendParam.refundAddress);\n        // @dev Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountDebitedLD, amountToCreditLD);\n\n        emit OFTSent(msgReceipt.guid, _lzSendParam.sendParam.dstEid, msg.sender, amountDebitedLD);\n    }\n}"
    },
    {
      "filename": "contracts/tapiocaOmnichainEngine/BaseTapiocaOmnichainEngine.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {IOAppMsgInspector} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\nimport {SendParam, MessagingFee} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\nimport {OAppSender} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\";\nimport {OFT} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\n// Tapioca\nimport {ITapiocaOmnichainReceiveExtender} from \"tapioca-periph/interfaces/periph/ITapiocaOmnichainEngine.sol\";\nimport {TapiocaOmnichainExtExec} from \"./extension/TapiocaOmnichainExtExec.sol\";\nimport {PearlmitHandler, IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {BaseToeMsgType} from \"./BaseToeMsgType.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract BaseTapiocaOmnichainEngine is OFT, PearlmitHandler, BaseToeMsgType {\n    using BytesLib for bytes;\n    using SafeERC20 for IERC20;\n    using OFTMsgCodec for bytes;\n    using OFTMsgCodec for bytes32;\n\n    /// @dev Used to execute certain extern calls from the TapToken contract, such as ERC20Permit approvals.\n    TapiocaOmnichainExtExec public toeExtExec;\n    /// @dev For future use, to extend the receive() operation.\n    ITapiocaOmnichainReceiveExtender public tapiocaOmnichainReceiveExtender;\n\n    error BaseTapiocaOmnichainEngine_NotValid();\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _endpoint,\n        address _delegate,\n        address _extExec,\n        IPearlmit _pearlmit\n    ) OFT(_name, _symbol, _endpoint, _delegate) PearlmitHandler(_pearlmit) {\n        toeExtExec = TapiocaOmnichainExtExec(_extExec);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     * @dev Extended the capabilities to check allowance and transfer on Pearlmit.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual override returns (bool) {\n        address spender = _msgSender();\n        // If allowance on this contract is not met, try a transferFrom via Pearlmit.\n        if (allowance(from, spender) < value) {\n            // _transfer(from, to, value);\n            bool isErr = pearlmit.transferFromERC20(from, to, address(this), value);\n            if (isErr) revert BaseTapiocaOmnichainEngine_NotValid();\n        } else {\n            // If allowance on this contract is met, perform a normal transferFrom.\n            _spendAllowance(from, spender, value);\n            _transfer(from, to, value);\n        }\n\n        return true;\n    }\n\n    /**\n     * @inheritdoc OAppSender\n     * @dev Overwrite to check for < values.\n     */\n    function _payNative(uint256 _nativeFee) internal override returns (uint256 nativeFee) {\n        if (msg.value < _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Sets the `tapiocaOmnichainReceiveExtender` contract.\n     */\n    function setTapiocaOmnichainReceiveExtender(address _tapiocaOmnichainReceiveExtender) external onlyOwner {\n        tapiocaOmnichainReceiveExtender = ITapiocaOmnichainReceiveExtender(_tapiocaOmnichainReceiveExtender);\n    }\n\n    /**\n     * @dev public function to remove dust from the given local decimal amount.\n     * @param _amountLD The amount in local decimals.\n     * @return amountLD The amount after removing dust.\n     *\n     * @dev Prevents the loss of dust when moving amounts between chains with different decimals.\n     * @dev eg. uint(123) with a conversion rate of 100 becomes uint(100).\n     */\n    function removeDust(uint256 _amountLD) public view virtual returns (uint256 amountLD) {\n        return _removeDust(_amountLD);\n    }\n\n    /**\n     * @dev Slightly modified version of the OFT quoteSend() operation. Includes a `_msgType` parameter.\n     * The `_buildMsgAndOptionsByType()` appends the packet type to the message.\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _extraOptions Additional options supplied by the caller to be used in the LayerZero message.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @param _composeMsg The composed message for the send() operation.\n     * @dev _oftCmd The OFT command to be executed.\n     * @return msgFee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSendPacket(\n        SendParam calldata _sendParam,\n        bytes calldata _extraOptions,\n        bool _payInLzToken,\n        bytes calldata _composeMsg,\n        bytes calldata /*_oftCmd*/ // @dev unused in the default implementation.\n    ) external view virtual returns (MessagingFee memory msgFee) {\n        // @dev mock the amount to credit, this is the same operation used in the send().\n        // The quote is as similar as possible to the actual send() operation.\n        (, uint256 amountToCreditLD) = _debitView(_sendParam.amountLD, _sendParam.minAmountLD, _sendParam.dstEid);\n\n        // @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) =\n            _buildOFTMsgAndOptions(_sendParam, _extraOptions, _composeMsg, amountToCreditLD);\n\n        // @dev Calculates the LayerZero fee for the send() operation.\n        return _quote(_sendParam.dstEid, message, options, _payInLzToken);\n    }\n\n    /**\n     * @notice Build an OFT message and option. The message contain OFT related info such as the amount to credit and the recipient.\n     * It also contains the `_composeMsg`, which is 1 or more TAP specific messages. See `_buildTapMsgAndOptions()`.\n     * The option is an aggregation of the OFT message as well as the TAP messages.\n     *\n     * @param _sendParam: The parameters for the send operation.\n     *      - dstEid::uint32: Destination endpoint ID.\n     *      - to::bytes32: Recipient address.\n     *      - amountToSendLD::uint256: Amount to send in local decimals.\n     *      - minAmountToCreditLD::uint256: Minimum amount to credit in local decimals.\n     * @param _extraOptions Additional options for the send() operation. If `_composeMsg` not empty, the `_extraOptions` should also contain the aggregation of its options.\n     * @param _composeMsg The composed message for the send() operation. Is a combination of 1 or more TAP specific messages.\n     * @param _amountToCreditLD The amount to credit in local decimals.\n     *\n     * @return message The encoded message.\n     * @return options The combined LZ msgType + `_extraOptions` options.\n     */\n    function _buildOFTMsgAndOptions(\n        SendParam calldata _sendParam,\n        bytes calldata _extraOptions,\n        bytes calldata _composeMsg,\n        uint256 _amountToCreditLD\n    ) internal view returns (bytes memory message, bytes memory options) {\n        bool hasCompose;\n\n        // @dev This generated message has the msg.sender encoded into the payload so the remote knows who the caller is.\n        // @dev NOTE the returned message will append `msg.sender` only if the message is composed.\n        // If it's the case, it'll add the `address(msg.sender)` at the `amountToCredit` offset.\n        (message, hasCompose) = OFTMsgCodec.encode(\n            _sendParam.to,\n            _toSD(_amountToCreditLD),\n            // @dev Must be include a non empty bytes if you want to compose, EVEN if you don't need it on the remote.\n            // EVEN if you don't require an arbitrary payload to be sent... eg. '0x01'\n            _composeMsg\n        );\n        // @dev Change the msg type depending if its composed or not.\n        uint16 _msgType = hasCompose ? SEND_AND_CALL : SEND;\n        // @dev Combine the callers _extraOptions with the enforced options via the OAppOptionsType3.\n        options = combineOptions(_sendParam.dstEid, _msgType, _extraOptions);\n\n        // @dev Optionally inspect the message and options depending if the OApp owner has set a msg inspector.\n        // @dev If it fails inspection, needs to revert in the implementation. ie. does not rely on return boolean\n        if (msgInspector != address(0)) {\n            IOAppMsgInspector(msgInspector).inspect(message, options);\n        }\n    }\n\n    /**\n     * @dev Internal function to return the current EID.\n     */\n    function _getChainId() internal view virtual returns (uint32) {}\n}"
    },
    {
      "filename": "contracts/tapiocaOmnichainEngine/TapiocaOmnichainSender.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    MessagingReceipt, OFTReceipt, SendParam\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\n\n// Tapioca\nimport {BaseTapiocaOmnichainEngine} from \"./BaseTapiocaOmnichainEngine.sol\";\nimport {LZSendParam} from \"tapioca-periph/interfaces/periph/ITapiocaOmnichainEngine.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract TapiocaOmnichainSender is BaseTapiocaOmnichainEngine {\n    /**\n     * @notice Sends TapToken messages.\n     *\n     * @dev Slightly modified version of the OFT send() operation. Includes a `_msgType` parameter.\n     * The `_buildMsgAndOptionsByType()` appends the packet type to the message.\n     * @dev !!! IMPORTANT !!! Use it externally only. Do not use it on a compose receive operation as the `msg.sender` will be the LZ executor.\n     * @dev !!! IMPORTANT !!! If you want to send a message without sending amounts, set both `amountToSendLD` and `minAmountToCreditLD` to 0.\n     *\n     * @param _lzSendParam The parameters for the send operation.\n     *      - _sendParam: The parameters for the send operation.\n     *          - dstEid::uint32: Destination endpoint ID.\n     *          - to::bytes32: Recipient address.\n     *          - amountToSendLD::uint256: Amount to send in local decimals.\n     *          - minAmountToCreditLD::uint256: Minimum amount to credit in local decimals.\n     *      - _fee: The calculated fee for the send() operation.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     *      - _extraOptions::bytes: Additional options for the send() operation.\n     *      - refundAddress::address: The address to refund the native fee to.\n     * @param _composeMsg The composed message for the send() operation. Is a combination of 1 or more TAP specific messages.\n     *\n     * @return msgReceipt The receipt for the send operation.\n     *      - guid::bytes32: The unique identifier for the sent message.\n     *      - nonce::uint64: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     * @return oftReceipt The OFT receipt information.\n     *      - amountDebitLD::uint256: Amount of tokens ACTUALLY debited in local decimals.\n     *      - amountCreditLD::uint256: Amount of tokens to be credited on the remote side.\n     */\n    // TODO parse and enforce composed options here.\n    function sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n        external\n        payable\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        // @dev Applies the token transfers regarding this send() operation.\n        // - amountDebitedLD is the amount in local decimals that was ACTUALLY debited from the sender.\n        // - amountToCreditLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.\n        (uint256 amountDebitedLD, uint256 amountToCreditLD) =\n            _debit(_lzSendParam.sendParam.amountLD, _lzSendParam.sendParam.minAmountLD, _lzSendParam.sendParam.dstEid);\n\n        // @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) =\n            _buildOFTMsgAndOptions(_lzSendParam.sendParam, _lzSendParam.extraOptions, _composeMsg, amountToCreditLD);\n\n        // @dev Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt =\n            _lzSend(_lzSendParam.sendParam.dstEid, message, options, _lzSendParam.fee, _lzSendParam.refundAddress);\n        // @dev Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountDebitedLD, amountToCreditLD);\n\n        emit OFTSent(msgReceipt.guid, _lzSendParam.sendParam.dstEid, msg.sender, amountDebitedLD);\n    }\n}"
    },
    {
      "filename": "contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    MessagingReceipt, OFTReceipt, SendParam\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {IOAppMsgInspector} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\nimport {IOAppComposer} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\nimport {Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport {OFT} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\";\n\n// Tapioca\nimport {\n    ITapiocaOmnichainReceiveExtender,\n    ERC721PermitApprovalMsg,\n    ERC20PermitApprovalMsg,\n    RemoteTransferMsg,\n    LZSendParam\n} from \"tapioca-periph/interfaces/periph/ITapiocaOmnichainEngine.sol\";\nimport {TapiocaOmnichainEngineCodec} from \"./TapiocaOmnichainEngineCodec.sol\";\nimport {BaseTapiocaOmnichainEngine} from \"./BaseTapiocaOmnichainEngine.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract TapiocaOmnichainReceiver is BaseTapiocaOmnichainEngine, IOAppComposer {\n    using OFTMsgCodec for bytes;\n    using OFTMsgCodec for bytes32;\n\n    /**\n     *  @dev Triggered if the address of the composer doesn't match current contract in `lzCompose`.\n     * Compose caller and receiver are the same address, which is this.\n     */\n    error InvalidComposer(address composer);\n    error InvalidCaller(address caller); // Should be the endpoint address\n    error InvalidMsgType(uint16 msgType); // Triggered if the msgType is invalid on an `_lzCompose`.\n\n    /// @dev Compose received.\n    event ComposeReceived(uint16 indexed msgType, bytes32 indexed guid, bytes composeMsg);\n    /// @dev twTAP unlock operation received.\n    event RemoteTransferReceived(address indexed owner, uint256 indexed dstEid, address indexed to, uint256 amount);\n\n    /**\n     * @dev !!! FIRST ENTRYPOINT, COMPOSE MSG ARE TO BE BUILT HERE  !!!\n     *\n     * @dev Slightly modified version of the OFT _lzReceive() operation.\n     * The composed message is sent to `address(this)` instead of `toAddress`.\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @dev Caller is verified on the public function. See `OAppReceiver.lzReceive()`.\n     *\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * _executor The address of the executor.\n     * _extraData Additional data.\n     */\n    // TODO check if OApp sender is sanitized?\n    // TODO !!!!!!!!! Perform ld2sd conversion on the compose messages amounts.\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address, /*_executor*/ // @dev unused in the default implementation.\n        bytes calldata /*_extraData*/ // @dev unused in the default implementation.\n    ) internal virtual override {\n        // @dev The src sending chain doesn't know the address length on this chain (potentially non-evm)\n        // Thus everything is bytes32() encoded in flight.\n        address toAddress = _message.sendTo().bytes32ToAddress();\n        // @dev Convert the amount to credit into local decimals.\n        uint256 amountToCreditLD = _toLD(_message.amountSD());\n        // @dev Credit the amount to the recipient and return the ACTUAL amount the recipient received in local decimals\n        uint256 amountReceivedLD = _credit(toAddress, amountToCreditLD, _origin.srcEid);\n\n        if (_message.isComposed()) {\n            // @dev Stores the lzCompose payload that will be executed in a separate tx.\n            // Standardizes functionality for executing arbitrary contract invocation on some non-evm chains.\n            // @dev The off-chain executor will listen and process the msg based on the src-chain-callers compose options passed.\n            // @dev The index is used when a OApp needs to compose multiple msgs on lzReceive.\n            // For default OFT implementation there is only 1 compose msg per lzReceive, thus its always 0.\n            endpoint.sendCompose(\n                address(this), // Updated from default `toAddress`\n                _guid,\n                0, /* the index of the composed message*/\n                _message.composeMsg()\n            );\n        }\n\n        emit OFTReceived(_guid, _origin.srcEid, toAddress, amountReceivedLD);\n    }\n\n    // TODO - SANITIZE MSG TYPE\n    /**\n     * @dev !!! SECOND ENTRYPOINT, CALLER NEEDS TO BE VERIFIED !!!\n     *\n     * @notice Composes a LayerZero message from an OApp.\n     * @dev The message comes in form:\n     *      - [composeSender::address][oftComposeMsg::bytes]\n     *                                          |\n     *                                          |\n     *                        [msgType::uint16, composeMsg::bytes]\n     * @dev The composeSender is the user that initiated the `sendPacket()` call on the srcChain.\n     *\n     * @param _from The address initiating the composition, typically the OApp where the lzReceive was called.\n     * @param _guid The unique identifier for the corresponding LayerZero src/dst tx.\n     * @param _message The composed message payload in bytes. NOT necessarily the same payload passed via lzReceive.\n     */\n    function lzCompose(\n        address _from,\n        bytes32 _guid,\n        bytes calldata _message,\n        address, //executor\n        bytes calldata //extra Data\n    ) external payable override {\n        // Validate the from and the caller.\n        if (_from != address(this)) {\n            revert InvalidComposer(_from);\n        }\n        if (msg.sender != address(endpoint)) {\n            revert InvalidCaller(msg.sender);\n        }\n\n        // Decode LZ compose message.\n        (address srcChainSender_, bytes memory oftComposeMsg_) =\n            TapiocaOmnichainEngineCodec.decodeLzComposeMsg(_message);\n        // Execute the composed message.\n        _lzCompose(srcChainSender_, _guid, oftComposeMsg_);\n    }\n\n    /**\n     * @dev Modifier behavior of composed calls to be executed as a single Tx.\n     * Since composed msgs and approval\n     */\n    function _lzCompose(address srcChainSender_, bytes32 _guid, bytes memory oftComposeMsg_) internal {\n        // Decode OFT compose message.\n        (uint16 msgType_,,, bytes memory tapComposeMsg_, bytes memory nextMsg_) =\n            TapiocaOmnichainEngineCodec.decodeToeComposeMsg(oftComposeMsg_);\n\n        // Call Permits/approvals if the msg type is a permit/approval.\n        // If the msg type is not a permit/approval, it will call the other receivers.\n        if (msgType_ == MSG_REMOTE_TRANSFER) {\n            _remoteTransferReceiver(srcChainSender_, tapComposeMsg_);\n        } else if (!_extExec(msgType_, tapComposeMsg_)) {\n            // Check if the TOE extender is set and the msg type is valid. If so, call the TOE extender to handle msg.\n            if (\n                address(tapiocaOmnichainReceiveExtender) != address(0)\n                    && tapiocaOmnichainReceiveExtender.isMsgTypeValid(msgType_)\n            ) {\n                bytes memory callData = abi.encodeWithSelector(\n                    ITapiocaOmnichainReceiveExtender.toeComposeReceiver.selector,\n                    msgType_,\n                    srcChainSender_,\n                    tapComposeMsg_\n                );\n                (bool success, bytes memory returnData) =\n                    address(tapiocaOmnichainReceiveExtender).delegatecall(callData);\n                if (!success) {\n                    revert(_getTOEExtenderRevertMsg(returnData));\n                }\n            } else {\n                // If no TOE extender is set or msg type doesn't match extender, try to call the internal receiver.\n                if (!_toeComposeReceiver(msgType_, srcChainSender_, tapComposeMsg_)) {\n                    revert InvalidMsgType(msgType_);\n                }\n            }\n        }\n\n        emit ComposeReceived(msgType_, _guid, tapComposeMsg_);\n        if (nextMsg_.length > 0) {\n            _lzCompose(srcChainSender_, _guid, nextMsg_);\n        }\n    }\n\n    // ********************* //\n    // ***** RECEIVERS ***** //\n    // ********************* //\n\n    /**\n     * @dev Meant to be override by TOE contracts, such as tOFT or TapToken, to handle their own msg types.\n     *\n     * @param _msgType is the msgType of the composed message. See `TapiocaOmnichainEngineCodec.decodeToeComposeMsg()`.\n     * See `BaseTapiocaOmnichainEngine` to see the default TOE messages types.\n     * @param _srcChainSender The address of the sender on the source chain.\n     * @param _toeComposeMsg is the composed message payload, of whatever the _msgType handler is expecting.\n     * @return success is the success of the composed message handler. If no handler is found, it should return false to trigger `InvalidMsgType()`.\n     */\n    function _toeComposeReceiver(uint16 _msgType, address _srcChainSender, bytes memory _toeComposeMsg)\n        internal\n        virtual\n        returns (bool success)\n    {}\n\n    /**\n     * // TODO Check if it's safe to send composed messages too.\n     * // TODO Write test for composed messages call. A->B->A-B/C?\n     * @dev Transfers tokens AND composed messages from this contract to the recipient on the chain A. Flow of calls is: A->B->A.\n     * @dev The user needs to have approved the TapToken contract to spend the TAP.\n     *\n     * @param _srcChainSender The address of the sender on the source chain.\n     * @param _data The call data containing info about the transfer (LZSendParam).\n     */\n    function _remoteTransferReceiver(address _srcChainSender, bytes memory _data) internal virtual {\n        RemoteTransferMsg memory remoteTransferMsg_ = TapiocaOmnichainEngineCodec.decodeRemoteTransferMsg(_data);\n\n        /// @dev xChain owner needs to have approved dst srcChain `sendPacket()` msg.sender in a previous composedMsg. Or be the same address.\n        _internalTransferWithAllowance(\n            remoteTransferMsg_.owner, _srcChainSender, remoteTransferMsg_.lzSendParam.sendParam.amountLD\n        );\n\n        // Make the internal transfer, burn the tokens from this contract and send them to the recipient on the other chain.\n        _internalRemoteTransferSendPacket(\n            remoteTransferMsg_.owner, remoteTransferMsg_.lzSendParam, remoteTransferMsg_.composeMsg\n        );\n\n        emit RemoteTransferReceived(\n            remoteTransferMsg_.owner,\n            remoteTransferMsg_.lzSendParam.sendParam.dstEid,\n            OFTMsgCodec.bytes32ToAddress(remoteTransferMsg_.lzSendParam.sendParam.to),\n            remoteTransferMsg_.lzSendParam.sendParam.amountLD\n        );\n    }\n\n    /**\n     * // TODO review this function.\n     *\n     * @dev Slightly modified version of the OFT _sendPacket() operation. To accommodate the `srcChainSender` parameter and potential dust.\n     * @dev !!! IMPORTANT !!! made ONLY for the `_remoteTransferReceiver()` operation.\n     */\n    function _internalRemoteTransferSendPacket(\n        address _srcChainSender,\n        LZSendParam memory _lzSendParam,\n        bytes memory _composeMsg\n    ) internal returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt) {\n        // Burn tokens from this contract\n        (uint256 amountDebitedLD_, uint256 amountToCreditLD_) = _debitView(\n            _lzSendParam.sendParam.amountLD, _lzSendParam.sendParam.minAmountLD, _lzSendParam.sendParam.dstEid\n        );\n        _burn(address(this), amountToCreditLD_);\n\n        _lzSendParam.sendParam.amountLD = amountToCreditLD_;\n        _lzSendParam.sendParam.minAmountLD = amountToCreditLD_;\n\n        // If the srcChain amount request is bigger than the debited one, overwrite the amount to credit with the amount debited and send the difference back to the user.\n        if (_lzSendParam.sendParam.amountLD > amountDebitedLD_) {\n            // Overwrite the amount to credit with the amount debited\n            _lzSendParam.sendParam.amountLD = amountDebitedLD_;\n            _lzSendParam.sendParam.minAmountLD = amountDebitedLD_;\n            // Send the difference back to the user\n            _transfer(address(this), _srcChainSender, _lzSendParam.sendParam.amountLD - amountDebitedLD_);\n        }\n\n        // Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildOFTMsgAndOptionsMemory(\n            _lzSendParam.sendParam, _lzSendParam.extraOptions, _composeMsg, amountToCreditLD_, _srcChainSender\n        ); // msgSender is the sender of the composed message. We keep context by passing `_srcChainSender`.\n\n        // Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt =\n            _lzSend(_lzSendParam.sendParam.dstEid, message, options, _lzSendParam.fee, _lzSendParam.refundAddress);\n        // Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountDebitedLD_, amountToCreditLD_);\n\n        emit OFTSent(msgReceipt.guid, _lzSendParam.sendParam.dstEid, _srcChainSender, amountDebitedLD_);\n    }\n\n    /**\n     * @dev Performs a transfer with an allowance check and consumption against the xChain msg sender.\n     * @dev Can only transfer to this address.\n     *\n     * @param _owner The account to transfer from.\n     * @param srcChainSender The address of the sender on the source chain.\n     * @param _amount The amount to transfer\n     */\n    function _internalTransferWithAllowance(address _owner, address srcChainSender, uint256 _amount) internal {\n        if (_owner != srcChainSender) {\n            _spendAllowance(_owner, srcChainSender, _amount);\n        }\n\n        _transfer(_owner, address(this), _amount);\n    }\n\n    /**\n     * @notice Sends a permit/approval call to the `tapiocaOmnichainReceiveExtender` contract.\n     * @param _msgType The type of the message.\n     * @param _data The call data containing info about the message.\n     * @return success is the success of the composed message handler. If no handler is found, it should return false to trigger `InvalidMsgType()`.\n     */\n    function _extExec(uint16 _msgType, bytes memory _data) internal returns (bool) {\n        if (_msgType == MSG_APPROVALS) {\n            toeExtExec.erc20PermitApproval(_data);\n        } else if (_msgType == MSG_NFT_APPROVALS) {\n            toeExtExec.erc721PermitApproval(_data);\n        } els"
    }
  ]
}