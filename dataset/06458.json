{
  "Title": "[H-35] `Rerange`/`rebalance` should not use `protocolFee` as an asset for adding liquidity",
  "Content": "\nThe account of `protocolFee` is broken because tokens of `protocolFee0` and `protocolFee1` are used while rerange/rebalance are used to add liquidity. At the same time, the variables `protocolFee0` and `protocolFee1` are not updated and the de-facto contract doesn't have `protocolFee` on balance.\n\n### Proof of Concept\n\nFunction `rerange` is used both in `rerange` and in `rebalance`:\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/strategies/TalosStrategySimple.sol#L30-L46>\n\n```solidity\n    function doRerange() internal override returns (uint256 amount0, uint256 amount1) {\n        (tickLower, tickUpper, amount0, amount1, tokenId, liquidity) = nonfungiblePositionManager.rerange(\n            PoolActions.ActionParams(pool, optimizer, token0, token1, tickSpacing), poolFee\n        );\n    }\n\n    function doRebalance() internal override returns (uint256 amount0, uint256 amount1) {\n        int24 baseThreshold = tickSpacing * optimizer.tickRangeMultiplier();\n\n        PoolActions.ActionParams memory actionParams =\n            PoolActions.ActionParams(pool, optimizer, token0, token1, tickSpacing);\n\n        PoolActions.swapToEqualAmounts(actionParams, baseThreshold);\n\n        (tickLower, tickUpper, amount0, amount1, tokenId, liquidity) =\n            nonfungiblePositionManager.rerange(actionParams, poolFee);\n    }\n```\n\nLet's have a look at this function. This function calls `getThisPositionTicks` to get the amounts of `balance0` and `balance1` of tokens to `addLiquidity`:\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/libraries/PoolActions.sol#L56-L88>\n\n```solidity\n    function rerange(\n        INonfungiblePositionManager nonfungiblePositionManager,\n        ActionParams memory actionParams,\n        uint24 poolFee\n    )\n        internal\n        returns (int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1, uint256 tokenId, uint128 liquidity)\n    {\n        int24 baseThreshold = actionParams.tickSpacing * actionParams.optimizer.tickRangeMultiplier();\n\n        uint256 balance0;\n        uint256 balance1;\n        (balance0, balance1, tickLower, tickUpper) = getThisPositionTicks(\n            actionParams.pool, actionParams.token0, actionParams.token1, baseThreshold, actionParams.tickSpacing\n        );\n        emit Snapshot(balance0, balance1);\n\n        (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(actionParams.token0),\n                token1: address(actionParams.token1),\n                amount0Desired: balance0,\n                amount1Desired: balance1,\n                ...\n            })\n        );\n    }\n```\n\nThe mistake is in the function `getThisPositionTicks()` because it returns the actual token balance of the `Strategy` contract:\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/libraries/PoolActions.sol#L90-L103>\n\n```solidity\n    function getThisPositionTicks(\n        IUniswapV3Pool pool,\n        ERC20 token0,\n        ERC20 token1,\n        int24 baseThreshold,\n        int24 tickSpacing\n    ) private view returns (uint256 balance0, uint256 balance1, int24 tickLower, int24 tickUpper) {\n        // Emit snapshot to record balances\n        balance0 = token0.balanceOf(address(this));\n        balance1 = token1.balanceOf(address(this));\n\n        //Get exact ticks depending on Optimizer's balances\n        (tickLower, tickUpper) = pool.getPositionTicks(balance0, balance1, baseThreshold, tickSpacing);\n    }\n```\n\nThis returns the actual balance which consists of 2 parts: `protocolFee` and users' funds. `Rerange` must use users' funds, but not `protocolFee`.\n\nSuppose the following scenario:\n\n1. A user has added 1000 tokens of liquidity.\n2. This liquidity generated 100 tokens of fee, 50 of which is `protocolFee`.\n3. `Rerange` is called. After removing liquidity contract, they have a 1000 + 100 tokens balance. And the contract adds liquidity of whole balances - 1100 tokens.\n4. Function `collectFee` doesn't work because the actual balance is less than the withdrawing amount and the protocol loses profit.\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/base/TalosBaseStrategy.sol#L394-L415>\n\n```solidity\n    function collectProtocolFees(uint256 amount0, uint256 amount1) external nonReentrant onlyOwner {\n        uint256 _protocolFees0 = protocolFees0;\n        uint256 _protocolFees1 = protocolFees1;\n\n        if (amount0 > _protocolFees0) {\n            revert Token0AmountIsBiggerThanProtocolFees();\n        }\n        if (amount1 > _protocolFees1) {\n            revert Token1AmountIsBiggerThanProtocolFees();\n        }\n        ERC20 _token0 = token0;\n        ERC20 _token1 = token1;\n        uint256 balance0 = _token0.balanceOf(address(this));\n        uint256 balance1 = _token1.balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) _token0.transfer(msg.sender, amount0);\n        if (amount1 > 0) _token1.transfer(msg.sender, amount1);\n\n        protocolFees0 = _protocolFees0 - amount0;\n        protocolFees1 = _protocolFees1 - amount1;\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n```\n\n### Recommended Mitigation Steps\n\nI suggest using a different address for `protocolFee`. Transfer all `protocolFee` tokens away from this contract to not mix it with users' assets. Create a contract like `ProtocolFeeReceiver.sol` and make a force transfer of tokens when `Strategy` gets fee.\n\nAlso a note - that in the forked parent project, `SorbettoFragola`, it is implemented via `burnExactLiquidity`. \n\n<https://github.com/Popsicle-Finance/SorbettoFragola/blob/9fb31b74f19005d86a78abc758553e7914e7ba49/SorbettoFragola.sol#L458-L483>\n\n### Assessed type\n\nMath\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/80#issuecomment-1631476429)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/80#issuecomment-1709947139):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/80).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/talos/strategies/TalosStrategySimple.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {TalosBaseStrategy} from \"../base/TalosBaseStrategy.sol\";\n\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {PoolActions} from \"../libraries/PoolActions.sol\";\n\nimport {ITalosOptimizer} from \"../interfaces/ITalosOptimizer.sol\";\n\n/// @title Rebalacing and reranging strategies for TALOS UniswapV3 LPs\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract TalosStrategySimple is TalosBaseStrategy {\n    using PoolActions for INonfungiblePositionManager;\n\n    constructor(\n        IUniswapV3Pool _pool,\n        ITalosOptimizer _strategy,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        address _strategyManager,\n        address _owner\n    ) TalosBaseStrategy(_pool, _strategy, _nonfungiblePositionManager, _strategyManager, _owner) {}\n\n    // /*//////////////////////////////////////////////////////////////\n    //                     RERANGE/REBALANCE LOGIC\n    // //////////////////////////////////////////////////////////////*/\n\n    function doRerange() internal override returns (uint256 amount0, uint256 amount1) {\n        (tickLower, tickUpper, amount0, amount1, tokenId, liquidity) = nonfungiblePositionManager.rerange(\n            PoolActions.ActionParams(pool, optimizer, token0, token1, tickSpacing), poolFee\n        );\n    }\n\n    function doRebalance() internal override returns (uint256 amount0, uint256 amount1) {\n        int24 baseThreshold = tickSpacing * optimizer.tickRangeMultiplier();\n\n        PoolActions.ActionParams memory actionParams =\n            PoolActions.ActionParams(pool, optimizer, token0, token1, tickSpacing);\n\n        PoolActions.swapToEqualAmounts(actionParams, baseThreshold);\n\n        (tickLower, tickUpper, amount0, amount1, tokenId, liquidity) =\n            nonfungiblePositionManager.rerange(actionParams, poolFee);\n    }\n}"
    },
    {
      "filename": "src/talos/libraries/PoolActions.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Logic inspired by Popsicle Finance Contracts (PopsicleV3Optimizer/contracts/libraries/PoolActions.sol)\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {ITalosOptimizer} from \"@talos/interfaces/ITalosOptimizer.sol\";\n\nimport {PoolVariables} from \"./PoolVariables.sol\";\n\n/// @title Pool Actions - Library for conducting uniswap v3 pool actions\n/// @author MaiaDAO\n/// @notice This library is created to conduct a variety of swap, burn and add liquidity methods.\nlibrary PoolActions {\n    using PoolVariables for IUniswapV3Pool;\n\n    /// @notice Shows current Optimizer's balances\n    /// @param totalAmount0 Current token0 Optimizer's balance\n    /// @param totalAmount1 Current token1 Optimizer's balance\n    event Snapshot(uint256 totalAmount0, uint256 totalAmount1);\n\n    //Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    struct SwapCallbackData {\n        bool zeroForOne;\n    }\n\n    struct ActionParams {\n        IUniswapV3Pool pool;\n        ITalosOptimizer optimizer;\n        ERC20 token0;\n        ERC20 token1;\n        int24 tickSpacing;\n    }\n\n    function swapToEqualAmounts(ActionParams memory actionParams, int24 baseThreshold) internal {\n        (bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96) = actionParams\n            .pool\n            .getSwapToEqualAmountsParams(\n            actionParams.optimizer, actionParams.tickSpacing, baseThreshold, actionParams.token0, actionParams.token1\n        );\n\n        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit\n        actionParams.pool.swap(\n            address(this),\n            zeroForOne,\n            amountSpecified,\n            sqrtPriceLimitX96,\n            abi.encode(SwapCallbackData({zeroForOne: zeroForOne}))\n        );\n    }\n\n    // Rerange a pool according to ITalosOptimizer's parameters\n    function rerange(\n        INonfungiblePositionManager nonfungiblePositionManager,\n        ActionParams memory actionParams,\n        uint24 poolFee\n    )\n        internal\n        returns (int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1, uint256 tokenId, uint128 liquidity)\n    {\n        int24 baseThreshold = actionParams.tickSpacing * actionParams.optimizer.tickRangeMultiplier();\n\n        uint256 balance0;\n        uint256 balance1;\n        (balance0, balance1, tickLower, tickUpper) = getThisPositionTicks(\n            actionParams.pool, actionParams.token0, actionParams.token1, baseThreshold, actionParams.tickSpacing\n        );\n        emit Snapshot(balance0, balance1);\n\n        (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(actionParams.token0),\n                token1: address(actionParams.token1),\n                fee: poolFee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                amount0Desired: balance0,\n                amount1Desired: balance1,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n    }\n\n    function getThisPositionTicks(\n        IUniswapV3Pool pool,\n        ERC20 token0,\n        ERC20 token1,\n        int24 baseThreshold,\n        int24 tickSpacing\n    ) private view returns (uint256 balance0, uint256 balance1, int24 tickLower, int24 tickUpper) {\n        // Emit snapshot to record balances\n        balance0 = token0.balanceOf(address(this));\n        balance1 = token1.balanceOf(address(this));\n\n        //Get exact ticks depending on Optimizer's balances\n        (tickLower, tickUpper) = pool.getPositionTicks(balance0, balance1, baseThreshold, tickSpacing);\n    }\n}"
    },
    {
      "filename": "src/talos/libraries/PoolActions.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Logic inspired by Popsicle Finance Contracts (PopsicleV3Optimizer/contracts/libraries/PoolActions.sol)\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {ITalosOptimizer} from \"@talos/interfaces/ITalosOptimizer.sol\";\n\nimport {PoolVariables} from \"./PoolVariables.sol\";\n\n/// @title Pool Actions - Library for conducting uniswap v3 pool actions\n/// @author MaiaDAO\n/// @notice This library is created to conduct a variety of swap, burn and add liquidity methods.\nlibrary PoolActions {\n    using PoolVariables for IUniswapV3Pool;\n\n    /// @notice Shows current Optimizer's balances\n    /// @param totalAmount0 Current token0 Optimizer's balance\n    /// @param totalAmount1 Current token1 Optimizer's balance\n    event Snapshot(uint256 totalAmount0, uint256 totalAmount1);\n\n    //Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    struct SwapCallbackData {\n        bool zeroForOne;\n    }\n\n    struct ActionParams {\n        IUniswapV3Pool pool;\n        ITalosOptimizer optimizer;\n        ERC20 token0;\n        ERC20 token1;\n        int24 tickSpacing;\n    }\n\n    function swapToEqualAmounts(ActionParams memory actionParams, int24 baseThreshold) internal {\n        (bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96) = actionParams\n            .pool\n            .getSwapToEqualAmountsParams(\n            actionParams.optimizer, actionParams.tickSpacing, baseThreshold, actionParams.token0, actionParams.token1\n        );\n\n        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit\n        actionParams.pool.swap(\n            address(this),\n            zeroForOne,\n            amountSpecified,\n            sqrtPriceLimitX96,\n            abi.encode(SwapCallbackData({zeroForOne: zeroForOne}))\n        );\n    }\n\n    // Rerange a pool according to ITalosOptimizer's parameters\n    function rerange(\n        INonfungiblePositionManager nonfungiblePositionManager,\n        ActionParams memory actionParams,\n        uint24 poolFee\n    )\n        internal\n        returns (int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1, uint256 tokenId, uint128 liquidity)\n    {\n        int24 baseThreshold = actionParams.tickSpacing * actionParams.optimizer.tickRangeMultiplier();\n\n        uint256 balance0;\n        uint256 balance1;\n        (balance0, balance1, tickLower, tickUpper) = getThisPositionTicks(\n            actionParams.pool, actionParams.token0, actionParams.token1, baseThreshold, actionParams.tickSpacing\n        );\n        emit Snapshot(balance0, balance1);\n\n        (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(actionParams.token0),\n                token1: address(actionParams.token1),\n                fee: poolFee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                amount0Desired: balance0,\n                amount1Desired: balance1,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n    }\n\n    function getThisPositionTicks(\n        IUniswapV3Pool pool,\n        ERC20 token0,\n        ERC20 token1,\n        int24 baseThreshold,\n        int24 tickSpacing\n    ) private view returns (uint256 balance0, uint256 balance1, int24 tickLower, int24 tickUpper) {\n        // Emit snapshot to record balances\n        balance0 = token0.balanceOf(address(this));\n        balance1 = token1.balanceOf(address(this));\n\n        //Get exact ticks depending on Optimizer's balances\n        (tickLower, tickUpper) = pool.getPositionTicks(balance0, balance1, baseThreshold, tickSpacing);\n    }\n}"
    },
    {
      "filename": "src/talos/base/TalosBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Logic inspired by Popsicle Finance Contracts (PopsicleV3Optimizer/contracts/popsicle-v3-optimizer/PopsicleV3Optimizer.sol)\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {PoolVariables} from \"../libraries/PoolVariables.sol\";\n\nimport {ITalosBaseStrategy} from \"../interfaces/ITalosBaseStrategy.sol\";\nimport {ITalosOptimizer} from \"../interfaces/ITalosOptimizer.sol\";\n\n/// @title Tokenized Vault implementation for Uniswap V3 Non Fungible Positions.\nabstract contract TalosBaseStrategy is Ownable, ERC20, ReentrancyGuard, ITalosBaseStrategy {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for uint128;\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint128;\n    using PoolVariables for IUniswapV3Pool;\n\n    /*//////////////////////////////////////////////////////////////\n                        TALOS BASE STRATEGY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public override tokenId;\n    /// @inheritdoc ITalosBaseStrategy\n    uint128 public override liquidity;\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees0;\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees1;\n\n    /// @notice Current tick lower of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickLower;\n    /// @notice Current tick higher of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickUpper;\n\n    /// @inheritdoc ITalosBaseStrategy\n    bool public initialized;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token0;\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token1;\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public immutable override tickSpacing;\n    /// @inheritdoc ITalosBaseStrategy\n    uint24 public immutable override poolFee;\n    /// @inheritdoc ITalosBaseStrategy\n    IUniswapV3Pool public immutable override pool;\n    /// @inheritdoc ITalosBaseStrategy\n    ITalosOptimizer public immutable override optimizer;\n    /// @inheritdoc ITalosBaseStrategy\n    address public immutable strategyManager;\n    /// @inheritdoc ITalosBaseStrategy\n    INonfungiblePositionManager public immutable override nonfungiblePositionManager;\n\n    uint24 internal constant MULTIPLIER = 1e6;\n\n    constructor(\n        IUniswapV3Pool _pool,\n        ITalosOptimizer _optimizer,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        address _strategyManager,\n        address _owner\n    ) ERC20(\"TALOS LP\", \"TLP\", 18) {\n        _initializeOwner(_owner);\n        optimizer = _optimizer;\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        strategyManager = _strategyManager;\n        pool = _pool;\n        token0 = ERC20(_pool.token0());\n        token1 = ERC20(_pool.token1());\n        tickSpacing = _pool.tickSpacing();\n        poolFee = _pool.fee();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INITIALIZATION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function init(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        external\n        virtual\n        nonReentrant\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        if (initialized) revert AlreadyInitialized();\n\n        {\n            // Own Scope to avoid stack to deep\n            int24 _tickSpacing = tickSpacing; // Saves an extra SLOAD\n            int24 baseThreshold = _tickSpacing * optimizer.tickRangeMultiplier();\n            (, int24 currentTick,,,,,) = pool.slot0();\n            int24 tickFloor = PoolVariables.floor(currentTick, _tickSpacing);\n\n            int24 _tickLower = tickFloor - baseThreshold; // Saves an extra SLOAD\n            int24 _tickUpper = tickFloor + baseThreshold; // Saves an extra SLOAD\n            PoolVariables.checkRange(_tickLower, _tickUpper); // Check ticks also for overflow/underflow\n            tickLower = _tickLower;\n            tickUpper = _tickUpper;\n        }\n\n        (ERC20 _token0, ERC20 _token1) = (token0, token1);\n        address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n        address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager; // Saves an extra SLOAD\n\n        address(_token0).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n        address(_token1).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n\n        uint128 _liquidity;\n        uint256 _tokenId;\n        (_tokenId, _liquidity, amount0, amount1) = _nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(_token0),\n                token1: address(_token1),\n                fee: poolFee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n        shares = _liquidity * MULTIPLIER;\n        liquidity = _liquidity;\n        tokenId = _tokenId;\n\n        _mint(receiver, shares);\n        if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n        emit Initialize(tokenId, msg.sender, receiver, amount0, amount1, shares);\n\n        afterDeposit(_tokenId);\n        initialized = true;\n\n        // Refund in both assets.\n        if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n        if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function deposit(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        uint256 _tokenId = tokenId;\n\n        beforeDeposit(_tokenId, receiver);\n\n        (ERC20 _token0, ERC20 _token1) = (token0, token1);\n\n        address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n        address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n        uint128 liquidityDifference;\n\n        (liquidityDifference, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: _tokenId,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        shares = supply == 0 ? liquidityDifference * MULTIPLIER : (liquidityDifference * supply) / liquidity;\n        liquidity += liquidityDifference;\n\n        _mint(receiver, shares);\n        if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n        emit Deposit(msg.sender, receiver, amount0, amount1, shares);\n\n        afterDeposit(_tokenId);\n\n        // Refund in both assets.\n        if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n        if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function redeem(uint256 shares, uint256 amount0Min, uint256 amount1Min, address receiver, address _owner)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 amount0, uint256 amount1)\n    {\n        if (msg.sender != _owner) {\n            uint256 allowed = allowance[_owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[_owner][msg.sender] = allowed - shares;\n        }\n\n        if (shares == 0) revert RedeemingZeroShares();\n        if (receiver == address(0)) revert ReceiverIsZeroAddress();\n\n        uint256 _tokenId = tokenId;\n\n        beforeRedeem(_tokenId, receiver);\n\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager; // Saves an extra SLOAD\n        {\n            uint128 liquidityToDecrease = uint128((liquidity * shares) / totalSupply);\n\n            (amount0, amount1) = _nonfungiblePositionManager.decreaseLiquidity(\n                INonfungiblePositionManager.DecreaseLiquidityParams({\n                    tokenId: _tokenId,\n                    liquidity: liquidityToDecrease,\n                    amount0Min: amount0Min,\n                    amount1Min: amount1Min,\n                    deadline: block.timestamp\n                })\n            );\n\n            if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n            _burn(_owner, shares);\n\n            liquidity -= liquidityToDecrease;\n        }\n        emit Redeem(msg.sender, receiver, _owner, amount0, amount1, shares);\n\n        (amount0, amount1) = _nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: receiver,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n\n        afterRedeem(_tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        RERANGE/REBALANCE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function rerange() external virtual override nonReentrant checkDeviation onlyStrategyManager {\n        uint256 _tokenId = tokenId;\n        beforeRerange(_tokenId);\n        // Redeem all liquidity from pool to rerange for Optimizer's balances.\n        _withdrawAll(_tokenId);\n\n        (uint256 amount0, uint256 amount1) = doRerange();\n        emit Rerange(tokenId, tickLower, tickUpper, amount0, amount1);\n\n        afterRerange(tokenId); // tokenId changed in doRerange\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function rebalance() external virtual override nonReentrant checkDeviation onlyStrategyManager {\n        uint256 _tokenId = tokenId;\n        beforeRerange(_tokenId);\n        // Redeem all liquidity from pool to rerange for Optimizer's balances.\n        _withdrawAll(_tokenId);\n\n        (uint256 amount0, uint256 amount1) = doRebalance();\n        emit Rerange(tokenId, tickLower, tickUpper, amount0, amount1);\n\n        afterRerange(tokenId); // tokenId changed in doRerange\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata _data) external {\n        if (msg.sender != address(pool)) revert CallerIsNotPool();\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) address(token0).safeTransfer(msg.sender, uint256(amount0));\n        else address(token1).safeTransfer(msg.sender, uint256(amount1));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Redeems all liquidity for a specific tokenId\n    /// @param _tokenId position to withdraw liquidity from\n    function _withdrawAll(uint256 _tokenId) internal {\n        uint128 _liquidity = liquidity; // Saves an extra SLOAD if totalSupply is non-zero.\n        if (_liquidity == 0) return;\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager;\n        _nonfungiblePositionManager.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: _tokenId,\n                liquidity: _liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n        liquidity = 0;\n        _nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: address(this),\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n    }\n\n    function beforeDeposit(uint256 _tokenId, address _receiver) internal virtual;\n\n    function afterDeposit(uint256 _tokenId) internal virtual;\n\n    function beforeRedeem(uint256 _tokenId, address _owner) internal virtual;\n\n    function afterRedeem(uint256 _tokenId) internal virtual;\n\n    function beforeRerange(uint256 _tokenId) internal virtual;\n\n    function afterRerange(uint256 _tokenId) internal virtual;\n\n    function doRerange() internal virtual returns (uint256 amount0, uint256 amount1);\n\n    function doRebalance() internal virtual returns (uint256 amount0, uint256 amount1);\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function collectProtocolFees(uint256 amount0, uint256 amount1) external nonReentrant onlyOwner {\n        uint256 _protocolFees0 = protocolFees0;\n        uint256 _protocolFees1 = protocolFees1;\n\n        if (amount0 > _protocolFees0) {\n            revert Token0AmountIsBiggerThanProtocolFees();\n        }\n        if (amount1 > _protocolFees1) {\n            revert Token1AmountIsBiggerThanProtocolFees();\n        }\n        ERC20 _token0 = token0;\n        ERC20 _token1 = token1;\n        uint256 balance0 = _token0.balanceOf(address(this));\n        uint256 balance1 = _token1.balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) _token0.transfer(msg.sender, amount0);\n        if (amount1 > 0) _token1.transfer(msg.sender, amount1);\n\n        protocolFees0 = _protocolFees0 - amount0;\n        protocolFees1 = _protocolFees1 - amount1;\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Function modifier that checks if price has not moved a lot recently.\n    /// This mitigates price manipulation during rebalance and also prevents placing orders when it's too volatile.\n    modifier checkDeviation() {\n        ITalosOptimizer _optimizer = optimizer;\n        pool.checkDeviation(_optimizer.maxTwapDeviation(), _optimizer.twapDuration());\n        _;\n    }\n\n    /// @notice Function modifier that checks if msg.sender is the strategy manager.\n    modifier onlyStrategyManager() {\n        if (msg.sender != strategyManager) revert NotStrategyManager();\n        _;\n    }\n}"
    },
    {
      "filename": "SorbettoFragola.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./interfaces/external/IWETH9.sol\";\nimport \"./utils/ReentrancyGuard.sol\";\nimport './libraries/TransferHelper.sol';\nimport \"./libraries/SqrtPriceMath.sol\";\nimport \"./base/ERC20Permit.sol\";\nimport \"./libraries/Babylonian.sol\";\nimport \"./libraries/PoolActions.sol\";\nimport \"./interfaces/ISorbettoStrategy.sol\";\nimport \"./interfaces/IsorbettoFragola.sol\";\n\n/// @title Sorbetto Fragola is a yield enchancement v3 contract\n/// @dev Sorbetto fragola is a Uniswap V3 yield enchancement contract which acts as\n/// intermediary between the user who wants to provide liquidity to specific pools\n/// and earn fees from such actions. The contract ensures that user position is in \n/// range and earns maximum amount of fees available at current liquidity utilization\n/// rate. \ncontract SorbettoFragola is ERC20Permit, ReentrancyGuard, ISorbettoFragola {\n    using LowGasSafeMath for uint256;\n    using LowGasSafeMath for uint160;\n    using LowGasSafeMath for uint128;\n    using UnsafeMath for uint256;\n    using SafeCast for uint256;\n    using PoolVariables for IUniswapV3Pool;\n    using PoolActions for IUniswapV3Pool;\n    \n    //Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n    struct MintCallbackData {\n        address payer;\n    }\n    //Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    struct SwapCallbackData {\n        bool zeroForOne;\n    }\n    // Info of each user\n    struct UserInfo {\n        uint256 token0Rewards; // The amount of fees in token 0\n        uint256 token1Rewards; // The amount of fees in token 1\n        uint256 token0PerSharePaid; // Token 0 reward debt \n        uint256 token1PerSharePaid; // Token 1 reward debt\n    }\n\n    /// @notice Emitted when user adds liquidity\n    /// @param sender The address that minted the liquidity\n    /// @param liquidity The amount of liquidity added by the user to position\n    /// @param amount0 How much token0 was required for the added liquidity\n    /// @param amount1 How much token1 was required for the added liquidity\n    event Deposit(\n        address indexed sender,\n        uint256 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n    \n    /// @notice Emitted when user withdraws liquidity\n    /// @param sender The address that minted the liquidity\n    /// @param shares of liquidity withdrawn by the user from the position\n    /// @param amount0 How much token0 was required for the added liquidity\n    /// @param amount1 How much token1 was required for the added liquidity\n    event Withdraw(\n        address indexed sender,\n        uint256 shares,\n        uint256 amount0,\n        uint256 amount1\n    );\n    \n    /// @notice Emitted when fees was collected from the pool\n    /// @param feesFromPool0 Total amount of fees collected in terms of token 0\n    /// @param feesFromPool1 Total amount of fees collected in terms of token 1\n    /// @param usersFees0 Total amount of fees collected by users in terms of token 0\n    /// @param usersFees1 Total amount of fees collected by users in terms of token 1\n    event CollectFees(\n        uint256 feesFromPool0,\n        uint256 feesFromPool1,\n        uint256 usersFees0,\n        uint256 usersFees1\n    );\n\n    /// @notice Emitted when sorbetto fragola changes the position in the pool\n    /// @param tickLower Lower price tick of the positon\n    /// @param tickUpper Upper price tick of the position\n    /// @param amount0 Amount of token 0 deposited to the position\n    /// @param amount1 Amount of token 1 deposited to the position\n    event Rerange(\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 amount0,\n        uint256 amount1\n    );\n    \n    /// @notice Emitted when user collects his fee share\n    /// @param sender User address\n    /// @param fees0 Exact amount of fees claimed by the users in terms of token 0 \n    /// @param fees1 Exact amount of fees claimed by the users in terms of token 1\n    event RewardPaid(\n        address indexed sender,\n        uint256 fees0,\n        uint256 fees1\n    );\n    \n    /// @notice Shows current Sorbetto's balances\n    /// @param totalAmount0 Current token0 Sorbetto's balance\n    /// @param totalAmount1 Current token1 Sorbetto's balance\n    event Snapshot(uint256 totalAmount0, uint256 totalAmount1);\n\n    event TransferGovernance(address indexed previousGovernance, address indexed newGovernance);\n    \n    /// @notice Prevents calls from users\n    modifier onlyGovernance {\n        require(msg.sender == governance, \"OG\");\n        _;\n    }\n    \n    mapping(address => UserInfo) public userInfo; // Info of each user that provides liquidity tokens.\n    /// @inheritdoc ISorbettoFragola\n    address public immutable override token0;\n    /// @inheritdoc ISorbettoFragola\n    address public immutable override token1;\n    // WETH address\n    address public immutable weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    // @inheritdoc ISorbettoFragola\n    int24 public immutable override tickSpacing;\n    uint24 immutable GLOBAL_DIVISIONER = 1e6; // for basis point (0.0001%)\n\n    // @inheritdoc ISorbettoFragola\n    IUniswapV3Pool public override pool;\n    // Accrued protocol fees in terms of token0\n    uint256"
    }
  ]
}