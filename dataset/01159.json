{
  "Title": "Missing and Misleading Documentation",
  "Content": "Throughout the codebase, there are various instances of misleading documentation:\n\n\n* The `burn` function of the [`IScrollERC20`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/token/IScrollERC20.sol#L36) and [`IScrollERC20Upgradeable`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/token/IScrollERC20Upgradeable.sol#L36) interface defines the `_amount` parameter as the \"token to mint\" although it should say burn.\n* The comment in the `L1CustomERC20Gateway` contract saying that [the message is passed to `L2StandardERC20Gateway`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/gateways/L1CustomERC20Gateway.sol#L142) should be about `L2CustomERC20Gateway`.\n* The NatSpec comments \"Update layer 2 to layer 2\" of the [`L1ERC1155Gateway`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/gateways/L1ERC1155Gateway.sol#L138) and [`L1ERC721Gateway`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/gateways/L1ERC721Gateway.sol#L133) should be \"Update layer 1 to layer 2\".\n* The `UpdateTokenMapping` event of the `L1ERC1155Gateway` contract [documents the L1 token twice](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/gateways/L1ERC1155Gateway.sol#L29), while the second one should be the L2 token.\n* The `L1ETHGateway` contract [mentions](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/gateways/L1ETHGateway.sol#L16) that \"The deposited ETH tokens are held in this gateway\", however, ETH is actually forwarded to the `L1ScrollMessenger` contract.\n* The revert string of [\"only EOA\"](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/L1MessageQueue.sol#L264) in the `L1MessageQueue` contract is not accurate for the check it performs, because contract accounts fulfill this condition during the construction time.\n* In the `IL2ETHGateway` the `gasLimit` parameter of the [withdraw functions](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/IL2ETHGateway.sol#L28-L53) is said to be optional, while the same parameter in the ERC-20, ERC-721, and ERC-1155 corresponding interfaces is said to be unused. Looking into [the relayer code](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/bridge/watcher/l2_watcher.go#L353-L362), the parameter is indeed unused. Hence, consider correcting the ETH gateway documentation.\n* In the `PatriciaMerkleTrieVerifier` library, the comment [\"calldata offset | value length\"](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/verifier/PatriciaMerkleTrieVerifier.sol#L234) should be reversed to \"value length | calldata offset\" as correctly pointed out in the [comments above](https://github.com/scroll-tech/scroll/blob/646ecb0124020e27cb261100d0dfa0e9e7513730/contracts/src/libraries/verifier/PatriciaMerkleTrieVerifier.sol#L202).\n* In the `ScrollChain` contract, [\"lastBlockHash\"](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/ScrollChain.sol#LL133C52-L133C65) should be \"parentBatchHash\" to be consistent.\n* In the `ScrollChain` contract the comment \"see the encoding in comments of `commitBatch`\" on lines [63](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/IScrollChain.sol#L63) and [68](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/IScrollChain.sol#L68) should refer to [`BatchHeaderV0Codec`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/codec/BatchHeaderV0Codec.sol) instead.\n* A comment in the `ScrollChain` contract says [\"check genesis batch header length\"](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/ScrollChain.sol#L125), although the following line of code checks that the `_stateRoot` function parameter is non-zero.\n* In the `L2GasPriceOracle` contract, the `setL2BaseFee` function is commented as [\"Allows the owner to modify the l2 base fee\"](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/L2GasPriceOracle.sol#L128), although the function is callable by whitelisted accounts which is a separate role from the owner.\n* The [`ScrollMessengerBase`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/ScrollMessengerBase.sol#L64) and [`L1ScrollMessenger`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/L1ScrollMessenger.sol#L76) contracts' NatSpec suggests that the fee vault is a custom contract on L1, while it is actually an EOA or multisig. Consider clarifying this in the documentation.\n* The `L1ScrollMessenger` contract documents that it can \"drop expired message due to sequencer problems\", while neither that functionality nor timestamps are implemented.\n\n\nBesides correcting the above documentation errors, consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. The following instances are concrete examples of missing documentation:\n\n\n* In the `ChunkCodec` library, L2 transactions are [encoded as part of the chunks and added as `bytes` at the end](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/codec/ChunkCodec.sol#LL14C9-L14C23). However, the encoding of `l2Transactions` is not documented, except for a [comment](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/codec/ChunkCodec.sol#L114) indicating that the first 4 bytes of each transaction are its length. Consider documenting it.\n* The [`_gasLimit` parameter](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/oracle/IGasOracle.sol#L14) of the `IGasOracle.estimateMessageFee` function is not documented.\n* The purpose of [`External.sol`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/External.sol#L7) should be documented.\n\n\nWhen writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Acknowledged, not resolved. The Scroll team stated:*\n\n\n\n> *This will be fixed later if we have more bandwidth.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/libraries/token/IScrollERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\n// The recommended ERC20 implementation for bridge token.\n// deployed in L2 when original token is on L1\n// deployed in L1 when original token is on L2\ninterface IScrollERC20 is IERC20, IERC20Permit {\n    /// @notice Return the address of Gateway the token belongs to.\n    function gateway() external view returns (address);\n\n    /// @notice Return the address of counterpart token.\n    function counterpart() external view returns (address);\n\n    /// @dev ERC677 Standard, see https://github.com/ethereum/EIPs/issues/677\n    /// Defi can use this method to transfer L1/L2 token to L2/L1,\n    /// and deposit to L2/L1 contract in one transaction\n    function transferAndCall(\n        address receiver,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success);\n\n    /// @notice Mint some token to recipient's account.\n    /// @dev Gateway Utilities, only gateway contract can call\n    /// @param _to The address of recipient.\n    /// @param _amount The amount of token to mint.\n    function mint(address _to, uint256 _amount) external;\n\n    /// @notice Mint some token from account.\n    /// @dev Gateway Utilities, only gateway contract can call\n    /// @param _from The address of account to burn token.\n    /// @param _amount The amount of token to mint.\n    function burn(address _from, uint256 _amount) external;\n}"
    },
    {
      "filename": "contracts/src/L1/gateways/L1CustomERC20Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {IL2ERC20Gateway} from \"../../L2/gateways/IL2ERC20Gateway.sol\";\nimport {IL1ScrollMessenger} from \"../IL1ScrollMessenger.sol\";\nimport {IL1ERC20Gateway} from \"./IL1ERC20Gateway.sol\";\n\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {L1ERC20Gateway} from \"./L1ERC20Gateway.sol\";\n\n/// @title L1CustomERC20Gateway\n/// @notice The `L1CustomERC20Gateway` is used to deposit custom ERC20 compatible tokens in layer 1 and\n/// finalize withdraw the tokens from layer 2.\n/// @dev The deposited tokens are held in this gateway. On finalizing withdraw, the corresponding\n/// tokens will be transfer to the recipient directly.\ncontract L1CustomERC20Gateway is OwnableUpgradeable, ScrollGatewayBase, L1ERC20Gateway {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC20 token is updated.\n    /// @param _l1Token The address of ERC20 token in layer 1.\n    /// @param _l2Token The address of corresponding ERC20 token in layer 2.\n    event UpdateTokenMapping(address _l1Token, address _l2Token);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from l1 token address to l2 token address for ERC20 token.\n    mapping(address => address) public tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Initialize the storage of L1CustomERC20Gateway.\n    /// @param _counterpart The address of L2CustomERC20Gateway in L2.\n    /// @param _router The address of L1GatewayRouter.\n    /// @param _messenger The address of L1ScrollMessenger.\n    function initialize(\n        address _counterpart,\n        address _router,\n        address _messenger\n    ) external initializer {\n        require(_router != address(0), \"zero router address\");\n\n        OwnableUpgradeable.__Ownable_init();\n        ScrollGatewayBase._initialize(_counterpart, _router, _messenger);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Token) public view override returns (address) {\n        return tokenMapping[_l1Token];\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCallByCounterpart nonReentrant {\n        require(msg.value == 0, \"nonzero msg.value\");\n        require(_l2Token != address(0), \"token address cannot be 0\");\n        require(_l2Token == tokenMapping[_l1Token], \"l2 token mismatch\");\n\n        // @note can possible trigger reentrant call to this contract or messenger,\n        // but it seems not a big problem.\n        IERC20Upgradeable(_l1Token).safeTransfer(_to, _amount);\n\n        _doCallback(_to, _data);\n\n        emit FinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update layer 1 to layer 2 token mapping.\n    /// @param _l1Token The address of ERC20 token in layer 1.\n    /// @param _l2Token The address of corresponding ERC20 token in layer 2.\n    function updateTokenMapping(address _l1Token, address _l2Token) external onlyOwner {\n        require(_l2Token != address(0), \"token address cannot be 0\");\n\n        tokenMapping[_l1Token] = _l2Token;\n\n        emit UpdateTokenMapping(_l1Token, _l2Token);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @inheritdoc L1ERC20Gateway\n    function _deposit(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual override nonReentrant {\n        address _l2Token = tokenMapping[_token];\n        require(_l2Token != address(0), \"no corresponding l2 token\");\n\n        // 1. Extract real sender if this call is from L1GatewayRouter.\n        address _from = msg.sender;\n        if (router == msg.sender) {\n            (_from, _data) = abi.decode(_data, (address, bytes));\n        }\n\n        // 2. Transfer token into this contract.\n        {\n            // common practice to handle fee on transfer token.\n            uint256 _before = IERC20Upgradeable(_token).balanceOf(address(this));\n            IERC20Upgradeable(_token).safeTransferFrom(_from, address(this), _amount);\n            uint256 _after = IERC20Upgradeable(_token).balanceOf(address(this));\n            // no unchecked here, since some weird token may return arbitrary balance.\n            _amount = _after - _before;\n            // ignore weird fee on transfer token\n            require(_amount > 0, \"deposit zero amount\");\n        }\n\n        // 3. Generate message passed to L2StandardERC20Gateway.\n        bytes memory _message = abi.encodeWithSelector(\n            IL2ERC20Gateway.finalizeDepositERC20.selector,\n            _token,\n            _l2Token,\n            _from,\n            _to,\n            _amount,\n            _data\n        );\n\n        // 4. Send message to L1ScrollMessenger.\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit DepositERC20(_token, _l2Token, _from, _to, _amount, _data);\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/gateways/L1ERC1155Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC1155Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport {ERC1155HolderUpgradeable, ERC1155ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\n\nimport {IL2ERC1155Gateway} from \"../../L2/gateways/IL2ERC1155Gateway.sol\";\nimport {IL1ScrollMessenger} from \"../IL1ScrollMessenger.sol\";\nimport {IL1ERC1155Gateway} from \"./IL1ERC1155Gateway.sol\";\n\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\n\n/// @title L1ERC1155Gateway\n/// @notice The `L1ERC1155Gateway` is used to deposit ERC1155 compatible NFT in layer 1 and\n/// finalize withdraw the NFTs from layer 2.\n/// @dev The deposited NFTs are held in this gateway. On finalizing withdraw, the corresponding\n/// NFT will be transfer to the recipient directly.\n///\n/// This will be changed if we have more specific scenarios.\ncontract L1ERC1155Gateway is OwnableUpgradeable, ERC1155HolderUpgradeable, ScrollGatewayBase, IL1ERC1155Gateway {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC1155 token is updated.\n    /// @param _l1Token The address of ERC1155 token in layer 1.\n    /// @param _l1Token The address of corresponding ERC1155 token in layer 2.\n    event UpdateTokenMapping(address _l1Token, address _l2Token);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from l1 token address to l2 token address for ERC1155 NFT.\n    mapping(address => address) public tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Initialize the storage of L1ERC1155Gateway.\n    /// @param _counterpart The address of L2ERC1155Gateway in L2.\n    /// @param _messenger The address of L1ScrollMessenger.\n    function initialize(address _counterpart, address _messenger) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        ERC1155HolderUpgradeable.__ERC1155Holder_init();\n        ERC1155ReceiverUpgradeable.__ERC1155Receiver_init();\n\n        ScrollGatewayBase._initialize(_counterpart, address(0), _messenger);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1ERC1155Gateway\n    function depositERC1155(\n        address _token,\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        _depositERC1155(_token, msg.sender, _tokenId, _amount, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC1155Gateway\n    function depositERC1155(\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        _depositERC1155(_token, _to, _tokenId, _amount, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC1155Gateway\n    function batchDepositERC1155(\n        address _token,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts,\n        uint256 _gasLimit\n    ) external payable override {\n        _batchDepositERC1155(_token, msg.sender, _tokenIds, _amounts, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC1155Gateway\n    function batchDepositERC1155(\n        address _token,\n        address _to,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts,\n        uint256 _gasLimit\n    ) external payable override {\n        _batchDepositERC1155(_token, _to, _tokenIds, _amounts, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC1155Gateway\n    function finalizeWithdrawERC1155(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount\n    ) external override onlyCallByCounterpart nonReentrant {\n        require(_l2Token != address(0), \"token address cannot be 0\");\n        require(_l2Token == tokenMapping[_l1Token], \"l2 token mismatch\");\n\n        IERC1155Upgradeable(_l1Token).safeTransferFrom(address(this), _to, _tokenId, _amount, \"\");\n\n        emit FinalizeWithdrawERC1155(_l1Token, _l2Token, _from, _to, _tokenId, _amount);\n    }\n\n    /// @inheritdoc IL1ERC1155Gateway\n    function finalizeBatchWithdrawERC1155(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts\n    ) external override onlyCallByCounterpart nonReentrant {\n        require(_l2Token != address(0), \"token address cannot be 0\");\n        require(_l2Token == tokenMapping[_l1Token], \"l2 token mismatch\");\n\n        IERC1155Upgradeable(_l1Token).safeBatchTransferFrom(address(this), _to, _tokenIds, _amounts, \"\");\n\n        emit FinalizeBatchWithdrawERC1155(_l1Token, _l2Token, _from, _to, _tokenIds, _amounts);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update layer 2 to layer 2 token mapping.\n    /// @param _l1Token The address of ERC1155 token in layer 1.\n    /// @param _l1Token The address of corresponding ERC1155 token in layer 2.\n    function updateTokenMapping(address _l1Token, address _l2Token) external onlyOwner {\n        require(_l2Token != address(0), \"token address cannot be 0\");\n\n        tokenMapping[_l1Token] = _l2Token;\n\n        emit UpdateTokenMapping(_l1Token, _l2Token);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit ERC1155 NFT to layer 2.\n    /// @param _token The address of ERC1155 NFT in layer 1.\n    /// @param _to The address of recipient in layer 2.\n    /// @param _tokenId The token id to deposit.\n    /// @param _amount The amount of token to deposit.\n    /// @param _gasLimit Estimated gas limit required to complete the deposit on layer 2.\n    function _depositERC1155(\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) internal nonReentrant {\n        require(_amount > 0, \"deposit zero amount\");\n\n        address _l2Token = tokenMapping[_token];\n        require(_l2Token != address(0), \"no corresponding l2 token\");\n\n        // 1. transfer token to this contract\n        IERC1155Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _tokenId, _amount, \"\");\n\n        // 2. Generate message passed to L2ERC1155Gateway.\n        bytes memory _message = abi.encodeWithSelector(\n            IL2ERC1155Gateway.finalizeDepositERC1155.selector,\n            _token,\n            _l2Token,\n            msg.sender,\n            _to,\n            _tokenId,\n            _amount\n        );\n\n        // 3. Send message to L1ScrollMessenger.\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit DepositERC1155(_token, _l2Token, msg.sender, _to, _tokenId, _amount);\n    }\n\n    /// @dev Internal function to batch deposit ERC1155 NFT to layer 2.\n    /// @param _token The address of ERC1155 NFT in layer 1.\n    /// @param _to The address of recipient in layer 2.\n    /// @param _tokenIds The list of token ids to deposit.\n    /// @param _amounts The list of corresponding number of token to deposit.\n    /// @param _gasLimit Estimated gas limit required to complete the deposit on layer 2.\n    function _batchDepositERC1155(\n        address _token,\n        address _to,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts,\n        uint256 _gasLimit\n    ) internal nonReentrant {\n        require(_tokenIds.length > 0, \"no token to deposit\");\n        require(_tokenIds.length == _amounts.length, \"length mismatch\");\n\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            require(_amounts[i] > 0, \"deposit zero amount\");\n        }\n\n        address _l2Token = tokenMapping[_token];\n        require(_l2Token != address(0), \"no corresponding l2 token\");\n\n        // 1. transfer token to this contract\n        IERC1155Upgradeable(_token).safeBatchTransferFrom(msg.sender, address(this), _tokenIds, _amounts, \"\");\n\n        // 2. Generate message passed to L2ERC1155Gateway.\n        bytes memory _message = abi.encodeWithSelector(\n            IL2ERC1155Gateway.finalizeBatchDepositERC1155.selector,\n            _token,\n            _l2Token,\n            msg.sender,\n            _to,\n            _tokenIds,\n            _amounts\n        );\n\n        // 3. Send message to L1ScrollMessenger.\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit BatchDepositERC1155(_token, _l2Token, msg.sender, _to, _tokenIds, _amounts);\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/gateways/L1ERC1155Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC1155Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport {ERC1155HolderUpgradeable, ERC1155ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\n\nimport {IL2ERC1155Gateway} from \"../../L2/gateways/IL2ERC1155Gateway.sol\";\nimport {IL1ScrollMessenger} from \"../IL1ScrollMessenger.sol\";\nimport {IL1ERC1155Gateway} from \"./IL1ERC1155Gateway.sol\";\n\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\n\n/// @title L1ERC1155Gateway\n/// @notice The `L1ERC1155Gateway` is used to deposit ERC1155 compatible NFT in layer 1 and\n/// finalize withdraw the NFTs from layer 2.\n/// @dev The deposited NFTs are held in this gateway. On finalizing withdraw, the corresponding\n/// NFT will be transfer to the recipient directly.\n///\n/// This will be changed if we have more specific scenarios.\ncontract L1ERC1155Gateway is OwnableUpgradeable, ERC1155HolderUpgradeable, ScrollGatewayBase, IL1ERC1155Gateway {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC1155 token is updated.\n    /// @param _l1Token The address of ERC1155 token in layer 1.\n    /// @param _l1Token The address of corresponding ERC1155 token in layer 2.\n    event UpdateTokenMapping(address _l1Token, address _l2Token);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from l1 token address to l2 token address for ERC1155 NFT.\n    mapping(address => address) public tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Initialize the storage of L1ERC1155Gateway.\n    /// @param _counterpart The address of L2ERC1155Gateway in L2.\n    /// @param _messenger The address of L1ScrollMessenger.\n    function initialize(address _counterpart, address _messenger) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        ERC1155HolderUpgradeable.__ERC1155Holder_init();\n        ERC1155ReceiverUpgradeable.__ERC1155Receiver_init();\n\n        ScrollGatewayBase._initialize(_counterpart, address(0), _messenger);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1ERC1155Gateway\n    function depositERC1155(\n        address _token,\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        _depositERC1155(_token, msg.sender, _tokenId, _amount, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC1155Gateway\n    function depositERC1155(\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        _depositERC1155(_token, _to, _tokenId, _amount, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC1155Gateway\n    function batchDepositERC1155(\n        address _token,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts,\n        uint256 _gasLimit\n    ) external payable override {\n        _batchDepositERC1155(_token, msg.sender, _tokenIds, _amounts, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC1155Gateway\n    function batchDepositERC1155(\n        address _token,\n        address _to,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts,\n        uint256 _gasLimit\n    ) external payable override {\n        _batchDepositERC1155(_token, _to, _tokenIds, _amounts, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC1155Gateway\n    function finalizeWithdrawERC1155(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount\n    ) external override onlyCallByCounterpart nonReentrant {\n        require(_l2Token != address(0), \"token address cannot be 0\");\n        require(_l2Token == tokenMapping[_l1Token], \"l2 token mismatch\");\n\n        IERC1155Upgradeable(_l1Token).safeTransferFrom(address(this), _to, _tokenId, _amount, \"\");\n\n        emit FinalizeWithdrawERC1155(_l1Token, _l2Token, _from, _to, _tokenId, _amount);\n    }\n\n    /// @inheritdoc IL1ERC1155Gateway\n    function finalizeBatchWithdrawERC1155(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts\n    ) external override onlyCallByCounterpart nonReentrant {\n        require(_l2Token != address(0), \"token address cannot be 0\");\n        require(_l2Token == tokenMapping[_l1Token], \"l2 token mismatch\");\n\n        IERC1155Upgradeable(_l1Token).safeBatchTransferFrom(address(this), _to, _tokenIds, _amounts, \"\");\n\n        emit FinalizeBatchWithdrawERC1155(_l1Token, _l2Token, _from, _to, _tokenIds, _amounts);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update layer 2 to layer 2 token mapping.\n    /// @param _l1Token The address of ERC1155 token in layer 1.\n    /// @param _l1Token The address of corresponding ERC1155 token in layer 2.\n    function updateTokenMapping(address _l1Token, address _l2Token) external onlyOwner {\n        require(_l2Token != address(0), \"token address cannot be 0\");\n\n        tokenMapping[_l1Token] = _l2Token;\n\n        emit UpdateTokenMapping(_l1Token, _l2Token);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit ERC1155 NFT to layer 2.\n    /// @param _token The address of ERC1155 NFT in layer 1.\n    /// @param _to The address of recipient in layer 2.\n    /// @param _tokenId The token id to deposit.\n    /// @param _amount The amount of token to deposit.\n    /// @param _gasLimit Estimated gas limit required to complete the deposit on layer 2.\n    function _depositERC1155(\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) internal nonReentrant {\n        require(_amount > 0, \"deposit zero amount\");\n\n        address _l2Token = tokenMapping[_token];\n        require(_l2Token != address(0), \"no corresponding l2 token\");\n\n        // 1. transfer token to this contract\n        IERC1155Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _tokenId, _amount, \"\");\n\n        // 2. Generate message passed to L2ERC1155Gateway.\n        bytes memory _message = abi.encodeWithSelector(\n            IL2ERC1155Gateway.finalizeDepositERC1155.selector,\n            _token,\n            _l2Token,\n            msg.sender,\n            _to,\n            _tokenId,\n            _amount\n        );\n\n        // 3. Send message to L1ScrollMessenger.\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit DepositERC1155(_token, _l2Token, msg.sender, _to, _tokenId, _amount);\n    }\n\n    /// @dev Internal function to batch deposit ERC1155 NFT to layer 2.\n    /// @param _token The address of ERC1155 NFT in layer 1.\n    /// @param _to The address of recipient in layer 2.\n    /// @param _tokenIds The list of token ids to deposit.\n    /// @param _amounts The list of corresponding number of token to deposit.\n    /// @param _gasLimit Estimated gas limit required to complete the deposit on layer 2.\n    function _batchDepositERC1155(\n        address _token,\n        address _to,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts,\n        uint256 _gasLimit\n    ) internal nonReentrant {\n        require(_tokenIds.length > 0, \"no token to deposit\");\n        require(_tokenIds.length == _amounts.length, \"length mismatch\");\n\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            require(_amounts[i] > 0, \"deposit zero amount\");\n        }\n\n        address _l2Token = tokenMapping[_token];\n        require(_l2Token != address(0), \"no corresponding l2 token\");\n\n        // 1. transfer token to this contract\n        IERC1155Upgradeable(_token).safeBatchTransferFrom(msg.sender, address(this), _tokenIds, _amounts, \"\");\n\n        // 2. Generate message passed to L2ERC1155Gateway.\n        bytes memory _message = abi.encodeWithSelector(\n            IL2ERC1155Gateway.finalizeBatchDepositERC1155.selector,\n            _token,\n            _l2Token,\n            msg.sender,\n            _to,\n            _tokenIds,\n            _amounts\n        );\n\n        // 3. Send message to L1ScrollMessenger.\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit BatchDepositERC1155(_token, _l2Token, msg.sender, _to, _tokenIds, _amounts);\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/gateways/L1ETHGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport {IL2ETHGateway} from \"../../L2/gateways/IL2ETHGateway.sol\";\nimport {IL1ScrollMessenger} from \"../IL1ScrollMessenger.sol\";\nimport {IL1ETHGateway} from \"./IL1ETHGateway.sol\";\n\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\n\n/// @title L1ETHGateway\n/// @notice The `L1ETHGateway` is used to deposit ETH in layer 1 and\n/// finalize withdraw ETH from layer 2.\n/// @dev The deposited ETH tokens are held in this gateway. On finalizing withdraw, the corresponding\n/// ETH will be transfer to the recipient directly.\ncontract L1ETHGateway is Initializable, ScrollGatewayBase, IL1ETHGateway {\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Initialize the storage of L1ETHGateway.\n    /// @param _counterpart The address of L2ETHGateway in L2.\n    /// @param _router The address of L1GatewayRouter.\n    /// @param _messenger The address of L1ScrollMessenger.\n    function initialize(\n        address _counterpart,\n        address _router,\n        address _messenger\n    ) external initializer {\n        require(_router != address(0), \"zero router address\");\n        ScrollGatewayBase._initialize(_counterpart, _router, _messenger);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        _deposit(msg.sender, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) public payable override {\n        _deposit(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes calldata _data,\n        uint256 _gasLimit\n    ) external payable override {\n        _deposit(_to, _amount, _data, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCallByCounterpart nonReentrant {\n        require(msg.value == _amount, \"msg.value mismatch\");\n\n        // @note can possible trigger reentrant call to messenger,\n        // but it seems not a big problem.\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool _success, ) = _to.call{value: _amount}(\"\");\n        require(_success, \"ETH transfer failed\");\n\n        _doCallback(_to, _data);\n\n        emit FinalizeWithdrawETH(_from, _to, _amount, _data);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev The internal ETH deposit implementation.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of ETH to be deposited.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function _deposit(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal nonReentrant {\n        require(_amount > 0, \"deposit zero eth\");\n\n        // 1. Extract real sender if this call is from L1GatewayRouter.\n        address _from = msg.sender;\n        if (router == msg.sender) {\n            (_from, _data) = abi.decode(_data, (address, bytes));\n        }\n\n        // 2. Generate message passed to L1ScrollMessenger.\n        bytes memory _message = abi.encodeWithSelector(\n            IL2ETHGateway.finalizeDepositETH.selector,\n            _from,\n            _to,\n            _amount,\n            _data\n        );\n\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, _amount, _message, _gasLimit);\n\n        emit DepositETH(_from, _to, _amount, _data);\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/L1MessageQueue.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {IL2GasPriceOracle} from \"./IL2GasPriceOracle.sol\";\nimport {IL1MessageQueue} from \"./IL1MessageQueue.sol\";\n\nimport {AddressAliasHelper} from \"../../libraries/common/AddressAliasHelper.sol\";\n\n/// @title L1MessageQueue\n/// @notice This contract will hold all L1 to L2 messages.\n/// Each appended message is assigned with a unique and increasing `uint256` index.\ncontract L1MessageQueue is OwnableUpgradeable, IL1MessageQueue {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address _oldGasOracle, address _newGasOracle);\n\n    /// @notice Emitted when owner updates EnforcedTxGateway contract.\n    /// @param _oldGateway The address of old EnforcedTxGateway contract.\n    /// @param _newGateway The address of new EnforcedTxGateway contract.\n    event UpdateEnforcedTxGateway(address _oldGateway, address _newGateway);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ScrollMessenger contract.\n    address public messenger;\n\n    /// @notice The address of ScrollChain contract.\n    address public scrollChain;\n\n    /// @notice The address EnforcedTxGateway contract.\n    address public enforcedTxGateway;\n\n    /// @notice The address of GasOracle contract.\n    address public gasOracle;\n\n    /// @notice The list of queued cross domain messages.\n    bytes32[] public messageQueue;\n\n    /// @inheritdoc IL1MessageQueue\n    uint256 public pendingQueueIndex;\n\n    /// @notice The max gas limit of L1 transactions.\n    uint256 public maxGasLimit;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    function initialize(\n        address _messenger,\n        address _scrollChain,\n        address _enforcedTxGateway,\n        address _gasOracle,\n        uint256 _maxGasLimit\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        messenger = _messenger;\n        scrollChain = _scrollChain;\n        enforcedTxGateway = _enforcedTxGateway;\n        gasOracle = _gasOracle;\n        maxGasLimit = _maxGasLimit;\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1MessageQueue\n    function nextCrossDomainMessageIndex() external view returns (uint256) {\n        return messageQueue.length;\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function getCrossDomainMessage(uint256 _queueIndex) external view returns (bytes32) {\n        return messageQueue[_queueIndex];\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function estimateCrossDomainMessageFee(uint256 _gasLimit) external view override returns (uint256) {\n        address _oracle = gasOracle;\n        if (_oracle == address(0)) return 0;\n        return IL2GasPr"
    }
  ]
}