{
  "Title": "[08] Take flash loan fee",
  "Content": "\nAlthough the fee for yin flash loans is currently zero ([`FLASH_FEE = 0`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/flash_mint.cairo#L32)), it should still be accounted for when [withdrawing the loan `amount` from the borrower](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/flash_mint.cairo#L141), just to make sure this step is not forgotten once the flash fee becomes non-zero in the future. \n\n```diff\ndiff --git a/src/core/flash_mint.cairo b/src/core/flash_mint.cairo\nindex d2114d8..97c21d9 100644\n--- a/src/core/flash_mint.cairo\n+++ b/src/core/flash_mint.cairo\n@@ -138,7 +138,7 @@ mod flash_mint {\n             assert(borrower_resp == ON_FLASH_MINT_SUCCESS, 'FM: on_flash_loan failed');\n \n             // This function in Shrine takes care of balance validation\n-            shrine.eject(receiver, amount_wad);\n+            shrine.eject(receiver, amount_wad + FLASH_FEE.try_into().unwrap());\n \n             if adjust_ceiling {\n                 shrine.set_debt_ceiling(ceiling);\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-opus",
  "Code": [
    {
      "filename": "src/core/flash_mint.cairo",
      "content": "//\n//\n//   Flash minting\n//\n//         |\n//        / \\\n//       / _ \\\n//      |.o '.|\n//      |'._.'|\n//      |     |\n//    ,'| LFG |`.\n//   /  |  |  |  \\\n//   |,-'--|--'-.|\n//\n//\n\n#[starknet::contract]\nmod flash_mint {\n    use opus::interfaces::IFlashBorrower::{IFlashBorrowerDispatcher, IFlashBorrowerDispatcherTrait};\n    use opus::interfaces::IFlashMint::IFlashMint;\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::utils::reentrancy_guard::reentrancy_guard_component;\n    use starknet::{ContractAddress, get_caller_address};\n    use wadray::{Wad, WadZeroable};\n\n    // The value of keccak256(\"ERC3156FlashBorrower.onFlashLoan\") as per EIP3156\n    // it is supposed to be returned from the onFlashLoan function by the receiver\n    const ON_FLASH_MINT_SUCCESS: u256 = 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9_u256;\n\n    // Percentage value of Yin's total supply that can be flash minted (wad)\n    const FLASH_MINT_AMOUNT_PCT: u128 = 50000000000000000;\n    const FLASH_FEE: u256 = 0;\n\n    component!(path: reentrancy_guard_component, storage: reentrancy_guard, event: ReentrancyGuardEvent);\n\n    impl ReentrancyGuardHelpers = reentrancy_guard_component::ReentrancyGuardHelpers<ContractState>;\n\n    #[storage]\n    struct Storage {\n        shrine: IShrineDispatcher,\n        // components\n        #[substorage(v0)]\n        reentrancy_guard: reentrancy_guard_component::Storage,\n    }\n\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        FlashMint: FlashMint,\n        // Component events\n        ReentrancyGuardEvent: reentrancy_guard_component::Event\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct FlashMint {\n        #[key]\n        initiator: ContractAddress,\n        #[key]\n        receiver: ContractAddress,\n        token: ContractAddress,\n        amount: u256\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, shrine: ContractAddress) {\n        self.shrine.write(IShrineDispatcher { contract_address: shrine });\n    }\n\n\n    #[abi(embed_v0)]\n    impl IFlashMintImpl of IFlashMint<ContractState> {\n        //\n        // View Functions\n        //\n        fn max_flash_loan(self: @ContractState, token: ContractAddress) -> u256 {\n            let shrine: IShrineDispatcher = self.shrine.read();\n\n            // Can only flash mint our own synthetic\n            if token == shrine.contract_address {\n                let supply: Wad = shrine.get_total_yin();\n                return (supply * FLASH_MINT_AMOUNT_PCT.into()).val.into();\n            }\n\n            0_u256\n        }\n\n        fn flash_fee(self: @ContractState, token: ContractAddress, amount: u256) -> u256 {\n            // as per EIP3156, if a token is not supported, this function must revert\n            // and we only support flash minting of our own synthetic\n            assert(self.shrine.read().contract_address == token, 'FM: Unsupported token');\n\n            FLASH_FEE\n        }\n\n        //\n        // External Functions\n        //\n\n        fn flash_loan(\n            ref self: ContractState,\n            receiver: ContractAddress,\n            token: ContractAddress,\n            amount: u256,\n            call_data: Span<felt252>\n        ) -> bool {\n            // prevents looping which would lead to excessive minting\n            // we only allow a FLASH_MINT_AMOUNT_PCT percentage of total\n            // yin to be minted, as per spec\n            self.reentrancy_guard.start();\n\n            assert(amount <= self.max_flash_loan(token), 'FM: amount exceeds maximum');\n\n            let shrine = self.shrine.read();\n\n            let amount_wad: Wad = amount.try_into().unwrap();\n\n            // temporarily increase the debt ceiling by the loan amount so that\n            // flash loans still work when total yin is at or exceeds the debt ceiling\n            let ceiling: Wad = shrine.get_debt_ceiling();\n            let total_yin: Wad = shrine.get_total_yin();\n            let budget_adjustment: Wad = match shrine.get_budget().try_into() {\n                Option::Some(surplus) => { surplus },\n                Option::None => { WadZeroable::zero() }\n            };\n            let adjust_ceiling: bool = total_yin + amount_wad + budget_adjustment > ceiling;\n            if adjust_ceiling {\n                shrine.set_debt_ceiling(total_yin + amount_wad + budget_adjustment);\n            }\n\n            shrine.inject(receiver, amount_wad);\n\n            let initiator: ContractAddress = get_caller_address();\n\n            let borrower_resp: u256 = IFlashBorrowerDispatcher { contract_address: receiver }\n                .on_flash_loan(initiator, token, amount, FLASH_FEE, call_data);\n\n            assert(borrower_resp == ON_FLASH_MINT_SUCCESS, 'FM: on_flash_loan failed');\n\n            // This function in Shrine takes care of balance validation\n            shrine.eject(receiver, amount_wad);\n\n            if adjust_ceiling {\n                shrine.set_debt_ceiling(ceiling);\n            }\n\n            self.emit(FlashMint { initiator, receiver, token, amount });\n\n            self.reentrancy_guard.end();\n\n            true\n        }\n    }\n}"
    }
  ]
}