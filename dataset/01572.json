{
  "Title": "M-3: Cancellation refunds should return tokens to order creator, not recipient",
  "Content": "# Issue M-3: Cancellation refunds should return tokens to order creator, not recipient \n\nSource: https://github.com/sherlock-audit/2023-06-dinari-judging/issues/61 \n\n## Found by \n0x007, ArmedGoose, Kodyvim, ctf\\_sec, dirk\\_y, james\\_wu, osmanozdemir1, shtesesamoubiq\n## Summary\nWhen an order is cancelled, the refund is sent to `order.recipient` instead of the order creator because it is the order creator (requestor) pay the payment token for buy order or pay the dShares for sell order\n\nAs is the standard in many L1/L2 bridges, cancelled deposits should be returned to the order creator instead of the recipient. In Dinari's current implementation, a refund acts as a transfer with a middle-man.\n\n## Vulnerability Detail\nSimply, the `_cancelOrderAccounting()` function returns the refund to the `order.recipient`:\n\n```solidity\n    function _cancelOrderAccounting(OrderRequest calldata orderRequest, bytes32 orderId, OrderState memory orderState)\n        internal\n        virtual\n        override\n    {\n        ...\n\n        uint256 refund = orderState.remainingOrder + feeState.remainingPercentageFees;\n\n        ...\n\n        if (refund + feeState.feesEarned == orderRequest.quantityIn) {\n            _closeOrder(orderId, orderRequest.paymentToken, 0);\n            // Refund full payment\n            refund = orderRequest.quantityIn;\n        } else {\n            // Otherwise close order and transfer fees\n            _closeOrder(orderId, orderRequest.paymentToken, feeState.feesEarned);\n        }\n\n\n        // Return escrow\n        IERC20(orderRequest.paymentToken).safeTransfer(orderRequest.recipient, refund);\n    }\n```\n\nRefunds should be returned to the order creator in cases where the input recipient was an incorrect address or simply the user changed their mind prior to the order being filled.\n\n## Impact\n- Potential for irreversible loss of funds\n- Inability to truly cancel order\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-dinari/blob/4851cb7ebc86a7bc26b8d0d399a7dd7f9520f393/sbt-contracts/src/issuer/BuyOrderIssuer.sol#L193-L215\n\n## Tool used\nManual Review\n\n## Recommendation\nReturn the funds to the order creator, not the recipient.\n\n\n\n## Discussion\n\n**bizzyvinci**\n\nEscalate\n\nThis issue ought to be high because it doesn't require external conditions or specific states for users to lose a significant amount.\nIt is very likely that `msg.sender != recipient` cause msg.sender and recipient could be different entities trying to have a deal either EOA-EOA or contract-EOA or contract-contract. Canceling order is meant to be a **perfect unwind** as mentioned by the sponsor.\n\nThis issue affects every single cancelled order, both buy, direct buy and sell orders.\n\n<img width=\"822\" alt=\"Screenshot 2023-07-11 at 13 56 06\" src=\"https://github.com/sherlock-audit/2023-06-dinari-judging/assets/22333930/7131c7ec-eb1f-4b07-80d5-ef450c80736a\">\n\n\n**sherlock-admin**\n\n> Escalate\n> \n> This issue ought to be high because it doesn't require external conditions or specific states for users to lose a significant amount.\n> It is very likely that `msg.sender != recipient` cause msg.sender and recipient could be different entities trying to have a deal either EOA-EOA or contract-EOA or contract-contract. Canceling order is meant to be a **perfect unwind** as mentioned by the sponsor.\n> \n> This issue affects every single cancelled order, both buy, direct buy and sell orders.\n> \n> <img width=\"822\" alt=\"Screenshot 2023-07-11 at 13 56 06\" src=\"https://github.com/sherlock-audit/2023-06-dinari-judging/assets/22333930/7131c7ec-eb1f-4b07-80d5-ef450c80736a\">\n> \n\nThe escalation could not be created because you are not exceeding the escalation threshold.\n\nYou can view the required number of additional valid issues/judging contest payouts in your Profile page,\nin the [Sherlock webapp](https://app.sherlock.xyz/audits/).\n\n\n**jaketimothy**\n\nFixed in \n- https://github.com/dinaricrypto/sbt-contracts/pull/117\n\n**ctf-sec**\n\nFix looks good\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/98",
  "Code": [
    {
      "filename": "sbt-contracts/src/issuer/BuyOrderIssuer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\nimport {SafeERC20, IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"prb-math/Common.sol\" as PrbMath;\nimport {OrderProcessor} from \"./OrderProcessor.sol\";\nimport {IMintBurn} from \"../IMintBurn.sol\";\n\n/// @notice Contract managing market purchase orders for bridged assets\n/// @author Dinari (https://github.com/dinaricrypto/sbt-contracts/blob/main/src/BuyOrderIssuer.sol)\n/// This order processor emits market orders to buy the underlying asset that are good until cancelled\n/// Fees are calculated upfront and held back from the order amount\n/// The payment is escrowed until the order is filled or cancelled\n/// Payment is automatically refunded if the order is cancelled\n/// Implicitly assumes that asset tokens are BridgedERC20 and can be minted\ncontract BuyOrderIssuer is OrderProcessor {\n    // Handle token transfers safely\n    using SafeERC20 for IERC20;\n\n    /// ------------------ Types ------------------ ///\n\n    struct FeeState {\n        // Percentage fees are calculated upfront and accumulated as order is filled\n        uint256 remainingPercentageFees;\n        // Total fees earned including flat fee\n        uint256 feesEarned;\n    }\n\n    /// @dev Order is too small to pay fees\n    error OrderTooSmall();\n\n    /// ------------------ State ------------------ ///\n\n    /// @dev orderId => FeeState\n    mapping(bytes32 => FeeState) private _feeState;\n\n    /// ------------------ Getters ------------------ ///\n\n    /// @inheritdoc OrderProcessor\n    function getOrderRequestForOrder(Order calldata order) public pure override returns (OrderRequest memory) {\n        return OrderRequest({\n            recipient: order.recipient,\n            assetToken: order.assetToken,\n            paymentToken: order.paymentToken,\n            // Add fees back to order quantity to recover total quantityIn\n            quantityIn: order.paymentTokenQuantity + order.fee,\n            price: order.price\n        });\n    }\n\n    /// @notice Get fees for an order\n    /// @param token Payment token for order\n    /// @param inputValue Total input value subject to fees\n    /// @return flatFee Flat fee for order\n    /// @return percentageFee Percentage fee for order\n    /// @dev Fees zero if no orderFees contract is set\n    function getFeesForOrder(address token, uint256 inputValue)\n        public\n        view\n        returns (uint256 flatFee, uint256 percentageFee)\n    {\n        // Check if fee contract is set\n        if (address(orderFees) == address(0)) {\n            return (0, 0);\n        }\n\n        // Calculate fees\n        flatFee = orderFees.flatFeeForOrder(token);\n        // If input value is greater than flat fee, calculate percentage fee on remaining value\n        if (inputValue > flatFee) {\n            percentageFee = orderFees.percentageFeeForValue(inputValue - flatFee);\n        } else {\n            percentageFee = 0;\n        }\n    }\n\n    /// @notice Get the raw input value and fees that produce a final order value\n    /// @param token Payment token for order\n    /// @param orderValue Final order value\n    /// @return inputValue Total input value subject to fees\n    /// @return flatFee Flat fee for order\n    /// @return percentageFee Percentage fee for order\n    /// @dev Fees zero if no orderFees contract is set\n    function getInputValueForOrderValue(address token, uint256 orderValue)\n        external\n        view\n        returns (uint256 inputValue, uint256 flatFee, uint256 percentageFee)\n    {\n        // Check if fee contract is set\n        if (address(orderFees) == address(0)) {\n            return (orderValue, 0, 0);\n        }\n\n        // Calculate input value after flat fee\n        uint256 recoveredValue = orderFees.recoverInputValueFromRemaining(orderValue);\n        // Calculate fees\n        percentageFee = orderFees.percentageFeeForValue(recoveredValue);\n        flatFee = orderFees.flatFeeForOrder(token);\n        // Calculate raw input value\n        inputValue = recoveredValue + flatFee;\n    }\n\n    /// ------------------ Order Lifecycle ------------------ ///\n\n    /// @inheritdoc OrderProcessor\n    function _requestOrderAccounting(OrderRequest calldata orderRequest, bytes32 orderId)\n        internal\n        virtual\n        override\n        returns (Order memory order)\n    {\n        // Determine fees\n        (uint256 flatFee, uint256 percentageFee) = getFeesForOrder(orderRequest.paymentToken, orderRequest.quantityIn);\n        uint256 totalFees = flatFee + percentageFee;\n        // Fees must not exceed order input value\n        if (totalFees >= orderRequest.quantityIn) revert OrderTooSmall();\n\n        // Initialize fee state for order\n        _feeState[orderId] = FeeState({remainingPercentageFees: percentageFee, feesEarned: flatFee});\n\n        // Construct order\n        order = Order({\n            recipient: orderRequest.recipient,\n            assetToken: orderRequest.assetToken,\n            paymentToken: orderRequest.paymentToken,\n            // Buy order\n            sell: false,\n            // Market order\n            orderType: OrderType.MARKET,\n            assetTokenQuantity: 0,\n            // Hold fees back from order amount\n            paymentTokenQuantity: orderRequest.quantityIn - totalFees,\n            price: orderRequest.price,\n            // Good until cancelled\n            tif: TIF.GTC,\n            // Emit fees held back from order amount\n            fee: totalFees\n        });\n\n        // Escrow payment for purchase\n        IERC20(orderRequest.paymentToken).safeTransferFrom(msg.sender, address(this), orderRequest.quantityIn);\n    }\n\n    /// @inheritdoc OrderProcessor\n    // slither-disable-next-line dead-code\n    function _fillOrderAccounting(\n        OrderRequest calldata orderRequest,\n        bytes32 orderId,\n        OrderState memory orderState,\n        uint256 fillAmount,\n        uint256 receivedAmount\n    ) internal virtual override {\n        // Calculate fees and mint asset\n        _fillBuyOrder(orderRequest, orderId, orderState, fillAmount, receivedAmount);\n\n        // Claim payment\n        IERC20(orderRequest.paymentToken).safeTransfer(msg.sender, fillAmount);\n    }\n\n    /// @dev Fill buy order accounting and mint asset\n    function _fillBuyOrder(\n        OrderRequest calldata orderRequest,\n        bytes32 orderId,\n        OrderState memory orderState,\n        uint256 fillAmount,\n        uint256 receivedAmount\n    ) internal virtual {\n        FeeState memory feeState = _feeState[orderId];\n        uint256 remainingOrder = orderState.remainingOrder - fillAmount;\n        // If order is done, close order and transfer fees\n        if (remainingOrder == 0) {\n            _closeOrder(orderId, orderRequest.paymentToken, feeState.remainingPercentageFees + feeState.feesEarned);\n        } else {\n            // Otherwise accumulate fees for fill\n            // Calculate fees\n            uint256 collection = 0;\n            if (feeState.remainingPercentageFees > 0) {\n                // fee = remainingPercentageFees * fillAmount / remainingOrder\n                collection = PrbMath.mulDiv(feeState.remainingPercentageFees, fillAmount, orderState.remainingOrder);\n            }\n            // Update fee state\n            if (collection > 0) {\n                _feeState[orderId].remainingPercentageFees = feeState.remainingPercentageFees - collection;\n                _feeState[orderId].feesEarned = feeState.feesEarned + collection;\n            }\n        }\n\n        // Mint asset\n        IMintBurn(orderRequest.assetToken).mint(orderRequest.recipient, receivedAmount);\n    }\n\n    /// @inheritdoc OrderProcessor\n    function _cancelOrderAccounting(OrderRequest calldata orderRequest, bytes32 orderId, OrderState memory orderState)\n        internal\n        virtual\n        override\n    {\n        FeeState memory feeState = _feeState[orderId];\n        // If no fills, then full refund\n        // This addition is required to check for any fills\n        uint256 refund = orderState.remainingOrder + feeState.remainingPercentageFees;\n        // If any fills, then orderState.remainingOrder would not be large enough to satisfy this condition\n        // feesEarned is always needed to recover flat fee\n        if (refund + feeState.feesEarned == orderRequest.quantityIn) {\n            _closeOrder(orderId, orderRequest.paymentToken, 0);\n            // Refund full payment\n            refund = orderRequest.quantityIn;\n        } else {\n            // Otherwise close order and transfer fees\n            _closeOrder(orderId, orderRequest.paymentToken, feeState.feesEarned);\n        }\n\n        // Return escrow\n        IERC20(orderRequest.paymentToken).safeTransfer(orderRequest.recipient, refund);\n    }\n\n    /// @dev Close order and transfer fees\n    function _closeOrder(bytes32 orderId, address paymentToken, uint256 feesEarned) private {\n        // Clear fee state\n        delete _feeState[orderId];\n\n        // Transfer earneds fees to treasury\n        if (feesEarned > 0) {\n            IERC20(paymentToken).safeTransfer(treasury, feesEarned);\n        }\n    }\n}"
    }
  ]
}