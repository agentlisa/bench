{
  "Title": "M-5: Price band caps apply to decreasing orders, but not to liquidations",
  "Content": "# Issue M-5: Price band caps apply to decreasing orders, but not to liquidations \n\nSource: https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/116 \n\n## Found by \nIllIllI\n## Summary\n\nPrice band caps limit the price at which an order can be settled (e.g. someone trying to reduce their exposure in order to avoid liquidation), but liquidations have no such limitation.\n\n\n## Vulnerability Detail\n\nPrice bands are [used](https://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/perp-contract-v3/test/orderGatewayV2/OrderGatewayV2.settleOrder.int.t.sol#L1269-L1273) in order to ensure that users can't trade a extreme prices, which would result in lower-than usual fees, and liquidations to be less likely, because borrowing fees, funding fees, and liquidation penalties are all based on the opening notional value, rather than the current position size's value, and the reduced fee wouldn't be enough incentive to liquidate the position.\n\nHaving price caps means that even if there are two willing parties willing to settle a trade at a market-determined price, they will be prevented from doing so. In traditional financial markets, there are also trading halts when there is extreme price movement. The difference here is that while no trades are allowed during market halts in traditional finance, in the Perpetual system, liquidations are allowed to take place even if users can't close their positions.\n\n\n## Impact\n\nThe whole purpose of the OracleMaker is to be able to provide liquidity at _all_ times, though this liquidity may be available at a disadvantageous price. If there's a price band, anyone who tries to exit their position before they're liquidated (incurring a fee charged on top of losing the position), will have their orders rejected, even at the disadvantageous price. Note that orders interacting with the OracleMaker, and with other non-whitelisted makers (other traders) are executed by Relayers, who are expected to settle orders after a delay, so definitionally, they'll either be using a stale oracle price or will be executing after other traders have had a change to withdraw their liquidity. In either case, during periods of high volatility and liquidations, the price being used will no longer match the market's clearing price.\n\n\n## Code Snippet\n\nOrders modifying/creating positions have price band checks:\n```solidity\n// File: src/clearingHouse/ClearingHouse.sol : ClearingHouse._openPosition()   #1\n\n321                if (params.isBaseToQuote) {\n322                    // base to exactOutput(quote), B2Q base- quote+\n323                    result.base = -oppositeAmount.toInt256();\n324                    result.quote = params.amount.toInt256();\n325                } else {\n326                    // quote to exactOutput(base), Q2B base+ quote-\n327                    result.base = params.amount.toInt256();\n328                    result.quote = -oppositeAmount.toInt256();\n329                }\n330            }\n331:@>         _checkPriceBand(params.marketId, result.quote.abs().divWad(result.base.abs()));\n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/clearingHouse/ClearingHouse.sol#L321-L331\n\nbut liquidations don't have any price caps, and dont have any authorization checks, which means it can be executed without going through the order gateways and their [relayers](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/orderGatewayV2/OrderGatewayV2.sol#L161):\n```solidity\n// File: src/clearingHouse/ClearingHouse.sol : ClearingHouse.params   #2\n\n160        /// @inheritdoc IClearingHouse\n161        function liquidate(\n162            LiquidatePositionParams calldata params\n163:       ) external nonZero(params.positionSize) returns (int256, int256) {\n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/clearingHouse/ClearingHouse.sol#L160-L163\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nDon't use the price bands for trades against the OracleMaker. As is shown by some of my other submissions, removing the price bands altogether is not safe.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**santipu_** commented:\n> Low - Relayers will execute delayed order with the current market price, not a stale one. And the spread price will never be enough to make the price deviate too much to fail the price band check. If it happened, it should be considered an admin mistake. \n\n**takarez** commented:\n>  seem valid; medium(2)\n\n\n\n**vinta**\n\nThis is invalid I suppose. Indeed, `openPosition()` does have price band but `liquidate()` doesn't. However, liquidation is \"liquidator takes over the liquidatable position at Pyth oracle price\". So no need to have price band for liquidation I think.\n\nThough I agree that trading with OracleMaker doesn't really need price band, but I guess it won't hurt if we still check price band for OracleMaker. It's simpler on implementation (no extra code to check whether it's trading with OracleMaker).\n\n**IllIllI000**\n\n@vinta This submission is about the fact that a normal user will be unable to reduce their position if the OracleMaker's price is outside the price bands, leading to a liquidation they can't do anything to prevent. Can you elaborate on what part is invalid?\n\n**vinta**\n\n@IllIllI000 But how does OracleMaker's price be outside the price band? Since the price band is based on the oracle price +- xx% and OracleMaker's price is from the same oracle. Liquidation is also using the same oracle price.\n\n**IllIllI000**\n\n@vinta if traders keep hitting the same side of the bid or ask, the OracleMaker quotes a worse and worse price for the next trade. Eventually, the next 'worse price' will be pushed outside of the price bands, even though the pyth/oracle price is still at the midpoint of (within) the price band. The liquidation will be using the midpoint, but a trader wanting to reduce their position by reducing against the OracleMaker will only have access to the 'worse price', which may be outside of the bands and will therefore be rejected\n\n**vinta**\n\n@IllIllI000 You're right, that would be a problem. Yes, this is valid! Thank you for pointing out this.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/perpetual-protocol/perp-contract-v3/pull/17\n\n\n**nirohgo**\n\nEscalate\n\nThis is a low:\n\n1. As the finding mentions, this may only be relevant for relayed trades that are delayed during high volatility. (either trader-to-trader or trader-to-oracle-maker)\n2. With regards to the Oracle maker, it always quotes within its configured max spread from the oracle price, so as long as the maximum spread is smaller than the price band it won't quote outside the price band (Admins are trusted to set these values correctly).\n3. So the only relevant case is trader-to-trader positions sent through the relayer where the pyth (market) price drops so quickly that it's outside the position's price band by the time it's settled (but not quickly enough to take the position directly from solid to liquidatable because then liquidation bots win anyway). However, if market conditions are that voletile and the trader tries to do an emeargency exit before liquidation, they can always use the Oracle Maker through the relayer which, as mentioned, will work inspite of the price band, or the SpotHedge maker directly.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This is a low:\n> \n> 1. As the finding mentions, this may only be relevant for relayed trades that are delayed during high volatility. (either trader-to-trader or trader-to-oracle-maker)\n> 2. With regards to the Oracle maker, it always quotes within its configured max spread from the oracle price, so as long as the maximum spread is smaller than the price band it won't quote outside the price band (Admins are trusted to set these values correctly).\n> 3. So the only relevant case is trader-to-trader positions sent through the relayer where the pyth (market) price drops so quickly that it's outside the position's price band by the time it's settled (but not quickly enough to take the position directly from solid to liquidatable because then liquidation bots win anyway). However, if market conditions are that voletile and the trader tries to do an emeargency exit before liquidation, they can always use the Oracle Maker through the relayer which, as mentioned, will work inspite of the price band, or the SpotHedge maker directly.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IllIllI000**\n\nThe goal of the OracleMaker is to provide liquidity essentially at all times in order to collect fees (`...undesirable because he won’t be earning fees on that side` https://perp.notion.site/PythOraclePool-e99a88be051f4bc8be0b1310eb982cd4 ), and requiring that the max spread be smaller than the price bands severely limits this ability, so I don't think it's reasonable to say that the admin is supposed to do this when it contradicts the design of the `maxSpread` being a `Sensitivity of the maker’s price premium to its risk exposure` https://perp.notion.site/PythOraclePool-e99a88be051f4bc8be0b1310eb982cd4 , not a proxy for the price bands. Furthermore, the escalator's assertion that the price bands must be smaller than the max spread essentially trades one risk for another, without regard to the effects of the other risk (see the other valid bugs relating to abusing the price bands). I'll also note that the sponsor has already provided a PR for this issue, so it's not a risk they're willing to take.\n\n**nirohgo**\n\nStill, a lot of stars need to align for this to happen (max spread happens to be larger than price bands, sudden but not too sudden price drop, OM quote is at the maximum spread) and when they do, the trader has the option to use SHBM.\n\n**nevillehuang**\n\nI believe medium severity is appropriate for this issue.\n\n**WangSecurity**\n\nAgree that this issue should remain medium since it causes loss of funds under certain external conditions and breaks core functionality.\n\nPlanning to reject the escalation and leave the issue as it is.\n\n**nirohgo**\n\n@WangSecurity please note that this is invalid because it requires a (trusted) admin to make a configuration error: The Price Band config is the general, systemwide restriction on position price deviation from the oracle price. It applies to all positions and will fail/revert any position settlement that breaks this config. The max spread config is a specific configuration for the Oracle Maker that determines the maximum it's price can deviate from the oracle price. Setting a specific config to a value that exceeds a system wide limit (and will surely fail because of that) is a clear admin error.\n\n**WangSecurity**\n\nBut as I understand, @IllIllI000 proves [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/116#issuecomment-2022203996) and [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/116#issuecomment-2041446230) how your assumption can be broken, no? And as I understand, you agree with it [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/116#issuecomment-2043835305).\n\n**nirohgo**\n\n> But as I understand, @IllIllI000 proves [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/116#issuecomment-2022203996) and [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/116#issuecomment-2041446230) how your assumption can be broken, no? And as I understand, you agree with it [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/116#issuecomment-2043835305).\n\n@WangSecurity  both comments you mentioned are not proofs but rather are based on a claim (that setting contradicting values to these configurations is not an admin error), I'm making a counter claim (that it is). I suppose you need to make a call based on your own judgement between the two claims.\n\n**WangSecurity**\n\nAs I understand from [this](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/116#issuecomment-2041446230) comment shows that the spread is not neccesseraly larger/smaller than the price band and the issue will happen if the spread is larger than the price band, then it will allow to bypass price bands during liquidations as shown [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/116#issuecomment-2022203996). I see that there are lots of conditions that have to align to make it work, but this is a broken core functionality allowing the attacker to bypass the price bands.\n\nHence, I believe medium is appropriate, planning to reject the escalation and leave the issue as it is.\n\n**nirohgo**\n\n@WangSecurity the first comment simply states that there's a legitimate reason to set the specific OM max spread to be larger then the general limitation of the price band. (which I claim is an admin error). The second comment merely states that the trader price will be worse than the liquidation price (which is by design and has nothing to do with this escalation) and that the trader price can be rejected because it may exceed the price band limit which again, can only happen if admins set the OM max spread to a larger value than the price band setting (which I claim is an admin error).\n\n**WangSecurity**\n\n@nirohgo @IllIllI000 the question is: is it documented anywhere (docs/code comments/discord msgs) that the max spread cannot exceed price bands, i.e. is it an invariant that the team will hold?\n\n**IllIllI000**\n\nNo it's not - not that I'm aware of\n\n**nirohgo**\n\n> @nirohgo @IllIllI000 the question is: is it documented anywhere (docs/code comments/discord msgs) that the max spread cannot exceed price bands, i.e. is it an invariant that the team will hold?\n\n@WangSecurity So, you're saying that on Sherlock a trusted admin error only counts as such if there's a specific documentation of it? The fact that it stems from basic logic is not enough?\n\n**WangSecurity**\n\n@nirohgo please share where that logic comes from.\n\n**nirohgo**\n\n> @nirohgo please share where that logic comes from.\n\n@WangSecurity Sure: The admin sets one configuration (price band) that limits price deviation from oracle across all positions (and will fail any settlement that breaks this limit). The OM max spread configuration determines by how much the OM price can deviate from oracle (so you can think about it as a more specific configuration that applies to the OM price). If the admin sets max spread to be larger than Price Band they are making a logical error (because whenever the spread exceeds price band the settlement will fail). Its as if the admin would be breaking a rule they themselves set in another config.\n\n\n**IllIllI000**\n\nI disagree that the intention was to use the price bands as a global limit for all trades. If you look at the origin of the bands, it was this test where a user gains an advantage by trading with themselves with an arbitrary price\n```solidity\n    // FIXME: We shouldn't allow this to happen\n    // probably add price band in OrderGatewayV2 or ClearingHouse,\n    // only allow order.price to be oracle price +- 10% when settling orders\n    // See https://app.asana.com/0/1202133750666965/1206662770651731/f\n    function test_SettleOrder_AtExtremePrice() public {\n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/perp-contract-v3/test/orderGatewayV2/OrderGatewayV2.settleOrder.int.t.sol#L1269-L1273\n\nI had forgotten that I had asked this, but it's clear that their intention for the band was to protect against the scenario in the test, where a user trades with themselves:\n```text\nIllIllI — 03/14/2024\nhi, can you elaborate on the problem that is solved by having price bands? \n    // FIXME: We shouldn't allow this to happen\n    // probably add price band in OrderGatewayV2 or ClearingHouse,\n    // only allow order.price to be oracle price +- 10% when settling orders\n    // See https://app.asana.com/0/1202133750666965/1206662770651731/f\n\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/perp-contract-v3/test/orderGatewayV2/OrderGatewayV2.settleOrder.int.t.sol#L1269-L1273\nis it just to avoid fat finger issues, or is there some other issue with allowing any price, that I'm missing? it looks like there isn't any negative effect to the system besides maybe the funding fee, since margin covers the price difference. the asana link is private, so I can't view it \nbchen4 ʕ̢·͡˔·ོɁ̡ — 03/15/2024\nif taker order match maker order via OrderGatewayV2 with 1 wei price, these two position's openNotional are 1 wei, so they might not to pay borrowingFee or fundingFee \nand there might has problem when liquidation, because we will calculate penalty by openNotional, so liquidator might not has incentive to liquidate and it will increase bad debt risk of our system\n```\n\nThey ended up going with using bands in the [clearinghouse](https://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/perp-contract-v3/src/clearingHouse/ClearingHouse.sol#L290-L331), where they note that a _user_ can choose an arbitrary price, and reference the test above, and so they add a price band check later in the function.\n\n\n**nirohgo**\n\n> I disagree that the intention was to use the price bands as a global limit for all trades. If you look at the origin of the bands, it was this test where a user gains an advantage by trading with themselves with an arbitrary price\n> \n> ```solidity\n>     // FIXME: We shouldn't allow this to happen\n>     // probably add price band in OrderGatewayV2 or ClearingHouse,\n>     // only allow order.price to be oracle price +- 10% when settling orders\n>     // See https://app.asana.com/0/1202133750666965/1206662770651731/f\n>     function test_SettleOrder_AtExtremePrice() public {\n> ```\n> \n> https://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/perp-contract-v3/test/orderGatewayV2/OrderGatewayV2.settleOrder.int.t.sol#L1269-L1273\n> \n> I had forgotten that I had asked this, but it's clear that their intention for the band was to protect against the scenario in the test, where a user trades with themselves:\n> \n> ```\n> IllIllI — 03/14/2024\n> hi, can you elaborate on the problem that is solved by having price bands? \n>     // FIXME: We shouldn't allow this to happen\n>     // probably add price band in OrderGatewayV2 or ClearingHouse,\n>     // only allow order.price to be oracle price +- 10% when settling orders\n>     // See https://app.asana.com/0/1202133750666965/1206662770651731/f\n> \n> https://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/perp-contract-v3/test/orderGatewayV2/OrderGatewayV2.settleOrder.int.t.sol#L1269-L1273\n> is it just to avoid fat finger issues, or is there some other issue with allowing any price, that I'm missing? it looks like there isn't any negative effect to the system besides maybe the funding fee, since margin covers the price difference. the asana link is private, so I can't view it \n> bchen4 ʕ̢·͡˔·ོɁ̡ — 03/15/2024\n> if taker order match maker order via OrderGatewayV2 with 1 wei price, these two position's openNotional are 1 wei, so they might not to pay borrowingFee or fundingFee \n> and there might has problem when liquidation, because we will calculate penalty by openNotional, so liquidator might not has incentive to liquidate and it will increase bad debt risk of our system\n> ```\n> \n> They ended up going with using bands in the [clearinghouse](https://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/perp-contract-v3/src/clearingHouse/ClearingHouse.sol#L290-L331), where they note that a _user_ can choose an arbitrary price, and reference the test above, and so they add a price band check later in the function.\n\nDon't see how that's relevant as it doesn't change the fact that setting OM spread to be larger than Price Band will only result in the admin DOSing their own system (whenever OM price exceeds the price band).\n\n**IllIllI000**\n\nIt's documentation of an intended usage that has a flaw in the design, leading to a negative outcome which I believe @WangSecurity is trying to point out [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/116#issuecomment-2072117193), and is the reason I submitted this finding. I believe all of the facts have been provided, so let's hear what they have to say.\n\n**WangSecurity**\n\nIt's not clear in readme / code comments / docs that the protocol planned on respecting the discussed invariant. Planning to reject the escalation and leave the issue as it is.\n\n**sherlock-admin3**\n\nThe Lead Senior Watson signed off on the fix.\n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nirohgo](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/116/#issuecomment-2041337618): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/219",
  "Code": [
    {
      "filename": "perp-contract-v3/test/orderGatewayV2/OrderGatewayV2.settleOrder.int.t.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport \"./OrderGatewayV2IntSetup.sol\";\nimport { OrderGatewayV2 } from \"../../src/orderGatewayV2/OrderGatewayV2.sol\";\nimport { IClearingHouse } from \"../../src/clearingHouse/IClearingHouse.sol\";\nimport { TestMaker } from \"../helper/TestMaker.sol\";\n\n// notion detail: https://www.notion.so/perp/Limit-Order-with-CLOB-fc215c94ce0b4a4da78fa74f22832f06?pvs=4#d8b26f6e80f7466288360a5f877240a7\ncontract OrderGatewayV2SettleOrderIntTest is OrderGatewayV2IntSetup {\n    using FixedPointMathLib for int256;\n\n    // T1xM1 (taker can be partial filled)\n    function test_SettleOrderOpenPositionWhenMakerIsOpenPositionOrder() public {\n        // taker order (short 1 eth)\n        OrderGatewayV2.SignedOrder memory takerSignOrder = _createSignOrder(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            -1 ether,\n            99.5 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.PartialFill,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"takerSignOrder\"\n        );\n\n        // maker order (long 0.5 eth)\n        OrderGatewayV2.SignedOrder memory makerSignOrder = _createSignOrder(\n            makerOrderOwner,\n            makerOrderOwnerPk,\n            0.4 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.PartialFill,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"makerSignOrder\"\n        );\n\n        OrderGatewayV2.SettleOrderParam[] memory settleOrderParams = new OrderGatewayV2.SettleOrderParam[](1);\n\n        settleOrderParams[0] = OrderGatewayV2.SettleOrderParam({\n            signedOrder: takerSignOrder,\n            fillAmount: 0.4 ether,\n            maker: makerOrderOwner,\n            makerData: abi.encode(makerSignOrder)\n        });\n\n        vm.prank(relay);\n        _expectEmitOrderFilled(makerSignOrder.order, 0.4 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        _expectEmitOrderFilled(takerSignOrder.order, 0.4 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        orderGatewayV2.settleOrder(settleOrderParams);\n\n        // check taker\n        uint256 takerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            takerSignOrder.order.owner,\n            takerSignOrder.order.id\n        );\n        assertEq(takerFilledAmount, 0.4 ether);\n        _assertEq(\n            _getPosition(marketId, takerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: -0.4 ether, openNotional: 40 ether, unsettledPnl: 0 }) // use maker price to settle\n        );\n\n        // check maker\n        uint256 makerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            makerSignOrder.order.owner,\n            makerSignOrder.order.id\n        );\n        assertEq(makerFilledAmount, 0.4 ether);\n        _assertEq(\n            _getPosition(marketId, makerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: 0.4 ether, openNotional: -40 ether, unsettledPnl: 0 })\n        );\n\n        assertEq(vault.getFund(address(orderGatewayV2)), defaultRelayFee * 2);\n    }\n\n    // T1xM2 (taker can be partial filled)\n    function test_SettleOrderOpenPositionWhenMakerIsFokOpenPositionOrder() public {\n        OrderGatewayV2.SignedOrder memory takerSignOrder = _createSignOrder(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            -1 ether,\n            99.5 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.PartialFill,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"takerSignOrder\"\n        );\n\n        // maker order (long 0.4 eth)\n        OrderGatewayV2.SignedOrder memory makerSignOrder = _createSignOrder(\n            makerOrderOwner,\n            makerOrderOwnerPk,\n            0.4 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"makerSignOrder\"\n        );\n\n        OrderGatewayV2.SettleOrderParam[] memory settleOrderParams = new OrderGatewayV2.SettleOrderParam[](1);\n\n        settleOrderParams[0] = OrderGatewayV2.SettleOrderParam({\n            signedOrder: takerSignOrder,\n            fillAmount: 0.4 ether,\n            maker: address(makerOrderOwner),\n            makerData: abi.encode(makerSignOrder)\n        });\n\n        vm.prank(relay);\n        _expectEmitOrderFilled(makerSignOrder.order, 0.4 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        _expectEmitOrderFilled(takerSignOrder.order, 0.4 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        orderGatewayV2.settleOrder(settleOrderParams);\n\n        // check taker\n        uint256 takerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            takerSignOrder.order.owner,\n            takerSignOrder.order.id\n        );\n        assertEq(takerFilledAmount, 0.4 ether);\n        _assertEq(\n            _getPosition(marketId, takerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: -0.4 ether, openNotional: 40 ether, unsettledPnl: 0 }) // use maker price to settle\n        );\n\n        // check maker\n        uint256 makerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            makerSignOrder.order.owner,\n            makerSignOrder.order.id\n        );\n        assertEq(makerFilledAmount, 0.4 ether);\n        _assertEq(\n            _getPosition(marketId, makerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: 0.4 ether, openNotional: -40 ether, unsettledPnl: 0 })\n        );\n\n        assertEq(vault.getFund(address(orderGatewayV2)), defaultRelayFee * 2);\n    }\n\n    // T1xM3 (taker can be partial filled)\n    function test_SettleOrderOpenPositionWhenMakerIsFokReduceOnlyOrder() public {\n        // maker open (0.4 short) first, then close later\n        _openPositionOnTestMaker(\n            makerOrderOwner,\n            makerOrderOwnerPk,\n            -0.4 ether,\n            0.4 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"makerOpenPosition\"\n        );\n\n        OrderGatewayV2.SignedOrder memory takerSignOrder = _createSignOrder(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            -1 ether,\n            99.5 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.PartialFill,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"takerSignOrder\"\n        );\n\n        // maker order (long 0.4 eth)\n        OrderGatewayV2.SignedOrder memory makerClosePositionSignOrder = _createSignOrder(\n            makerOrderOwner,\n            makerOrderOwnerPk,\n            0.4 ether,\n            100 ether,\n            0,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.ReduceOnly,\n            \"makerClosePositionSignOrder\"\n        );\n\n        OrderGatewayV2.SettleOrderParam[] memory settleOrderParams = new OrderGatewayV2.SettleOrderParam[](1);\n\n        settleOrderParams[0] = OrderGatewayV2.SettleOrderParam({\n            signedOrder: takerSignOrder,\n            fillAmount: 0.4 ether,\n            maker: makerOrderOwner,\n            makerData: abi.encode(makerClosePositionSignOrder)\n        });\n\n        vm.prank(relay);\n        _expectEmitOrderFilled(\n            makerClosePositionSignOrder.order,\n            0.4 ether,\n            makerClosePositionSignOrder.order.price,\n            makerClosePositionSignOrder.order.owner\n        );\n        _expectEmitOrderFilled(\n            takerSignOrder.order,\n            0.4 ether,\n            makerClosePositionSignOrder.order.price,\n            makerClosePositionSignOrder.order.owner\n        );\n        orderGatewayV2.settleOrder(settleOrderParams);\n\n        // check taker\n        uint256 takerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            takerSignOrder.order.owner,\n            takerSignOrder.order.id\n        );\n        assertEq(takerFilledAmount, 0.4 ether);\n        _assertEq(\n            _getPosition(marketId, takerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: -0.4 ether, openNotional: 40 ether, unsettledPnl: 0 })\n        );\n        assertEq(vault.getFund(address(takerOrderOwner)), defaultMarginXCD + defaultRelayFee);\n\n        // check maker\n        uint256 makerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            makerClosePositionSignOrder.order.owner,\n            makerClosePositionSignOrder.order.id\n        );\n        assertEq(makerFilledAmount, 0.4 ether);\n        _assertEq(\n            _getPosition(marketId, makerOrderOwner),\n            PositionProfile({ margin: 0 ether, positionSize: 0 ether, openNotional: 0 ether, unsettledPnl: 0 })\n        );\n        assertEq(vault.getFund(address(makerOrderOwner)), defaultMarginXCD * 2);\n\n        assertEq(vault.getFund(address(orderGatewayV2)), defaultRelayFee * 3);\n    }\n\n    // T1xM4 (taker can be partial filled)\n    function test_SettleOrderOpenPositionWhenMakerIsTestMaker() public {\n        // taker open 1 ether long, but filled 0.4 ether\n        OrderGatewayV2.SignedOrder memory takerSignedOrder = _createSignOrder(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            1 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.PartialFill,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"takerSignedOrder\"\n        );\n\n        OrderGatewayV2.SettleOrderParam[] memory settleOrderParams = new OrderGatewayV2.SettleOrderParam[](1);\n\n        settleOrderParams[0] = OrderGatewayV2.SettleOrderParam({\n            signedOrder: takerSignedOrder,\n            fillAmount: 0.4 ether,\n            maker: address(maker),\n            makerData: \"\"\n        });\n\n        vm.prank(relay);\n        _expectEmitOrderFilled(takerSignedOrder.order, 0.4 ether, 100 ether, address(maker));\n        orderGatewayV2.settleOrder(settleOrderParams);\n\n        assertEq(vault.getFund(address(orderGatewayV2)), defaultRelayFee);\n        _assertEq(\n            _getPosition(marketId, takerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: 0.4 ether, openNotional: -40 ether, unsettledPnl: 0 })\n        );\n    }\n\n    // T2xM1 (maker partial filled)\n    function test_SettleOrderFokOpenPositionWhenMakerIsOpenPositionOrder() public {\n        // taker order (short 1 eth)\n        OrderGatewayV2.SignedOrder memory takerSignOrder = _createSignOrder(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            -0.4 ether,\n            99.5 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"takerSignOrder\"\n        );\n\n        // maker order (long 2 eth)\n        OrderGatewayV2.SignedOrder memory makerSignOrder = _createSignOrder(\n            makerOrderOwner,\n            makerOrderOwnerPk,\n            2 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.PartialFill,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"makerSignOrder\"\n        );\n\n        OrderGatewayV2.SettleOrderParam[] memory settleOrderParams = new OrderGatewayV2.SettleOrderParam[](1);\n\n        settleOrderParams[0] = OrderGatewayV2.SettleOrderParam({\n            signedOrder: takerSignOrder,\n            fillAmount: 0.4 ether,\n            maker: makerOrderOwner,\n            makerData: abi.encode(makerSignOrder)\n        });\n\n        vm.prank(relay);\n        _expectEmitOrderFilled(makerSignOrder.order, 0.4 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        _expectEmitOrderFilled(takerSignOrder.order, 0.4 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        orderGatewayV2.settleOrder(settleOrderParams);\n\n        // check taker\n        uint256 takerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            takerSignOrder.order.owner,\n            takerSignOrder.order.id\n        );\n        assertEq(takerFilledAmount, 0.4 ether);\n        _assertEq(\n            _getPosition(marketId, takerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: -0.4 ether, openNotional: 40 ether, unsettledPnl: 0 }) // use maker price to settle\n        );\n\n        // check maker\n        uint256 makerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            makerSignOrder.order.owner,\n            makerSignOrder.order.id\n        );\n        assertEq(makerFilledAmount, 0.4 ether);\n        _assertEq(\n            _getPosition(marketId, makerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: 0.4 ether, openNotional: -40 ether, unsettledPnl: 0 })\n        );\n\n        assertEq(vault.getFund(address(orderGatewayV2)), defaultRelayFee * 2);\n    }\n\n    // T2xM2\n    function test_SettleOrderFokOpenPositionWhenMakerIsFokOpenPositionOrder() public {\n        OrderGatewayV2.SignedOrder memory takerSignOrder = _createSignOrder(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            -1 ether,\n            99.5 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"takerSignOrder\"\n        );\n\n        // maker order (long 1 eth)\n        OrderGatewayV2.SignedOrder memory makerSignOrder = _createSignOrder(\n            makerOrderOwner,\n            makerOrderOwnerPk,\n            1 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"makerSignOrder\"\n        );\n\n        OrderGatewayV2.SettleOrderParam[] memory settleOrderParams = new OrderGatewayV2.SettleOrderParam[](1);\n\n        settleOrderParams[0] = OrderGatewayV2.SettleOrderParam({\n            signedOrder: takerSignOrder,\n            fillAmount: 1 ether,\n            maker: makerOrderOwner,\n            makerData: abi.encode(makerSignOrder)\n        });\n\n        vm.prank(relay);\n        _expectEmitOrderFilled(makerSignOrder.order, 1 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        _expectEmitOrderFilled(takerSignOrder.order, 1 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        orderGatewayV2.settleOrder(settleOrderParams);\n\n        // check taker\n        uint256 takerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            takerSignOrder.order.owner,\n            takerSignOrder.order.id\n        );\n        assertEq(takerFilledAmount, 1 ether);\n        _assertEq(\n            _getPosition(marketId, takerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: -1 ether, openNotional: 100 ether, unsettledPnl: 0 }) // use maker price to settle\n        );\n\n        // check maker\n        uint256 makerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            makerSignOrder.order.owner,\n            makerSignOrder.order.id\n        );\n        assertEq(makerFilledAmount, 1 ether);\n        _assertEq(\n            _getPosition(marketId, makerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: 1 ether, openNotional: -100 ether, unsettledPnl: 0 })\n        );\n\n        assertEq(vault.getFund(address(orderGatewayV2)), defaultRelayFee * 2);\n    }\n\n    // T2xM3 (maker close fok)\n    function test_SettleOrderFokOpenPositionWhenMakerIsFokReduceOnlyOrder() public {\n        // maker open (1 short) first, then close later\n        _openPositionOnTestMaker(\n            makerOrderOwner,\n            makerOrderOwnerPk,\n            -1 ether,\n            1 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"makerOpenPositionSignedOrder\"\n        );\n\n        OrderGatewayV2.SignedOrder memory takerSignOrder = _createSignOrder(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            -1 ether,\n            99.5 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"takerSignOrder\"\n        );\n\n        // maker order (long 1 eth)\n        OrderGatewayV2.SignedOrder memory makerClosePositionSignOrder = _createSignOrder(\n            makerOrderOwner,\n            makerOrderOwnerPk,\n            1 ether,\n            100 ether,\n            0,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.ReduceOnly,\n            \"makerClosePositionSignOrder\"\n        );\n\n        OrderGatewayV2.SettleOrderParam[] memory settleOrderParams = new OrderGatewayV2.SettleOrderParam[](1);\n\n        settleOrderParams[0] = OrderGatewayV2.SettleOrderParam({\n            signedOrder: takerSignOrder,\n            fillAmount: 1 ether,\n            maker: makerOrderOwner,\n            makerData: abi.encode(makerClosePositionSignOrder)\n        });\n\n        vm.prank(relay);\n        _expectEmitOrderFilled(\n            makerClosePositionSignOrder.order,\n            1 ether,\n            makerClosePositionSignOrder.order.price,\n            makerClosePositionSignOrder.order.owner\n        );\n        _expectEmitOrderFilled(\n            takerSignOrder.order,\n            1 ether,\n            makerClosePositionSignOrder.order.price,\n            makerClosePositionSignOrder.order.owner\n        );\n        orderGatewayV2.settleOrder(settleOrderParams);\n\n        // check taker\n        uint256 takerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            takerSignOrder.order.owner,\n            takerSignOrder.order.id\n        );\n        assertEq(takerFilledAmount, 1 ether);\n        _assertEq(\n            _getPosition(marketId, takerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: -1 ether, openNotional: 100 ether, unsettledPnl: 0 }) // use maker price to settle\n        );\n        assertEq(vault.getFund(address(takerOrderOwner)), defaultMarginXCD + defaultRelayFee);\n\n        // check maker\n        uint256 makerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            makerClosePositionSignOrder.order.owner,\n            makerClosePositionSignOrder.order.id\n        );\n        assertEq(makerFilledAmount, 1 ether);\n        _assertEq(\n            _getPosition(marketId, makerOrderOwner),\n            PositionProfile({ margin: 0 ether, positionSize: 0 ether, openNotional: 0 ether, unsettledPnl: 0 })\n        );\n        assertEq(vault.getFund(address(makerOrderOwner)), defaultMarginXCD * 2);\n\n        assertEq(vault.getFund(address(orderGatewayV2)), defaultRelayFee * 3);\n    }\n\n    // T2xM4\n    function test_SettleOrderFokOpenPositionWhenMakerIsTestMaker() public {\n        OrderGatewayV2.SignedOrder memory takerSignOrder = _createSignOrder(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            -1 ether,\n            99.5 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"takerSignOrder\"\n        );\n\n        OrderGatewayV2.SettleOrderParam[] memory settleOrderParams = new OrderGatewayV2.SettleOrderParam[](1);\n\n        settleOrderParams[0] = OrderGatewayV2.SettleOrderParam({\n            signedOrder: takerSignOrder,\n            fillAmount: 1 ether,\n            maker: address(maker),\n            makerData: \"\"\n        });\n\n        vm.startPrank(relay);\n        _expectEmitOrderFilled(takerSignOrder.order, 1 ether, 100 ether, address(maker));\n        orderGatewayV2.settleOrder(settleOrderParams);\n\n        uint256 filledAmount = orderGatewayV2.getOrderFilledAmount(takerSignOrder.order.owner, takerSignOrder.order.id);\n        assertEq(filledAmount, 1 ether);\n        assertEq(vault.getFund(address(orderGatewayV2)), defaultRelayFee);\n        _assertEq(\n            _getPosition(marketId, takerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: -1 ether, openNotional: 100 ether, unsettledPnl: 0 })\n        );\n    }\n\n    // T3xM1 (maker can be partial filled)\n    function test_SettleOrderFokReduceOnlyWhenMakerIsOpenPositionOrder() public {\n        // taker long 1 eth first, then close later\n        _openPositionOnTestMaker(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            1 ether,\n            1 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"takerOpenPosition\"\n        );\n\n        OrderGatewayV2.SignedOrder memory takerSignOrder = _createSignOrder(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            -1 ether,\n            100 ether,\n            0,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.ReduceOnly,\n            \"takerSignOrder\"\n        );\n\n        OrderGatewayV2.SignedOrder memory makerSignOrder = _createSignOrder(\n            makerOrderOwner,\n            makerOrderOwnerPk,\n            1.4 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.PartialFill,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"makerSignOrder\"\n        );\n\n        OrderGatewayV2.SettleOrderParam[] memory settleOrderParams = new OrderGatewayV2.SettleOrderParam[](1);\n\n        settleOrderParams[0] = OrderGatewayV2.SettleOrderParam({\n            signedOrder: takerSignOrder,\n            fillAmount: 1 ether,\n            maker: makerOrderOwner,\n            makerData: abi.encode(makerSignOrder)\n        });\n\n        vm.prank(relay);\n        _expectEmitOrderFilled(makerSignOrder.order, 1 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        _expectEmitOrderFilled(takerSignOrder.order, 1 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        orderGatewayV2.settleOrder(settleOrderParams);\n\n        // check taker\n        uint256 takerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            takerSignOrder.order.owner,\n            takerSignOrder.order.id\n        );\n        assertEq(takerFilledAmount, 1 ether);\n        _assertEq(\n            _getPosition(marketId, takerOrderOwner),\n            PositionProfile({ margin: 0 ether, positionSize: 0 ether, openNotional: 0 ether, unsettledPnl: 0 }) // use maker price to settle\n        );\n        assertEq(vault.getFund(address(takerOrderOwner)), defaultMarginXCD * 2);\n\n        // check maker\n        uint256 makerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            makerSignOrder.order.owner,\n            makerSignOrder.order.id\n        );\n        assertEq(makerFilledAmount, 1 ether);\n        _assertEq(\n            _getPosition(marketId, makerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: 1 ether, openNotional: -100 ether, unsettledPnl: 0 })\n        );\n        assertEq(vault.getFund(address(makerOrderOwner)), defaultMarginXCD + defaultRelayFee);\n\n        assertEq(vault.getFund(address(orderGatewayV2)), defaultRelayFee * 3);\n    }\n\n    // (taker and maker can be partial filled)\n    function test_SettleOrderPartialFillReduceOnlyWhenMakerIsOpenPositionOrder() public {\n        // taker long 1 eth first, then close later\n        _openPositionOnTestMaker(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            1 ether,\n            1 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"takerOpenPosition\"\n        );\n\n        OrderGatewayV2.SignedOrder memory takerSignOrder = _createSignOrder(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            -1 ether,\n            100 ether,\n            0,\n            OrderGatewayV2.TradeType.PartialFill,\n            OrderGatewayV2.ActionType.ReduceOnly,\n            \"takerSignOrder\"\n        );\n\n        OrderGatewayV2.SignedOrder memory makerSignOrder = _createSignOrder(\n            makerOrderOwner,\n            makerOrderOwnerPk,\n            1.4 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.PartialFill,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"makerSignOrder\"\n        );\n\n        OrderGatewayV2.SettleOrderParam[] memory settleOrderParams = new OrderGatewayV2.SettleOrderParam[](1);\n\n        settleOrderParams[0] = OrderGatewayV2.SettleOrderParam({\n            signedOrder: takerSignOrder,\n            fillAmount: 0.4 ether,\n            maker: makerOrderOwner,\n            makerData: abi.encode(makerSignOrder)\n        });\n\n        vm.prank(relay);\n        _expectEmitOrderFilled(makerSignOrder.order, 0.4 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        _expectEmitOrderFilled(takerSignOrder.order, 0.4 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        orderGatewayV2.settleOrder(settleOrderParams);\n\n        // check taker\n        uint256 takerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            takerSignOrder.order.owner,\n            takerSignOrder.order.id\n        );\n        assertEq(takerFilledAmount, 0.4 ether);\n        _assertEq(\n            _getPosition(marketId, takerOrderOwner),\n            PositionProfile({ margin: 60 ether, positionSize: 0.6 ether, openNotional: -60 ether, unsettledPnl: 0 }) // use maker price to settle\n        );\n        assertEq(vault.getFund(address(takerOrderOwner)), defaultMarginXCD + 40e6);\n\n        // check maker\n        uint256 makerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            makerSignOrder.order.owner,\n            makerSignOrder.order.id\n        );\n        assertEq(makerFilledAmount, 0.4 ether);\n        _assertEq(\n            _getPosition(marketId, makerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: 0.4 ether, openNotional: -40 ether, unsettledPnl: 0 })\n        );\n        assertEq(vault.getFund(address(makerOrderOwner)), defaultMarginXCD + defaultRelayFee);\n\n        assertEq(vault.getFund(address(orderGatewayV2)), defaultRelayFee * 3);\n    }\n\n    // T3xM2\n    function test_SettleOrderFokReduceOnlyWhenMakerIsFokOpenPositionOrder() public {\n        // taker long 1 eth first, then close later\n        _openPositionOnTestMaker(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            1 ether,\n            1 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"takerOpenPosition\"\n        );\n\n        OrderGatewayV2.SignedOrder memory takerSignOrder = _createSignOrder(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            -1 ether,\n            100 ether,\n            0,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.ReduceOnly,\n            \"takerSignOrder\"\n        );\n\n        OrderGatewayV2.SignedOrder memory makerSignOrder = _createSignOrder(\n            makerOrderOwner,\n            makerOrderOwnerPk,\n            1 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"makerSignOrder\"\n        );\n\n        OrderGatewayV2.SettleOrderParam[] memory settleOrderParams = new OrderGatewayV2.SettleOrderParam[](1);\n\n        settleOrderParams[0] = OrderGatewayV2.SettleOrderParam({\n            signedOrder: takerSignOrder,\n            fillAmount: 1 ether,\n            maker: makerOrderOwner,\n            makerData: abi.encode(makerSignOrder)\n        });\n\n        vm.prank(relay);\n        _expectEmitOrderFilled(makerSignOrder.order, 1 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        _expectEmitOrderFilled(takerSignOrder.order, 1 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        orderGatewayV2.settleOrder(settleOrderParams);\n\n        // check taker\n        uint256 takerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            takerSignOrder.order.owner,\n            takerSignOrder.order.id\n        );\n        assertEq(takerFilledAmount, 1 ether);\n        _assertEq(\n            _getPosition(marketId, takerOrderOwner),\n            PositionProfile({ margin: 0 ether, positionSize: 0 ether, openNotional: 0 ether, unsettledPnl: 0 }) // use maker price to settle\n        );\n        assertEq(vault.getFund(address(takerOrderOwner)), defaultMarginXCD * 2);\n\n        // check maker\n        uint256 makerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            makerSignOrder.order.owner,\n            makerSignOrder.order.id\n        );\n        assertEq(makerFilledAmount, 1 ether);\n        _assertEq(\n            _getPosition(marketId, makerOrderOwner),\n            PositionProfile({ margin: 100 ether, positionSize: 1 ether, openNotional: -100 ether, unsettledPnl: 0 })\n        );\n        assertEq(vault.getFund(address(makerOrderOwner)), defaultMarginXCD + defaultRelayFee);\n\n        assertEq(vault.getFund(address(orderGatewayV2)), defaultRelayFee * 3);\n    }\n\n    // T3xM3\n    function test_SettleOrderFokReduceOnlyWhenMakerIsFokReduceOnlyOrder() public {\n        // taker long 1 eth first, then close later\n        _openPositionOnTestMaker(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            1 ether,\n            1 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"takerOpenPosition\"\n        );\n\n        // maker short 1 eth first, then close later\n        _openPositionOnTestMaker(\n            makerOrderOwner,\n            makerOrderOwnerPk,\n            -1 ether,\n            1 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,\n            \"makerOpenPosition\"\n        );\n\n        OrderGatewayV2.SignedOrder memory takerSignOrder = _createSignOrder(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            -1 ether,\n            100 ether,\n            0,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.ReduceOnly,\n            \"takerSignOrder\"\n        );\n\n        OrderGatewayV2.SignedOrder memory makerSignOrder = _createSignOrder(\n            makerOrderOwner,\n            makerOrderOwnerPk,\n            1 ether,\n            100 ether,\n            0,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.ReduceOnly,\n            \"makerSignOrder\"\n        );\n\n        OrderGatewayV2.SettleOrderParam[] memory settleOrderParams = new OrderGatewayV2.SettleOrderParam[](1);\n\n        settleOrderParams[0] = OrderGatewayV2.SettleOrderParam({\n            signedOrder: takerSignOrder,\n            fillAmount: 1 ether,\n            maker: makerOrderOwner,\n            makerData: abi.encode(makerSignOrder)\n        });\n\n        vm.prank(relay);\n        _expectEmitOrderFilled(makerSignOrder.order, 1 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        _expectEmitOrderFilled(takerSignOrder.order, 1 ether, makerSignOrder.order.price, makerSignOrder.order.owner);\n        orderGatewayV2.settleOrder(settleOrderParams);\n\n        // check taker\n        uint256 takerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            takerSignOrder.order.owner,\n            takerSignOrder.order.id\n        );\n        assertEq(takerFilledAmount, 1 ether);\n        _assertEq(\n            _getPosition(marketId, takerOrderOwner),\n            PositionProfile({ margin: 0 ether, positionSize: 0 ether, openNotional: 0 ether, unsettledPnl: 0 })\n        );\n        assertEq(vault.getFund(address(takerOrderOwner)), defaultMarginXCD * 2);\n\n        // check maker\n        uint256 makerFilledAmount = orderGatewayV2.getOrderFilledAmount(\n            makerSignOrder.order.owner,\n            makerSignOrder.order.id\n        );\n        assertEq(makerFilledAmount, 1 ether);\n        _assertEq(\n            _getPosition(marketId, makerOrderOwner),\n            PositionProfile({ margin: 0 ether, positionSize: 0 ether, openNotional: 0 ether, unsettledPnl: 0 })\n        );\n        assertEq(vault.getFund(address(makerOrderOwner)), defaultMarginXCD * 2);\n\n        assertEq(vault.getFund(address(orderGatewayV2)), defaultRelayFee * 4);\n    }\n\n    // T3xM4\n    function test_SettleOrderFokReduceOnlyWhenMakerIsTestMaker() public {\n        // taker long 1 eth first, then close later\n        _openPositionOnTestMaker(\n            takerOrderOwner,\n            takerOrderOwnerPk,\n            1 ether,\n            1 ether,\n            100 ether,\n            defaultMarginXCD,\n            OrderGatewayV2.TradeType.FoK,\n            OrderGatewayV2.ActionType.OpenPosition,"
    }
  ]
}