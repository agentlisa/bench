{
  "Title": "[M-12] Rewards for initial period can be lost in all of the synthetix derivative contracts",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/stakerewardV2pool.sol#L132-L150> <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L227-L240> <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/EUSDMiningIncentives.sol#L226-L242>\n\n### Impact\n\nRewards in the synthetix derivative contracts (`EUSDMinningIncentives.sol`, `ProtocolRewardsPool.sol` and `stakerRewardsV2Pool.sol`) are initiated when the owner calls the `notifyRewardAmount`. This function calculates the reward rate per second and also records the start of the reward period. This has an edge case where rewards are not counted for the initial period of time until there is at least one participant.\n\n### Proof of Concept\n\nLook at the code for `stakerrewardV2Pool.sol` (other files have somewhat similar logic too), derived from the synthetix:\n\n```solidity\n    function notifyRewardAmount(uint256 _amount) external onlyOwner updateReward(address(0)) {\n        if (block.timestamp >= finishAt) {\n            rewardRatio = _amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;\n            rewardRatio = (_amount + remainingRewards) / duration;\n        }\n\n        require(rewardRatio > 0, \"reward ratio = 0\");\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n        emit NotifyRewardChanged(_amount, block.timestamp);\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}\n```\n\nThe intention here, is to calculate how many tokens should be rewarded by unit of time (second) and record the span of time for the reward cycle. However, this has an edge case where rewards are not counted for the initial period of time until there is at least one participant (in this case, a holder of `BathTokens`). During this initial period of time, the reward rate will still apply but as there isn't any participant, then no one will be able to claim these rewards and these rewards will be lost and stuck in the system.\n\nThis is a known vulnerability that has been covered before. The following reports can be used as a reference for the described issue:\n- [0xMacro Blog - Synthetix Vulnerability](https://0xmacro.com/blog/synthetix-staking-rewards-issue-inefficient-reward-distribution/)\n- [Same vulnerability in y2k report](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/93)\n\nAs described by the 0xmacro blogpost, this can play out as the following:\n\nLet's consider that you have a `StakingRewards` contract with a reward duration of one month seconds (2592000):\n\nBlock N Timestamp = X\n\nYou call `notifyRewardAmount()` with a reward of one month seconds (2592000) only. The intention is for a period of a month, 1 reward token per second should be distributed to stakers.\n\n- State :\n\n    - `rewardRate` = 1\n    - `periodFinish` = X + **2592000**\n\nBlock M Timestamp = X + Y\n\nY time has passed and the first staker stakes some amount:\n\n1. `stake()`\n2. `updateReward`<br>`rewardPerTokenStored` = 0<br>`lastUpdateTime` = X + Y\n\nHence, for this staker, the clock has started from X+Y, and they will accumulate rewards from this point.\n\nPlease note, that the `periodFinish` is X + `rewardsDuration`, not X + Y + `rewardsDuration`. Therefore, the contract will only distribute rewards until X + `rewardsDuration`, losing  Y &ast; `rewardRate` => Y &ast; 1  inside of the contract, as `rewardRate` = 1 (if we consider the above example).\n\nNow, if we consider delay (Y) to be 30 minutes, then:\n\nOnly 2590200 (2592000-1800) tokens will be distributed and these 1800 tokens will remain unused in the contract until the next cycle of `notifyRewardAmount()`.\n\n### Tools Used\n\nManual Review\n\n### Recommended Mitigation Steps\n\nA possible solution to the issue would be to set the start and end time for the current reward cycle when the first participant joins the reward program (i.e. when the total supply is greater than zero) instead of starting the process in the `notifyRewardAmount`.\n\n**[0xean (judge) decreased severity to Medium](https://github.com/code-423n4/2023-06-lybra-findings/issues/484#issuecomment-1650715347)**\n\n**[LybraFinance confirmed](https://github.com/code-423n4/2023-06-lybra-findings/issues/484#issuecomment-1653181697)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/miner/stakerewardV2pool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract StakingRewardsV2 is Ownable {\n    // Immutable variables for staking and rewards tokens\n    IERC20 public immutable stakingToken;\n    IesLBR public immutable rewardsToken;\n    IesLBRBoost public esLBRBoost;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n\n    // Total staked\n    uint256 public totalSupply;\n    // User address => staked amount\n    mapping(address => uint256) public balanceOf;\n\n    ///events\n    event StakeToken(address indexed user, uint256 amount, uint256 time);\n    event WithdrawToken(address indexed user, uint256 amount, uint256 time);\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    constructor(address _stakingToken, address _rewardToken, address _boost) {\n        stakingToken = IERC20(_stakingToken);\n        rewardsToken = IesLBR(_rewardToken);\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    // Update user's claimable reward data and record the timestamp.\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    // Returns the last time the reward was applicable\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    // Calculates and returns the reward per token\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalSupply;\n    }\n\n    // Allows users to stake a specified amount of tokens\n    function stake(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        bool success = stakingToken.transferFrom(msg.sender, address(this), _amount);\n        require(success, \"TF\");\n        balanceOf[msg.sender] += _amount;\n        totalSupply += _amount;\n        emit StakeToken(msg.sender, _amount, block.timestamp);\n    }\n\n    // Allows users to withdraw a specified amount of staked tokens\n    function withdraw(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        balanceOf[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        stakingToken.transfer(msg.sender, _amount);\n        emit WithdrawToken(msg.sender, _amount, block.timestamp);\n    }\n\n    function getBoost(address _account) public view returns (uint256) {\n        return 100 * 1e18 + esLBRBoost.getUserBoost(_account, userUpdatedAt[_account], finishAt);\n    }\n\n    // Calculates and returns the earned rewards for a user\n    function earned(address _account) public view returns (uint256) {\n        return ((balanceOf[_account] * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n    }\n\n    // Allows users to claim their earned rewards\n    function getReward() external updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.mint(msg.sender, reward);\n            emit ClaimReward(msg.sender, reward, block.timestamp);\n        }\n    }\n\n    // Allows the owner to set the rewards duration\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    // Allows the owner to set the boost contract address\n    function setBoost(address _boost) external onlyOwner {\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    // Allows the owner to set the mining rewards.\n    function notifyRewardAmount(uint256 _amount) external onlyOwner updateReward(address(0)) {\n        if (block.timestamp >= finishAt) {\n            rewardRatio = _amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;\n            rewardRatio = (_amount + remainingRewards) / duration;\n        }\n\n        require(rewardRatio > 0, \"reward ratio = 0\");\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n        emit NotifyRewardChanged(_amount, block.timestamp);\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}"
    }
  ]
}