{
  "Title": "[M-26] `**Harvest()**` may not be executed when changing a **Vault** adapter",
  "Content": "\n<https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L594-L613>\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L162>\n\n### Impact\n\nChanging the adapter (that uses a strategy) of an already credited vault can result in a loss of user funds.\n\n### Proof of Concept\n\n**Scenario:**\n\n*   A **Vault** owner wants to change the underlying `**Adapter**`\n*   Owner calls the `**proposeAdapter()**` and then `**changeAdapter()**` that will call the `**redeem()**` adapter function :\n    *   <https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L193-L235>\n*   Here the goal is to empty the **Strategy** and **Adapter** underlying contracts of the  **Vault** to make a safe adapter change.\n\nIssue scenario **1** : the `**harvest()**` function is in cooldown.\n\nIssue scenario **2** : the `**harvest()**` function revert.\n\nIn both cases, the `**harvest()**` function will not execute. The adapter will change without harvesting from the **Strategy** causing the loss of unclaimed rewards.\n\n### Recommended Mitigation Steps\n\nChange the `harvest()` function from :\n\n```js\nfunction harvest() public takeFees {\n    if (\n        address(strategy) != address(0) &&\n        ((lastHarvest + harvestCooldown) < block.timestamp)\n    ) {\n        // solhint-disable\n        address(strategy).delegatecall(\n            abi.encodeWithSignature(\"harvest()\")\n        );\n    }\n\n    emit Harvested();\n}\n```\n\nto :\n\n```js\nfunction harvest() public takeFees {\n    if (\n        address(strategy) == address(0) ||\n        ((lastHarvest + harvestCooldown) > block.timestamp)\n    ) {\n        revert();  // Fixing the \"Issue senario 1\"\n    }\n\n    (bool success, ) = address(strategy).delegatecall(\n        abi.encodeWithSignature(\"harvest()\")\n    );\n\n    if (!success) revert(); // Fixing the \"Issue senario 2\"\n\n    emit Harvested();\n}\n```\n\n**[RedVeil (Popcorn) confirmed, but disagreed with severity](https://github.com/code-423n4/2023-01-popcorn-findings/issues/284)** \n\n**[LSDan (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-popcorn-findings/issues/284)** \n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-popcorn",
  "Code": [
    {
      "filename": "src/vault/Vault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport {SafeERC20Upgradeable as SafeERC20} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {IERC4626, IERC20} from \"../interfaces/vault/IERC4626.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {VaultFees} from \"../interfaces/vault/IVault.sol\";\nimport {MathUpgradeable as Math} from \"openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {OwnedUpgradeable} from \"../utils/OwnedUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/**\n * @title   Vault\n * @author  RedVeil\n * @notice  See the following for the full EIP-4626 specification https://eips.ethereum.org/EIPS/eip-4626.\n *\n * A simple ERC4626-Implementation of a Vault.\n * The vault delegates any actual protocol interaction to an adapter.\n * It allows for multiple type of fees which are taken by issuing new vault shares.\n * Adapter and fees can be changed by the owner after a ragequit time.\n */\ncontract Vault is\n    ERC20Upgradeable,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    OwnedUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    uint256 constant SECONDS_PER_YEAR = 365.25 days;\n\n    IERC20 public asset;\n    uint8 internal _decimals;\n\n    bytes32 public contractName;\n\n    event VaultInitialized(bytes32 contractName, address indexed asset);\n\n    error InvalidAsset();\n    error InvalidAdapter();\n\n    /**\n     * @notice Initialize a new Vault.\n     * @param asset_ Underlying Asset which users will deposit.\n     * @param adapter_ Adapter which will be used to interact with the wrapped protocol.\n     * @param fees_ Desired fees in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n     * @param feeRecipient_ Recipient of all vault fees. (Must not be zero address)\n     * @param owner Owner of the contract. Controls management functions.\n     * @dev This function is called by the factory contract when deploying a new vault.\n     * @dev Usually the adapter should already be pre configured. Otherwise a new one can only be added after a ragequit time.\n     */\n    function initialize(\n        IERC20 asset_,\n        IERC4626 adapter_,\n        VaultFees calldata fees_,\n        address feeRecipient_,\n        address owner\n    ) external initializer {\n        __ERC20_init(\n            string.concat(\n                \"Popcorn \",\n                IERC20Metadata(address(asset_)).name(),\n                \" Vault\"\n            ),\n            string.concat(\"pop-\", IERC20Metadata(address(asset_)).symbol())\n        );\n        __Owned_init(owner);\n\n        if (address(asset_) == address(0)) revert InvalidAsset();\n        if (address(asset_) != adapter_.asset()) revert InvalidAdapter();\n\n        asset = asset_;\n        adapter = adapter_;\n\n        asset.approve(address(adapter_), type(uint256).max);\n\n        _decimals = IERC20Metadata(address(asset_)).decimals();\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n\n        feesUpdatedAt = block.timestamp;\n        fees = fees_;\n\n        if (feeRecipient_ == address(0)) revert InvalidFeeRecipient();\n        feeRecipient = feeRecipient_;\n\n        contractName = keccak256(\n            abi.encodePacked(\"Popcorn\", name(), block.timestamp, \"Vault\")\n        );\n\n        emit VaultInitialized(contractName, address(asset));\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    error InvalidReceiver();\n\n    function deposit(uint256 assets) public returns (uint256) {\n        return deposit(assets, msg.sender);\n    }\n\n    /**\n     * @notice Deposit exactly `assets` amount of tokens, issuing vault shares to `receiver`.\n     * @param assets Quantity of tokens to deposit.\n     * @param receiver Receiver of issued vault shares.\n     * @return shares Quantity of vault shares issued to `receiver`.\n     */\n    function deposit(uint256 assets, address receiver)\n        public\n        nonReentrant\n        whenNotPaused\n        syncFeeCheckpoint\n        returns (uint256 shares)\n    {\n        if (receiver == address(0)) revert InvalidReceiver();\n\n        uint256 feeShares = convertToShares(\n            assets.mulDiv(uint256(fees.deposit), 1e18, Math.Rounding.Down)\n        );\n\n        shares = convertToShares(assets) - feeShares;\n\n        if (feeShares > 0) _mint(feeRecipient, feeShares);\n\n        _mint(receiver, shares);\n\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        adapter.deposit(assets, address(this));\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function mint(uint256 shares) external returns (uint256) {\n        return mint(shares, msg.sender);\n    }\n\n    /**\n     * @notice Mint exactly `shares` vault shares to `receiver`, taking the necessary amount of `asset` from the caller.\n     * @param shares Quantity of shares to mint.\n     * @param receiver Receiver of issued vault shares.\n     * @return assets Quantity of assets deposited by caller.\n     */\n    function mint(uint256 shares, address receiver)\n        public\n        nonReentrant\n        whenNotPaused\n        syncFeeCheckpoint\n        returns (uint256 assets)\n    {\n        if (receiver == address(0)) revert InvalidReceiver();\n\n        uint256 depositFee = uint256(fees.deposit);\n\n        uint256 feeShares = shares.mulDiv(\n            depositFee,\n            1e18 - depositFee,\n            Math.Rounding.Down\n        );\n\n        assets = convertToAssets(shares + feeShares);\n\n        if (feeShares > 0) _mint(feeRecipient, feeShares);\n\n        _mint(receiver, shares);\n\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        adapter.deposit(assets, address(this));\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function withdraw(uint256 assets) public returns (uint256) {\n        return withdraw(assets, msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice Burn shares from `owner` in exchange for `assets` amount of underlying token.\n     * @param assets Quantity of underlying `asset` token to withdraw.\n     * @param receiver Receiver of underlying token.\n     * @param owner Owner of burned vault shares.\n     * @return shares Quantity of vault shares burned in exchange for `assets`.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public nonReentrant syncFeeCheckpoint returns (uint256 shares) {\n        if (receiver == address(0)) revert InvalidReceiver();\n\n        shares = convertToShares(assets);\n\n        uint256 withdrawalFee = uint256(fees.withdrawal);\n\n        uint256 feeShares = shares.mulDiv(\n            withdrawalFee,\n            1e18 - withdrawalFee,\n            Math.Rounding.Down\n        );\n\n        shares += feeShares;\n\n        if (msg.sender != owner)\n            _approve(owner, msg.sender, allowance(owner, msg.sender) - shares);\n\n        _burn(owner, shares);\n\n        if (feeShares > 0) _mint(feeRecipient, feeShares);\n\n        adapter.withdraw(assets, receiver, address(this));\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n    }\n\n    function redeem(uint256 shares) external returns (uint256) {\n        return redeem(shares, msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice Burn exactly `shares` vault shares from `owner` and send underlying `asset` tokens to `receiver`.\n     * @param shares Quantity of vault shares to exchange for underlying tokens.\n     * @param receiver Receiver of underlying tokens.\n     * @param owner Owner of burned vault shares.\n     * @return assets Quantity of `asset` sent to `receiver`.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public nonReentrant returns (uint256 assets) {\n        if (receiver == address(0)) revert InvalidReceiver();\n\n        if (msg.sender != owner)\n            _approve(owner, msg.sender, allowance(owner, msg.sender) - shares);\n\n        uint256 feeShares = shares.mulDiv(\n            uint256(fees.withdrawal),\n            1e18,\n            Math.Rounding.Down\n        );\n\n        assets = convertToAssets(shares - feeShares);\n\n        _burn(owner, shares);\n\n        if (feeShares > 0) _mint(feeRecipient, feeShares);\n\n        adapter.withdraw(assets, receiver, address(this));\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @return Total amount of underlying `asset` token managed by vault. Delegates to adapter.\n    function totalAssets() public view returns (uint256) {\n        return adapter.convertToAssets(adapter.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Amount of shares the vault would exchange for given amount of assets, in an ideal scenario.\n     * @param assets Exact amount of assets\n     * @return Exact amount of shares\n     */\n    function convertToShares(uint256 assets) public view returns (uint256) {\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return\n            supply == 0\n                ? assets\n                : assets.mulDiv(supply, totalAssets(), Math.Rounding.Down);\n    }\n\n    /**\n     * @notice Amount of assets the vault would exchange for given amount of shares, in an ideal scenario.\n     * @param shares Exact amount of shares\n     * @return Exact amount of assets\n     */\n    function convertToAssets(uint256 shares) public view returns (uint256) {\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return\n            supply == 0\n                ? shares\n                : shares.mulDiv(totalAssets(), supply, Math.Rounding.Down);\n    }\n\n    /**\n     * @notice Simulate the effects of a deposit at the current block, given current on-chain conditions.\n     * @param assets Exact amount of underlying `asset` token to deposit\n     * @return shares of the vault issued in exchange to the user for `assets`\n     * @dev This method accounts for issuance of accrued fee shares.\n     */\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        shares = adapter.previewDeposit(\n            assets -\n                assets.mulDiv(uint256(fees.deposit), 1e18, Math.Rounding.Down)\n        );\n    }\n\n    /**\n     * @notice Simulate the effects of a mint at the current block, given current on-chain conditions.\n     * @param shares Exact amount of vault shares to mint.\n     * @return assets quantity of underlying needed in exchange to mint `shares`.\n     * @dev This method accounts for issuance of accrued fee shares.\n     */\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        uint256 depositFee = uint256(fees.deposit);\n\n        shares += shares.mulDiv(\n            depositFee,\n            1e18 - depositFee,\n            Math.Rounding.Up\n        );\n\n        assets = adapter.previewMint(shares);\n    }\n\n    /**\n     * @notice Simulate the effects of a withdrawal at the current block, given current on-chain conditions.\n     * @param assets Exact amount of `assets` to withdraw\n     * @return shares to be burned in exchange for `assets`\n     * @dev This method accounts for both issuance of fee shares and withdrawal fee.\n     */\n    function previewWithdraw(uint256 assets)\n        external\n        view\n        returns (uint256 shares)\n    {\n        uint256 withdrawalFee = uint256(fees.withdrawal);\n\n        assets += assets.mulDiv(\n            withdrawalFee,\n            1e18 - withdrawalFee,\n            Math.Rounding.Up\n        );\n\n        shares = adapter.previewWithdraw(assets);\n    }\n\n    /**\n     * @notice Simulate the effects of a redemption at the current block, given current on-chain conditions.\n     * @param shares Exact amount of `shares` to redeem\n     * @return assets quantity of underlying returned in exchange for `shares`.\n     * @dev This method accounts for both issuance of fee shares and withdrawal fee.\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = adapter.previewRedeem(shares);\n\n        assets -= assets.mulDiv(\n            uint256(fees.withdrawal),\n            1e18,\n            Math.Rounding.Down\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @return Maximum amount of underlying `asset` token that may be deposited for a given address. Delegates to adapter.\n    function maxDeposit(address caller) public view returns (uint256) {\n        return adapter.maxDeposit(caller);\n    }\n\n    /// @return Maximum amount of vault shares that may be minted to given address. Delegates to adapter.\n    function maxMint(address caller) external view returns (uint256) {\n        return adapter.maxMint(caller);\n    }\n\n    /// @return Maximum amount of underlying `asset` token that can be withdrawn by `caller` address. Delegates to adapter.\n    function maxWithdraw(address caller) external view returns (uint256) {\n        return adapter.maxWithdraw(caller);\n    }\n\n    /// @return Maximum amount of shares that may be redeemed by `caller` address. Delegates to adapter.\n    function maxRedeem(address caller) external view returns (uint256) {\n        return adapter.maxRedeem(caller);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        FEE ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Management fee that has accrued since last fee harvest.\n     * @return Accrued management fee in underlying `asset` token.\n     * @dev Management fee is annualized per minute, based on 525,600 minutes per year. Total assets are calculated using\n     *  the average of their current value and the value at the previous fee harvest checkpoint. This method is similar to\n     *  calculating a definite integral using the trapezoid rule.\n     */\n    function accruedManagementFee() public view returns (uint256) {\n        uint256 managementFee = fees.management;\n        return\n            managementFee > 0\n                ? managementFee.mulDiv(\n                    totalAssets() * (block.timestamp - feesUpdatedAt),\n                    SECONDS_PER_YEAR,\n                    Math.Rounding.Down\n                ) / 1e18\n                : 0;\n    }\n\n    /**\n     * @notice Performance fee that has accrued since last fee harvest.\n     * @return Accrued performance fee in underlying `asset` token.\n     * @dev Performance fee is based on a high water mark value. If vault share value has increased above the\n     *   HWM in a fee period, issue fee shares to the vault equal to the performance fee.\n     */\n    function accruedPerformanceFee() public view returns (uint256) {\n        uint256 highWaterMark_ = highWaterMark;\n        uint256 shareValue = convertToAssets(1e18);\n        uint256 performanceFee = fees.performance;\n\n        return\n            performanceFee > 0 && shareValue > highWaterMark\n                ? performanceFee.mulDiv(\n                    (shareValue - highWaterMark) * totalSupply(),\n                    1e36,\n                    Math.Rounding.Down\n                )\n                : 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            FEE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public highWaterMark = 1e18;\n    uint256 public assetsCheckpoint;\n    uint256 public feesUpdatedAt;\n\n    error InsufficientWithdrawalAmount(uint256 amount);\n\n    /// @notice Minimal function to call `takeFees` modifier.\n    function takeManagementAndPerformanceFees()\n        external\n        nonReentrant\n        takeFees\n    {}\n\n    /// @notice Collect management and performance fees and update vault share high water mark.\n    modifier takeFees() {\n        uint256 managementFee = accruedManagementFee();\n        uint256 totalFee = managementFee + accruedPerformanceFee();\n        uint256 currentAssets = totalAssets();\n        uint256 shareValue = convertToAssets(1e18);\n\n        if (shareValue > highWaterMark) highWaterMark = shareValue;\n\n        if (managementFee > 0) feesUpdatedAt = block.timestamp;\n\n        if (totalFee > 0 && currentAssets > 0)\n            _mint(feeRecipient, convertToShares(totalFee));\n\n        _;\n    }\n\n    modifier syncFeeCheckpoint() {\n        _;\n        highWaterMark = convertToAssets(1e18);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            FEE MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    VaultFees public fees;\n\n    VaultFees public proposedFees;\n    uint256 public proposedFeeTime;\n\n    address public feeRecipient;\n\n    event NewFeesProposed(VaultFees newFees, uint256 timestamp);\n    event ChangedFees(VaultFees oldFees, VaultFees newFees);\n    event FeeRecipientUpdated(address oldFeeRecipient, address newFeeRecipient);\n\n    error InvalidVaultFees();\n    error InvalidFeeRecipient();\n    error NotPassedQuitPeriod(uint256 quitPeriod);\n\n    /**\n     * @notice Propose new fees for this vault. Caller must be owner.\n     * @param newFees Fees for depositing, withdrawal, management and performance in 1e18.\n     * @dev Fees can be 0 but never 1e18 (1e18 = 100%, 1e14 = 1 BPS)\n     */\n    function proposeFees(VaultFees calldata newFees) external onlyOwner {\n        if (\n            newFees.deposit >= 1e18 ||\n            newFees.withdrawal >= 1e18 ||\n            newFees.management >= 1e18 ||\n            newFees.performance >= 1e18\n        ) revert InvalidVaultFees();\n\n        proposedFees = newFees;\n        proposedFeeTime = block.timestamp;\n\n        emit NewFeesProposed(newFees, block.timestamp);\n    }\n\n    /// @notice Change fees to the previously proposed fees after the quit period has passed.\n    function changeFees() external {\n        if (block.timestamp < proposedFeeTime + quitPeriod)\n            revert NotPassedQuitPeriod(quitPeriod);\n\n        emit ChangedFees(fees, proposedFees);\n        fees = proposedFees;\n    }\n\n    /**\n     * @notice Change `feeRecipient`. Caller must be Owner.\n     * @param _feeRecipient The new fee recipient.\n     * @dev Accrued fees wont be transferred to the new feeRecipient.\n     */\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        if (_feeRecipient == address(0)) revert InvalidFeeRecipient();\n\n        emit FeeRecipientUpdated(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          ADAPTER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    IERC4626 public adapter;\n    IERC4626 public proposedAdapter;\n    uint256 public proposedAdapterTime;\n\n    event NewAdapterProposed(IERC4626 newAdapter, uint256 timestamp);\n    event ChangedAdapter(IERC4626 oldAdapter, IERC4626 newAdapter);\n\n    error VaultAssetMismatchNewAdapterAsset();\n\n    /**\n     * @notice Propose a new adapter for this vault. Caller must be Owner.\n     * @param newAdapter A new ERC4626 that should be used as a yield adapter for this asset.\n     */\n    function proposeAdapter(IERC4626 newAdapter) external onlyOwner {\n        if (newAdapter.asset() != address(asset))\n            revert VaultAssetMismatchNewAdapterAsset();\n\n        proposedAdapter = newAdapter;\n        proposedAdapterTime = block.timestamp;\n\n        emit NewAdapterProposed(newAdapter, block.timestamp);\n    }\n\n    /**\n     * @notice Set a new Adapter for this Vault after the quit period has passed.\n     * @dev This migration function will remove all assets from the old Vault and move them into the new vault\n     * @dev Additionally it will zero old allowances and set new ones\n     * @dev Last we update HWM and assetsCheckpoint for fees to make sure they adjust to the new adapter\n     */\n    function changeAdapter() external takeFees {\n        if (block.timestamp < proposedAdapterTime + quitPeriod)\n            revert NotPassedQuitPeriod(quitPeriod);\n\n        adapter.redeem(\n            adapter.balanceOf(address(this)),\n            address(this),\n            address(this)\n        );\n\n        asset.approve(address(adapter), 0);\n\n        emit ChangedAdapter(adapter, proposedAdapter);\n\n        adapter = proposedAdapter;\n\n        asset.approve(address(adapter), type(uint256).max);\n\n        adapter.deposit(asset.balanceOf(address(this)), address(this));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          RAGE QUIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public quitPeriod = 3 days;\n\n    event QuitPeriodSet(uint256 quitPeriod);\n\n    error InvalidQuitPeriod();\n\n    /**\n     * @notice Set a quitPeriod for rage quitting after new adapter or fees are proposed. Caller must be Owner.\n     * @param _quitPeriod Time to rage quit after proposal.\n     */\n    function setQuitPeriod(uint256 _quitPeriod) external onlyOwner {\n        if (_quitPeriod < 1 days || _quitPeriod > 7 days)\n            revert InvalidQuitPeriod();\n\n        quitPeriod = _quitPeriod;\n\n        emit QuitPeriodSet(quitPeriod);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          PAUSING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Pause deposits. Caller must be Owner.\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Unpause deposits. Caller must be Owner.\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      EIP-2612 LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    //  EIP-2612 STORAGE\n    uint256 internal INITIAL_CHAIN_ID;\n    bytes32 internal INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n\n    error PermitDeadlineExpired(uint256 deadline);\n    error InvalidSigner(address signer);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (deadline < block.timestamp) revert PermitDeadlineExpired(deadline);\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            if (recoveredAddress == address(0) || recoveredAddress != owner)\n                revert InvalidSigner(recoveredAddress);\n\n            _approve(recoveredAddress, spender, value);\n        }\n    }\n\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        return\n            block.chainid == INITIAL_CHAIN_ID\n                ? INITIAL_DOMAIN_SEPARATOR\n                : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(name())),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n}"
    },
    {
      "filename": "src/vault/adapter/abstracts/AdapterBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport {ERC4626Upgradeable, IERC20Upgradeable as IERC20, IERC20MetadataUpgradeable as IERC20Metadata, ERC20Upgradeable as ERC20} from \"openzeppelin-contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {MathUpgradeable as Math} from \"openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {IStrategy} from \"../../../interfaces/vault/IStrategy.sol\";\nimport {IAdapter} from \"../../../interfaces/vault/IAdapter.sol\";\nimport {EIP165} from \"../../../utils/EIP165.sol\";\nimport {OnlyStrategy} from \"./OnlyStrategy.sol\";\nimport {OwnedUpgradeable} from \"../../../utils/OwnedUpgradeable.sol\";\n\n/**\n * @title   AdapterBase\n * @author  RedVeil\n * @notice  See the following for the full EIP-4626 specification https://eips.ethereum.org/EIPS/eip-4626.\n *\n * The ERC4626 compliant base contract for all adapter contracts.\n * It allows interacting with an underlying protocol.\n * All specific interactions for the underlying protocol need to be overriden in the actual implementation.\n * The adapter can be initialized with a strategy that can perform additional operations. (Leverage, Compounding, etc.)\n */\nabstract contract AdapterBase is\n    ERC4626Upgradeable,\n    PausableUpgradeable,\n    OwnedUpgradeable,\n    ReentrancyGuardUpgradeable,\n    EIP165,\n    OnlyStrategy\n{\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    uint8 internal _decimals;\n\n    error StrategySetupFailed();\n\n    /**\n     * @notice Initialize a new Adapter.\n     * @param popERC4626InitData Encoded data for the base adapter initialization.\n     * @dev `asset` - The underlying asset\n     * @dev `_owner` - Owner of the contract. Controls management functions.\n     * @dev `_strategy` - An optional strategy to enrich the adapter with additional functionality.\n     * @dev `_harvestCooldown` - Cooldown period between harvests.\n     * @dev `_requiredSigs` - Function signatures required by the strategy (EIP-165)\n     * @dev `_strategyConfig` - Additional data which can be used by the strategy on `harvest()`\n     * @dev This function is called by the factory contract when deploying a new vault.\n     * @dev Each Adapter implementation should implement checks to make sure that the adapter is wrapping the underlying protocol correctly.\n     * @dev If a strategy is provided, it will be verified to make sure it implements the required functions.\n     */\n    function __AdapterBase_init(bytes memory popERC4626InitData)\n        internal\n        onlyInitializing\n    {\n        (\n            address asset,\n            address _owner,\n            address _strategy,\n            uint256 _harvestCooldown,\n            bytes4[8] memory _requiredSigs,\n            bytes memory _strategyConfig\n        ) = abi.decode(\n                popERC4626InitData,\n                (address, address, address, uint256, bytes4[8], bytes)\n            );\n        __Owned_init(_owner);\n        __Pausable_init();\n        __ERC4626_init(IERC20Metadata(asset));\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n\n        _decimals = IERC20Metadata(asset).decimals();\n\n        strategy = IStrategy(_strategy);\n        strategyConfig = _strategyConfig;\n        harvestCooldown = _harvestCooldown;\n\n        if (_strategy != address(0)) _verifyAndSetupStrategy(_requiredSigs);\n\n        highWaterMark = 1e18;\n        lastHarvest = block.timestamp;\n    }\n\n    function decimals()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (uint8)\n    {\n        return _decimals;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    error MaxError(uint256 amount);\n    error ZeroAmount();\n\n    /**\n     * @notice Deposits assets into the underlying protocol and mints vault shares to `receiver`.\n     * @param assets Amount of assets to deposit.\n     * @param receiver Receiver of the shares.\n     */\n    function deposit(uint256 assets, address receiver)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        if (assets > maxDeposit(receiver)) revert MaxError(assets);\n\n        uint256 shares = _previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /**\n     * @notice Mints vault shares to `receiver` and deposits assets into the underlying protocol.\n     * @param shares Amount of shares to mint.\n     * @param receiver Receiver of the shares.\n     */\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        if (shares > maxMint(receiver)) revert MaxError(shares);\n\n        uint256 assets = _previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @notice Deposit `assets` into the underlying protocol and mints vault shares to `receiver`.\n     * @dev Executes harvest if `harvestCooldown` is passed since last invocation.\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal nonReentrant virtual override {\n        IERC20(asset()).safeTransferFrom(caller, address(this), assets);\n        \n        uint256 underlyingBalance_ = _underlyingBalance();\n        _protocolDeposit(assets, shares);\n        // Update the underlying balance to prevent inflation attacks\n        underlyingBalance += _underlyingBalance() - underlyingBalance_;\n\n        _mint(receiver, shares);\n\n        harvest();\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @notice Withdraws `assets` from the underlying protocol and burns vault shares from `owner`.\n     * @param assets Amount of assets to withdraw.\n     * @param receiver Receiver of the assets.\n     * @param owner Owner of the shares.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        if (assets > maxWithdraw(owner)) revert MaxError(assets);\n\n        uint256 shares = _previewWithdraw(assets);\n\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /**\n     * @notice Burns vault shares from `owner` and withdraws `assets` from the underlying protocol.\n     * @param shares Amount of shares to burn.\n     * @param receiver Receiver of the assets.\n     * @param owner Owner of the shares.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        if (shares > maxRedeem(owner)) revert MaxError(shares);\n\n        uint256 assets = _previewRedeem(share"
    }
  ]
}