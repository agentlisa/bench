{
  "Title": "[H-09] `PriceOracle` Does Not Filter Price Feed Outliers",
  "Content": "_Submitted by leastwood_\n\n#### Impact\n\nIf for whatever reason the Chainlink oracle returns a malformed price due to oracle manipulation or a malfunctioned price, the result will be passed onto users, causing unintended consequences as a result.\n\nIn the same time it's possible to construct mitigation mechanics for such cases, so user economics be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/PriceOracle.sol#L149-L161>\n```solidity\nfunction getLatestPrice(address num, address den) external view override returns (uint256, uint256) {\n    uint256 _price;\n    uint256 _decimals;\n    (_price, _decimals) = getChainlinkLatestPrice(num, den);\n    if (_decimals != 0) {\n        return (_price, _decimals);\n    }\n    (_price, _decimals) = getUniswapLatestPrice(num, den);\n    if (_decimals != 0) {\n        return (_price, _decimals);\n    }\n    revert(\"PriceOracle::getLatestPrice - Price Feed doesn't exist\");\n}\n```\nThe above code outlines how prices are utilised regardless of their actual value (assuming it is always a non-zero value).\n\n#### Recommended Mitigation Steps\n\nConsider querying both the Chainlink oracle and Uniswap pool for latest prices, ensuring that these two values are within some upper/lower bounds of each other. It may also be useful to track historic values and ensure that there are no sharp changes in price. However, the first option provides a level of simplicity as UniswapV3's TWAP implementation is incredibly resistant to flash loan attacks. Hence, the main issue to address is a malfunctioning Chainlink oracle.\n\n**[ritik99 (Sublime) disputed](https://github.com/code-423n4/2021-12-sublime-findings/issues/51#issuecomment-1007996594):**\n > The described suggestion is fairly complex - besides the increase in code complexity, we'd also have to decide the bounds within which the Uniswap and Chainlink oracles should report prices that won't be trivial. We've also noted in the [assumptions](https://github.com/code-423n4/2021-12-sublime#assumptions--design-choices) section of our contest repo that oracles are assumed to be accurate\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-12-sublime-findings/issues/51#issuecomment-1018064762):**\n > \" We expect these feeds to be fairly reliable.\" - Based on this quote, I am going to leave this open at the current risk level.  These are valid changes that could significantly reduce the risk of the implementation and unintended liquidations. \n> \n> Fairly reliable != 100% reliable\n> \n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2021-12-sublime-contest",
  "Code": [
    {
      "filename": "contracts/PriceOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.6;\n\nimport '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport './interfaces/IPriceOracle.sol';\n\ncontract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {\n    using SafeMath for uint256;\n\n    uint32 uniswapPriceAveragingPeriod;\n    struct PriceData {\n        address oracle;\n        uint256 decimals;\n    }\n    /**\n     * @notice stores the price oracle and its decimals for chainlink feeds\n     **/\n    mapping(address => PriceData) public chainlinkFeedAddresses;\n    mapping(address => uint256) decimals;\n\n    /**\n     * @notice stores the addresses of price feeds for uniswap token pairs\n     **/\n    mapping(bytes32 => address) public uniswapPools;\n\n    /**\n     * @notice Used to initialize the price oracle contract\n     * @dev can only be invoked once\n     * @param _admin owner of the price oracle\n     **/\n    function initialize(address _admin) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_admin);\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token from chainlink\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {\n        PriceData memory _feedData1 = chainlinkFeedAddresses[num];\n        PriceData memory _feedData2 = chainlinkFeedAddresses[den];\n        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) {\n            return (0, 0);\n        }\n        int256 price1;\n        int256 price2;\n        {\n            uint80 roundID1;\n            uint256 timeStamp1;\n            uint80 answeredInRound1;\n            (\n                roundID1,\n                price1,\n                ,\n                timeStamp1,\n                answeredInRound1\n            ) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();\n            if(timeStamp1 == 0 || answeredInRound1 < roundID1) {\n                return (0, 0);\n            }\n        }\n        {\n            uint80 roundID2;\n            uint256 timeStamp2;\n            uint80 answeredInRound2;\n            (\n                roundID2,\n                price2,\n                ,\n                timeStamp2,\n                answeredInRound2\n            ) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();\n            if(timeStamp2 == 0 || answeredInRound2 < roundID2) {\n                return (0, 0);\n            }\n        }\n        uint256 price = uint256(price1)\n            .mul(10**_feedData2.decimals)\n            .mul(10**30)\n            .div(uint256(price2))\n            .div(10**_feedData1.decimals)\n            .mul(10**decimals[den])\n            .div(10**decimals[num]);\n        return (price, 30);\n    }\n\n    /**\n     * @notice Used to get decimals for a token\n     * @param _token address of the token\n     * @return number of decimals for the token\n     **/\n    function getDecimals(address _token) internal view returns (uint8) {\n        if (_token == address(0)) {\n            return 18;\n        }\n\n        try ERC20(_token).decimals() returns (uint8 v) {\n            return v;\n        } catch Error(string memory) {\n            return 0;\n        } catch (bytes memory) {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token from uniswap\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {\n        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);\n        address _pool = uniswapPools[_poolTokensId];\n        if (_pool == address(0)) {\n            return (0, 0);\n        }\n\n        int24 _twapTick = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);\n        uint256 _numTokens = OracleLibrary.getQuoteAtTick(_twapTick, 10**30, num, den);\n        return (_numTokens, 30);\n    }\n\n    function getUniswapPoolTokenId(address num, address den) internal pure returns (bytes32) {\n        if (uint256(num) < uint256(den)) {\n            return keccak256(abi.encodePacked(num, den));\n        } else {\n            return keccak256(abi.encodePacked(den, num));\n        }\n    }\n\n    /**\n     * @notice Used to get price of the num vs den token\n     * @param num the address of the token for which price in queried\n     * @param den the address of the token in which price is queried\n     * @return price of the num in terms of den\n     * @return no of decimals for the price\n     **/\n    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {\n        uint256 _price;\n        uint256 _decimals;\n        (_price, _decimals) = getChainlinkLatestPrice(num, den);\n        if (_decimals != 0) {\n            return (_price, _decimals);\n        }\n        (_price, _decimals) = getUniswapLatestPrice(num, den);\n        if (_decimals != 0) {\n            return (_price, _decimals);\n        }\n        revert(\"PriceOracle::getLatestPrice - Price Feed doesn't exist\");\n    }\n\n    /**\n     * @notice used to check if price feed exists between 2 tokens\n     * @param token1 one of the token for which price feed is to be checked\n     * @param token2 other token for which price feed is to be checked\n     * @return if price feed exists for the token pair\n     **/\n    function doesFeedExist(address token1, address token2) external view override returns (bool) {\n        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {\n            return true;\n        }\n\n        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);\n\n        if (uniswapPools[_poolTokensId] != address(0)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Used to set the price feed address for a token in chainlink\n     * @dev only owner can set\n     * @param token address of token for which price feed is added\n     * @param priceOracle addrewss of the price feed for the token\n     **/\n    function setChainlinkFeedAddress(address token, address priceOracle) external onlyOwner {\n        uint256 priceOracleDecimals = AggregatorV3Interface(priceOracle).decimals();\n        chainlinkFeedAddresses[token] = PriceData(priceOracle, priceOracleDecimals);\n        decimals[token] = getDecimals(token);\n        emit ChainlinkFeedUpdated(token, priceOracle);\n    }\n\n    /**\n     * @notice Used to set the price feed address for a token pair in uniswap\n     * @dev only owner can set\n     * @param token1 address of one of the tokens for which price feed is added\n     * @param token2 address of other token for which price feed is added\n     * @param pool addrewss of the price feed for the token pair\n     **/\n    function setUniswapFeedAddress(\n        address token1,\n        address token2,\n        address pool\n    ) external onlyOwner {\n        require(token1 != token2, 'token1 and token2 should be different addresses');\n        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);\n        uniswapPools[_poolTokensId] = pool;\n        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);\n    }\n\n    /**\n     * @notice Used to set the period in which uniswap price is averaged\n     * @dev only owner can set. This is used to prevent attacks to control price feed\n     * @param _uniswapPriceAveragingPeriod period for uniswap price averaging\n     **/\n    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {\n        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;\n        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);\n    }\n}"
    }
  ]
}