{
  "Title": "Duplicate fees will be paid by `LibTransfer::transferFee` when transferring fee-on-transfer tokens with `EXTERNAL_INTERNAL` 'from' mode and `EXTERNAL` 'to' mode",
  "Content": "**Description:** Beanstalk utilizes an internal virtual balance system that significantly reduces transaction fees when using tokens that are intended to remain within the protocol. `LibTransfer` achieves this by managing every transfer between accounts, considering both the origin 'from' and destination 'to' modes of the in-flight funds. As a result, there are four types of transfers based on the source of the funds (from mode):\n\n* `EXTERNAL`: The sender will not use their internal balances for the operation.\n* `INTERNAL`: The sender will use their internal balances for the operation.\n* `EXTERNAL_INTERNAL`: The sender will attempt to utilize their internal balance to transfer all desired funds. If funds remain to be sent, their externally owned funds will be utilized to cover the difference.\n* `INTERNAL_TOLERANT`: The sender will utilize their internal balances for the operation. With insufficient internal balance, the operation will continue (without reverting) with this reduced amount. It is, therefore, imperative to always check the return value of LibTransfer functions to continue the execution of calling functions with the true utilized amount, especially in this internal tolerant case.\n\nThe current implementation of [`LibTransfer::transferToken`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Token/LibTransfer.sol#L43-L44) for `(from mode: EXTERNAL ; to mode: EXTERNAL)` ensures a safe transfer operation from the sender to the recipient:\n\n```solidity\n// LibTransfer::transferToken\nif (fromMode == From.EXTERNAL && toMode == To.EXTERNAL) {\n    uint256 beforeBalance = token.balanceOf(recipient);\n    token.safeTransferFrom(sender, recipient, amount);\n    return token.balanceOf(recipient).sub(beforeBalance);\n}\namount = receiveToken(token, amount, sender, fromMode);\nsendToken(token, amount, recipient, toMode);\nreturn amount;\n```\n\nPerforming this operation allows duplication of fee-on-transfer token fees to be avoided if funds are first transferred to the contract and then to the recipient; however, `LibTransfer::transferToken` balance will incur double the fee if this function is used for `(from mode: EXTERNAL_INTERNAL ; to mode: EXTERNAL)` when the internal balance is insufficient cover the full transfer amount, given that:\n\n1. The remaining token balance would first be transferred to the Beanstalk Diamond, incurring fees.\n2. The remaining token balance would then be transferred to the recipient, incurring fees again.\n\n**Impact:** `LibTransfer::transferToken` will incur duplicate fees if this function is used for `(from mode: EXTERNAL_INTERNAL ; to mode: EXTERNAL)` with fee-on-transfer tokens if the internal balance is not sufficient to cover the full transfer amount.\n\nEven though Beanstalk currently does not impose any fees on token transfers, USDT is associated with the protocol, and its contract has already introduced logic to implement a fee on token transfer mechanism if ever desired in the future. Considering that the duplication of fees implies a loss of funds, but also taking into account the low likelihood of this issue occurring, the severity assigned to this issue is **MEDIUM**.\n\n**Recommended Mitigation:** Add an internal function `LibTransfer::handleFromExternalInternalToExternalTransfer` to handle this case to avoid duplication of fees. For instance:\n\n```solidity\nfunction handleFromExternalInternalToExternalTransfer(\n    IERC20 token,\n    address sender,\n    address recipient,\n    address amount\n) internal {\n    uint256 amountFromInternal = LibBalance.decreaseInternalBalance(\n        sender,\n        token,\n        amount,\n        true // allowPartial to avoid revert\n    );\n    uint256 pendingAmount = amount - amountFromInternal;\n    if (pendingAmount != 0) {\n        token.safeTransferFrom(sender, recipient, pendingAmount);\n    }\n    token.safeTransfer(sender, amountFromInternal);\n}\n```\n\nThen consider the use of this new function in `LibTransfer::transferToken`:\n\n```diff\n    function transferToken(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount,\n        From fromMode,\n        To toMode\n    ) internal returns (uint256 transferredAmount) {\n-       if (fromMode == From.EXTERNAL && toMode == To.EXTERNAL) {\n+       if (toMode == To.EXTERNAL) {\n+           if (fromMode == From.EXTERNAL) {\n                uint256 beforeBalance = token.balanceOf(recipient);\n                token.safeTransferFrom(sender, recipient, amount);\n                return token.balanceOf(recipient).sub(beforeBalance);\n+           } else if (fromMode == From.EXTERNAL_INTERNAL) {\n+               handleFromExternalInternalToExternalTransfer(token, sender, recipient, amount);\n+               return amount;\n+           }\n        }\n        amount = receiveToken(token, amount, sender, fromMode);\n        sendToken(token, amount, recipient, toMode);\n        return amount;\n    }\n```",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Token/LibTransfer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../interfaces/IBean.sol\";\nimport \"./LibBalance.sol\";\n\n/**\n * @title LibTransfer\n * @author Publius\n * @notice Handles the recieving and sending of Tokens to/from internal Balances.\n */\nlibrary LibTransfer {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum From {\n        EXTERNAL,\n        INTERNAL,\n        EXTERNAL_INTERNAL,\n        INTERNAL_TOLERANT\n    }\n    enum To {\n        EXTERNAL,\n        INTERNAL\n    }\n\n    function transferToken(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount,\n        From fromMode,\n        To toMode\n    ) internal returns (uint256 transferredAmount) {\n        if (fromMode == From.EXTERNAL && toMode == To.EXTERNAL) {\n            uint256 beforeBalance = token.balanceOf(recipient);\n            token.safeTransferFrom(sender, recipient, amount);\n            return token.balanceOf(recipient).sub(beforeBalance);\n        }\n        amount = receiveToken(token, amount, sender, fromMode);\n        sendToken(token, amount, recipient, toMode);\n        return amount;\n    }\n\n    function receiveToken(\n        IERC20 token,\n        uint256 amount,\n        address sender,\n        From mode\n    ) internal returns (uint256 receivedAmount) {\n        if (amount == 0) return 0;\n        if (mode != From.EXTERNAL) {\n            receivedAmount = LibBalance.decreaseInternalBalance(\n                sender,\n                token,\n                amount,\n                mode != From.INTERNAL\n            );\n            if (amount == receivedAmount || mode == From.INTERNAL_TOLERANT)\n                return receivedAmount;\n        }\n        uint256 beforeBalance = token.balanceOf(address(this));\n        token.safeTransferFrom(sender, address(this), amount - receivedAmount);\n        return\n            receivedAmount.add(\n                token.balanceOf(address(this)).sub(beforeBalance)\n            );\n    }\n\n    function sendToken(\n        IERC20 token,\n        uint256 amount,\n        address recipient,\n        To mode\n    ) internal {\n        if (amount == 0) return;\n        if (mode == To.INTERNAL)\n            LibBalance.increaseInternalBalance(recipient, token, amount);\n        else token.safeTransfer(recipient, amount);\n    }\n\n    function burnToken(\n        IBean token,\n        uint256 amount,\n        address sender,\n        From mode\n    ) internal returns (uint256 burnt) {\n        // burnToken only can be called with Unripe Bean, Unripe Bean:3Crv or Bean token, which are all Beanstalk tokens.\n        // Beanstalk's ERC-20 implementation uses OpenZeppelin's ERC20Burnable\n        // which reverts if burnFrom function call cannot burn full amount.\n        if (mode == From.EXTERNAL) {\n            token.burnFrom(sender, amount);\n            burnt = amount;\n        } else {\n            burnt = LibTransfer.receiveToken(token, amount, sender, mode);\n            token.burn(burnt);\n        }\n    }\n\n    function mintToken(\n        IBean token,\n        uint256 amount,\n        address recipient,\n        To mode\n    ) internal {\n        if (mode == To.EXTERNAL) {\n            token.mint(recipient, amount);\n        } else {\n            token.mint(address(this), amount);\n            LibTransfer.sendToken(token, amount, recipient, mode);\n        }\n    }\n}"
    }
  ]
}