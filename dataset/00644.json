{
  "Title": "M-8: Oracle can return different prices in same transaction",
  "Content": "# Issue M-8: Oracle can return different prices in same transaction \n\nSource: https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/216 \n\n## Found by \nshaka\n## Summary\n\nThe Pyth network oracle contract allows to submit and read two different prices in the same transaction. This can be used to create arbitrage opportunities that can make a profit with no risk at the expense of users on the other side of the trade.\n\n## Vulnerability Detail\n\n`OracleModule.sol` uses Pyth network as the primary source of price feeds. This oracle works in the following way:\n\n- A dedicated network keeps track of the latest price consensus, together with the timestamp.\n- This data is queried off-chain and submitted to the on-chain oracle.\n- It is checked that the data submitted is valid and the new price data is stored.\n- New requests for the latest price will now return the data submitted until a more recent price is submitted.\n\nOne thing to note is that the Pyth network is constantly updating the latest price (every 400ms), so when a new price is submitted on-chain it is not necessary that the price is the latest one. Otherwise, the process of querying the data off-chain, building the transaction, and submitting it on-chain would be required to be done with a latency of less than 400ms, which is not feasible. This makes it possible to submit two different prices in the same transaction and, thus, fetch two different prices in the same transaction.\n\nThis can be used to create some arbitrage opportunities that can make a profit with no risk. \n\n### How this can be exploited\n\nAn example of how this can be exploited, and showed in the PoC, would be:\n- Create a small leverage position.\n- Announce an adjustment order to increase the size of the position by some amount.\n- In the same block, announce a limit close order.\n- After the minimum execution time has elapsed, retrieve two prices from the Pyth oracle where the second price is higher than the first one.\n- Execute the adjustment order sending the first price.\n- Execute the limit close order sending the second price.\n\nThe result is approximately a profit of\n\n```shell\nadjustmentSize * (secondPrice - firstPrice) - (adjustmentSize * tradeFees * 2)\n```\n\n> Note: For simplicity, we do not take into account the initial size of the position, which in any case can be insignificant compared to the adjustment size. The keeper fee is also not included, as is the owner of the position that is executing the orders.\n\nThe following things are required to make a profit out of this attack:\n- Submit the orders before other keepers. This can be easily achieved, as there are not always enough incentives to execute the orders as soon as possible.\n- Obtain a positive delta between two prices in the time frame where the orders are executable that is greater than twice the trade fees. This can be very feasible, especially in moments of high volatility. Note also, that this requirement can be lowered to a delta greater than once the trade fees if we take into account that there is currently [another vulnerability](https://github.com/sherlock-audit/2023-12-flatmoney-shaka0x/issues/2) that allows to avoid paying fees for the limit order.\n\nIn the case of not being able to obtain the required delta or observing that a keeper has already submitted a transaction to execute them before the delta is obtained, the user can simply cancel the limit order and will have just the adjustment order executed.\n\nAnother possible strategy would pass through the following steps:\n- Create a leverage position.\n- Announce another leverage position with the same size.\n- In the same block, announce a limit close order.\n- After the minimum execution time has elapsed, retrieve two prices from the Pyth oracle where the second price is lower than the first one.\n- Execute the limit close order sending the first price.\n- Execute the open order sending the second price.\n\nThe result in this case is having a position with the same size as the original one, but having either lowered the `position.lastPrice` or getting a profit from the original position, depending on how the price has moved since the original position was opened.\n\n## Proof of concept\n\n<details>\n\n<summary>Pyth network multiple submissions</summary>\n\nWe can find proof that it is possible to submit and read two different prices in the same transaction [here](https://basescan.org/tx/0x0e0c22e5996ae58bbff806eba6d51e8fc773a3598ef0e0a359432e08f0b51b95). In this transaction `updatePriceFeeds` is called with two different prices. After each call the current price is fetched and an event is emitted with the price and timestamp received. As we can see, the values fetched are different for each query of the price.\n\n```js\nAddress 0x8250f4af4b972684f7b336503e2d6dfedeb1487a\nName    PriceFeedUpdate (index_topic_1 bytes32 id, uint64 publishTime, int64 price, uint64 conf)\nTopics  0 0xd06a6b7f4918494b3719217d1802786c1f5112a6c1d88fe2cfec00b4584f6aec\n        1 FF61491A931112DDF1BD8147CD1B641375F79F5825126D665480874634FD0ACE\nData    publishTime: 1706358779\n        price: 226646416525\n        conf: 115941591\n\nAddress 0xbf668dadb9cb8934468fcba6103fb42bb50f31ec\nTopics  0 0x734558db0ee3a7f77fb28b877f9d617525904e6dad1559f727ec93aa06370866\nData    226646416525\n        1706358779\n\nAddress 0x8250f4af4b972684f7b336503e2d6dfedeb1487a\nName    PriceFeedUpdate (index_topic_1 bytes32 id, uint64 publishTime, int64 price, uint64 conf)View Source\nTopics  0 0xd06a6b7f4918494b3719217d1802786c1f5112a6c1d88fe2cfec00b4584f6aec\n        1 FF61491A931112DDF1BD8147CD1B641375F79F5825126D665480874634FD0ACE\nData    publishTime: 1706358790\n        price: 226649088828\n        conf: 119840116\n\nAddress 0xbf668dadb9cb8934468fcba6103fb42bb50f31ec\nTopics  0 0x734558db0ee3a7f77fb28b877f9d617525904e6dad1559f727ec93aa06370866\nData    226649088828\n        1706358790\n```\n\n</details>\n\n<details>\n\n<summary>Arbitrage example</summary>\n\nAdd the following function to the `OracleTest` contract and run `forge test --mt testMultiplePricesInSameTx -vv`:\n\n```solidity\nfunction testMultiplePricesInSameTx() public {\n        // Setup\n        vm.startPrank(admin);\n        leverageModProxy.setLevTradingFee(0.001e18); // 0.1%\n        uint256 collateralPrice = 1000e8;\n        setWethPrice(collateralPrice);\n        announceAndExecuteDeposit({\n                traderAccount: bob,\n                keeperAccount: keeper,\n                depositAmount: 10000e18,\n                oraclePrice: collateralPrice,\n                keeperFeeAmount: 0\n        });\n        uint256 aliceCollateralBalanceBefore = WETH.balanceOf(alice);\n\n        // Create small leverage position\n        uint256 initialMargin = 0.05e18;\n        uint256 initialSize = 0.1e18;\n        uint256 tokenId = announceAndExecuteLeverageOpen({\n                traderAccount: alice,\n                keeperAccount: keeper,\n                margin: initialMargin,\n                additionalSize: initialSize,\n                oraclePrice: collateralPrice,\n                keeperFeeAmount: 0\n        });\n\n        // Announce leverage adjustment\n        announceAdjustLeverage({\n                traderAccount: alice,\n                tokenId: tokenId,\n                marginAdjustment: 100e18,\n                additionalSizeAdjustment: 2400e18,\n                keeperFeeAmount: 0\n        });\n\n        // Anounce limit order in the same block\n        vm.startPrank(alice);\n        limitOrderProxy.announceLimitOrder({\n                tokenId: tokenId,\n                priceLowerThreshold: 0,\n                priceUpperThreshold: 1 // executable at any price\n        });\n\n        // Wait for the orders to be executable\n        skip(vaultProxy.minExecutabilityAge());\n        bytes[] memory priceUpdateData1 = getPriceUpdateData(collateralPrice);\n        // Price increases slightly after one second\n        skip(1);\n        bytes[] memory priceUpdateData2 = getPriceUpdateData(collateralPrice + 1.2e8);\n\n        // Execute the adjustment with the lower price and the limit order with the higher price\n        delayedOrderProxy.executeOrder{value: 1}(alice, priceUpdateData1);\n        limitOrderProxy.executeLimitOrder{value: 1}(tokenId, priceUpdateData2);\n\n        uint256 aliceCollateralBalanceAfter = WETH.balanceOf(alice);\n        if (aliceCollateralBalanceAfter < aliceCollateralBalanceBefore) {\n                console2.log(\"loss: %s\", aliceCollateralBalanceBefore - aliceCollateralBalanceAfter);\n        } else {\n                console2.log(\"profit: %s\", aliceCollateralBalanceAfter - aliceCollateralBalanceBefore);\n        }\n}\n```\n\nConsole output:\n\n```js\n[PASS] testMultiplePricesInSameTx() (gas: 2351256)\nLogs:\n  profit: 475467998401917697\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 13.67ms\n```\n</details>\n\n## Impact\n\nDifferent oracle prices can be fetched in the same transaction, which can be used to create arbitrage opportunities that can make a profit with no risk at the expense of users on the other side of the trade.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/OracleModule.sol#L69\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/OracleModule.sol#L167\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\nFile: OracleModule.sol\n    FlatcoinStructs.OffchainOracle public offchainOracle; // Offchain Pyth network oracle\n\n+   uint256 public lastOffchainUpdate;\n\n    (...)\n\n    function updatePythPrice(address sender, bytes[] calldata priceUpdateData) external payable nonReentrant {\n+       if (lastOffchainUpdate >= block.timestamp) return;\n+       lastOffchainUpdate = block.timestamp;\n+\n        // Get fee amount to pay to Pyth\n        uint256 fee = offchainOracle.oracleContract.getUpdateFee(priceUpdateData);\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid\n\n\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dhedge/flatcoin-v1/pull/276.\n\n**0xLogos**\n\nEscalate \n\nLow (at least medium)\n\n- trader fee should be small\n- volatility should be high\n- profit is small and not guaranteed, loss is possible\n- can do roughly the same executing 2 last steps in 2 consecutive txs\n\n**sherlock-admin2**\n\n> Escalate \n> \n> Low (at least medium)\n> \n> - trader fee should be small\n> - volatility should be high\n> - profit is small and not guaranteed, loss is possible\n> - can do roughly the same executing 2 last steps in 2 consecutive txs\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**shaka0x**\n\n> * trader fee should be small\n\nThe PoC uses the trade fees mentioned in the documentation and in the test suite. We can argue that it can be increase, but by the same token it can also be decreased and make the attack even more profitable.\n\n> * volatility should be high\n\nA change of 0.1% is enough.\n\n> * profit is small and not guaranteed, loss is possible\n\nAs I stated, the user can just cancel the limit order if it is not favorable, so no loss beyond the gas fees of the txs.\n\n> * can do roughly the same executing 2 last steps in 2 consecutive txs\n\nThe attacker has no control over the change in the prices submitted between two transactions. Doing it atomically is the only way he can assured that the second is greater than the first or vice versa.\n\n\n**0xLogos**\n\n@shaka0x\n\nhmm, i see...\n\n- In poc mentioned vulnerability (avoid fee for limit orders) is used, without it there will be loss\n- User can cancel limit order, but adjust order has risk to be executed with fee large fee\n- User must first announce 2 orders and only after that seek for arb oportunity which increase complexity and risks\n\nAttack easily can fail:\n- Create a small leverage position.\n- Announce an adjustment order to increase the size of the position by some amount.\n- In the same block, announce a limit close order.\n- After the minimum execution time has elapsed, attacker fails to retrieve two prices from the Pyth oracle where the second price is higher than the first one.\n- Adjustment order is executed by keeper and attacker lost big fees.\n\n**xiaoming9090**\n\nEscalate. \n\nThe risk rating of this issue should be Medium.\n\nThe only token in scope for this audit contest is rETH per the Contest's README. Thus, we will use rETH for the rest of the example.\n\nAlso, in the [setup script](https://github.com/sherlock-audit/2023-12-flatmoney/blob/bba4f077a64f43fbd565f8983388d0e985cb85db/flatcoin-v1/test/helpers/Setup.sol#L147), the `minExecutabilityAge` is set to 10 seconds and `maxExecutabilityAge` is set to 1 minute. The system will only accept the Pyth price that is generated within the time between T1 and T2 (in Green below), which is within the 1-minute range.\n\n![image](https://github.com/sherlock-audit/2023-12-flatmoney-judging/assets/102820284/965eb5f4-41c6-4bf3-b7dd-5ea5807149ca)\n\nFor the attack to be profitable, the following equation needs to be satisfied (ignoring the gas fee for simplicity - but the attack will be slightly more difficult if we consider the gas fee. So we are being optimistic below)\n\n```\nOriginal Formula:\nadjustmentSize * (secondPrice - firstPrice) - (adjustmentSize * tradeFees * 2) > 0\n\nFor it to break even against the trade fee\n(secondPrice - firstPrice) > tradeFees * 2\n(secondPrice - firstPrice) > 0.1% * 2\n(secondPrice - firstPrice) > 0.2%\n```\n\nThe first requirement for the attack to break even (gain of zero or more) is that the ETH increases by more than 0.2% within 1 minute (e.g., \\$3000 to above \\$3006), which might or might not happen. Note that ETH is generally not a volatile asset. My calculation shows that the price increase needs to be more than 0.2% to break even.\n\n![image](https://github.com/sherlock-audit/2023-12-flatmoney-judging/assets/102820284/aab98baa-b357-4e13-b0a6-41700de093b0)\n\nThe second requirement is that while the malicious keeper is waiting for the right ETH price increase within the 1-minute timeframe if any other keeper executes EITHER the adjustment order OR limit close order, the attack path will be broken. The malicious keeper has to restart again. In addition, the malicious keeper will lose their trading fee when their malicious orders are being executed by someone else because a trade fee needs to be paid whenever an order is executed. Thus, this attack is generally unprofitable due to the high risk of failure, and when failure occurs, the malicious keeper needs to pay or lose the trade fee (no refund).\n\nThe report also mentioned the following, which could allow malicious keepers to cancel the limit order to mitigate the risk of loss. However, the problem is that the protocol is intended to be deployed on Base only (Per [Contest's Readme](https://github.com/sherlock-audit/2023-12-flatmoney/tree/bba4f077a64f43fbd565f8983388d0e985cb85db?tab=readme-ov-file#q-on-what-chains-are-the-smart-contracts-going-to-be-deployed)), which is similar to Optimism L2 that uses a sequencer. The sequencer operates in the FIFO (first in first out) manner with a queuing system. Thus, by the time the malicious keeper is aware of the unfavorable condition or some other keeper intends to execute their orders, it is already too late as the malicious keeper cannot front-run someone else TX due to the Sequence's queuing design. Even on Ethereum, there is no guarantee that one can always front-run a TX unless one pays an enormous amount of gas fee.\n\n> In the case of not being able to obtain the required delta or observing that a keeper has already submitted a transaction to execute them before the delta is obtained, the user can simply cancel the limit order and will have just the adjustment order executed.\n\nLastly, the adjustment size of the position must be large enough to overcome the risk VS profit hurdle. My above chart shows that 10 ETH will give around 30 USD profit if the price increases by more than 0.02%, and 100 ETH will give around 300 USD profit if the attack is successful.\n\nThe protocol is designed in a manner where it is balanced most of the time (delta-neutral), using various incentives to bring the balance back. This means most of the time, the short (LPs) and long trader sides will be 100%-100%, respectively. The worst case it can go is 100%-120% as the system will prevent the skew to be more than 20%. Thus, there is a limit being imposed on the position size that a user can open. If the LP side is 100 ETH, and the current total long position size is 115 ETH. The maximum amount of position size one can open is left with 5 ETH. This is another constraint that the attacker faces.\n\n**sherlock-admin2**\n\n> Escalate. \n> \n> The risk rating of this issue should be Medium.\n> \n> The only token in scope for this audit contest is rETH per the Contest's README. Thus, we will use rETH for the rest of the example.\n> \n> Also, in the [setup script](https://github.com/sherlock-audit/2023-12-flatmoney/blob/bba4f077a64f43fbd565f8983388d0e985cb85db/flatcoin-v1/test/helpers/Setup.sol#L147), the `minExecutabilityAge` is set to 10 seconds and `maxExecutabilityAge` is set to 1 minute. The system will only accept the Pyth price that is generated within the time between T1 and T2 (in Green below), which is within the 1-minute range.\n> \n> ![image](https://github.com/sherlock-audit/2023-12-flatmoney-judging/assets/102820284/965eb5f4-41c6-4bf3-b7dd-5ea5807149ca)\n> \n> For the attack to be profitable, the following equation needs to be satisfied (ignoring the gas fee for simplicity - but the attack will be slightly more difficult if we consider the gas fee. So we are being optimistic below)\n> \n> ```\n> Original Formula:\n> adjustmentSize * (secondPrice - firstPrice) - (adjustmentSize * tradeFees * 2) > 0\n> \n> For it to break even against the trade fee\n> (secondPrice - firstPrice) > tradeFees * 2\n> (secondPrice - firstPrice) > 0.1% * 2\n> (secondPrice - firstPrice) > 0.2%\n> ```\n> \n> The first requirement for the attack to break even (gain of zero or more) is that the ETH increases by more than 0.2% within 1 minute (e.g., \\$3000 to above \\$3006), which might or might not happen. Note that ETH is generally not a volatile asset. My calculation shows that the price increase needs to be more than 0.2% to break even.\n> \n> ![image](https://github.com/sherlock-audit/2023-12-flatmoney-judging/assets/102820284/aab98baa-b357-4e13-b0a6-41700de093b0)\n> \n> The second requirement is that while the malicious keeper is waiting for the right ETH price increase within the 1-minute timeframe if any other keeper executes EITHER the adjustment order OR limit close order, the attack path will be broken. The malicious keeper has to restart again. In addition, the malicious keeper will lose their trading fee when their malicious orders are being executed by someone else because a trade fee needs to be paid whenever an order is executed. Thus, this attack is generally unprofitable due to the high risk of failure, and when failure occurs, the malicious keeper needs to pay or lose the trade fee (no refund).\n> \n> The report also mentioned the following, which could allow malicious keepers to cancel the limit order to mitigate the risk of loss. However, the problem is that the protocol is intended to be deployed on Base only (Per [Contest's Readme](https://github.com/sherlock-audit/2023-12-flatmoney/tree/bba4f077a64f43fbd565f8983388d0e985cb85db?tab=readme-ov-file#q-on-what-chains-are-the-smart-contracts-going-to-be-deployed)), which is similar to Optimism L2 that uses a sequencer. The sequencer operates in the FIFO (first in first out) manner with a queuing system. Thus, by the time the malicious keeper is aware of the unfavorable condition or some other keeper intends to execute their orders, it is already too late as the malicious keeper cannot front-run someone else TX due to the Sequence's queuing design. Even on Ethereum, there is no guarantee that one can always front-run a TX unless one pays an enormous amount of gas fee.\n> \n> > In the case of not being able to obtain the required delta or observing that a keeper has already submitted a transaction to execute them before the delta is obtained, the user can simply cancel the limit order and will have just the adjustment order executed.\n> \n> Lastly, the adjustment size of the position must be large enough to overcome the risk VS profit hurdle. My above chart shows that 10 ETH will give around 30 USD profit if the price increases by more than 0.02%, and 100 ETH will give around 300 USD profit if the attack is successful.\n> \n> The protocol is designed in a manner where it is balanced most of the time (delta-neutral), using various incentives to bring the balance back. This means most of the time, the short (LPs) and long trader sides will be 100%-100%, respectively. The worst case it can go is 100%-120% as the system will prevent the skew to be more than 20%. Thus, there is a limit being imposed on the position size that a user can open. If the LP side is 100 ETH, and the current total long position size is 115 ETH. The maximum amount of position size one can open is left with 5 ETH. This is another constraint that the attacker faces.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**RealLTDingZhen**\n\nThis issue should be Low/informational. \n\n> After the minimum execution time has elapsed, retrieve two prices from the Pyth oracle where the second price is higher than the first one.\n\nBecause of the minimum execution time protection, such arbitrage opportunity is only possible when arbitrageurs can steadily guess where the market is going. If the market falls during the minimum execution time, arbitrageurs suffer more losses.\n\n\n**shaka0x**\n\n> This issue should be Low/informational.\n> \n> > After the minimum execution time has elapsed, retrieve two prices from the Pyth oracle where the second price is higher than the first one.\n> \n> Because of the minimum execution time protection, such arbitrage opportunity is only possible when arbitrageurs can steadily guess where the market is going. If the market falls during the minimum execution time, arbitrageurs suffer more losses.\n\nThe attack can be profitable even with small price movements. Given that prices are reported every 400ms, the chances of obtaining an increase in price are very high.\n\n**nevillehuang**\n\nAgree with @xiaoming9090 given the high dependency of price fluctuations within small periods of time, I believe medium severity to be more appropriate\n\n**Czar102**\n\nFees are to make up for possible losses of this type, doing this attack atomically is practically the same as executing it within a few seconds.\n\nSince this issue mentions a the fee bypass, and this is the only way it is of severity above Low, I think it should be duplicated with #212, since the impact of this issue can be High only because of the fee bypass.\n\nPlanning to accept the first escalation and consider this a duplicate of #212.\n\n**shaka0x**\n\n@Czar102 thank you for your feedback, but I don't understand in what sense this one could be considered as a duplicate of #212 What is explained in the issue is that in order to be profitable the gains due to the change in price have to be higher than the amount paid in fee. And I just point out that if we take into account that some fees can be avoided, as showed in #212, it is even easier to reach that profitability. But the issue is present independently of the fact that the fees can be avoided. The issue itself is not about avoiding fees, but about arbitraging the price.\n\nAlso, the performing the attack atomically is the only way of having control over the prices. To perform it in two blocks we have to rely on the second order not being executed by the keeper after we execute the first transaction in the previous block. By doing it atomically we ensure both orders are executed at the price we want, as long as we do it before the keeper (paying higher gas fees). If we execute the first order in block \"n\" and have to wait until block \"n+1\" to execute the second order, the keeper could just have executed it in block \"n\" after we executed ours.\n\n**Czar102**\n\nI believe this issue is a low severity one without #212. Thinking alternatively, this issue is another severe impact of the core issue #212 – lack of fees results in both this attack and revenue losses for the LPs.\n\nI believe counterarguments to all other points have been provided in https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/216#issuecomment-1959552564 and https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/216#issuecomment-1956126680.\n\n**shaka0x**\n\n> I believe this issue is a low severity one without #212. Thinking alternatively, this issue is another severe impact of the core issue #212 – lack of fees results in both this attack and revenue losses for the LPs.\n\n@Czar102 I politely ask you to read again the explanation of the issue. None of the calculations shown are counting on the effects of #212. There is no requirement of #212 to be present in order for the attack to be profitable. Even the escalator recognizes that in [this message](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/216#issuecomment-1959552564), only that considers the impact should not be high but medium, what I still disagree.\n\nAs I showed, the resultant profit of the attack is:\n```\nadjustmentSize * (secondPrice - firstPrice) - (adjustmentSize * tradeFees * 2)\n```\n\nThat is **without** the outcome of the issue #212. If we take this outcome into account, the result would be:\n```\nadjustmentSize * (secondPrice - firstPrice) - (adjustmentSize * tradeFees)\n```\n\nBut my assertion is based on the first case. I only pointed out, that the outcome of the attack could be even greater if we combine it with #212.\n\n**nevillehuang**\n\nI too fail to see how this issue is a duplicate of #212. They share completely separate root causes. With the impact described by LSW [here](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/216#issuecomment-1959552564), the issue is only worsened if price fluctuations is significant, so it should be downgraded to medium severity given dependency on external factors.\n\n**RealLTDingZhen**\n\nSorry to disturb, but I still haven't figured out how this arbitrage works. After users announce leverage adjust, they have to wait 10s for their order to be executed. How could the arbitrageur know whether the value returned by oracle in the same block after ten seconds will be lower or higher? If the corresponding block does not fulfill the condition, then the transaction is likely to be executed by another keeper, making it unprofitable for the arbitrageurs.\n\n If this path is not feasible, such logic flaw should not cause any financial loss, right?\n\n\n**shaka0x**\n\nThe attacker does not know the future price, but can take advantage of price increases. The issue is that during the lifespan of the block many prices are valid (a new price is emitted every 400ms), and the flaw in the design is that multiple prices are allowed to be submitted in the same block. So the requirement is finding two prices during the lifespan of the block that make the arbitrage profitable.\n\nIn the worst case scenario for the attacker, they are not found or are found before keeper has executed the orders (here we are assuming that keepers will try to execute all orders ASAP and be faster, which is not necessarily the case), so the attacker will lose an amount equivalent to the fees paid. But specially in moments of high volatility the attacker is incentivized to perform the attack, as the potential profit compensates the possible losses in trade fees.\n\n**RealLTDingZhen**\n\nAh I got it, when there are no fees, the arbitrageur's only risk is the market movement in 10s. In an balanced market, arbitrageurs can always make a profit through it.\n\n**Czar102**\n\n@shaka0x @nevillehuang How I see it is that there are two elements to this issue:\n1. The ability to use the same price twice, which is the case even if it wouldn't be possible to do that in a single transaction. It's impossible for profits from this to exceed costs in fees, as shown by @xiaoming9090. This issue is informational.\n2. The ability to extract value if there are no fees. Then, this becomes a High severity issue, since the fees don't make up for possible losses, but this is really just another impact of lack of fees, hence I thought to duplicate it with #212.\n\nI hope my approach makes sense now. In the end, whether this issue is invalidated or considered a duplicate of #212 won't impact the reward calculation at all.\n\n@nevillehuang If you still think this issue should not be duplicated with #212, I'll consider it informational.\n\n**nevillehuang**\n\n@Czar102 Can you elaborate on point 1? Why would it be impossible for profits to exceed cost in fees given price fluctuations cannot be predicted? I believe this shouldn't be duplicated with #212.\n\n**shaka0x**\n\n> 1. The ability to use the same price twice, which is the case even if it wouldn't be possible to do that in a single transaction. It's impossible for profits from this to exceed costs in fees, as shown by @xiaoming9090. This issue is informational.\n\n@Czar102 The analysis of @xiaoming9090 shows that it is profitable as long as the price is increase is more than 0.2%. In fact can be very profitable, while the loss is capped to the trading fees. Can you explain why you think it says that it is impossible to be profitable?\n\nQuoting his analysis:\n\n> My calculation shows that the price increase needs to be more than 0.2% to break even.\n\n\n**shaka0x**\n\nTo add a bit of context, just looking at today's Pyth price feed for [ETH/USD](https://pyth.network/price-feeds/crypto-eth-usd?range=1D) I have found some movements higher than 2% in a minute. That is, a movement 10 times bigger than the amount required to break even.\n\n**Czar102**\n\nIt seems I misunderstood the scope here. Is rETH/ETH or rETH/USD a tradeable pair here? I thought rETH/ETH is being traded, so there is no way there is a difference of 0.2% in price within 60 seconds.\n\n**shaka0x**\n\nHey @Czar102 the intended pair used for the protocol is rETH/USD. However, as pointed in #90 and duplicates, there is no such pair in Chainlink, so the protocol will have to either use ETH/USD (original design intent) or adapt the code to use rETH/USD. In any case, the pair is against USD.\n\n**Czar102**\n\nI see now. I believe this is a valid High severity issue. I think this attack persists even if executed non-atomically. @nevillehuang @shaka0x would you agree?\n\nPlanning to reject the escalation and leave the issue as is.\n\n**xiaoming9090**\n\n@Czar102 Just wanted to add on. Other escalators (@0xLogos & @RealLTDingZhen) and I have raised points that the attackers have a high chance of losing their fees, potential risk faces, and external conditions required for executing this attack. Many attacks could be carried out when prices move up or down within a timeframe, but the potential risk involved might deter attackers from carrying out the attack. Thus, I believe these should be taken into consideration, and a Medium would be more appropriate.\n\n**shaka0x**\n\n> I see now. I believe this is a valid High severity issue. I think this attack persists even if executed non-atomically. @nevillehuang @shaka0x would you agree?\n> \n> Planning to reject the escalation and leave the issue as is.\n\nThe issue is that for performing it not atomically, you have to assume that keepers will not execute the orders ASAP. Executing it atomically, it is much easier to perform if keepers do not execute it ASAP, but still feasible if they do.\n\nAs for the risk of losses, in moments of high volatility it is easy to reach the required movement and the risk of losing the amount of the trade fees is bearable in contracts with the potential profit. Also, note that it is a necessary lag in the submission of the transaction (it is required to query the offchain price, build the request and submit the transaction), that for keepers is augmented, as they will have to process many orders in the same block. So the attacker can just cancel the second order if in the first seconds of the order being executable the requirements for profitability are not reached.\n\n**xiaoming9090**\n\n> I see now. I believe this is a valid High severity issue. I think this attack persists even if executed non-atomically. @nevillehuang @shaka0x would you agree?\n> \n> Planning to reject the e",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/132",
  "Code": [
    {
      "filename": "flatcoin-v1/src/OracleModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC20Upgradeable.sol\";\nimport {SignedMath} from \"openzeppelin-contracts/contracts/utils/math/SignedMath.sol\";\nimport {IPyth} from \"pyth-sdk-solidity/IPyth.sol\";\nimport {PythStructs} from \"pyth-sdk-solidity/PythStructs.sol\";\n\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {IChainlinkAggregatorV3} from \"./interfaces/IChainlinkAggregatorV3.sol\";\n\n/// @title OracleModule\n/// @author dHEDGE\n/// @notice Can query collateral oracle price.\n/// @dev Interfaces with onchain and offchain oracles (eg. Chainlink and Pyth network).\ncontract OracleModule is IOracleModule, ModuleUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeCastUpgradeable for *;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SignedMath for int256;\n\n    address public asset; // Asset to price\n\n    FlatcoinStructs.OnchainOracle public onchainOracle; // Onchain Chainlink oracle\n\n    FlatcoinStructs.OffchainOracle public offchainOracle; // Offchain Pyth network oracle\n\n    // Max difference between onchain and offchain oracle. 1e18 = 100%\n    uint256 public maxDiffPercent;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(\n        IFlatcoinVault _vault,\n        address _asset,\n        FlatcoinStructs.OnchainOracle calldata _onchainOracle,\n        FlatcoinStructs.OffchainOracle calldata _offchainOracle,\n        uint256 _maxDiffPercent\n    ) external initializer {\n        __Module_init(FlatcoinModuleKeys._ORACLE_MODULE_KEY, _vault);\n        __ReentrancyGuard_init();\n\n        _setAsset(_asset);\n        _setOnchainOracle(_onchainOracle);\n        _setOffchainOracle(_offchainOracle);\n        _setMaxDiffPercent(_maxDiffPercent);\n    }\n\n    function updatePythPrice(address sender, bytes[] calldata priceUpdateData) external payable nonReentrant {\n        // Get fee amount to pay to Pyth\n        uint256 fee = offchainOracle.oracleContract.getUpdateFee(priceUpdateData);\n\n        // Update the price data (and pay the fee)\n        offchainOracle.oracleContract.updatePriceFeeds{value: fee}(priceUpdateData);\n\n        if (msg.value - fee > 0) {\n            // Need to refund caller. Try to return unused value, or revert if failed\n            (bool success, ) = sender.call{value: msg.value - fee}(\"\");\n            if (success == false) revert FlatcoinErrors.RefundFailed();\n        }\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the latest 18 decimal price of asset from either Pyth.network or Chainlink.\n    /// @dev The oldest pricestamp will be the Chainlink oracle `maxAge` setting. Otherwise the call will revert.\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function getPrice() public view returns (uint256 price, uint256 timestamp) {\n        (price, timestamp) = _getPrice(type(uint32).max);\n    }\n\n    /// @notice The same as getPrice() but it includes maximum acceptable oracle timestamp input parameter.\n    /// @param maxAge Oldest acceptable oracle price.\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function getPrice(uint32 maxAge) public view returns (uint256 price, uint256 timestamp) {\n        (price, timestamp) = _getPrice(maxAge);\n    }\n\n    /////////////////////////////////////////////\n    //            Internal Functions           //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the latest 18 decimal price of asset from either Pyth.network or Chainlink.\n    /// @dev It verifies the Pyth network price against Chainlink price (ensure that it is within a threshold).\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function _getPrice(uint32 maxAge) internal view returns (uint256 price, uint256 timestamp) {\n        (uint256 onchainPrice, uint256 onchainTime) = _getOnchainPrice(); // will revert if invalid\n        (uint256 offchainPrice, uint256 offchainTime, bool offchainInvalid) = _getOffchainPrice();\n        bool offchain;\n\n        uint256 priceDiff = (int256(onchainPrice) - int256(offchainPrice)).abs();\n        uint256 diffPercent = (priceDiff * 1e18) / onchainPrice;\n        if (diffPercent > maxDiffPercent) revert FlatcoinErrors.PriceMismatch(diffPercent);\n\n        if (offchainInvalid == false) {\n            // return the freshest price\n            if (offchainTime >= onchainTime) {\n                price = offchainPrice;\n                timestamp = offchainTime;\n                offchain = true;\n            } else {\n                price = onchainPrice;\n                timestamp = onchainTime;\n            }\n        } else {\n            price = onchainPrice;\n            timestamp = onchainTime;\n        }\n\n        // Check that the timestamp is within the required age\n        if (maxAge < type(uint32).max && timestamp + maxAge < block.timestamp) {\n            revert FlatcoinErrors.PriceStale(\n                offchain ? FlatcoinErrors.PriceSource.OffChain : FlatcoinErrors.PriceSource.OnChain\n            );\n        }\n    }\n\n    /// @dev Will revert on any issue. This is because the Onchain price is critical\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function _getOnchainPrice() internal view returns (uint256 price, uint256 timestamp) {\n        IChainlinkAggregatorV3 oracle = onchainOracle.oracleContract;\n        if (address(oracle) == address(0)) revert FlatcoinErrors.ZeroAddress(\"oracle\");\n\n        (, int256 _price, , uint256 updatedAt, ) = oracle.latestRoundData();\n        timestamp = updatedAt;\n        // check Chainlink oracle price updated within `maxAge` time.\n        if (block.timestamp > timestamp + onchainOracle.maxAge)\n            revert FlatcoinErrors.PriceStale(FlatcoinErrors.PriceSource.OnChain);\n\n        if (_price > 0) {\n            price = uint256(_price) * (10 ** 10); // convert Chainlink oracle decimals 8 -> 18\n        } else {\n            // Issue with onchain oracle indicates a serious problem\n            revert FlatcoinErrors.PriceInvalid(FlatcoinErrors.PriceSource.OnChain);\n        }\n    }\n\n    /// @dev `_getPrice` can fall back to the Onchain oracle.\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    /// @return invalid True if the price is invalid.\n    function _getOffchainPrice() internal view returns (uint256 price, uint256 timestamp, bool invalid) {\n        IPyth oracle = offchainOracle.oracleContract;\n        if (address(oracle) == address(0)) revert FlatcoinErrors.ZeroAddress(\"oracle\");\n\n        try oracle.getPriceNoOlderThan(offchainOracle.priceId, offchainOracle.maxAge) returns (\n            PythStructs.Price memory priceData\n        ) {\n            timestamp = priceData.publishTime;\n\n            // Check that Pyth price and confidence is a positive value\n            // Check that the exponential param is negative (eg -8 for 8 decimals)\n            if (priceData.price > 0 && priceData.conf > 0 && priceData.expo < 0) {\n                price = ((priceData.price).toUint256()) * (10 ** (18 + priceData.expo).toUint256()); // convert oracle expo/decimals eg 8 -> 18\n\n                // Check that Pyth price confidence meets minimum\n                if (priceData.price / int64(priceData.conf) < int32(offchainOracle.minConfidenceRatio)) {\n                    invalid = true; // price confidence is too low\n                }\n            } else {\n                invalid = true;\n            }\n        } catch {\n            invalid = true; // couldn't fetch the price with the asked input param\n        }\n    }\n\n    /// @dev Sets the asset to price.\n    /// @param _asset The asset to price.\n    function _setAsset(address _asset) internal {\n        if (_asset == address(0)) revert FlatcoinErrors.ZeroAddress(\"asset\");\n\n        asset = _asset;\n        emit FlatcoinEvents.SetAsset(_asset);\n    }\n\n    /// @notice Setting a Chainlink price feed push oracle.\n    /// @param newOracle The Chainlink aggregator oracle address.\n    function _setOnchainOracle(FlatcoinStructs.OnchainOracle calldata newOracle) internal {\n        if (address(newOracle.oracleContract) == address(0) || newOracle.maxAge <= 0)\n            revert FlatcoinErrors.OracleConfigInvalid();\n\n        onchainOracle = newOracle;\n        emit FlatcoinEvents.SetOnChainOracle(newOracle);\n    }\n\n    /// @notice Setting a Pyth Network price feed pull oracle.\n    /// @param newOracle The new onchain oracle configuration.\n    function _setOffchainOracle(FlatcoinStructs.OffchainOracle calldata newOracle) internal {\n        if (\n            address(newOracle.oracleContract) == address(0) ||\n            newOracle.priceId == bytes32(0) ||\n            newOracle.maxAge <= 0 ||\n            newOracle.minConfidenceRatio <= 0\n        ) revert FlatcoinErrors.OracleConfigInvalid();\n\n        offchainOracle = FlatcoinStructs.OffchainOracle(\n            newOracle.oracleContract,\n            newOracle.priceId,\n            newOracle.maxAge,\n            newOracle.minConfidenceRatio\n        );\n        emit FlatcoinEvents.SetOffChainOracle(newOracle);\n    }\n\n    /// @notice Setting the maximum percentage between onchain and offchain oracle.\n    /// @param _maxDiffPercent The maximum percentage between onchain and offchain oracle.\n    function _setMaxDiffPercent(uint256 _maxDiffPercent) internal {\n        // Max diff percent must be between 0 and (or equal to) 100%.\n        // 0 means that we don't ever expect the oracle prices to differ.\n        // 1e18 means that we don't care if the oracle prices differ.\n        if (_maxDiffPercent == 0 || _maxDiffPercent > 1e18) revert FlatcoinErrors.OracleConfigInvalid();\n\n        maxDiffPercent = _maxDiffPercent;\n\n        emit FlatcoinEvents.SetMaxDiffPercent(_maxDiffPercent);\n    }\n\n    /////////////////////////////////////////////\n    //             Owner Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Sets the asset and oracles (onchain and offchain).\n    /// @dev Changes should be handled with care as it's possible to misconfigure.\n    /// @param _asset The asset to price.\n    /// @param _onchainOracle The onchain oracle configuration.\n    /// @param _offchainOracle The offchain oracle configuration.\n    function setOracle(\n        address _asset,\n        FlatcoinStructs.OnchainOracle calldata _onchainOracle,\n        FlatcoinStructs.OffchainOracle calldata _offchainOracle\n    ) external onlyOwner {\n        // Note: It's not possible to check that the oracles match the configured asset\n        // and any configuration changes should be handled with care.\n        _setAsset(_asset);\n        _setOnchainOracle(_onchainOracle);\n        _setOffchainOracle(_offchainOracle);\n    }\n\n    /// @notice Sets the maximum percentage between onchain and offchain oracle\n    /// @param _maxDiffPercent The maximum percentage between onchain and offchain oracle\n    function setMaxDiffPercent(uint256 _maxDiffPercent) external onlyOwner {\n        _setMaxDiffPercent(_maxDiffPercent);\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/OracleModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC20Upgradeable.sol\";\nimport {SignedMath} from \"openzeppelin-contracts/contracts/utils/math/SignedMath.sol\";\nimport {IPyth} from \"pyth-sdk-solidity/IPyth.sol\";\nimport {PythStructs} from \"pyth-sdk-solidity/PythStructs.sol\";\n\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {IChainlinkAggregatorV3} from \"./interfaces/IChainlinkAggregatorV3.sol\";\n\n/// @title OracleModule\n/// @author dHEDGE\n/// @notice Can query collateral oracle price.\n/// @dev Interfaces with onchain and offchain oracles (eg. Chainlink and Pyth network).\ncontract OracleModule is IOracleModule, ModuleUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeCastUpgradeable for *;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SignedMath for int256;\n\n    address public asset; // Asset to price\n\n    FlatcoinStructs.OnchainOracle public onchainOracle; // Onchain Chainlink oracle\n\n    FlatcoinStructs.OffchainOracle public offchainOracle; // Offchain Pyth network oracle\n\n    // Max difference between onchain and offchain oracle. 1e18 = 100%\n    uint256 public maxDiffPercent;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(\n        IFlatcoinVault _vault,\n        address _asset,\n        FlatcoinStructs.OnchainOracle calldata _onchainOracle,\n        FlatcoinStructs.OffchainOracle calldata _offchainOracle,\n        uint256 _maxDiffPercent\n    ) external initializer {\n        __Module_init(FlatcoinModuleKeys._ORACLE_MODULE_KEY, _vault);\n        __ReentrancyGuard_init();\n\n        _setAsset(_asset);\n        _setOnchainOracle(_onchainOracle);\n        _setOffchainOracle(_offchainOracle);\n        _setMaxDiffPercent(_maxDiffPercent);\n    }\n\n    function updatePythPrice(address sender, bytes[] calldata priceUpdateData) external payable nonReentrant {\n        // Get fee amount to pay to Pyth\n        uint256 fee = offchainOracle.oracleContract.getUpdateFee(priceUpdateData);\n\n        // Update the price data (and pay the fee)\n        offchainOracle.oracleContract.updatePriceFeeds{value: fee}(priceUpdateData);\n\n        if (msg.value - fee > 0) {\n            // Need to refund caller. Try to return unused value, or revert if failed\n            (bool success, ) = sender.call{value: msg.value - fee}(\"\");\n            if (success == false) revert FlatcoinErrors.RefundFailed();\n        }\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the latest 18 decimal price of asset from either Pyth.network or Chainlink.\n    /// @dev The oldest pricestamp will be the Chainlink oracle `maxAge` setting. Otherwise the call will revert.\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function getPrice() public view returns (uint256 price, uint256 timestamp) {\n        (price, timestamp) = _getPrice(type(uint32).max);\n    }\n\n    /// @notice The same as getPrice() but it includes maximum acceptable oracle timestamp input parameter.\n    /// @param maxAge Oldest acceptable oracle price.\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function getPrice(uint32 maxAge) public view returns (uint256 price, uint256 timestamp) {\n        (price, timestamp) = _getPrice(maxAge);\n    }\n\n    /////////////////////////////////////////////\n    //            Internal Functions           //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the latest 18 decimal price of asset from either Pyth.network or Chainlink.\n    /// @dev It verifies the Pyth network price against Chainlink price (ensure that it is within a threshold).\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function _getPrice(uint32 maxAge) internal view returns (uint256 price, uint256 timestamp) {\n        (uint256 onchainPrice, uint256 onchainTime) = _getOnchainPrice(); // will revert if invalid\n        (uint256 offchainPrice, uint256 offchainTime, bool offchainInvalid) = _getOffchainPrice();\n        bool offchain;\n\n        uint256 priceDiff = (int256(onchainPrice) - int256(offchainPrice)).abs();\n        uint256 diffPercent = (priceDiff * 1e18) / onchainPrice;\n        if (diffPercent > maxDiffPercent) revert FlatcoinErrors.PriceMismatch(diffPercent);\n\n        if (offchainInvalid == false) {\n            // return the freshest price\n            if (offchainTime >= onchainTime) {\n                price = offchainPrice;\n                timestamp = offchainTime;\n                offchain = true;\n            } else {\n                price = onchainPrice;\n                timestamp = onchainTime;\n            }\n        } else {\n            price = onchainPrice;\n            timestamp = onchainTime;\n        }\n\n        // Check that the timestamp is within the required age\n        if (maxAge < type(uint32).max && timestamp + maxAge < block.timestamp) {\n            revert FlatcoinErrors.PriceStale(\n                offchain ? FlatcoinErrors.PriceSource.OffChain : FlatcoinErrors.PriceSource.OnChain\n            );\n        }\n    }\n\n    /// @dev Will revert on any issue. This is because the Onchain price is critical\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function _getOnchainPrice() internal view returns (uint256 price, uint256 timestamp) {\n        IChainlinkAggregatorV3 oracle = onchainOracle.oracleContract;\n        if (address(oracle) == address(0)) revert FlatcoinErrors.ZeroAddress(\"oracle\");\n\n        (, int256 _price, , uint256 updatedAt, ) = oracle.latestRoundData();\n        timestamp = updatedAt;\n        // check Chainlink oracle price updated within `maxAge` time.\n        if (block.timestamp > timestamp + onchainOracle.maxAge)\n            revert FlatcoinErrors.PriceStale(FlatcoinErrors.PriceSource.OnChain);\n\n        if (_price > 0) {\n            price = uint256(_price) * (10 ** 10); // convert Chainlink oracle decimals 8 -> 18\n        } else {\n            // Issue with onchain oracle indicates a serious problem\n            revert FlatcoinErrors.PriceInvalid(FlatcoinErrors.PriceSource.OnChain);\n        }\n    }\n\n    /// @dev `_getPrice` can fall back to the Onchain oracle.\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    /// @return invalid True if the price is invalid.\n    function _getOffchainPrice() internal view returns (uint256 price, uint256 timestamp, bool invalid) {\n        IPyth oracle = offchainOracle.oracleContract;\n        if (address(oracle) == address(0)) revert FlatcoinErrors.ZeroAddress(\"oracle\");\n\n        try oracle.getPriceNoOlderThan(offchainOracle.priceId, offchainOracle.maxAge) returns (\n            PythStructs.Price memory priceData\n        ) {\n            timestamp = priceData.publishTime;\n\n            // Check that Pyth price and confidence is a positive value\n            // Check that the exponential param is negative (eg -8 for 8 decimals)\n            if (priceData.price > 0 && priceData.conf > 0 && priceData.expo < 0) {\n                price = ((priceData.price).toUint256()) * (10 ** (18 + priceData.expo).toUint256()); // convert oracle expo/decimals eg 8 -> 18\n\n                // Check that Pyth price confidence meets minimum\n                if (priceData.price / int64(priceData.conf) < int32(offchainOracle.minConfidenceRatio)) {\n                    invalid = true; // price confidence is too low\n                }\n            } else {\n                invalid = true;\n            }\n        } catch {\n            invalid = true; // couldn't fetch the price with the asked input param\n        }\n    }\n\n    /// @dev Sets the asset to price.\n    /// @param _asset The asset to price.\n    function _setAsset(address _asset) internal {\n        if (_asset == address(0)) revert FlatcoinErrors.ZeroAddress(\"asset\");\n\n        asset = _asset;\n        emit FlatcoinEvents.SetAsset(_asset);\n    }\n\n    /// @notice Setting a Chainlink price feed push oracle.\n    /// @param newOracle The Chainlink aggregator oracle address.\n    function _setOnchainOracle(FlatcoinStructs.OnchainOracle calldata newOracle) internal {\n        if (address(newOracle.oracleContract) == address(0) || newOracle.maxAge <= 0)\n            revert FlatcoinErrors.OracleConfigInvalid();\n\n        onchainOracle = newOracle;\n        emit FlatcoinEvents.SetOnChainOracle(newOracle);\n    }\n\n    /// @notice Setting a Pyth Network price feed pull oracle.\n    /// @param newOracle The new onchain oracle configuration.\n    function _setOffchainOracle(FlatcoinStructs.OffchainOracle calldata newOracle) internal {\n        if (\n            address(newOracle.oracleContract) == address(0) ||\n            newOracle.priceId == bytes32(0) ||\n            newOracle.maxAge <= 0 ||\n            newOracle.minConfidenceRatio <= 0\n        ) revert FlatcoinErrors.OracleConfigInvalid();\n\n        offchainOracle = FlatcoinStructs.OffchainOracle(\n            newOracle.oracleContract,\n            newOracle.priceId,\n            newOracle.maxAge,\n            newOracle.minConfidenceRatio\n        );\n        emit FlatcoinEvents.SetOffChainOracle(newOracle);\n    }\n\n    /// @notice Setting the maximum percentage between onchain and offchain oracle.\n    /// @param _maxDiffPercent The maximum percentage between onchain and offchain oracle.\n    function _setMaxDiffPercent(uint256 _maxDiffPercent) internal {\n        // Max diff percent must be between 0 and (or equal to) 100%.\n        // 0 means that we don't ever expect the oracle prices to differ.\n        // 1e18 means that we don't care if the oracle prices differ.\n        if (_maxDiffPercent == 0 || _maxDiffPercent > 1e18) revert FlatcoinErrors.OracleConfigInvalid();\n\n        maxDiffPercent = _maxDiffPercent;\n\n        emit FlatcoinEvents.SetMaxDiffPercent(_maxDiffPercent);\n    }\n\n    /////////////////////////////////////////////\n    //             Owner Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Sets the asset and oracles (onchain and offchain).\n    /// @dev Changes should be handled with care as it's possible to misconfigure.\n    /// @param _asset The asset to price.\n    /// @param _onchainOracle The onchain oracle configuration.\n    /// @param _offchainOracle The offchain oracle configuration.\n    function setOracle(\n        address _asset,\n        FlatcoinStructs.OnchainOracle calldata _onchainOracle,\n        FlatcoinStructs.OffchainOracle calldata _offchainOracle\n    ) external onlyOwner {\n        // Note: It's not possible to check that the oracles match the configured asset\n        // and any configuration changes should be handled with care.\n        _setAsset(_asset);\n        _setOnchainOracle(_onchainOracle);\n        _setOffchainOracle(_offchainOracle);\n    }\n\n    /// @notice Sets the maximum percentage between onchain and offchain oracle\n    /// @param _maxDiffPercent The maximum percentage between onchain and offchain oracle\n    function setMaxDiffPercent(uint256 _maxDiffPercent) external onlyOwner {\n        _setMaxDiffPercent(_maxDiffPercent);\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/test/helpers/Setup.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {ProxyAdmin} from \"openzeppelin-contracts/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {TransparentUpgradeableProxy} from \"openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {Create2Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/Create2Upgradeable.sol\";\nimport {ERC20} from \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20} from \"openzeppelin-contracts/contracts/interfaces/IERC20.sol\";\nimport {MockPyth} from \"pyth-sdk-solidity/MockPyth.sol\";\nimport {IPyth} from \"pyth-sdk-solidity/IPyth.sol\";\n\nimport {DelayedOrder} from \"src/DelayedOrder.sol\";\nimport {FlatcoinVault} from \"src/FlatcoinVault.sol\";\nimport {LimitOrder} from \"src/LimitOrder.sol\";\nimport {StableModule} from \"src/StableModule.sol\";\nimport {OracleModule} from \"src/OracleModule.sol\";\nimport {LeverageModule} from \"src/LeverageModule.sol\";\nimport {PointsModule} from \"src/PointsModule.sol\";\nimport {MockKeeperFee} from \"../unit/mocks/MockKeeperFee.sol\";\n\nimport {FlatcoinStructs} from \"src/libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"src/libraries/FlatcoinModuleKeys.sol\";\n\nimport {IChainlinkAggregatorV3} from \"src/interfaces/IChainlinkAggregatorV3.sol\";\nimport {ILeverageModule} from \"src/interfaces/ILeverageModule.sol\";\nimport {IStableModule} from \"src/interfaces/IStableModule.sol\";\nimport {IPointsModule} from \"src/interfaces/IPointsModule.sol\";\nimport {IKeeperFee} from \"src/interfaces/IKeeperFee.sol\";\n\nimport {Viewer} from \"src/misc/Viewer.sol\";\nimport {LiquidationModule} from \"src/LiquidationModule.sol\";\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console2.sol\";\n\nabstract contract Setup is Test {\n    /********************************************\n     *                 Accounts                 *\n     ********************************************/\n    address internal admin = makeAddr(\"admin\");\n    address internal alice = makeAddr(\"alice\");\n    address internal bob = makeAddr(\"bob\");\n    address internal carol = makeAddr(\"carol\");\n    address internal keeper = makeAddr(\"keeper\");\n    address internal liquidator = makeAddr(\"liquidator\");\n    address internal treasury = makeAddr(\"treasury\");\n    address[] internal accounts = [admin, alice, bob, carol, keeper, liquidator, treasury];\n\n    /********************************************\n     *                 Mocks                    *\n     ********************************************/\n    IChainlinkAggregatorV3 internal wethChainlinkAggregatorV3 =\n        IChainlinkAggregatorV3(makeAddr(\"chainlinkAggregatorV3\"));\n    ERC20 internal WETH;\n    MockPyth internal mockPyth; // validTimePeriod, singleUpdateFeeInWei\n    IKeeperFee internal mockKeeperFee;\n\n    /********************************************\n     *             System contracts             *\n     ********************************************/\n    bytes32 internal constant STABLE_MODULE_KEY = FlatcoinModuleKeys._STABLE_MODULE_KEY;\n    bytes32 internal constant LEVERAGE_MODULE_KEY = FlatcoinModuleKeys._LEVERAGE_MODULE_KEY;\n    bytes32 internal constant ORACLE_MODULE_KEY = FlatcoinModuleKeys._ORACLE_MODULE_KEY;\n    bytes32 internal constant DELAYED_ORDER_KEY = FlatcoinModuleKeys._DELAYED_ORDER_KEY;\n    bytes32 internal constant LIMIT_ORDER_KEY = FlatcoinModuleKeys._LIMIT_ORDER_KEY;\n    bytes32 internal constant LIQUIDATION_MODULE_KEY = FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY;\n    bytes32 internal constant POINTS_MODULE_KEY = FlatcoinModuleKeys._POINTS_MODULE_KEY;\n    bytes32 internal constant KEEPER_FEE_MODULE_KEY = FlatcoinModuleKeys._KEEPER_FEE_MODULE_KEY;\n\n    address internal leverageModImplementation;\n    address internal stableModImplementation;\n    address internal oracleModImplementation;\n    address internal delayedOrderImplementation;\n    address internal limitOrderImplementation;\n    address internal liquidationModImplementation;\n    address internal pointsModImplementation;\n    address internal vaultImplementation;\n\n    ProxyAdmin internal proxyAdmin;\n    LeverageModule internal leverageModProxy;\n    StableModule internal stableModProxy;\n    OracleModule internal oracleModProxy;\n    DelayedOrder internal delayedOrderProxy;\n    LimitOrder internal limitOrderProxy;\n    LiquidationModule internal liquidationModProxy;\n    PointsModule internal pointsModProxy;\n    FlatcoinVault internal vaultProxy;\n    Viewer internal viewer;\n\n    function setUp() public virtual {\n        vm.startPrank(admin);\n\n        WETH = new ERC20(\"WETH Mock\", \"WETH\");\n        mockPyth = new MockPyth(60, 1);\n        mockKeeperFee = new MockKeeperFee();\n\n        // Deploy proxy admin for all the system contracts.\n        proxyAdmin = new ProxyAdmin();\n\n        // Deploy implementations of all the system contracts.\n        leverageModImplementation = address(new LeverageModule());\n        stableModImplementation = address(new StableModule());\n        oracleModImplementation = address(new OracleModule());\n        delayedOrderImplementation = address(new DelayedOrder());\n        limitOrderImplementation = address(new LimitOrder());\n        liquidationModImplementation = address(new LiquidationModule());\n        pointsModImplementation = address(new PointsModule());\n        vaultImplementation = address(new FlatcoinVault());\n\n        // Deploy proxies using the above implementation contracts.\n        leverageModProxy = LeverageModule(\n            address(new TransparentUpgradeableProxy(leverageModImplementation, address(proxyAdmin), \"\"))\n        );\n        stableModProxy = StableModule(\n            address(new TransparentUpgradeableProxy(stableModImplementation, address(proxyAdmin), \"\"))\n        );\n        oracleModProxy = OracleModule(\n            address(new TransparentUpgradeableProxy(oracleModImplementation, address(proxyAdmin), \"\"))\n        );\n        delayedOrderProxy = DelayedOrder(\n            address(new TransparentUpgradeableProxy(delayedOrderImplementation, address(proxyAdmin), \"\"))\n        );\n        limitOrderProxy = LimitOrder(\n            address(new TransparentUpgradeableProxy(limitOrderImplementation, address(proxyAdmin), \"\"))\n        );\n        liquidationModProxy = LiquidationModule(\n            address(new TransparentUpgradeableProxy(liquidationModImplementation, address(proxyAdmin), \"\"))\n        );\n        pointsModProxy = PointsModule(\n            address(new TransparentUpgradeableProxy(pointsModImplementation, address(proxyAdmin), \"\"))\n        );\n        vaultProxy = FlatcoinVault(\n            address(new TransparentUpgradeableProxy(vaultImplementation, address(proxyAdmin), \"\"))\n        );\n\n        // Initialize the vault.\n        // By default, max funding velocity will be 0.\n        vaultProxy.initialize({\n            _owner: admin,\n            _collateral: IERC20Upgradeable(address(WETH)),\n            _maxFundingVelocity: 0,\n            _maxVelocitySkew: 0.1e18, // 10% skew to reach max funding velocity\n            _skewFractionMax: 1.2e18,\n            _stableCollateralCap: type(uint256).max,\n            _minExecutabilityAge: 10 seconds,\n            _maxExecutabilityAge: 1 minutes\n        });\n\n        /* Initialize the modules */\n\n        // Can consider later enabling trade fees for all tests. Eg set it to 0.1% 0.001e18\n        leverageModProxy.initialize({\n            _vault: vaultProxy,\n            _levTradingFee: 0,\n            _marginMin: 0.05e18,\n            _leverageMin: 1.5e18,\n            _leverageMax: 25e18\n        });\n\n        // Can consider la"
    }
  ]
}