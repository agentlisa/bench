{
  "Title": "[M-03] Governor can rug pull the escrow",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/gateway/BridgeEscrow.sol#L28-L30\n\n\n# Vulnerability details\n\n\n\n\n## Impact\nGovernor can rug pull all GRT held by BridgeEscrow, which is a severe undermining of decentralization.\n\n## Proof of Concept\nThe governor can approve an arbitrary address to spend any amount from BridgeEscrow, so they can steal all escrowed tokens. Even if the governor is well intended, the contract can still be called out which would degrade the reputation of the protocol (e.g. see here: https://twitter.com/RugDocIO/status/1411732108029181960). This is especially an issue as the escrowed tokens are never burnt, so the users would need to trust the governor perpetually (not about stealing their L2 tokens, but about not taking a massive amount of L1 tokens for free for themselves).\n\nThis seems an unnecessary power granted to the governor and turns a decentralized bridge into a needless bottleneck of centralization.\n\n## Tools Used\nCode inspection\n\n## Recommended Mitigation Steps\nRestrict access to `approveAll()` to the [\"bridge that manages the GRT funds held by the escrow\"](https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/gateway/BridgeEscrow.sol#L25). Or, similarly to how `finalizeInboundTransfer` in the gateways is restricted to its respective counterpart, only allow spending via other protocol functions.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-the-graph-l2-bridge-contest",
  "Code": [
    {
      "filename": "contracts/gateway/BridgeEscrow.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\nimport \"../upgrades/GraphUpgradeable.sol\";\nimport \"../governance/Managed.sol\";\nimport \"../token/IGraphToken.sol\";\n\n/**\n * @title Bridge Escrow\n * @dev This contracts acts as a gateway for an L2 bridge (or several). It simply holds GRT and has\n * a set of spenders that can transfer the tokens; the L1 side of each L2 bridge has to be\n * approved as a spender.\n */\ncontract BridgeEscrow is GraphUpgradeable, Managed {\n    /**\n     * @dev Initialize this contract.\n     * @param _controller Address of the Controller that manages this contract\n     */\n    function initialize(address _controller) external onlyImpl {\n        Managed._initialize(_controller);\n    }\n\n    /**\n     * @dev Approve a spender (i.e. a bridge that manages the GRT funds held by the escrow)\n     * @param _spender Address of the spender that will be approved\n     */\n    function approveAll(address _spender) external onlyGovernor {\n        graphToken().approve(_spender, type(uint256).max);\n    }\n\n    /**\n     * @dev Revoke a spender (i.e. a bridge that will no longer manage the GRT funds held by the escrow)\n     * @param _spender Address of the spender that will be revoked\n     */\n    function revokeAll(address _spender) external onlyGovernor {\n        IGraphToken grt = graphToken();\n        grt.decreaseAllowance(_spender, grt.allowance(address(this), _spender));\n    }\n}"
    }
  ]
}