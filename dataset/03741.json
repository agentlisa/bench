{
  "Title": "Unstable gauge version check",
  "Content": "##### Description\n`ShashFactory` contract have gauge version check based on call probes defined at https://github.com/convex-eth/platform/blob/754d9e700693246275b613e895b4044b63ce9ed5/contracts/contracts/StashFactory.sol#L51-L61, that approach is very dangerous in case of new version added to curve. E.g if curve will add new version of gauge that have `rewarded_token()` or `reward_tokens(uint256)` and with different behavior, then version checker will wrongly classify version and allow to create stash with invalid version. That can lead to broken logic.\n\n##### Recommendation\nWe recommend to use another approach to check version, e.g whitelisting gauges. Curve have only around ~40 gauges.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/StashFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"./ExtraRewardStashV1.sol\";\nimport \"./ExtraRewardStashV2.sol\";\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\n\ncontract StashFactory {\n    using Address for address;\n\n    bytes4 private constant rewarded_token = 0x16fa50b1; //rewarded_token()\n    bytes4 private constant reward_tokens = 0x54c49fe9; //reward_tokens(uint256)\n\n    address public operator;\n    address public rewardFactory;\n\n    constructor(address _operator, address _rewardFactory) public {\n        operator = _operator;\n        rewardFactory = _rewardFactory;\n    }\n\n    //Create a stash contract for the given gauge.\n    //function calls are different depending on the version of curve gauges so determine which stash type is needed\n    function CreateStash(uint256 _pid, address _gauge, address _staker, uint256 _stashVersion) external returns(address){\n        require(msg.sender == operator, \"!authorized\");\n\n        //This logic should be easily doable without an input parameter\n        // ..but ganache-cli and/or truffle is giving a weird invalid opcode error\n        // TODO: try different environment or deploy and test\n       \n        if(_stashVersion == uint256(1) && IsV1(_gauge)){\n            //v1\n            ExtraRewardStashV1 stash = new ExtraRewardStashV1(_pid,operator,_staker,_gauge,rewardFactory);\n            return address(stash);\n        }else if(_stashVersion == uint256(2) && IsV2(_gauge)){\n            //v2\n            ExtraRewardStashV2 stash = new ExtraRewardStashV2(_pid,operator,_staker,_gauge,rewardFactory);\n            return address(stash);\n        }\n        bool isV1 = IsV1(_gauge);\n        bool isV2 = IsV2(_gauge);\n        require(!isV1 && !isV2,\"stash version mismatch\");\n        return address(0);\n    }\n\n    function IsV1(address _gauge) private returns(bool){\n        bytes memory data = abi.encode(rewarded_token);\n        (bool success,) = _gauge.call.value(0)(data);\n        return success;\n    }\n\n    function IsV2(address _gauge) private returns(bool){\n        bytes memory data = abi.encodeWithSelector(reward_tokens,uint256(0));\n        (bool success,) = _gauge.call.value(0)(data);\n        return success;\n    }\n}"
    }
  ]
}