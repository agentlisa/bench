{
  "Title": "Inadequate Visibility of State Variables in RedemptionReceiver Contract",
  "Content": "The visibility of the state variables [`_subjects`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/RedemptionReceiver.sol#L22) and [`_subjectsPending`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/RedemptionReceiver.sol#L24) is set to `private`, posing a significant usability concern within the Forta Vault's claim functionality. This restricted visibility forces users to depend excessively on the Forta Vault user interface to know the remaining number of FORT tokens available for claim. Users might incorrectly conclude that they have claimed all entitled tokens following the execution of the [`claimReedem`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/FortaStakingVault.sol#L383) function, unaware that additional subjects may still be pending, awaiting the deadline for eligibility.\n\n\nThe [`claim`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/RedemptionReceiver.sol#L76) function iterates through the `_subjects` array, verifying the timestamp against `_subjectsPending` and checking if the subject is in a frozen state. When a subject meets all the criteria, its stake is retrieved, it is then removed from the array, and its related entry in `_subjectsPending` is eliminated. If a subject fails to meet the necessary conditions, it is either because the user must have invoked the function past a certain deadline or because the subject is currently frozen.\n\n\nConsider providing public access or creating getter functions. This change would let users independently verify their claimable tokens, reducing dependency on the Forta Vault UI and mitigating the risk of misunderstandings regarding their token claims.\n\n\n***Update:** Resolved in [pull request #40](https://github.com/NethermindEth/forta-staking-vault/pull/40).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/RedemptionReceiver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC1155HolderUpgradeable } from\n    \"@openzeppelin-upgradeable/contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { OperatorFeeUtils } from \"./utils/OperatorFeeUtils.sol\";\nimport { IFortaStaking, DELEGATOR_SCANNER_POOL_SUBJECT } from \"./interfaces/IFortaStaking.sol\";\nimport { InactiveSharesDistributor } from \"./InactiveSharesDistributor.sol\";\n\n/**\n * @title Redemption Receiver\n * @author Nethermind\n * @notice Personal contract for each Vault participant to receive redeemed assets\n * @dev Needed to separate delays associated to redemptions of different users\n */\ncontract RedemptionReceiver is OwnableUpgradeable, ERC1155HolderUpgradeable {\n    using SafeERC20 for IERC20;\n\n    uint256[] private _subjects;\n    address[] private _distributors;\n    mapping(uint256 => uint256) private _subjectsPending;\n    mapping(address => bool) private _distributorsPending;\n    IFortaStaking private _staking;\n    IERC20 private _token;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * Initialiazes the contract\n     * @param staking FortaStaking contract address\n     * @param token FORT contract address\n     */\n    function initialize(IFortaStaking staking, IERC20 token) public initializer {\n        __Ownable_init(msg.sender);\n        _staking = staking;\n        _token = token;\n    }\n\n    /**\n     * @notice Register undelegations to initiate\n     * @param newUndelegations List of subjects to undelegate from\n     * @param shares list of shares to undelegate from each subject\n     */\n    function addUndelegations(uint256[] memory newUndelegations, uint256[] memory shares) public onlyOwner {\n        for (uint256 i = 0; i < newUndelegations.length; ++i) {\n            uint256 subject = newUndelegations[i];\n            if (_subjectsPending[subject] == 0) {\n                _subjects.push(subject);\n            }\n            _subjectsPending[subject] = _staking.initiateWithdrawal(DELEGATOR_SCANNER_POOL_SUBJECT, subject, shares[i]);\n        }\n    }\n\n    /**\n     * @notice Register inactive shares to claim\n     * @param newDistributors List of inactive shares distributors contracts to claim from\n     */\n    function addDistributors(address[] memory newDistributors) public onlyOwner {\n        for (uint256 i = 0; i < newDistributors.length; ++i) {\n            address distributor = newDistributors[i];\n            if (!_distributorsPending[distributor]) {\n                _distributors.push(distributor);\n                _distributorsPending[distributor] = true;\n            }\n        }\n    }\n\n    /**\n     * @notice Claim user redemptions\n     */\n    function claim(\n        address receiver,\n        uint256 feeInBasisPoints,\n        address feeTreasury\n    )\n        public\n        onlyOwner\n        returns (uint256)\n    {\n        uint256 stake;\n        for (uint256 i = 0; i < _subjects.length;) {\n            uint256 subject = _subjects[i];\n            if (\n                (_subjectsPending[subject] < block.timestamp)\n                    && !_staking.isFrozen(DELEGATOR_SCANNER_POOL_SUBJECT, subject)\n            ) {\n                stake += _staking.withdraw(DELEGATOR_SCANNER_POOL_SUBJECT, subject);\n                _subjects[i] = _subjects[_subjects.length - 1];\n                delete _subjectsPending[subject];\n                _subjects.pop();\n            } else {\n                ++i;\n            }\n        }\n        for (uint256 i = 0; i < _distributors.length;) {\n            InactiveSharesDistributor distributor = InactiveSharesDistributor(_distributors[i]);\n            uint256 balanceBefore = _token.balanceOf(address(this));\n            bool validClaim = distributor.claim();\n            if (validClaim) {\n                uint256 balanceAfter = _token.balanceOf(address(this));\n                stake += (balanceAfter - balanceBefore);\n                _distributorsPending[address(distributor)] = false;\n                _distributors[i] = _distributors[_distributors.length - 1];\n                _distributors.pop();\n            } else {\n                ++i;\n            }\n        }\n        uint256 userStake = OperatorFeeUtils.deductAndTransferFee(stake, feeInBasisPoints, feeTreasury, _token);\n        _token.safeTransfer(receiver, userStake);\n        return stake;\n    }\n}"
    },
    {
      "filename": "src/RedemptionReceiver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC1155HolderUpgradeable } from\n    \"@openzeppelin-upgradeable/contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { OperatorFeeUtils } from \"./utils/OperatorFeeUtils.sol\";\nimport { IFortaStaking, DELEGATOR_SCANNER_POOL_SUBJECT } from \"./interfaces/IFortaStaking.sol\";\nimport { InactiveSharesDistributor } from \"./InactiveSharesDistributor.sol\";\n\n/**\n * @title Redemption Receiver\n * @author Nethermind\n * @notice Personal contract for each Vault participant to receive redeemed assets\n * @dev Needed to separate delays associated to redemptions of different users\n */\ncontract RedemptionReceiver is OwnableUpgradeable, ERC1155HolderUpgradeable {\n    using SafeERC20 for IERC20;\n\n    uint256[] private _subjects;\n    address[] private _distributors;\n    mapping(uint256 => uint256) private _subjectsPending;\n    mapping(address => bool) private _distributorsPending;\n    IFortaStaking private _staking;\n    IERC20 private _token;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * Initialiazes the contract\n     * @param staking FortaStaking contract address\n     * @param token FORT contract address\n     */\n    function initialize(IFortaStaking staking, IERC20 token) public initializer {\n        __Ownable_init(msg.sender);\n        _staking = staking;\n        _token = token;\n    }\n\n    /**\n     * @notice Register undelegations to initiate\n     * @param newUndelegations List of subjects to undelegate from\n     * @param shares list of shares to undelegate from each subject\n     */\n    function addUndelegations(uint256[] memory newUndelegations, uint256[] memory shares) public onlyOwner {\n        for (uint256 i = 0; i < newUndelegations.length; ++i) {\n            uint256 subject = newUndelegations[i];\n            if (_subjectsPending[subject] == 0) {\n                _subjects.push(subject);\n            }\n            _subjectsPending[subject] = _staking.initiateWithdrawal(DELEGATOR_SCANNER_POOL_SUBJECT, subject, shares[i]);\n        }\n    }\n\n    /**\n     * @notice Register inactive shares to claim\n     * @param newDistributors List of inactive shares distributors contracts to claim from\n     */\n    function addDistributors(address[] memory newDistributors) public onlyOwner {\n        for (uint256 i = 0; i < newDistributors.length; ++i) {\n            address distributor = newDistributors[i];\n            if (!_distributorsPending[distributor]) {\n                _distributors.push(distributor);\n                _distributorsPending[distributor] = true;\n            }\n        }\n    }\n\n    /**\n     * @notice Claim user redemptions\n     */\n    function claim(\n        address receiver,\n        uint256 feeInBasisPoints,\n        address feeTreasury\n    )\n        public\n        onlyOwner\n        returns (uint256)\n    {\n        uint256 stake;\n        for (uint256 i = 0; i < _subjects.length;) {\n            uint256 subject = _subjects[i];\n            if (\n                (_subjectsPending[subject] < block.timestamp)\n                    && !_staking.isFrozen(DELEGATOR_SCANNER_POOL_SUBJECT, subject)\n            ) {\n                stake += _staking.withdraw(DELEGATOR_SCANNER_POOL_SUBJECT, subject);\n                _subjects[i] = _subjects[_subjects.length - 1];\n                delete _subjectsPending[subject];\n                _subjects.pop();\n            } else {\n                ++i;\n            }\n        }\n        for (uint256 i = 0; i < _distributors.length;) {\n            InactiveSharesDistributor distributor = InactiveSharesDistributor(_distributors[i]);\n            uint256 balanceBefore = _token.balanceOf(address(this));\n            bool validClaim = distributor.claim();\n            if (validClaim) {\n                uint256 balanceAfter = _token.balanceOf(address(this));\n                stake += (balanceAfter - balanceBefore);\n                _distributorsPending[address(distributor)] = false;\n                _distributors[i] = _distributors[_distributors.length - 1];\n                _distributors.pop();\n            } else {\n                ++i;\n            }\n        }\n        uint256 userStake = OperatorFeeUtils.deductAndTransferFee(stake, feeInBasisPoints, feeTreasury, _token);\n        _token.safeTransfer(receiver, userStake);\n        return stake;\n    }\n}"
    }
  ]
}