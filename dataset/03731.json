{
  "Title": "[L02] Unclean code",
  "Content": "In the [`lockTokens` function](https://github.com/graphprotocol/contracts/blob/01c891829d39e1d6adc30bf13a2c8bf64504f808/contracts/staking/libs/Stakes.sol#L76) of the `Stakes` contract the [`weightedAverage` function](https://github.com/graphprotocol/contracts/blob/01c891829d39e1d6adc30bf13a2c8bf64504f808/contracts/staking/libs/MathUtils.sol#L17) is called, but it is not clear what function parameters each of its four inputs denote. This is because as the inputs are passed in, their names are not suggestive of, or similar to, the parameters belonging to the function signature of the `weightedAverage` function.\n\n\nThis hinders readability and understanding of the code by auditors or other stakeholders.\n\n\nConsider either documenting as comments in the code the correspondence of each input to parameter or defining and using intermediate variables with suggestive names as inputs.\n\n\n**Update:** *Fixed in [PR465](https://github.com/graphprotocol/contracts/pull/465) at commit [`bead8f1e9f248764eec8f4ae5f627c86da33c78d`](https://github.com/graphprotocol/contracts/pull/465/commits/bead8f1e9f248764eec8f4ae5f627c86da33c78d).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/staking/libs/Stakes.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./MathUtils.sol\";\n\n/**\n * @title A collection of data structures and functions to manage the Indexer Stake state.\n *        Used for low-level state changes, require() conditions should be evaluated\n *        at the caller function scope.\n */\nlibrary Stakes {\n    using SafeMath for uint256;\n    using Stakes for Stakes.Indexer;\n\n    struct Indexer {\n        uint256 tokensStaked; // Tokens on the indexer stake (staked by the indexer)\n        uint256 tokensAllocated; // Tokens used in allocations\n        uint256 tokensLocked; // Tokens locked for withdrawal subject to thawing period\n        uint256 tokensLockedUntil; // Block when locked tokens can be withdrawn\n    }\n\n    /**\n     * @dev Deposit tokens to the indexer stake.\n     * @param stake Stake data\n     * @param _tokens Amount of tokens to deposit\n     */\n    function deposit(Stakes.Indexer storage stake, uint256 _tokens) internal {\n        stake.tokensStaked = stake.tokensStaked.add(_tokens);\n    }\n\n    /**\n     * @dev Release tokens from the indexer stake.\n     * @param stake Stake data\n     * @param _tokens Amount of tokens to release\n     */\n    function release(Stakes.Indexer storage stake, uint256 _tokens) internal {\n        stake.tokensStaked = stake.tokensStaked.sub(_tokens);\n    }\n\n    /**\n     * @dev Allocate tokens from the main stack to a SubgraphDeployment.\n     * @param stake Stake data\n     * @param _tokens Amount of tokens to allocate\n     */\n    function allocate(Stakes.Indexer storage stake, uint256 _tokens) internal {\n        stake.tokensAllocated = stake.tokensAllocated.add(_tokens);\n    }\n\n    /**\n     * @dev Unallocate tokens from a SubgraphDeployment back to the main stack.\n     * @param stake Stake data\n     * @param _tokens Amount of tokens to unallocate\n     */\n    function unallocate(Stakes.Indexer storage stake, uint256 _tokens) internal {\n        stake.tokensAllocated = stake.tokensAllocated.sub(_tokens);\n    }\n\n    /**\n     * @dev Lock tokens until a thawing period pass.\n     * @param stake Stake data\n     * @param _tokens Amount of tokens to unstake\n     * @param _period Period in blocks that need to pass before withdrawal\n     */\n    function lockTokens(\n        Stakes.Indexer storage stake,\n        uint256 _tokens,\n        uint256 _period\n    ) internal {\n        // Take into account period averaging for multiple unstake requests\n        uint256 lockingPeriod = _period;\n        if (stake.tokensLocked > 0) {\n            lockingPeriod = MathUtils.weightedAverage(\n                MathUtils.diff(stake.tokensLockedUntil, block.number),\n                stake.tokensLocked,\n                _period,\n                _tokens\n            );\n        }\n\n        // Update balances\n        stake.tokensLocked = stake.tokensLocked.add(_tokens);\n        stake.tokensLockedUntil = block.number.add(lockingPeriod);\n    }\n\n    /**\n     * @dev Unlock tokens.\n     * @param stake Stake data\n     * @param _tokens Amount of tokens to unkock\n     */\n    function unlockTokens(Stakes.Indexer storage stake, uint256 _tokens) internal {\n        stake.tokensLocked = stake.tokensLocked.sub(_tokens);\n        if (stake.tokensLocked == 0) {\n            stake.tokensLockedUntil = 0;\n        }\n    }\n\n    /**\n     * @dev Take all tokens out from the locked stake for withdrawal.\n     * @param stake Stake data\n     * @return Amount of tokens being withdrawn\n     */\n    function withdrawTokens(Stakes.Indexer storage stake) internal returns (uint256) {\n        // Calculate tokens that can be released\n        uint256 tokensToWithdraw = stake.tokensWithdrawable();\n\n        if (tokensToWithdraw > 0) {\n            // Reset locked tokens\n            stake.unlockTokens(tokensToWithdraw);\n\n            // Decrease indexer stake\n            stake.release(tokensToWithdraw);\n        }\n\n        return tokensToWithdraw;\n    }\n\n    /**\n     * @dev Return the amount of tokens used in allocations and locked for withdrawal.\n     * @param stake Stake data\n     * @return Token amount\n     */\n    function tokensUsed(Stakes.Indexer memory stake) internal pure returns (uint256) {\n        return stake.tokensAllocated.add(stake.tokensLocked);\n    }\n\n    /**\n     * @dev Return the amount of tokens staked not considering the ones that are already going\n     * through the thawing period or are ready for withdrawal. We call it secure stake because\n     * it is not subject to change by a withdraw call from the indexer.\n     * @param stake Stake data\n     * @return Token amount\n     */\n    function tokensSecureStake(Stakes.Indexer memory stake) internal pure returns (uint256) {\n        return stake.tokensStaked.sub(stake.tokensLocked);\n    }\n\n    /**\n     * @dev Tokens free balance on the indexer stake that can be used for any purpose.\n     * Any token that is allocated cannot be used as well as tokens that are going through the\n     * thawing period or are withdrawable\n     * Calc: tokensStaked - tokensAllocated - tokensLocked\n     * @param stake Stake data\n     * @return Token amount\n     */\n    function tokensAvailable(Stakes.Indexer memory stake) internal pure returns (uint256) {\n        return stake.tokensAvailableWithDelegation(0);\n    }\n\n    /**\n     * @dev Tokens free balance on the indexer stake that can be used for allocations.\n     * This function accepts a parameter for extra delegated capacity that takes into\n     * account delegated tokens\n     * @param stake Stake data\n     * @param _delegatedCapacity Amount of tokens used from delegators to calculate availability\n     * @return Token amount\n     */\n    function tokensAvailableWithDelegation(Stakes.Indexer memory stake, uint256 _delegatedCapacity)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 tokensCapacity = stake.tokensStaked.add(_delegatedCapacity);\n        uint256 _tokensUsed = stake.tokensUsed();\n        // If more tokens are used than the current capacity, the indexer is overallocated.\n        // This means the indexer doesn't have available capacity to create new allocations.\n        // We can reach this state when the indexer has funds allocated and then any\n        // of these conditions happen:\n        // - The delegationCapacity ratio is reduced.\n        // - The indexer stake is slashed.\n        // - A delegator removes enough stake.\n        if (_tokensUsed > tokensCapacity) {\n            // Indexer stake is over allocated: return 0 to avoid stake to be used until\n            // the overallocation is restored by staking more tokens, unallocating tokens\n            // or using more delegated funds\n            return 0;\n        }\n        return tokensCapacity.sub(_tokensUsed);\n    }\n\n    /**\n     * @dev Tokens available for withdrawal after thawing period.\n     * @param stake Stake data\n     * @return Token amount\n     */\n    function tokensWithdrawable(Stakes.Indexer memory stake) internal view returns (uint256) {\n        // No tokens to withdraw before locking period\n        if (stake.tokensLockedUntil == 0 || block.number < stake.tokensLockedUntil) {\n            return 0;\n        }\n        return stake.tokensLocked;\n    }\n}"
    }
  ]
}