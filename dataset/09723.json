{
  "Title": "[M-01] Duplicate  `_tokenNameSuffix` and `_tokenSymbolSuffix` will incorrectly update current Market",
  "Content": "_Submitted by csanuragjain_\n\n[PrePOMarketFactory.sol#L42](https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/PrePOMarketFactory.sol#L42)<br>\n\nImpacted Function: `createMarket`.\n\n1.  Owner calls createMarket with  \\_tokenNameSuffix S1 and \\_tokenSymbolSuffix S2 which creates a new market M1 with \\_deployedMarkets\\[\\_salt] pointing to M1. Here salt can be S which is computed using  \\_tokenNameSuffix and \\_tokenSymbolSuffix\n2.  This market is now being used\n3.  After some time owner again mistakenly calls createMarket with  \\_tokenNameSuffix S1 and \\_tokenSymbolSuffix S2\n4.  Instead of returning error mentioning that this name and symbol already exists, new market gets created. The problem here is that salt which is computed using \\_tokenNameSuffix and \\_tokenSymbolSuffix will again come as S (as in step 1) which means \\_deployedMarkets\\[\\_salt] will now get updated to M2. This means reference to M1 is gone\n\n### Recommended Mitigation Steps\n\nAdd below check:\n\n    require(_deployedMarkets[_salt]==address(0), \"Market already exists\");\n\n**[ramenforbreakfast (prePO) confirmed and commented](https://github.com/code-423n4/2022-03-prepo-findings/issues/2#issuecomment-1075674396):**\n > This is a valid submission, and since this would overwrite the existing mapping within `PrePOMarketFactory`, I think it is fair for this to remain as medium severity.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-03-prepo-findings/issues/2#issuecomment-1086869315):**\n > Agree with sponsor.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-prepo-contest",
  "Code": [
    {
      "filename": "contracts/core/PrePOMarketFactory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./LongShortToken.sol\";\nimport \"./PrePOMarket.sol\";\nimport \"./interfaces/ILongShortToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./interfaces/IPrePOMarketFactory.sol\";\n\ncontract PrePOMarketFactory is\n    IPrePOMarketFactory,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    mapping(address => bool) private _validCollateral;\n    mapping(bytes32 => address) private _deployedMarkets;\n\n    function initialize() public initializer {\n        OwnableUpgradeable.__Ownable_init();\n    }\n\n    function isCollateralValid(address _collateral)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _validCollateral[_collateral];\n    }\n\n    function getMarket(bytes32 _longShortHash)\n        external\n        view\n        override\n        returns (IPrePOMarket)\n    {\n        return IPrePOMarket(_deployedMarkets[_longShortHash]);\n    }\n\n    function createMarket(\n        string memory _tokenNameSuffix,\n        string memory _tokenSymbolSuffix,\n        address _governance,\n        address _collateral,\n        uint256 _floorLongPrice,\n        uint256 _ceilingLongPrice,\n        uint256 _floorValuation,\n        uint256 _ceilingValuation,\n        uint256 _mintingFee,\n        uint256 _redemptionFee,\n        uint256 _expiryTime\n    ) external override onlyOwner nonReentrant {\n        require(_validCollateral[_collateral], \"Invalid collateral\");\n\n        (\n            LongShortToken _longToken,\n            LongShortToken _shortToken\n        ) = _createPairTokens(_tokenNameSuffix, _tokenSymbolSuffix);\n        bytes32 _salt = keccak256(abi.encodePacked(_longToken, _shortToken));\n\n        PrePOMarket _newMarket = new PrePOMarket{salt: _salt}(\n            _governance,\n            _collateral,\n            ILongShortToken(address(_longToken)),\n            ILongShortToken(address(_shortToken)),\n            _floorLongPrice,\n            _ceilingLongPrice,\n            _floorValuation,\n            _ceilingValuation,\n            _mintingFee,\n            _redemptionFee,\n            _expiryTime,\n            false\n        );\n        _deployedMarkets[_salt] = address(_newMarket);\n\n        _longToken.transferOwnership(address(_newMarket));\n        _shortToken.transferOwnership(address(_newMarket));\n        emit MarketAdded(address(_newMarket), _salt);\n    }\n\n    function setCollateralValidity(address _collateral, bool _validity)\n        external\n        override\n        onlyOwner\n    {\n        _validCollateral[_collateral] = _validity;\n        emit CollateralValidityChanged(_collateral, _validity);\n    }\n\n    function _createPairTokens(\n        string memory _tokenNameSuffix,\n        string memory _tokenSymbolSuffix\n    )\n        internal\n        returns (LongShortToken _newLongToken, LongShortToken _newShortToken)\n    {\n        string memory _longTokenName = string(\n            abi.encodePacked(\"LONG\", \" \", _tokenNameSuffix)\n        );\n        string memory _shortTokenName = string(\n            abi.encodePacked(\"SHORT\", \" \", _tokenNameSuffix)\n        );\n        string memory _longTokenSymbol = string(\n            abi.encodePacked(\"L\", \"_\", _tokenSymbolSuffix)\n        );\n        string memory _shortTokenSymbol = string(\n            abi.encodePacked(\"S\", \"_\", _tokenSymbolSuffix)\n        );\n        _newLongToken = new LongShortToken(_longTokenName, _longTokenSymbol);\n        _newShortToken = new LongShortToken(\n            _shortTokenName,\n            _shortTokenSymbol\n        );\n        return (_newLongToken, _newShortToken);\n    }\n}"
    }
  ]
}