{
  "Title": "[G-01] Using immutable on variables that are only set in the constructor and never after (2.1k gas per var)",
  "Content": "Use immutable if you want to assign a permanent value at construction. Use constants if you already know the permanent value. Both get directly embedded in bytecode, saving SLOAD.<br>\nVariables only set in the constructor and never edited afterwards should be marked as immutable, as it would avoid the expensive storage-writing operation in the constructor (around 20 000 gas per variable) and replace the expensive storage-reading operations (around 2100 gas per reading) to a less expensive value reading (3 gas).\n\n**Total instaces: 1 `gas savings 1 * 2.1k = 2.1k gas`**\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/JumpRateModelV2.sol#L24\n```solidity\nFile: /contracts/lending/JumpRateModelV2.sol\n24:  address public owner;\n```\n\n```diff\ndiff --git a/contracts/lending/JumpRateModelV2.sol b/contracts/lending/JumpRateModelV2.sol\nindex a3971c6..d4f2285 100644\n--- a/contracts/lending/JumpRateModelV2.sol\n+++ b/contracts/lending/JumpRateModelV2.sol\n@@ -21,7 +21,7 @@ contract JumpRateModelV2 is InterestRateModel {\n   /**\n    * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\n    */\n-  address public owner;\n+  address public immutable owner;\n\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-ondo-finance-contest",
  "Code": [
    {
      "filename": "contracts/lending/JumpRateModelV2.sol",
      "content": "pragma solidity ^0.5.16;\n\nimport \"./compound/InterestRateModel.sol\";\nimport \"./compound/SafeMath.sol\";\n\n/**\n * @title Ondo's modified JumpRateModel Contract V2\n * @author Compound (modified by Dharma Labs)\n * @notice Version 2 modifies Version 1 by enabling updateable parameters.\n */\ncontract JumpRateModelV2 is InterestRateModel {\n  using SafeMath for uint;\n\n  event NewInterestParams(\n    uint baseRatePerBlock,\n    uint multiplierPerBlock,\n    uint jumpMultiplierPerBlock,\n    uint kink\n  );\n\n  /**\n   * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\n   */\n  address public owner;\n\n  /**\n   * @notice The approximate number of blocks per year that is assumed by the interest rate model\n   */\n  uint public constant blocksPerYear = 2628000;\n\n  /**\n   * @notice The multiplier of utilization rate that gives the slope of the interest rate\n   */\n  uint public multiplierPerBlock;\n\n  /**\n   * @notice The base interest rate which is the y-intercept when utilization rate is 0\n   */\n  uint public baseRatePerBlock;\n\n  /**\n   * @notice The multiplierPerBlock after hitting a specified utilization point\n   */\n  uint public jumpMultiplierPerBlock;\n\n  /**\n   * @notice The utilization point at which the jump multiplier is applied\n   */\n  uint public kink;\n\n  /**\n   * @notice Construct an interest rate model\n   * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n   * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n   * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n   * @param kink_ The utilization point at which the jump multiplier is applied\n   * @param owner_ The address of the owner, i.e. the Timelock contract (which has the ability to update parameters directly)\n   */\n  constructor(\n    uint baseRatePerYear,\n    uint multiplierPerYear,\n    uint jumpMultiplierPerYear,\n    uint kink_,\n    address owner_\n  ) public {\n    owner = owner_;\n\n    updateJumpRateModelInternal(\n      baseRatePerYear,\n      multiplierPerYear,\n      jumpMultiplierPerYear,\n      kink_\n    );\n  }\n\n  /**\n   * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\n   * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n   * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n   * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n   * @param kink_ The utilization point at which the jump multiplier is applied\n   */\n  function updateJumpRateModel(\n    uint baseRatePerYear,\n    uint multiplierPerYear,\n    uint jumpMultiplierPerYear,\n    uint kink_\n  ) external {\n    require(msg.sender == owner, \"only the owner may call this function.\");\n\n    updateJumpRateModelInternal(\n      baseRatePerYear,\n      multiplierPerYear,\n      jumpMultiplierPerYear,\n      kink_\n    );\n  }\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market (currently unused)\n   * @return The utilization rate as a mantissa between [0, 1e18]\n   */\n  function utilizationRate(\n    uint cash,\n    uint borrows,\n    uint reserves\n  ) public pure returns (uint) {\n    // Utilization rate is 0 when there are no borrows\n    if (borrows == 0) {\n      return 0;\n    }\n\n    return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n  }\n\n  /**\n   * @notice Calculates the current borrow rate per block, with the error code expected by the market\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n   */\n  function getBorrowRate(\n    uint cash,\n    uint borrows,\n    uint reserves\n  ) public view returns (uint) {\n    uint util = utilizationRate(cash, borrows, reserves);\n\n    if (util <= kink) {\n      return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n    } else {\n      uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(\n        baseRatePerBlock\n      );\n      uint excessUtil = util.sub(kink);\n      return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n    }\n  }\n\n  /**\n   * @notice Calculates the current supply rate per block\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @param reserveFactorMantissa The current reserve factor for the market\n   * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint cash,\n    uint borrows,\n    uint reserves,\n    uint reserveFactorMantissa\n  ) public view returns (uint) {\n    uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);\n    uint borrowRate = getBorrowRate(cash, borrows, reserves);\n    uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n    return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n  }\n\n  /**\n   * @notice Internal function to update the parameters of the interest rate model\n   * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n   * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n   * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n   * @param kink_ The utilization point at which the jump multiplier is applied\n   */\n  function updateJumpRateModelInternal(\n    uint baseRatePerYear,\n    uint multiplierPerYear,\n    uint jumpMultiplierPerYear,\n    uint kink_\n  ) internal {\n    baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n    multiplierPerBlock = (multiplierPerYear.mul(1e18)).div(\n      blocksPerYear.mul(kink_)\n    );\n    jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\n    kink = kink_;\n\n    emit NewInterestParams(\n      baseRatePerBlock,\n      multiplierPerBlock,\n      jumpMultiplierPerBlock,\n      kink\n    );\n  }\n}"
    }
  ]
}