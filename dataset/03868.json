{
  "Title": "Keep invariant `burnPercent <= divider`",
  "Content": "##### Description\nAccording logic at line https://github.com/tosdis/TosDisFinance/blob/be50dbf8a52a8f919694498bf30394d328d88fbb/StakeMaster/contracts/StakeMaster.sol#L75 `burnPercent` should be less or equal than `divider`, but in contract that invariant never checked\n\n##### Recommendation\nWe recommend add particular check\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "StakeMaster/contracts/StakeMaster.sol",
      "content": "pragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"./StakingPool.sol\";\n\ncontract StakeMaster is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20Burnable;\n    using SafeERC20 for IERC20;\n\n    ERC20Burnable public feeToken;\n    address public feeWallet;\n    uint256 public feeAmount;\n    uint256 public burnPercent;\n    uint256 public divider;\n\n    event StakingPoolCreated(address owner, address pool, address stakingToken, address poolToken, uint256 startBlock, uint256 finishBlock, uint256 poolTokenAmount);\n    event TokenFeeUpdated(address newFeeToken);\n    event FeeAmountUpdated(uint256 newFeeAmount);\n    event BurnPercentUpdated(uint256 newBurnPercent, uint256 divider);\n    event FeeWalletUpdated(address newFeeWallet);\n\n    constructor(\n        ERC20Burnable _feeToken,\n        address _feeWallet,\n        uint256 _feeAmount,\n        uint256 _burnPercent\n    ) public {\n        feeToken = _feeToken;\n        feeAmount = _feeAmount;\n        feeWallet = _feeWallet;\n        burnPercent = _burnPercent;\n        divider = 100;\n    }\n\n    function setFeeToken(address _newFeeToken) external onlyOwner {\n        require(isContract(_newFeeToken), \"New address is not a token\");\n        feeToken = ERC20Burnable(_newFeeToken);\n\n        emit TokenFeeUpdated(_newFeeToken);\n    }\n\n    function setFeeAmount(uint256 _newFeeAmount) external onlyOwner {\n        feeAmount = _newFeeAmount;\n\n        emit FeeAmountUpdated(_newFeeAmount);\n    }\n\n    function setFeeWallet(address _newFeeWallet) external onlyOwner {\n        feeWallet = _newFeeWallet;\n\n        emit FeeWalletUpdated(_newFeeWallet);\n    }\n\n    function setBurnPercent(uint256 _newBurnPercent, uint256 _newDivider)\n        external\n        onlyOwner\n    {\n        burnPercent = _newBurnPercent;\n        divider = _newDivider;\n\n        emit BurnPercentUpdated(_newBurnPercent, _newDivider);\n    }\n\n    function createStakingPool(\n        IERC20 _stakingToken,\n        IERC20 _poolToken,\n        uint256 _startBlock,\n        uint256 _finishBlock,\n        uint256 _poolTokenAmount\n    ) external {\n        uint256 burnAmount = feeAmount.mul(burnPercent).div(divider);\n\n        feeToken.safeTransferFrom(\n            msg.sender,\n            feeWallet,\n            feeAmount.sub(burnAmount)\n        );\n        feeToken.safeTransferFrom(msg.sender, address(this), burnAmount);\n        feeToken.burn(burnAmount);\n\n        StakingPool stakingPool =\n            new StakingPool(\n                _stakingToken,\n                _poolToken,\n                _startBlock,\n                _finishBlock,\n                _poolTokenAmount\n            );\n        stakingPool.transferOwnership(msg.sender);\n\n        _poolToken.safeTransferFrom(\n            msg.sender,\n            address(stakingPool),\n            _poolTokenAmount\n        );\n\n        emit StakingPoolCreated(msg.sender, address(stakingPool), address(_stakingToken), address(_poolToken), _startBlock, _finishBlock, _poolTokenAmount);\n    }\n\n    function isContract(address _addr) private view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n}"
    }
  ]
}