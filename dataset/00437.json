{
  "Title": "M-18: `getCollateral` and `getAsset` functions of the AssetTotsDaiLeverageExecutor contract decode data incorrectly",
  "Content": "# Issue M-18: `getCollateral` and `getAsset` functions of the AssetTotsDaiLeverageExecutor contract decode data incorrectly \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/84 \n\n## Found by \nduc\n## Summary\nSee vulnerability detail\n## Vulnerability Detail\nIn AssetTotsDaiLeverageExecutor contract, `getCollateral` function decodes the data before passing it to `_swapAndTransferToSender` function.\n```solidity=\nSLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\nuint256 daiAmount =\n    _swapAndTransferToSender(false, assetAddress, daiAddress, assetAmountIn, swapData.swapperData);\n```\nHowever, `_swapAndTransferToSender` will decode this data again to obtain the swapperData:\n```solidity=\nfunction _swapAndTransferToSender(\n    bool sendBack,\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    bytes memory data\n) internal returns (uint256 amountOut) {\n    SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\n    ...\n```\nThe redundant decoding will cause the data to not align as expected, which is different from `SimpleLeverageExecutor.getCollateral()` function ([code snippet](https://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/leverage/SimpleLeverageExecutor.sol#L46))\n## Impact\n`getCollateral` and `getAsset` of AssetTotsDaiLeverageExecutor will not work as intended due to incorrectly decoding data.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/leverage/AssetTotsDaiLeverageExecutor.sol#L53-L55\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/leverage/AssetTotsDaiLeverageExecutor.sol#L88-L91\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThe AssetTotsDaiLeverageExecutor contract should pass data directly to `_swapAndTransferToSender`, similar to the SimpleLeverageExecutor contract\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  it seem to have been encoded twice, cuz it will not work if its encoded once in the first place\n\n\n\n**nevillehuang**\n\n@cryptotechmaker This seems to lack an impact description, but would this cause an revert within `_swapAndTransferToSender`?\n\n**cryptotechmaker**\n\nYes, it causes a revert. \n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/commit/2432f1e85cb241d46b8da220226a744b7fc36f88.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/leverage/SimpleLeverageExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// Tapioca\nimport {IZeroXSwapper} from \"tapioca-periph/interfaces/periph/IZeroXSwapper.sol\";\nimport {IWeth9} from \"tapioca-periph/interfaces/external/weth/IWeth9.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {BaseLeverageExecutor} from \"./BaseLeverageExecutor.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SimpleLeverageExecutor is BaseLeverageExecutor {\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n\n    constructor(IZeroXSwapper _swapper, ICluster _cluster) BaseLeverageExecutor(_swapper, _cluster) {}\n\n    // ********************* //\n    // *** PUBLIC METHODS *** //\n    // ********************* //\n\n    /**\n     * @inheritdoc BaseLeverageExecutor\n     */\n    function getCollateral(\n        address assetAddress,\n        address collateralAddress,\n        uint256 assetAmountIn,\n        bytes calldata swapperData\n    ) external payable override returns (uint256 collateralAmountOut) {\n        // Should be called only by approved SGL/BB markets.\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n        return _swapAndTransferToSender(true, assetAddress, collateralAddress, assetAmountIn, swapperData);\n    }\n\n    /**\n     * @inheritdoc BaseLeverageExecutor\n     */\n    function getAsset(\n        address collateralAddress,\n        address assetAddress,\n        uint256 collateralAmountIn,\n        bytes calldata swapperData\n    ) external override returns (uint256 assetAmountOut) {\n        // Should be called only by approved SGL/BB markets.\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n        return _swapAndTransferToSender(true, collateralAddress, assetAddress, collateralAmountIn, swapperData);\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/leverage/AssetTotsDaiLeverageExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n//interfaces\nimport {ISavingsDai} from \"tapioca-periph/interfaces/external/makerdao/ISavingsDai.sol\";\nimport {BaseLeverageExecutor, SLeverageSwapData} from \"./BaseLeverageExecutor.sol\";\nimport {IZeroXSwapper} from \"tapioca-periph/interfaces/periph/IZeroXSwapper.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract AssetTotsDaiLeverageExecutor is BaseLeverageExecutor {\n    using SafeApprove for address;\n\n    constructor(IZeroXSwapper _swapper, ICluster _cluster) BaseLeverageExecutor(_swapper, _cluster) {}\n\n    // ********************* //\n    // *** PUBLIC METHODS *** //\n    // ********************* //\n\n    /**\n     * @dev USDO > DAI > sDAi > wrap to tsDai\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenInToft to be false. Does the unwrapping internally.\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenOutToft to be false. Does the wrapping internally.\n     * @inheritdoc BaseLeverageExecutor\n     */\n    function getCollateral(address assetAddress, address collateralAddress, uint256 assetAmountIn, bytes calldata data)\n        external\n        payable\n        override\n        returns (uint256 collateralAmountOut)\n    {\n        if (msg.value > 0) revert NativeNotSupported();\n\n        // Should be called only by approved SGL/BB markets.\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n\n        //retrieve addresses\n        (address sDaiAddress, address daiAddress) = _getAddresses(collateralAddress);\n\n        //swap USDO (asset) with DAI\n        SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\n        uint256 daiAmount =\n            _swapAndTransferToSender(false, assetAddress, daiAddress, assetAmountIn, swapData.swapperData);\n\n        //obtain sDai\n        daiAddress.safeApprove(sDaiAddress, daiAmount);\n        collateralAmountOut = ISavingsDai(sDaiAddress).deposit(daiAmount, address(this));\n\n        // Wrap into tsDai to sender\n        sDaiAddress.safeApprove(collateralAddress, collateralAmountOut);\n        ITOFT(collateralAddress).wrap(address(this), msg.sender, collateralAmountOut);\n        sDaiAddress.safeApprove(collateralAddress, 0);\n    }\n\n    /**\n     * @dev unwrap tsDai > withdraw sDai > Dai > USDO\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenInToft to be false. Does the unwrapping internally.\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenOutToft to be false. Does the wrapping internally.\n     * @inheritdoc BaseLeverageExecutor\n     */\n    function getAsset(address collateralAddress, address assetAddress, uint256 collateralAmountIn, bytes calldata data)\n        external\n        override\n        returns (uint256 assetAmountOut)\n    {\n        // Should be called only by approved SGL/BB markets.\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n\n        //retrieve addresses\n        (address sDaiAddress, address daiAddress) = _getAddresses(collateralAddress);\n        //unwrap tsDai\n        ITOFT(collateralAddress).unwrap(address(this), collateralAmountIn);\n        //redeem from sDai\n        uint256 obtainedDai = ISavingsDai(sDaiAddress).redeem(collateralAmountIn, address(this), address(this));\n        // swap DAI with USDO, and transfer to sender\n        SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\n        // If sendBack true and swapData.swapperData.toftInfo.isTokenOutToft false\n        // The asset will be transfer via IERC20 transfer.\n        assetAmountOut = _swapAndTransferToSender(true, daiAddress, assetAddress, obtainedDai, swapData.swapperData);\n    }\n\n    // ********************** //\n    // *** PRIVATE METHODS *** //\n    // ********************** //\n\n    /**\n     * @dev retrieve sDai and Dai addresses from tsDai\n     */\n    function _getAddresses(address collateralAddress) private view returns (address sDaiAddress, address daiAddress) {\n        //retrieve sDAI address from tsDai\n        sDaiAddress = ITOFT(collateralAddress).erc20();\n        if (sDaiAddress == address(0)) revert TokenNotValid();\n\n        //retrieve DAI address from sDAI\n        daiAddress = ISavingsDai(sDaiAddress).dai();\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/leverage/AssetTotsDaiLeverageExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n//interfaces\nimport {ISavingsDai} from \"tapioca-periph/interfaces/external/makerdao/ISavingsDai.sol\";\nimport {BaseLeverageExecutor, SLeverageSwapData} from \"./BaseLeverageExecutor.sol\";\nimport {IZeroXSwapper} from \"tapioca-periph/interfaces/periph/IZeroXSwapper.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract AssetTotsDaiLeverageExecutor is BaseLeverageExecutor {\n    using SafeApprove for address;\n\n    constructor(IZeroXSwapper _swapper, ICluster _cluster) BaseLeverageExecutor(_swapper, _cluster) {}\n\n    // ********************* //\n    // *** PUBLIC METHODS *** //\n    // ********************* //\n\n    /**\n     * @dev USDO > DAI > sDAi > wrap to tsDai\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenInToft to be false. Does the unwrapping internally.\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenOutToft to be false. Does the wrapping internally.\n     * @inheritdoc BaseLeverageExecutor\n     */\n    function getCollateral(address assetAddress, address collateralAddress, uint256 assetAmountIn, bytes calldata data)\n        external\n        payable\n        override\n        returns (uint256 collateralAmountOut)\n    {\n        if (msg.value > 0) revert NativeNotSupported();\n\n        // Should be called only by approved SGL/BB markets.\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n\n        //retrieve addresses\n        (address sDaiAddress, address daiAddress) = _getAddresses(collateralAddress);\n\n        //swap USDO (asset) with DAI\n        SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\n        uint256 daiAmount =\n            _swapAndTransferToSender(false, assetAddress, daiAddress, assetAmountIn, swapData.swapperData);\n\n        //obtain sDai\n        daiAddress.safeApprove(sDaiAddress, daiAmount);\n        collateralAmountOut = ISavingsDai(sDaiAddress).deposit(daiAmount, address(this));\n\n        // Wrap into tsDai to sender\n        sDaiAddress.safeApprove(collateralAddress, collateralAmountOut);\n        ITOFT(collateralAddress).wrap(address(this), msg.sender, collateralAmountOut);\n        sDaiAddress.safeApprove(collateralAddress, 0);\n    }\n\n    /**\n     * @dev unwrap tsDai > withdraw sDai > Dai > USDO\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenInToft to be false. Does the unwrapping internally.\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenOutToft to be false. Does the wrapping internally.\n     * @inheritdoc BaseLeverageExecutor\n     */\n    function getAsset(address collateralAddress, address assetAddress, uint256 collateralAmountIn, bytes calldata data)\n        external\n        override\n        returns (uint256 assetAmountOut)\n    {\n        // Should be called only by approved SGL/BB markets.\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n\n        //retrieve addresses\n        (address sDaiAddress, address daiAddress) = _getAddresses(collateralAddress);\n        //unwrap tsDai\n        ITOFT(collateralAddress).unwrap(address(this), collateralAmountIn);\n        //redeem from sDai\n        uint256 obtainedDai = ISavingsDai(sDaiAddress).redeem(collateralAmountIn, address(this), address(this));\n        // swap DAI with USDO, and transfer to sender\n        SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\n        // If sendBack true and swapData.swapperData.toftInfo.isTokenOutToft false\n        // The asset will be transfer via IERC20 transfer.\n        assetAmountOut = _swapAndTransferToSender(true, daiAddress, assetAddress, obtainedDai, swapData.swapperData);\n    }\n\n    // ********************** //\n    // *** PRIVATE METHODS *** //\n    // ********************** //\n\n    /**\n     * @dev retrieve sDai and Dai addresses from tsDai\n     */\n    function _getAddresses(address collateralAddress) private view returns (address sDaiAddress, address daiAddress) {\n        //retrieve sDAI address from tsDai\n        sDaiAddress = ITOFT(collateralAddress).erc20();\n        if (sDaiAddress == address(0)) revert TokenNotValid();\n\n        //retrieve DAI address from sDAI\n        daiAddress = ISavingsDai(sDaiAddress).dai();\n    }\n}"
    }
  ]
}