{
  "Title": "[G-05] Splitting require() statements that use && saves gas - (saves 8 gas per &&)",
  "Content": "\nInstead of using the && operator in a single require statement to check multiple conditions,using multiple require statements with 1 condition per require statement will save 8 GAS per &&<br>\nThe gas difference would only be realized if the revert condition is realized(met).\n\nFile: Disputes.sol [Line 61](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Disputes.sol#L61-L65)\n\n```solidity\n        require(\n            _disputeID < disputeCount &&\n                disputes[_disputeID].status == Status.Active,\n            \"Disputes::!Resolvable\"\n        );\n```\n\nThe above should be modified to\n\n```solidity\n        require( _disputeID < disputeCount,  \"Disputes::!Resolvable\");\n        require(disputes[_disputeID].status == Status.Active, \"Disputes::!Resolvable\");\n```\n\nFile: Disputes.sol [Line 106](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Disputes.sol#L106-L109)\n\n```solidity\n        require(\n            _actionType > 0 && _actionType <= uint8(ActionType.TaskPay),\n            \"Disputes::!ActionType\"\n        );\n```\n\nFile: Community.sol [Line 353](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Community.sol#L353)\n\n```solidity\n        require(\n            _lendingNeeded >= _communityProject.totalLent &&\n                _lendingNeeded <= IProject(_project).projectCost(),\n            \"Community::invalid lending\"\n        );\n```\n\n**Proof**<br>\n**The following tests were carried out in remix with both optimization turned on and off**\n\n```\nfunction multiple (uint a) public pure returns (uint){\n\trequire ( a > 1 && a < 5, \"Initialized\");\n\treturn  a + 2;\n}\n```\n\n**Execution cost**<br>\n21617 with optimization and using &&<br>\n21976 without optimization and using &&<br>\n\nAfter splitting the require statement\n\n```\nfunction multiple(uint a) public pure returns (uint){\n\trequire (a > 1 ,\"Initialized\");\n\trequire (a < 5 , \"Initialized\");\n\treturn a + 2;\n}\n```\n\n**Execution cost**<br>\n21609 with optimization and split require<br>\n21968 without optimization and using split require\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-08-rigor-protocol-contest",
  "Code": [
    {
      "filename": "contracts/Disputes.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Disputes Contract for HomeFi v2.5.0\n\n * @dev Module for raising disputes for arbitration within HomeFi projects\n */\ncontract Disputes is\n    IDisputes,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    IHomeFi public override homeFi;\n    /// @inheritdoc IDisputes\n    uint256 public override disputeCount; //starts from 0\n    /// @inheritdoc IDisputes\n    mapping(uint256 => Dispute) public override disputes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00)\n        require(_address != address(0), \"Disputes::0 address\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        // Revert if sender is not HomeFi admin\n        // Only HomeFi admin can resolve dispute\n        require(homeFi.admin() == _msgSender(), \"Disputes::!Admin\");\n        _;\n    }\n\n    modifier onlyProject() {\n        // Revert if project not originated of HomeFi\n        require(homeFi.isProjectExist(_msgSender()), \"Disputes::!Project\");\n        _;\n    }\n\n    /**\n     * Affirm that a given dispute is currently resolvable\n     * @param _disputeID uint256 - the serial/id of the dispute\n     */\n    modifier resolvable(uint256 _disputeID) {\n        require(\n            _disputeID < disputeCount &&\n                disputes[_disputeID].status == Status.Active,\n            \"Disputes::!Resolvable\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        homeFi = IHomeFi(_homeFi);\n    }\n\n    /// @inheritdoc IDisputes\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        onlyProject\n    {\n        // Recover signer from signature\n        address _signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (\n            address _project,\n            uint256 _taskID,\n            uint8 _actionType,\n            bytes memory _actionData,\n            bytes memory _reason\n        ) = abi.decode(_data, (address, uint256, uint8, bytes, bytes));\n\n        // Revert if _actionType is invalid\n        require(\n            _actionType > 0 && _actionType <= uint8(ActionType.TaskPay),\n            \"Disputes::!ActionType\"\n        );\n\n        // Store dispute details\n        Dispute storage _dispute = disputes[disputeCount];\n        _dispute.status = Status.Active;\n        _dispute.project = _project;\n        _dispute.taskID = _taskID;\n        _dispute.raisedBy = _signer;\n        _dispute.actionType = ActionType(_actionType);\n        _dispute.actionData = _actionData;\n\n        // Increment dispute counter and emit event\n        emit DisputeRaised(disputeCount++, _reason);\n    }\n\n    /// @inheritdoc IDisputes\n    function attachDocument(uint256 _disputeID, bytes calldata _attachment)\n        external\n        override\n        resolvable(_disputeID)\n    {\n        // Local instance of variable. For saving gas.\n        Dispute storage _dispute = disputes[_disputeID];\n\n        // Check if sender is related to dispute\n        assertMember(_dispute.project, _dispute.taskID, _msgSender());\n\n        // Emit _attachment in event. To save it in logs.\n        emit DisputeAttachmentAdded(_disputeID, _msgSender(), _attachment);\n    }\n\n    /// @inheritdoc IDisputes\n    function resolveDispute(\n        uint256 _disputeID,\n        bytes calldata _judgement,\n        bool _ratify\n    ) external override onlyAdmin nonReentrant resolvable(_disputeID) {\n        // If dispute is accepted\n        if (_ratify) {\n            // Complete dispute actions\n            resolveHandler(_disputeID);\n\n            // Mark dispute as accepted\n            disputes[_disputeID].status = Status.Accepted;\n        }\n        // If dispute is rejected\n        else {\n            // Mark dispute as rejected\n            disputes[_disputeID].status = Status.Rejected;\n        }\n\n        emit DisputeResolved(_disputeID, _ratify, _judgement);\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    function assertMember(\n        address _project,\n        uint256 _taskID,\n        address _address\n    ) public view override {\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Get task subcontractor\n        (, address _sc, ) = _projectInstance.getTask(_taskID);\n\n        // Revert is signer is not builder, contractor or subcontractor.\n        bool _result = _projectInstance.builder() == _address ||\n            _projectInstance.contractor() == _address ||\n            _sc == _address;\n        require(_result, \"Disputes::!Member\");\n    }\n\n    /// @inheritdoc IDisputes\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IDisputes)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice Given an id, attempt to execute the action to enforce the arbitration\n\n     * @notice logic for decoding and enforcing outcome of arbitration judgement\n\n     * @param _disputeID uint256 - the dispute to attempt to\n     */\n    function resolveHandler(uint256 _disputeID) internal {\n        // Local instance of variable. For saving gas.\n        Dispute storage dispute = disputes[_disputeID];\n\n        // If action type is add task then execute add task\n        if (dispute.actionType == ActionType.TaskAdd) {\n            executeTaskAdd(dispute.project, dispute.actionData);\n        }\n        // If action type is task change then execute task change\n        else if (dispute.actionType == ActionType.TaskChange) {\n            executeTaskChange(dispute.project, dispute.actionData);\n        }\n        // Else execute task pay\n        else {\n            executeTaskPay(dispute.project, dispute.actionData);\n        }\n    }\n\n    /**\n     * @dev Arbitration enforcement of task change orders\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task add transaction data stored when dispute was raised\n     * - _hash bytes[] - bytes IPFS hash of task details\n     * - _taskCosts uint256[] - an array of cost for each task index\n     * - _taskCount uint256 - current task count before adding these tasks. Can be fetched by taskCount.\n     *   For signature security.\n     * - _projectAddress address - the address of this contract. For signature security.\n     */\n    function executeTaskAdd(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).addTasks(_actionData, bytes(\"\"));\n    }\n\n    /**\n     * @dev Arbitration enforcement of task change orders\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task change order transaction data stored when dispute was raised\n     * - _taskID uint256 - index of the task\n     * - _newSC address - address of new subcontractor.\n     *   If do not want to replace subcontractor, then pass address of existing subcontractor.\n     * - _newCost uint256 - new cost for the task.\n     *   If do not want to change cost, then pass existing cost.\n     * - _project address - address of project\n     */\n    function executeTaskChange(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).changeOrder(_actionData, bytes(\"\"));\n    }\n\n    /**\n     * @dev Arbitration enforcement of task payout\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task payout transaction data stored when dispute was raised\n     * - _taskID uint256 - the index of task\n     * - _projectAddress address - the address of this contract. For signature security.\n     */\n    function executeTaskPay(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).setComplete(_actionData, bytes(\"\"));\n    }\n}"
    },
    {
      "filename": "contracts/Disputes.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Disputes Contract for HomeFi v2.5.0\n\n * @dev Module for raising disputes for arbitration within HomeFi projects\n */\ncontract Disputes is\n    IDisputes,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    IHomeFi public override homeFi;\n    /// @inheritdoc IDisputes\n    uint256 public override disputeCount; //starts from 0\n    /// @inheritdoc IDisputes\n    mapping(uint256 => Dispute) public override disputes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00)\n        require(_address != address(0), \"Disputes::0 address\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        // Revert if sender is not HomeFi admin\n        // Only HomeFi admin can resolve dispute\n        require(homeFi.admin() == _msgSender(), \"Disputes::!Admin\");\n        _;\n    }\n\n    modifier onlyProject() {\n        // Revert if project not originated of HomeFi\n        require(homeFi.isProjectExist(_msgSender()), \"Disputes::!Project\");\n        _;\n    }\n\n    /**\n     * Affirm that a given dispute is currently resolvable\n     * @param _disputeID uint256 - the serial/id of the dispute\n     */\n    modifier resolvable(uint256 _disputeID) {\n        require(\n            _disputeID < disputeCount &&\n                disputes[_disputeID].status == Status.Active,\n            \"Disputes::!Resolvable\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        homeFi = IHomeFi(_homeFi);\n    }\n\n    /// @inheritdoc IDisputes\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        onlyProject\n    {\n        // Recover signer from signature\n        address _signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (\n            address _project,\n            uint256 _taskID,\n            uint8 _actionType,\n            bytes memory _actionData,\n            bytes memory _reason\n        ) = abi.decode(_data, (address, uint256, uint8, bytes, bytes));\n\n        // Revert if _actionType is invalid\n        require(\n            _actionType > 0 && _actionType <= uint8(ActionType.TaskPay),\n            \"Disputes::!ActionType\"\n        );\n\n        // Store dispute details\n        Dispute storage _dispute = disputes[disputeCount];\n        _dispute.status = Status.Active;\n        _dispute.project = _project;\n        _dispute.taskID = _taskID;\n        _dispute.raisedBy = _signer;\n        _dispute.actionType = ActionType(_actionType);\n        _dispute.actionData = _actionData;\n\n        // Increment dispute counter and emit event\n        emit DisputeRaised(disputeCount++, _reason);\n    }\n\n    /// @inheritdoc IDisputes\n    function attachDocument(uint256 _disputeID, bytes calldata _attachment)\n        external\n        override\n        resolvable(_disputeID)\n    {\n        // Local instance of variable. For saving gas.\n        Dispute storage _dispute = disputes[_disputeID];\n\n        // Check if sender is related to dispute\n        assertMember(_dispute.project, _dispute.taskID, _msgSender());\n\n        // Emit _attachment in event. To save it in logs.\n        emit DisputeAttachmentAdded(_disputeID, _msgSender(), _attachment);\n    }\n\n    /// @inheritdoc IDisputes\n    function resolveDispute(\n        uint256 _disputeID,\n        bytes calldata _judgement,\n        bool _ratify\n    ) external override onlyAdmin nonReentrant resolvable(_disputeID) {\n        // If dispute is accepted\n        if (_ratify) {\n            // Complete dispute actions\n            resolveHandler(_disputeID);\n\n            // Mark dispute as accepted\n            disputes[_disputeID].status = Status.Accepted;\n        }\n        // If dispute is rejected\n        else {\n            // Mark dispute as rejected\n            disputes[_disputeID].status = Status.Rejected;\n        }\n\n        emit DisputeResolved(_disputeID, _ratify, _judgement);\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    function assertMember(\n        address _project,\n        uint256 _taskID,\n        address _address\n    ) public view override {\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Get task subcontractor\n        (, address _sc, ) = _projectInstance.getTask(_taskID);\n\n        // Revert is signer is not builder, contractor or subcontractor.\n        bool _result = _projectInstance.builder() == _address ||\n            _projectInstance.contractor() == _address ||\n            _sc == _address;\n        require(_result, \"Disputes::!Member\");\n    }\n\n    /// @inheritdoc IDisputes\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IDisputes)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice Given an id, attempt to execute the action to enforce the arbitration\n\n     * @notice logic for decoding and enforcing outcome of arbitration judgement\n\n     * @param _disputeID uint256 - the dispute to attempt to\n     */\n    function resolveHandler(uint256 _disputeID) internal {\n        // Local instance of variable. For saving gas.\n        Dispute storage dispute = disputes[_disputeID];\n\n        // If action type is add task then execute add task\n        if (dispute.actionType == ActionType.TaskAdd) {\n            executeTaskAdd(dispute.project, dispute.actionData);\n        }\n        // If action type is task change then execute task change\n        else if (dispute.actionType == ActionType.TaskChange) {\n            executeTaskChange(dispute.project, dispute.actionData);\n        }\n        // Else execute task pay\n        else {\n            executeTaskPay(dispute.project, dispute.actionData);\n        }\n    }\n\n    /**\n     * @dev Arbitration enforcement of task change orders\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task add transaction data stored when dispute was raised\n     * - _hash bytes[] - bytes IPFS hash of task details\n     * - _taskCosts uint256[] - an array of cost for each task index\n     * - _taskCount uint256 - current task count before adding these tasks. Can be fetched by taskCount.\n     *   For signature security.\n     * - _projectAddress address - the address of this contract. For signature security.\n     */\n    function executeTaskAdd(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).addTasks(_actionData, bytes(\"\"));\n    }\n\n    /**\n     * @dev Arbitration enforcement of task change orders\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task change order transaction data stored when dispute was raised\n     * - _taskID uint256 - index of the task\n     * - _newSC address - address of new subcontractor.\n     *   If do not want to replace subcontractor, then pass address of existing subcontractor.\n     * - _newCost uint256 - new cost for the task.\n     *   If do not want to change cost, then pass existing cost.\n     * - _project address - address of project\n     */\n    function executeTaskChange(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).changeOrder(_actionData, bytes(\"\"));\n    }\n\n    /**\n     * @dev Arbitration enforcement of task payout\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task payout transaction data stored when dispute was raised\n     * - _taskID uint256 - the index of task\n     * - _projectAddress address - the address of this contract. For signature security.\n     */\n    function executeTaskPay(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).setComplete(_actionData, bytes(\"\"));\n    }\n}"
    },
    {
      "filename": "contracts/Community.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {ICommunity, IDebtToken} from \"./interfaces/ICommunity.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Community Contract for HomeFi v2.5.0\n \n * @notice Module for coordinating lending groups on HomeFi protocol\n */\ncontract Community is\n    ICommunity,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ---------------------FIXED INTERNAL STORED PROPERTIES---------------------- *\n     *******************************************************************************/\n    address internal tokenCurrency1;\n    address internal tokenCurrency2;\n    address internal tokenCurrency3;\n\n    /*******************************************************************************\n     * --------------------VARIABLE INTERNAL STORED PROPERTIES-------------------- *\n     *******************************************************************************/\n\n    mapping(uint256 => CommunityStruct) internal _communities;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    IHomeFi public override homeFi;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    bool public override restrictedToAdmin;\n    /// @inheritdoc ICommunity\n    uint256 public override communityCount;\n    /// @inheritdoc ICommunity\n    mapping(address => uint256) public override projectPublished;\n    /// @inheritdoc ICommunity\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00) (invalid)\n        require(_address != address(0), \"Community::0 address\");\n        _;\n    }\n\n    modifier onlyHomeFiAdmin() {\n        // Revert if sender is not homeFi admin\n        require(_msgSender() == homeFi.admin(), \"Community::!admin\");\n        _;\n    }\n\n    modifier isPublishedToCommunity(uint256 _communityID, address _project) {\n        // Revert if _project is not published to _communityID\n        require(\n            projectPublished[_project] == _communityID,\n            \"Community::!published\"\n        );\n        _;\n    }\n\n    modifier onlyProjectBuilder(address _project) {\n        // Revert if sender is not _project builder\n        require(\n            _msgSender() == IProject(_project).builder(),\n            \"Community::!Builder\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        // Initialize pausable. Set pause to false;\n        __Pausable_init();\n\n        // Initialize variables\n        homeFi = IHomeFi(_homeFi);\n        tokenCurrency1 = homeFi.tokenCurrency1();\n        tokenCurrency2 = homeFi.tokenCurrency2();\n        tokenCurrency3 = homeFi.tokenCurrency3();\n\n        // Community creation is paused for non admin by default paused\n        restrictedToAdmin = true;\n    }\n\n    /// @inheritdoc ICommunity\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        override\n        whenNotPaused\n    {\n        // Local variable for sender. For gas saving.\n        address _sender = _msgSender();\n\n        // Revert if community creation is paused or sender is not HomeFi admin\n        require(\n            !restrictedToAdmin || _sender == homeFi.admin(),\n            \"Community::!admin\"\n        );\n\n        // Revert if currency is not supported by HomeFi\n        homeFi.validCurrency(_currency);\n\n        // Increment community counter\n        communityCount++;\n\n        // Store community details\n        CommunityStruct storage _community = _communities[communityCount];\n        _community.owner = _sender;\n        _community.currency = IDebtToken(_currency);\n        _community.memberCount = 1;\n        _community.members[0] = _sender;\n        _community.isMember[_sender] = true;\n\n        emit CommunityAdded(communityCount, _sender, _currency, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function updateCommunityHash(uint256 _communityID, bytes calldata _hash)\n        external\n        override\n    {\n        // Revert if sender is not _communityID owner\n        require(\n            _communities[_communityID].owner == _msgSender(),\n            \"Community::!owner\"\n        );\n\n        // Emit event if _hash. This way this hash needs not be stored in memory.\n        emit UpdateCommunityHash(_communityID, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function addMember(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _newMemberAddr,\n            bytes memory _messageHash\n        ) = abi.decode(_data, (uint256, address, bytes));\n\n        CommunityStruct storage _community = _communities[_communityID];\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member\n\n        // Revert if new member already exists\n        require(\n            !_community.isMember[_newMemberAddr],\n            \"Community::Member Exists\"\n        );\n\n        // Store updated community details\n        uint256 _memberCount = _community.memberCount;\n        _community.memberCount = _memberCount + 1;\n        _community.members[_memberCount] = _newMemberAddr;\n        _community.isMember[_newMemberAddr] = true;\n\n        emit MemberAdded(_communityID, _newMemberAddr, _messageHash);\n    }\n\n    /// @inheritdoc ICommunity\n    function publishProject(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _project,\n            uint256 _apr,\n            uint256 _publishFee,\n            uint256 _publishNonce,\n            bytes memory _messageHash\n        ) = abi.decode(\n                _data,\n                (uint256, address, uint256, uint256, uint256, bytes)\n            );\n\n        // Local instance of community and community  project details. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(\n            _publishNonce == _community.publishNonce,\n            \"Community::invalid publishNonce\"\n        );\n\n        // Reverts if _project not originated from HomeFi\n        require(homeFi.isProjectExist(_project), \"Community::Project !Exists\");\n\n        // Local instance of variables. For saving gas.\n        IProject _projectInstance = IProject(_project);\n        address _builder = _projectInstance.builder();\n\n        // Revert if project builder is not community member\n        require(_community.isMember[_builder], \"Community::!Member\");\n\n        // Revert if project currency does not match community currency\n        require(\n            _projectInstance.currency() == _community.currency,\n            \"Community::!Currency\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be project builder\n\n        // If already published then unpublish first\n        if (projectPublished[_project] > 0) {\n            _unpublishProject(_project);\n        }\n\n        // Store updated details\n        _community.publishNonce = ++_community.publishNonce;\n        _communityProject.apr = _apr;\n        _communityProject.publishFee = _publishFee;\n        projectPublished[_project] = _communityID;\n\n        // If _publishFee is zero than mark publish fee as paid\n        if (_publishFee == 0) _communityProject.publishFeePaid = true;\n\n        emit ProjectPublished(\n            _communityID,\n            _project,\n            _apr,\n            _publishFee,\n            _communityProject.publishFeePaid,\n            _messageHash\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function unpublishProject(uint256 _communityID, address _project)\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Call internal function to unpublish project\n        _unpublishProject(_project);\n    }\n\n    /// @inheritdoc ICommunity\n    function payPublishFee(uint256 _communityID, address _project)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if publish fee already paid\n        require(\n            !_communityProject.publishFeePaid,\n            \"Community::publish fee paid\"\n        );\n\n        // Store updated detail\n        _communityProject.publishFeePaid = true;\n\n        // Transfer publishFee to community owner (lender)\n        _community.currency.safeTransferFrom(\n            _msgSender(),\n            _community.owner,\n            _communityProject.publishFee\n        );\n\n        emit PublishFeePaid(_communityID, _project);\n    }\n\n    /// @inheritdoc ICommunity\n    function toggleLendingNeeded(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingNeeded\n    )\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        // Revert if publish fee not paid\n        require(\n            _communityProject.publishFeePaid,\n            \"Community::publish fee !paid\"\n        );\n\n        // Revert if _lendingNeeded is more than projectCost or less than what is already lent\n        require(\n            _lendingNeeded >= _communityProject.totalLent &&\n                _lendingNeeded <= IProject(_project).projectCost(),\n            \"Community::invalid lending\"\n        );\n\n        // Store updated detail\n        _communityProject.lendingNeeded = _lendingNeeded;\n\n        emit ToggleLendingNeeded(_communityID, _project, _lendingNeeded);\n    }\n\n    /// @inheritdoc ICommunity\n    function lendToProject(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingAmount,\n        bytes calldata _hash\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        isPublish"
    }
  ]
}