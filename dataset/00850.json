{
  "Title": "Redundant event emission in `P2pSsvProxy.fallback`",
  "Content": "##### Description\nThis issue is found in the [`fallback`](https://github.com/p2p-org/p2p-ssv-proxy/blob/9dd4728002d9c275e29e8ba38bcf7d90efc7531b/src/p2pSsvProxy/P2pSsvProxy.sol#L164C56-L164C56) function of the `P2pSsvProxy` contract.\nThe current implementation emits an event before a `revert` operation. However, it's important to note that a transaction revert fully reverses all state changes made during the transaction, including the event log. This renders the event emission redundant and ineffective, as it will be erased upon the execution of `revert`.\n\n##### Recommendation\nWe recommend removing this event emission.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/p2pSsvProxy/P2pSsvProxy.sol",
      "content": "// SPDX-FileCopyrightText: 2023 P2P Validator <info@p2p.org>\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport \"../@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../constants/P2pConstants.sol\";\nimport \"../interfaces/ssv/ISSVNetwork.sol\";\nimport \"../interfaces/IDepositContract.sol\";\nimport \"../interfaces/p2p/IFeeDistributorFactory.sol\";\nimport \"../access/OwnableWithOperator.sol\";\nimport \"../assetRecovering/OwnableAssetRecoverer.sol\";\nimport \"../structs/P2pStructs.sol\";\nimport \"../p2pSsvProxyFactory/IP2pSsvProxyFactory.sol\";\nimport \"./IP2pSsvProxy.sol\";\n\n\n/// @notice _referenceFeeDistributor should implement IFeeDistributor interface\n/// @param _passedAddress passed address for _referenceFeeDistributor\nerror P2pSsvProxy__NotFeeDistributor(address _passedAddress);\n\n/// @notice Should be a P2pSsvProxyFactory contract\n/// @param _passedAddress passed address that does not support IP2pSsvProxyFactory interface\nerror P2pSsvProxy__NotP2pSsvProxyFactory(address _passedAddress);\n\n/// @notice Throws if called by any account other than the client.\n/// @param _caller address of the caller\n/// @param _client address of the client\nerror P2pSsvProxy__CallerNotClient(address _caller, address _client);\n\n/// @notice The caller was neither operator nor owner\n/// @param _caller address of the caller\n/// @param _operator address of the operator\n/// @param _owner address of the owner\nerror P2pSsvProxy__CallerNeitherOperatorNorOwner(address _caller, address _operator, address _owner);\n\n/// @notice The caller was neither operator nor owner nor client\n/// @param _caller address of the caller\nerror P2pSsvProxy__CallerNeitherOperatorNorOwnerNorClient(address _caller);\n\n/// @notice Only factory can call `initialize`.\n/// @param _msgSender sender address.\n/// @param _actualFactory the actual factory address that can call `initialize`.\nerror P2pSsvProxy__NotP2pSsvProxyFactoryCalled(address _msgSender, IP2pSsvProxyFactory _actualFactory);\n\n/// @notice _pubkeys and _operatorIds arrays should have the same lengths\nerror P2pSsvProxy__AmountOfParametersError();\n\n/// @notice Selector is not allowed for the caller.\n/// @param _caller caller address\n/// @param _selector function selector to be called on SSVNetwork\nerror P2pSsvProxy__SelectorNotAllowed(address _caller, bytes4 _selector);\n\n/// @title Proxy for SSVNetwork calls.\n/// @dev Each instance of P2pSsvProxy corresponds to 1 FeeDistributor instance.\n/// Thus, client to P2pSsvProxy instances is a 1-to-many relation.\n/// SSV tokens are managed by P2P.\n/// Clients cover the costs of SSV tokens by EL rewards via FeeDistributor instance.\ncontract P2pSsvProxy is OwnableAssetRecoverer, ERC165, IP2pSsvProxy {\n\n    /// @notice P2pSsvProxyFactory address\n    IP2pSsvProxyFactory private immutable i_p2pSsvProxyFactory;\n\n    /// @notice SSVNetwork address\n    ISSVNetwork private immutable i_ssvNetwork;\n\n    /// @notice SSV token (ERC-20) address\n    IERC20 private immutable i_ssvToken;\n\n    /// @notice FeeDistributor instance address\n    IFeeDistributor private s_feeDistributor;\n\n    /// @notice If caller is not client, revert\n    modifier onlyClient() {\n        address clientAddress = getClient();\n\n        if (clientAddress != msg.sender) {\n            revert P2pSsvProxy__CallerNotClient(msg.sender, clientAddress);\n        }\n        _;\n    }\n\n    /// @notice If caller is neither operator nor owner, revert\n    modifier onlyOperatorOrOwner() {\n        address currentOwner = owner();\n        address currentOperator = operator();\n\n        if (currentOperator != msg.sender && currentOwner != msg.sender) {\n            revert P2pSsvProxy__CallerNeitherOperatorNorOwner(msg.sender, currentOperator, currentOwner);\n        }\n\n        _;\n    }\n\n    /// @notice If caller is neither operator nor owner nor client, revert\n    modifier onlyOperatorOrOwnerOrClient() {\n        address operator_ = operator();\n        address owner_ = owner();\n        address client_ = getClient();\n\n        if (operator_ != msg.sender && owner_ != msg.sender && client_ != msg.sender) {\n            revert P2pSsvProxy__CallerNeitherOperatorNorOwnerNorClient(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice If caller is not factory, revert\n    modifier onlyP2pSsvProxyFactory() {\n        if (msg.sender != address(i_p2pSsvProxyFactory)) {\n            revert P2pSsvProxy__NotP2pSsvProxyFactoryCalled(msg.sender, i_p2pSsvProxyFactory);\n        }\n        _;\n    }\n\n    /// @dev Set values that are constant, common for all clients, known at the initial deploy time.\n    /// @param _p2pSsvProxyFactory address of P2pSsvProxyFactory\n    constructor(\n        address _p2pSsvProxyFactory\n    ) {\n        if (!ERC165Checker.supportsInterface(_p2pSsvProxyFactory, type(IP2pSsvProxyFactory).interfaceId)) {\n            revert P2pSsvProxy__NotP2pSsvProxyFactory(_p2pSsvProxyFactory);\n        }\n        i_p2pSsvProxyFactory = IP2pSsvProxyFactory(_p2pSsvProxyFactory);\n\n        i_ssvNetwork = (block.chainid == 1)\n            ? ISSVNetwork(0xDD9BC35aE942eF0cFa76930954a156B3fF30a4E1)\n            : ISSVNetwork(0xC3CD9A0aE89Fff83b71b58b6512D43F8a41f363D);\n\n        i_ssvToken = (block.chainid == 1)\n            ? IERC20(0x9D65fF81a3c488d585bBfb0Bfe3c7707c7917f54)\n            : IERC20(0x3a9f01091C446bdE031E39ea8354647AFef091E7);\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function initialize(\n        address _feeDistributor\n    ) external onlyP2pSsvProxyFactory {\n        s_feeDistributor = IFeeDistributor(_feeDistributor);\n\n        i_ssvToken.approve(address(i_ssvNetwork), type(uint256).max);\n\n        emit P2pSsvProxy__Initialized(_feeDistributor);\n    }\n\n    /// @dev Access any SSVNetwork function as cluster owner (this P2pSsvProxy instance)\n    /// Each selector access is managed by P2pSsvProxyFactory roles (owner, operator, client)\n    fallback() external {\n        address caller = msg.sender;\n        bytes4 selector = msg.sig;\n\n        bool isAllowed = msg.sender == owner() ||\n            (msg.sender == operator() && i_p2pSsvProxyFactory.isOperatorSelectorAllowed(selector)) ||\n            (msg.sender == getClient() && i_p2pSsvProxyFactory.isClientSelectorAllowed(selector));\n\n        if (!isAllowed) {\n            revert P2pSsvProxy__SelectorNotAllowed(caller, selector);\n        }\n\n        (bool success, bytes memory data) = address(i_ssvNetwork).call(msg.data);\n        if (success) {\n            emit P2pSsvProxy__SuccessfullyCalledViaFallback(caller, selector);\n\n            assembly {\n                return(add(data, 0x20), mload(data))\n            }\n        } else {\n            emit P2pSsvProxy__CallingViaFallbackFailed(caller, selector);\n\n            // Decode the reason from the error data returned from the call and revert with it.\n            revert(string(data));\n        }\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function registerValidators(\n        SsvPayload calldata _ssvPayload,\n        address _feeDistributorInstance\n    ) external onlyP2pSsvProxyFactory {\n        (\n            uint64[] memory operatorIds,\n            uint64 clusterIndex\n        ) = _getOperatorIdsAndClusterIndex(_ssvPayload.ssvOperators);\n\n        uint256 ssvSlot0 = uint256(_ssvPayload.ssvSlot0);\n\n        // see https://github.com/bloxapp/ssv-network/blob/1e61c35736578d4b03bacbff9da2128ad12a5620/contracts/libraries/ProtocolLib.sol#L15\n        uint64 currentNetworkFeeIndex = uint64(ssvSlot0 >> 192) + uint64(block.number - uint32(ssvSlot0)) * uint64(ssvSlot0 >> 128);\n\n        uint256 balance = _getBalance(_ssvPayload.cluster, clusterIndex, currentNetworkFeeIndex, _ssvPayload.tokenAmount);\n\n        i_ssvNetwork.registerValidator(\n            _ssvPayload.ssvValidators[0].pubkey,\n            operatorIds,\n            _ssvPayload.ssvValidators[0].sharesData,\n            _ssvPayload.tokenAmount,\n            _ssvPayload.cluster\n        );\n\n        for (uint256 i = 1; i < _ssvPayload.ssvValidators.length;) {\n            _registerValidator(\n                i,\n                operatorIds,\n                _ssvPayload.cluster,\n                clusterIndex,\n                _ssvPayload.ssvValidators[i].pubkey,\n                _ssvPayload.ssvValidators[i].sharesData,\n                currentNetworkFeeIndex,\n                balance\n            );\n\n            unchecked {++i;}\n        }\n\n        i_ssvNetwork.setFeeRecipientAddress(_feeDistributorInstance);\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function removeValidators(\n        bytes[] calldata _pubkeys,\n        uint64[] calldata _operatorIds,\n        ISSVNetwork.Cluster[] calldata _clusters\n    ) external onlyOperatorOrOwnerOrClient {\n        uint256 validatorCount = _pubkeys.length;\n\n        if (!(\n            _clusters.length == validatorCount\n        )) {\n            revert P2pSsvProxy__AmountOfParametersError();\n        }\n\n        for (uint256 i = 0; i < validatorCount;) {\n            i_ssvNetwork.removeValidator(_pubkeys[i], _operatorIds, _clusters[i]);\n\n            unchecked {++i;}\n        }\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function liquidate(\n        uint64[] calldata _operatorIds,\n        ISSVNetwork.Cluster[] calldata _clusters\n    ) external onlyOperatorOrOwner {\n        address clusterOwner = address(this);\n        uint256 validatorCount = _clusters.length;\n\n        for (uint256 i = 0; i < validatorCount;) {\n            i_ssvNetwork.liquidate(clusterOwner, _operatorIds, _clusters[i]);\n\n            unchecked {++i;}\n        }\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function reactivate(\n        uint256 _tokenAmount,\n        uint64[] calldata _operatorIds,\n        ISSVNetwork.Cluster[] calldata _clusters\n    ) external onlyOperatorOrOwner {\n        uint256 tokenPerValidator = _tokenAmount / _clusters.length;\n        uint256 validatorCount = _clusters.length;\n\n        for (uint256 i = 0; i < validatorCount;) {\n            i_ssvNetwork.reactivate(_operatorIds, tokenPerValidator, _clusters[i]);\n\n            unchecked {++i;}\n        }\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function depositToSSV(\n        uint256 _tokenAmount,\n        uint64[] calldata _operatorIds,\n        ISSVNetwork.Cluster[] calldata _clusters\n    ) external {\n        address clusterOwner = address(this);\n        uint256 validatorCount = _clusters.length;\n        uint256 tokenPerValidator = _tokenAmount / validatorCount;\n\n        for (uint256 i = 0; i < validatorCount;) {\n            i_ssvNetwork.deposit(clusterOwner, _operatorIds, tokenPerValidator, _clusters[i]);\n\n            unchecked {++i;}\n        }\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function withdrawFromSSV(\n        uint256 _tokenAmount,\n        uint64[] calldata _operatorIds,\n        ISSVNetwork.Cluster[] calldata _clusters\n    ) external onlyOperatorOrOwner {\n        uint256 tokenPerValidator = _tokenAmount / _clusters.length;\n        uint256 validatorCount = _clusters.length;\n\n        for (uint256 i = 0; i < validatorCount;) {\n            i_ssvNetwork.withdraw(_operatorIds, tokenPerValidator, _clusters[i]);\n\n            unchecked {++i;}\n        }\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function withdrawSSVTokens(\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        i_ssvToken.transfer(_to, _amount);\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function setFeeRecipientAddress(\n        address _feeRecipientAddress\n    ) external onlyOperatorOrOwner {\n        i_ssvNetwork.setFeeRecipientAddress(_feeRecipientAddress);\n    }\n\n    /// @notice Extract operatorIds and clusterIndex out of SsvOperator list\n    /// @param _ssvOperators list of SSV operator data\n    /// @return operatorIds list of SSV operator IDs, clusterIndex updated cluster index\n    function _getOperatorIdsAndClusterIndex(\n        SsvOperator[] calldata _ssvOperators\n    ) private view returns(\n        uint64[] memory operatorIds,\n        uint64 clusterIndex\n    ) {\n        // clusterIndex updating logic reflects\n        // https://github.com/bloxapp/ssv-network/blob/fe3b9b178344dd723b19792d01ab5010dfd2dcf9/contracts/modules/SSVClusters.sol#L77\n\n        clusterIndex = 0;\n        uint256 operatorCount = _ssvOperators.length;\n        operatorIds = new uint64[](operatorCount);\n        for (uint256 i = 0; i < operatorCount;) {\n            operatorIds[i] = _ssvOperators[i].id;\n\n            uint256 snapshot = uint256(_ssvOperators[i].snapshot);\n\n            // see https://github.com/bloxapp/ssv-network/blob/6ae5903a5c99c8d75b59fc0d35574d87f82e5861/contracts/libraries/OperatorLib.sol#L13\n            clusterIndex += uint64(snapshot >> 32) + (uint32(block.number) - uint32(snapshot)) * uint64(_ssvOperators[i].fee / 10_000_000);\n\n            unchecked {++i;}\n        }\n    }\n\n    /// @notice Calculate the balance for the subsequent cluster values in a batch\n    /// @param _cluster cluster value before the 1st validator registration\n    /// @param _newIndex clusterIndex value after the 1st validator registration\n    /// @param _currentNetworkFeeIndex currentNetworkFeeIndex from ssvSlot0\n    /// @param _tokenAmount amount of SSV tokens deposited along with the 1st validator registration\n    /// @return balance updated balance after the 1st validator registration\n    function _getBalance(\n        ISSVNetwork.Cluster calldata _cluster,\n        uint64 _newIndex,\n        uint64 _currentNetworkFeeIndex,\n        uint256 _tokenAmount\n    ) private pure returns(uint256 balance) {\n        uint256 balanceBefore = _cluster.balance + _tokenAmount;\n\n        // see https://github.com/bloxapp/ssv-network/blob/1e61c35736578d4b03bacbff9da2128ad12a5620/contracts/libraries/ClusterLib.sol#L16\n        uint64 networkFee = uint64(_currentNetworkFeeIndex - _cluster.networkFeeIndex) * _cluster.validatorCount;\n        uint64 usage = (_newIndex - _cluster.index) * _cluster.validatorCount + networkFee;\n        uint256 expandedUsage = usage * 10_000_000;\n        balance = expandedUsage > balanceBefore? 0 : balanceBefore - expandedUsage;\n    }\n\n    /// @notice Register subsequent validators after the 1st one\n    /// @param i validator index in calldata\n    /// @param _operatorIds list of SSV operator IDs\n    /// @param _cluster cluster value before the 1st registration\n    /// @param _clusterIndex calculated clusterIndex after the 1st registration\n    /// @param _pubkey validator pubkey\n    /// @param _sharesData validator SSV sharesData\n    /// @param _currentNetworkFeeIndex currentNetworkFeeIndex from ssvSlot0\n    /// @param _balance cluster balance after the 1st validator registration\n    function _registerValidator(\n        uint256 i,\n        uint64[] memory _operatorIds,\n        ISSVNetwork.Cluster calldata _cluster,\n        uint64 _clusterIndex,\n        bytes calldata _pubkey,\n        bytes calldata _sharesData,\n        uint64 _currentNetworkFeeIndex,\n        uint256 _balance\n    ) private {\n        ISSVClusters.Cluster memory cluster = ISSVClusters.Cluster({\n            validatorCount: uint32(_cluster.validatorCount + i),\n            networkFeeIndex: _currentNetworkFeeIndex,\n            index: _clusterIndex,\n            active: true,\n            balance: _balance\n        });\n\n        i_ssvNetwork.registerValidator(\n            _pubkey,\n            _operatorIds,\n            _sharesData,\n            0,\n            cluster\n        );\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function getClient() public view returns (address) {\n        return s_feeDistributor.client();\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function getFactory() external view returns (address) {\n        return address(i_p2pSsvProxyFactory);\n    }\n\n    /// @inheritdoc IOwnable\n    function owner() public view override(OwnableBase, IOwnable) returns (address) {\n        return i_p2pSsvProxyFactory.owner();\n    }\n\n    /// @inheritdoc IOwnableWithOperator\n    function operator() public view returns (address) {\n        return i_p2pSsvProxyFactory.operator();\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function getFeeDistributor() external view returns (address) {\n        return address(s_feeDistributor);\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IP2pSsvProxy).interfaceId || super.supportsInterface(interfaceId);\n    }\n}"
    }
  ]
}