{
  "Title": "[L-03] `getDeployedControllers()` will not return the last index",
  "Content": "\n[WildcatMarketControllerFactory Line 138](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatMarketControllerFactory.sol#L138)\n\n### Issue Description\n\nThe `getDeployedControllers()` function takes a start and end index of the controllers to be retrieved. However, due to the current implementation of the function, it only returns controllers from the start index to `end-1`. In other words, the controller at the `end` index is not included in the returned list. \n\n### POC\n\nThis simple POC can be added to the `WIldcatMarketController` test to check for the issue.\n\n```solidity\nfunction test_getControllers() external {\n//Deploy 10 contracts\n\tfor(uint256 i = 0; i < 10; i++)\n\t{\n\t\tcontrollerFactory.deployController();\n\t}\n\t  \n\t//Want to access 2-7 (6 controllers)\n\taddress[] memory controllers = controllerFactory.getDeployedControllers(2, 7);\n\t\n\t//Check that the length is correct\n\trequire(controllers.length == 5, \"We have not received an incorrect number\");\n\t\n\t//We only received controllers 2-6 due to the implementation\n}\n```\n\nThe same issue also exists in the functions:\n- `WildcatMarketController.getAuthorizedLenders()`\n- `WildcatMarketController.getControlledMarkets()`\n- `WildcatArchController.getRegisteredBorrowers()`\n- `WildcatArchController.getRegisteredControllerFactories()`\n- `WildcatArchController.getRegisteredControllers()`\n- `WildcatArchController.getRegisteredMarkets()`\n\n### Recommended Mitigation Steps\n\nTo resolve this issue, the `getDeployedControllers()` function should be rewritten as follows:\n\n```solidity\nfunction getDeployedControllers(\nuint256 start,\nuint256 end\n) external view returns (address[] memory arr) {\n\tuint256 len = _deployedControllers.length();\n\tend = MathUtils.min(end, len-1);\n\tuint256 count = end - start + 1;\n\tarr = new address[](count);\n\tfor (uint256 i = 0; i < count; i++) {\n\t\tarr[i] = _deployedControllers.at(start + i);\n\t}\n}\n```\n\nThe same change should be applied to other affected functions as well.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/WildcatMarketControllerFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport './interfaces/WildcatStructsAndEnums.sol';\nimport './interfaces/IWildcatMarketController.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\nimport './market/WildcatMarket.sol';\nimport './WildcatMarketController.sol';\n\ncontract WildcatMarketControllerFactory {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  event NewController(address borrower, address controller, string namePrefix, string symbolPrefix);\n  event UpdateProtocolFeeConfiguration(\n    address feeRecipient,\n    uint16 protocolFeeBips,\n    address originationFeeAsset,\n    uint256 originationFeeAmount\n  );\n\n  error NotRegisteredBorrower();\n  error InvalidProtocolFeeConfiguration();\n  error CallerNotArchControllerOwner();\n  error InvalidConstraints();\n  error ControllerAlreadyDeployed();\n\n  // Returns immutable arch-controller\n  IWildcatArchController public immutable archController;\n\n  // Returns sentinel used by controller\n  address public immutable sentinel;\n\n  address public immutable marketInitCodeStorage;\n\n  uint256 public immutable marketInitCodeHash;\n\n  address public immutable controllerInitCodeStorage;\n\n  uint256 public immutable controllerInitCodeHash;\n\n  uint256 internal immutable ownCreate2Prefix = LibStoredInitCode.getCreate2Prefix(address(this));\n\n  uint32 internal immutable MinimumDelinquencyGracePeriod;\n  uint32 internal immutable MaximumDelinquencyGracePeriod;\n\n  uint16 internal immutable MinimumReserveRatioBips;\n  uint16 internal immutable MaximumReserveRatioBips;\n\n  uint16 internal immutable MinimumDelinquencyFeeBips;\n  uint16 internal immutable MaximumDelinquencyFeeBips;\n\n  uint32 internal immutable MinimumWithdrawalBatchDuration;\n  uint32 internal immutable MaximumWithdrawalBatchDuration;\n\n  uint16 internal immutable MinimumAnnualInterestBips;\n  uint16 internal immutable MaximumAnnualInterestBips;\n\n  ProtocolFeeConfiguration internal _protocolFeeConfiguration;\n\n  EnumerableSet.AddressSet internal _deployedControllers;\n\n  modifier onlyArchControllerOwner() {\n    if (msg.sender != archController.owner()) {\n      revert CallerNotArchControllerOwner();\n    }\n    _;\n  }\n\n  constructor(\n    address _archController,\n    address _sentinel,\n    MarketParameterConstraints memory constraints\n  ) {\n    archController = IWildcatArchController(_archController);\n    sentinel = _sentinel;\n    if (\n      constraints.minimumAnnualInterestBips > constraints.maximumAnnualInterestBips ||\n      constraints.maximumAnnualInterestBips > 10000 ||\n      constraints.minimumDelinquencyFeeBips > constraints.maximumDelinquencyFeeBips ||\n      constraints.maximumDelinquencyFeeBips > 10000 ||\n      constraints.minimumReserveRatioBips > constraints.maximumReserveRatioBips ||\n      constraints.maximumReserveRatioBips > 10000 ||\n      constraints.minimumDelinquencyGracePeriod > constraints.maximumDelinquencyGracePeriod ||\n      constraints.minimumWithdrawalBatchDuration > constraints.maximumWithdrawalBatchDuration\n    ) {\n      revert InvalidConstraints();\n    }\n    MinimumDelinquencyGracePeriod = constraints.minimumDelinquencyGracePeriod;\n    MaximumDelinquencyGracePeriod = constraints.maximumDelinquencyGracePeriod;\n    MinimumReserveRatioBips = constraints.minimumReserveRatioBips;\n    MaximumReserveRatioBips = constraints.maximumReserveRatioBips;\n    MinimumDelinquencyFeeBips = constraints.minimumDelinquencyFeeBips;\n    MaximumDelinquencyFeeBips = constraints.maximumDelinquencyFeeBips;\n    MinimumWithdrawalBatchDuration = constraints.minimumWithdrawalBatchDuration;\n    MaximumWithdrawalBatchDuration = constraints.maximumWithdrawalBatchDuration;\n    MinimumAnnualInterestBips = constraints.minimumAnnualInterestBips;\n    MaximumAnnualInterestBips = constraints.maximumAnnualInterestBips;\n\n    (controllerInitCodeStorage, controllerInitCodeHash) = _storeControllerInitCode();\n    (marketInitCodeStorage, marketInitCodeHash) = _storeMarketInitCode();\n  }\n\n  function _storeControllerInitCode()\n    internal\n    virtual\n    returns (address initCodeStorage, uint256 initCodeHash)\n  {\n    bytes memory controllerInitCode = type(WildcatMarketController).creationCode;\n    initCodeHash = uint256(keccak256(controllerInitCode));\n    initCodeStorage = LibStoredInitCode.deployInitCode(controllerInitCode);\n  }\n\n  function _storeMarketInitCode()\n    internal\n    virtual\n    returns (address initCodeStorage, uint256 initCodeHash)\n  {\n    bytes memory marketInitCode = type(WildcatMarket).creationCode;\n    initCodeHash = uint256(keccak256(marketInitCode));\n    initCodeStorage = LibStoredInitCode.deployInitCode(marketInitCode);\n  }\n\n  function isDeployedController(address controller) external view returns (bool) {\n    return _deployedControllers.contains(controller);\n  }\n\n  function getDeployedControllersCount() external view returns (uint256) {\n    return _deployedControllers.length();\n  }\n\n  function getDeployedControllers() external view returns (address[] memory) {\n    return _deployedControllers.values();\n  }\n\n  function getDeployedControllers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _deployedControllers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _deployedControllers.at(start + i);\n    }\n  }\n\n  /**\n   * @dev Returns protocol fee configuration for new markets.\n   *\n   *      These can be updated by the arch-controller owner but\n   *      `protocolFeeBips` and `feeRecipient` are immutable once\n   *      a market is deployed.\n   *\n   * @return feeRecipient         feeRecipient to use in new markets\n   * @return originationFeeAsset  Asset used to pay fees for new market\n   *                              deployments\n   * @return originationFeeAmount Amount of originationFeeAsset paid\n   *                              for new market deployments\n   * @return protocolFeeBips      protocolFeeBips to use in new markets\n   */\n  function getProtocolFeeConfiguration()\n    external\n    view\n    returns (\n      address feeRecipient,\n      address originationFeeAsset,\n      uint80 originationFeeAmount,\n      uint16 protocolFeeBips\n    )\n  {\n    return (\n      _protocolFeeConfiguration.feeRecipient,\n      _protocolFeeConfiguration.originationFeeAsset,\n      _protocolFeeConfiguration.originationFeeAmount,\n      _protocolFeeConfiguration.protocolFeeBips\n    );\n  }\n\n  /**\n   * @dev Sets protocol fee configuration for new market deployments via\n   *      controllers deployed by this factory.\n   *\n   *      If caller is not `archController.owner()`, reverts with\n   *      `NotArchControllerOwner`.\n   *\n   *      Revert with `InvalidProtocolFeeConfiguration` if:\n   *      - `protocolFeeBips > 0 && feeRecipient == address(0)`\n   *      - OR `originationFeeAmount > 0 && originationFeeAsset == address(0)`\n   *      - OR `originationFeeAmount > 0 && feeRecipient == address(0)`\n   */\n  function setProtocolFeeConfiguration(\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) external onlyArchControllerOwner {\n    bool hasOriginationFee = originationFeeAmount > 0;\n    bool nullFeeRecipient = feeRecipient == address(0);\n    bool nullOriginationFeeAsset = originationFeeAsset == address(0);\n    if (\n      (protocolFeeBips > 0 && nullFeeRecipient) ||\n      (hasOriginationFee && nullFeeRecipient) ||\n      (hasOriginationFee && nullOriginationFeeAsset)\n    ) {\n      revert InvalidProtocolFeeConfiguration();\n    }\n    _protocolFeeConfiguration = ProtocolFeeConfiguration({\n      feeRecipient: feeRecipient,\n      originationFeeAsset: originationFeeAsset,\n      originationFeeAmount: originationFeeAmount,\n      protocolFeeBips: protocolFeeBips\n    });\n  }\n\n  /**\n   * @dev Returns immutable constraints on market parameters that\n   *      the controller variant will enforce.\n   */\n  function getParameterConstraints()\n    external\n    view\n    returns (MarketParameterConstraints memory constraints)\n  {\n    constraints.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    constraints.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    constraints.minimumReserveRatioBips = MinimumReserveRatioBips;\n    constraints.maximumReserveRatioBips = MaximumReserveRatioBips;\n    constraints.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    constraints.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    constraints.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    constraints.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    constraints.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    constraints.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                            Controller Deployment                           */\n  /* -------------------------------------------------------------------------- */\n\n  address internal _tmpMarketBorrowerParameter = address(1);\n\n  function getMarketControllerParameters()\n    external\n    view\n    virtual\n    returns (MarketControllerParameters memory parameters)\n  {\n    parameters.archController = address(archController);\n    parameters.borrower = _tmpMarketBorrowerParameter;\n    parameters.sentinel = sentinel;\n    parameters.marketInitCodeStorage = marketInitCodeStorage;\n    parameters.marketInitCodeHash = marketInitCodeHash;\n    parameters.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    parameters.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    parameters.minimumReserveRatioBips = MinimumReserveRatioBips;\n    parameters.maximumReserveRatioBips = MaximumReserveRatioBips;\n    parameters.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    parameters.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    parameters.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    parameters.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    parameters.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    parameters.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarketController`\n   *      unique to the borrower and registers it with the arch-controller.\n   *\n   *      If a controller is already deployed for the borrower, reverts\n   *      with `ControllerAlreadyDeployed`.\n   *\n   *\t  If `archController.isRegisteredBorrower(msg.sender)` returns false\n   *      reverts with `NotRegisteredBorrower`.\n   *\n   *      Calls `archController.registerController(controller)` and emits\n   *      `NewController(borrower, controller)`.\n   */\n  function deployController() public returns (address controller) {\n    if (!archController.isRegisteredBorrower(msg.sender)) {\n      revert NotRegisteredBorrower();\n    }\n    _tmpMarketBorrowerParameter = msg.sender;\n    // Salt is borrower address\n    bytes32 salt = bytes32(uint256(uint160(msg.sender)));\n    controller = LibStoredInitCode.calculateCreate2Address(\n      ownCreate2Prefix,\n      salt,\n      controllerInitCodeHash\n    );\n    if (controller.codehash != bytes32(0)) {\n      revert ControllerAlreadyDeployed();\n    }\n    LibStoredInitCode.create2WithStoredInitCode(controllerInitCodeStorage, salt);\n    _tmpMarketBorrowerParameter = address(1);\n    archController.registerController(controller);\n    _deployedControllers.add(controller);\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarketController`\n   *      unique to the borrower and registers it with the arch-controller,\n   *      then deploys a new market through the controller.\n   *\n   *      If a controller is already deployed for the borrower, reverts\n   *      with `ControllerAlreadyDeployed`.\n   *\n   *\t  If `archController.isRegisteredBorrower(msg.sender)` returns false\n   *\t  reverts with `NotRegisteredBorrower`.\n   *\n   *      Calls `archController.registerController(controller)` and emits\n   * \t  `NewController(borrower, controller, namePrefix, symbolPrefix)`.\n   */\n  function deployControllerAndMarket(\n    string memory namePrefix,\n    string memory symbolPrefix,\n    address asset,\n    uint128 maxTotalSupply,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) external returns (address controller, address market) {\n    controller = deployController();\n    market = IWildcatMarketController(controller).deployMarket(\n      asset,\n      namePrefix,\n      symbolPrefix,\n      maxTotalSupply,\n      annualInterestBips,\n      delinquencyFeeBips,\n      withdrawalBatchDuration,\n      reserveRatioBips,\n      delinquencyGracePeriod\n    );\n  }\n\n  function computeControllerAddress(address borrower) external view returns (address) {\n    // Salt is borrower address\n    bytes32 salt = bytes32(uint256(uint160(borrower)));\n    return\n      LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, controllerInitCodeHash);\n  }\n}"
    }
  ]
}