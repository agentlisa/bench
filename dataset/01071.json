{
  "Title": "M-5: Uniswap Aggregated Fees Can be Increased at Close to Zero Cost",
  "Content": "# Issue M-5: Uniswap Aggregated Fees Can be Increased at Close to Zero Cost \n\nSource: https://github.com/sherlock-audit/2023-10-aloe-judging/issues/45 \n\n## Found by \nBandit\n\nThe recorded fee collection in a Uniswap pool can be manipulated in the method described below while paying very little in \"real\" fees. This means that `IV` can be pushed upwards to unfairly liquidate pre-existing borrowers.\n\n## Vulnerability Detail\n\nIn a sufficiently liquid pool and high trading volume, the potential attack profits you may get from swapping a large amount of tokens back and forth is likely lower than the profit an attacker can make from manipulating IV. This is especially true due to the `IV_CHANGE_PER_UPDATE` which limits of the amount that IV can be manipulated per update.\n\nHowever, its possible to boost the recorded trading fees via trading fees while paying a very small cost relative to the fee increase amount.\n\nThe attack rests on 2 facts:\n\n1. Aside from pools where the 2 pool assets are pegged to the same value, only a tiny portion of the total liquidity is in the \"in-range\" `tickSpacing`. \n2. In Uniswap, 100% of fees goes to the liquidity providers, in proportion to liquidity at the active tick, or ticks that gets passed through. This is different from other exchanges, where some portion of fees is distrubted to token holders, or the exchange operator.\n\nDue to (1), a user with a large amount of capital can deposit all of it in the active tick and have >99% of the liquidity in the active tick. Due to (2), this also means that if they wash trade while keeping the price within that tick, they get >99% of the trading fees captured by their LP position. If $200K is deposited into that tick, then up to $200k can be traded, if the pool price starts exactly at the lower tick and ends at the upper tick, or vice versa. \n\nThe wash trading can performed in one flashbots bundle, and since the trades are basically against the oneself, the trading profits-and-loss and impermanant gain/loss approximately cancel out.\n\nManipulating fees higher drives the `IV` higher, which in turn reduces the `LTV`. Let's say a position is not liquidatable yet, but a reduction in LTV will make that position liquidatable. There is profit incentive for an attacker to use the wash trading manipulation to decrease the LTV and then liquidate that position.\n\nNote that this efficiency in wash trading to inflate fees is only possible in Uniswap v3. In v2 style pools, liquidity cannot be concentrated and it is impractical to deposit enough liquidity to capture the overwhelming majority of an entire pool. Most CLOB such as dYdX, IDEX etc have some fees that go to the protocol or token stakers (Uniswap 100% of \"taker\" fees go to LP's or \"makers\"), which means that even though a maker and taker order can be matched by wash traders, there is still significant fee externalisation to the protocol.\n\n## Impact\n\n- `IV` is cheaply and easily manipulated upwards, and thus `LTV` can be decreased, which can unfairly liquidate users\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/libraries/Volatility.sol#L44-L81\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUsing the MEDIAN fee of many short price intervals to calculate the Uniswap fees makes it more difficult to manipulate. The median, unlike mean (which is also implicitly used in the context a TWAP), is unaffected by large manipulations in a single block.\n\n\n\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> medium, because the volatility manipulation is still limited and not free, but possible to do to unfairly liquidate the accounts\n\n**MohammedRizwan** commented:\n>  valid\n\n\n\n**haydenshively**\n\nManipulation is actually easier than that; an attacker can simply overpay in a flash swap and Uniswap will credit the overpayment directly to fee growth globals. The `IV_CHANGE_PER_UPDATE` constrains the impact of such an attack, making it quite expensive for limited payoff, especially considering the attacker doesn't know whether potential victims will respond to `Warn` or not. Medium for these reasons.\n\nAs for a fix, we could lower the constant to further constrain the attack. Since we're increasing the liquidation grace period in response to #73, borrowers should have more time to respond to unfair liquidations. And we could try to do the median feeGrowthGlobals thing as part of #91 improvements.\n\n**haydenshively**\n\nFixed in https://github.com/aloelabs/aloe-ii/pull/219\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/120",
  "Code": [
    {
      "filename": "aloe-ii/core/src/libraries/Volatility.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Math} from \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {FixedPointMathLib as SoladyMath} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {square, mulDiv96, mulDiv128, mulDiv224} from \"./MulDiv.sol\";\nimport {Oracle} from \"./Oracle.sol\";\nimport {TickMath} from \"./TickMath.sol\";\n\n/// @title Volatility\n/// @notice Provides functions that use Uniswap v3 to compute price volatility\n/// @author Aloe Labs, Inc.\nlibrary Volatility {\n    struct PoolMetadata {\n        // the overall fee minus the protocol fee for token0, times 1e6\n        uint24 gamma0;\n        // the overall fee minus the protocol fee for token1, times 1e6\n        uint24 gamma1;\n        // the pool tick spacing\n        int24 tickSpacing;\n    }\n\n    struct FeeGrowthGlobals {\n        // the fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n        uint256 feeGrowthGlobal0X128;\n        // the fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n        uint256 feeGrowthGlobal1X128;\n        // the block timestamp at which feeGrowthGlobal0X128 and feeGrowthGlobal1X128 were last updated\n        uint32 timestamp;\n    }\n\n    /**\n     * @notice Estimates implied volatility using\n     * [this math](https://lambert-guillaume.medium.com/on-chain-volatility-and-uniswap-v3-d031b98143d1).\n     * @dev The return value can fit in uint128 if necessary\n     * @param metadata The pool's metadata (may be cached)\n     * @param data A summary of the pool's state from `pool.slot0` `pool.observe` and `pool.liquidity`\n     * @param a The pool's cumulative feeGrowthGlobals some time in the past\n     * @param b The pool's cumulative feeGrowthGlobals as of the current block\n     * @param scale The timescale (in seconds) in which IV should be reported, e.g. hourly, daily, annualized\n     * @return An estimate of the implied volatility scaled by 1e12\n     */\n    function estimate(\n        PoolMetadata memory metadata,\n        Oracle.PoolData memory data,\n        FeeGrowthGlobals memory a,\n        FeeGrowthGlobals memory b,\n        uint32 scale\n    ) internal pure returns (uint256) {\n        uint256 tickTvl = computeTickTvl(metadata.tickSpacing, data.currentTick, data.sqrtPriceX96, data.tickLiquidity);\n\n        // Return early to avoid division by 0\n        if (data.secondsPerLiquidityX128 == 0 || b.timestamp - a.timestamp == 0 || tickTvl == 0) return 0;\n\n        uint256 revenue0Gamma1 = computeRevenueGamma(\n            a.feeGrowthGlobal0X128,\n            b.feeGrowthGlobal0X128,\n            data.secondsPerLiquidityX128,\n            data.oracleLookback,\n            metadata.gamma1\n        );\n        uint256 revenue1Gamma0 = computeRevenueGamma(\n            a.feeGrowthGlobal1X128,\n            b.feeGrowthGlobal1X128,\n            data.secondsPerLiquidityX128,\n            data.oracleLookback,\n            metadata.gamma0\n        );\n        // This is an approximation. Ideally the fees earned during each swap would be multiplied by the price\n        // *at that swap*. But for prices simulated with GBM and swap sizes either normally or uniformly distributed,\n        // the error you get from using geometric mean price is <1% even with high drift and volatility.\n        uint256 volumeGamma0Gamma1 = revenue1Gamma0 + amount0ToAmount1(revenue0Gamma1, data.sqrtMeanPriceX96);\n        // Clamp to prevent overflow later on\n        if (volumeGamma0Gamma1 > (1 << 128)) volumeGamma0Gamma1 = (1 << 128);\n\n        unchecked {\n            // Scale volume to the target time frame, divide by `tickTvl`, and sqrt for final result\n            return SoladyMath.sqrt((4e24 * volumeGamma0Gamma1 * scale) / (b.timestamp - a.timestamp) / tickTvl);\n        }\n    }\n\n    /**\n     * @notice Computes an `amount1` that (at `tick`) is equivalent in worth to the provided `amount0`\n     * @param amount0 The amount of token0 to convert\n     * @param sqrtPriceX96 The sqrt(price) at which the conversion should hold true\n     * @return amount1 An equivalent amount of token1\n     */\n    function amount0ToAmount1(uint256 amount0, uint160 sqrtPriceX96) internal pure returns (uint256 amount1) {\n        uint256 priceX128 = square(sqrtPriceX96);\n        amount1 = mulDiv128(amount0, priceX128);\n    }\n\n    /**\n     * @notice Computes pool revenue using feeGrowthGlobal accumulators, then scales it down by a factor of gamma\n     * @param feeGrowthGlobalAX128 The value of feeGrowthGlobal (either 0 or 1) at time A\n     * @param feeGrowthGlobalBX128 The value of feeGrowthGlobal (either 0 or 1, but matching) at time B (B > A)\n     * @param secondsPerLiquidityX128 The difference in the secondsPerLiquidity accumulator from `secondsAgo` seconds ago until now\n     * @param secondsAgo The oracle lookback period that was used to find `secondsPerLiquidityX128`\n     * @param gamma The fee factor to scale by\n     * @return Revenue over the period from `block.timestamp - secondsAgo` to `block.timestamp`, scaled down by a factor of gamma\n     */\n    function computeRevenueGamma(\n        uint256 feeGrowthGlobalAX128,\n        uint256 feeGrowthGlobalBX128,\n        uint160 secondsPerLiquidityX128,\n        uint32 secondsAgo,\n        uint24 gamma\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 delta;\n\n            if (feeGrowthGlobalBX128 >= feeGrowthGlobalAX128) {\n                // feeGrowthGlobal has increased from time A to time B\n                delta = feeGrowthGlobalBX128 - feeGrowthGlobalAX128;\n            } else {\n                // feeGrowthGlobal has overflowed between time A and time B\n                delta = type(uint256).max - feeGrowthGlobalAX128 + feeGrowthGlobalBX128;\n            }\n\n            return Math.mulDiv(delta, secondsAgo * uint256(gamma), secondsPerLiquidityX128 * uint256(1e6));\n        }\n    }\n\n    /**\n     * @notice Computes the value of liquidity available at the current tick, denominated in token1\n     * @param tickSpacing The pool tick spacing (from pool.tickSpacing())\n     * @param tick The current tick (from pool.slot0())\n     * @param sqrtPriceX96 The current price (from pool.slot0())\n     * @param liquidity The liquidity depth at currentTick (from pool.liquidity())\n     */\n    function computeTickTvl(\n        int24 tickSpacing,\n        int24 tick,\n        uint160 sqrtPriceX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 tickTvl) {\n        unchecked {\n            tick = TickMath.floor(tick, tickSpacing);\n\n            tickTvl = _getValueOfLiquidity(\n                sqrtPriceX96,\n                TickMath.getSqrtRatioAtTick(tick),\n                TickMath.getSqrtRatioAtTick(tick + tickSpacing),\n                liquidity\n            );\n        }\n    }\n\n    /**\n     * @notice Computes the value of the liquidity in terms of token1\n     * @dev The return value can fit in uint193 if necessary\n     * @param sqrtRatioX96 A sqrt price representing the current pool prices\n     * @param sqrtRatioAX96 A sqrt price representing the lower tick boundary\n     * @param sqrtRatioBX96 A sqrt price representing the upper tick boundary\n     * @param liquidity The liquidity being valued\n     * @return value The total value of `liquidity`, in terms of token1\n     */\n    function _getValueOfLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) private pure returns (uint256 value) {\n        assert(sqrtRatioAX96 <= sqrtRatioX96 && sqrtRatioX96 <= sqrtRatioBX96);\n\n        unchecked {\n            uint256 numerator = Math.mulDiv(uint256(liquidity) << 128, sqrtRatioX96, sqrtRatioBX96);\n\n            value =\n                mulDiv224(numerator, sqrtRatioBX96 - sqrtRatioX96) +\n                mulDiv96(liquidity, sqrtRatioX96 - sqrtRatioAX96);\n        }\n    }\n}"
    }
  ]
}