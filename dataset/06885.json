{
  "Title": "[L-01] AVOID USING TX.ORIGIN",
  "Content": "\ntx.origin is a global variable in Solidity that returns the address of the account that sent the transaction.\n\nUsing the variable could make a contract vulnerable if an authorized account calls a malicious contract. You can impersonate a user using a third party contract.\n\nFILE : 2023-03-canto-identity/canto-pfp-protocol/src/ProfilePicture.sol\n\n    63:  turnstile.register(tx.origin);\n\n[ProfilePicture.sol#L63](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-pfp-protocol/src/ProfilePicture.sol#L63)\n\nFILE : 2023-03-canto-identity/canto-bio-protocol/src/Bio.sol\n\n    36: turnstile.register(tx.origin);\n\n[Bio.sol#L36](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-bio-protocol/src/Bio.sol#L36)\n\nFILE : 2023-03-canto-identity/canto-namespace-protocol/src/Namespace.sol\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2023-03-canto-identity-subprotocols-contest",
  "Code": [
    {
      "filename": "canto-pfp-protocol/src/ProfilePicture.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport \"../interface/Turnstile.sol\";\nimport \"../interface/ICidNFT.sol\";\n\ncontract ProfilePicture is ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Reference to the CID NFT\n    ICidNFT private immutable cidNFT;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Data that is stored per PFP\n    struct ProfilePictureData {\n        /// @notice Reference to the NFT contract\n        address nftContract;\n        /// @notice Referenced nft ID\n        uint256 nftID;\n    }\n\n    /// @notice Number of tokens minted\n    uint256 public numMinted;\n\n    /// @notice Stores the pfp data per NFT\n    mapping(uint256 => ProfilePictureData) private pfp;\n\n    /// @notice Name with which the subprotocol is registered\n    string public subprotocolName;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event PfpAdded(\n        address indexed minter,\n        uint256 indexed pfpNftID,\n        address indexed referencedContract,\n        uint256 referencedNftId\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error PFPNoLongerOwnedByOriginalOwner(uint256 tokenID);\n    error PFPNotOwnedByCaller(address caller, address nftContract, uint256 nftID);\n\n    /// @notice Initiates CSR on mainnet\n    /// @param _cidNFT Address of the CID NFT\n    /// @param _subprotocolName Name with which the subprotocol is / will be registered in the registry. Registration will not be performed automatically\n    constructor(address _cidNFT, string memory _subprotocolName) ERC721(\"Profile Picture\", \"PFP\") {\n        cidNFT = ICidNFT(_cidNFT);\n        subprotocolName = _subprotocolName;\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @param _id ID to query for\n    /// @dev Reverts if PFP is no longer owned by owner of associated CID NFT\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        (address nftContract, uint256 nftID) = getPFP(_id);\n        if (nftContract == address(0)) revert PFPNoLongerOwnedByOriginalOwner(_id);\n        return ERC721(nftContract).tokenURI(nftID);\n    }\n\n    /// @notice Mint a new PFP NFT\n    /// @param _nftContract The nft contract address to reference\n    /// @param _nftID The nft ID to reference\n    function mint(address _nftContract, uint256 _nftID) external {\n        uint256 tokenId = ++numMinted;\n        if (ERC721(_nftContract).ownerOf(_nftID) != msg.sender)\n            revert PFPNotOwnedByCaller(msg.sender, _nftContract, _nftID);\n        ProfilePictureData storage pictureData = pfp[tokenId];\n        pictureData.nftContract = _nftContract;\n        pictureData.nftID = _nftID;\n        _mint(msg.sender, tokenId);\n        emit PfpAdded(msg.sender, tokenId, _nftContract, _nftID);\n    }\n\n    /// @notice Query the referenced profile picture\n    /// @dev Checks if the PFP is still owned by the owner of the CID NFT\n    /// @param _pfpID Profile picture NFT ID to query\n    /// @return nftContract The referenced NFT contract (address(0) if no longer owned), nftID The referenced NFT ID\n    function getPFP(uint256 _pfpID) public view returns (address nftContract, uint256 nftID) {\n        if (_ownerOf[_pfpID] == address(0)) revert TokenNotMinted(_pfpID);\n        ProfilePictureData storage pictureData = pfp[_pfpID];\n        nftContract = pictureData.nftContract;\n        nftID = pictureData.nftID;\n        uint256 cidNFTID = cidNFT.getPrimaryCIDNFT(subprotocolName, _pfpID);\n        IAddressRegistry addressRegistry = cidNFT.addressRegistry();\n        if (cidNFTID == 0 || addressRegistry.getAddress(cidNFTID) != ERC721(nftContract).ownerOf(nftID)) {\n            nftContract = address(0);\n            nftID = 0; // Strictly not needed because nftContract has to be always checked, but reset nevertheless to 0\n        }\n    }\n}"
    },
    {
      "filename": "canto-bio-protocol/src/Bio.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport \"../interface/Turnstile.sol\";\n\ncontract Bio is ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of tokens minted\n    uint256 public numMinted;\n\n    /// @notice Stores the bio value per NFT\n    mapping(uint256 => string) public bio;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event BioAdded(address indexed minter, uint256 indexed nftID, string indexed bio);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error InvalidBioLength(uint256 length);\n\n    /// @notice Initiates CSR on mainnet\n    constructor() ERC721(\"Biography\", \"Bio\") {\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @dev Generates an on-chain SVG with a new line after 40 bytes. Line splitting generally supports UTF-8 multibyte characters and emojis, but is not tested for arbitrary UTF-8 characters\n    /// @param _id ID to query for\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (_ownerOf[_id] == address(0)) revert TokenNotMinted(_id);\n        string memory bioText = bio[_id];\n        bytes memory bioTextBytes = bytes(bioText);\n        uint lengthInBytes = bioTextBytes.length;\n        // Insert a new line after 40 characters, taking into account unicode character\n        uint lines = (lengthInBytes - 1) / 40 + 1;\n        string[] memory strLines = new string[](lines);\n        bool prevByteWasContinuation;\n        uint256 insertedLines;\n        // Because we do not split on zero-width joiners, line in bytes can technically be much longer. Will be shortened to the needed length afterwards\n        bytes memory bytesLines = new bytes(80);\n        uint bytesOffset;\n        for (uint i; i < lengthInBytes; ++i) {\n            bytes1 character = bioTextBytes[i];\n            bytesLines[bytesOffset] = character;\n            bytesOffset++;\n            if ((i > 0 && (i + 1) % 40 == 0) || prevByteWasContinuation || i == lengthInBytes - 1) {\n                bytes1 nextCharacter;\n                if (i != lengthInBytes - 1) {\n                    nextCharacter = bioTextBytes[i + 1];\n                }\n                if (nextCharacter & 0xC0 == 0x80) {\n                    // Unicode continuation byte, top two bits are 10\n                    prevByteWasContinuation = true;\n                } else {\n                    // Do not split when the prev. or next character is a zero width joiner. Otherwise, üë®‚Äçüëß‚Äçüë¶ could become üë®>‚Äçüëß‚Äçüë¶\n                    // Furthermore, do not split when next character is skin tone modifier to avoid ü§¶‚Äç‚ôÇÔ∏è\\nüèª\n                    if (\n                        // Note that we do not need to check i < lengthInBytes - 4, because we assume that it's a valid UTF8 string and these prefixes imply that another byte follows\n                        (nextCharacter == 0xE2 && bioTextBytes[i + 2] == 0x80 && bioTextBytes[i + 3] == 0x8D) ||\n                        (nextCharacter == 0xF0 &&\n                            bioTextBytes[i + 2] == 0x9F &&\n                            bioTextBytes[i + 3] == 0x8F &&\n                            uint8(bioTextBytes[i + 4]) >= 187 &&\n                            uint8(bioTextBytes[i + 4]) <= 191) ||\n                        (i >= 2 &&\n                            bioTextBytes[i - 2] == 0xE2 &&\n                            bioTextBytes[i - 1] == 0x80 &&\n                            bioTextBytes[i] == 0x8D)\n                    ) {\n                        prevByteWasContinuation = true;\n                        continue;\n                    }\n                    assembly {\n                        mstore(bytesLines, bytesOffset)\n                    }\n                    strLines[insertedLines++] = string(bytesLines);\n                    bytesLines = new bytes(80);\n                    prevByteWasContinuation = false;\n                    bytesOffset = 0;\n                }\n            }\n        }\n        string\n            memory svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 400 100\"><style>text { font-family: sans-serif; font-size: 12px; }</style>';\n        string memory text = '<text x=\"50%\" y=\"50%\" dominant-baseline=\"middle\" text-anchor=\"middle\">';\n        for (uint i; i < lines; ++i) {\n            text = string.concat(text, '<tspan x=\"50%\" dy=\"20\">', strLines[i], \"</tspan>\");\n        }\n        string memory json = Base64.encode(\n            bytes(\n                string.concat(\n                    '{\"name\": \"Bio #',\n                    LibString.toString(_id),\n                    '\", \"description\": \"',\n                    bioText,\n                    '\", \"image\": \"data:image/svg+xml;base64,',\n                    Base64.encode(bytes(string.concat(svg, text, \"</text></svg>\"))),\n                    '\"}'\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice Mint a new Bio NFT\n    /// @param _bio The text to add\n    function mint(string calldata _bio) external {\n        // We check the length in bytes, so will be higher for UTF-8 characters. But sufficient for this check\n        if (bytes(_bio).length == 0 || bytes(_bio).length > 200) revert InvalidBioLength(bytes(_bio).length);\n        uint256 tokenId = ++numMinted;\n        bio[tokenId] = _bio;\n        _mint(msg.sender, tokenId);\n        emit BioAdded(msg.sender, tokenId, _bio);\n    }\n}"
    }
  ]
}