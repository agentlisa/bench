{
  "Title": "M-2: PythOracle `commit()` function doesn't require (nor stores) pyth price publish timestamp to be after the previous commit's publish timestamp, which makes it possible to manipulate price to unfairly liquidate users and possible stealing protocol funds",
  "Content": "# Issue M-2: PythOracle `commit()` function doesn't require (nor stores) pyth price publish timestamp to be after the previous commit's publish timestamp, which makes it possible to manipulate price to unfairly liquidate users and possible stealing protocol funds \n\nSource: https://github.com/sherlock-audit/2023-07-perennial-judging/issues/44 \n\n## Found by \npanprog\n\nPythOracle allows any user to commit non-requested oracle version. However, it doesn't verify pyth price publish timestamp to be in order (like `commitRequested` does). This makes it possible to commit prices out of order, potentially leading to price manipulations allowing to unfairly liquidate users or steal funds from the protocol.\n\n## Vulnerability Detail\n\nPythOracle `commitRequested()` has the following check:\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L138-L139\n\nHowever, `commit()` doesn't have the same check. This allows malicious user to commit prices out of order, which can potentially lead to price manipulation attacks and unfair liquidation of users or loss of protocol funds.\n\nFor example, the following scenario is possible:\nTimestamp = 100: Alice requests to open 1 ETH long position with $10 collateral\nTimestamp = 113: pyth price = $980\nTimestamp = 114: pyth price = $990\nTimestamp = 115: pyth price = $1000\nTimestamp = 116: Keeper commits requested price = $1000 (with publish timestamp = 115)\nTimestamp = 117: Malicious user Bob commits oracle version 101 with price = $980 (publish timestamp = 113) and immediately liquidates Alice.\n\nEven though the current price is $1000, Alice is liquidated using the price which is *earlier* than the price when Alice position is opened, which is unfair liquidation. The other more complex scenarios are also possible for malicious Bob to liquidate itself to steal protocol funds.\n\n## Impact\n\nUnfair liquidation as described in the scenario above or possible loss of protocol funds.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd publish time check and store publish time in `PythOracle.commit()`:\n```solidity\n    function commit(uint256 oracleVersion, bytes calldata updateData) external payable {\n        // Must be before the next requested version to commit, if it exists\n        // Otherwise, try to commit it as the next request version to commit\n        if (versionList.length > nextVersionIndexToCommit && oracleVersion >= versionList[nextVersionIndexToCommit]) {\n            commitRequested(nextVersionIndexToCommit, updateData);\n            return;\n        }\n\n+        if (pythPrice.publishTime <= _lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n+        _lastCommittedPublishTime = pythPrice.publishTime;\n\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(oracleVersion, updateData);\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**__141345__** commented:\n> m\n\n\n\n**Emedudu**\n\nEscalate\n\nThis is an invalid issue.\n>Malicious user Bob commits oracle version 101 with price = $980 (publish timestamp = 113) and immediately liquidates Alice.\n\nHow is Bob malicious? He committed the more recent price.\n>Timestamp = 116: Keeper commits requested price = $1000 (with publish timestamp = 115)\n\nIf this price is used(which was requested at timestamp 100, when current timestamp is 115), it means that protocol is using a 15 seconds stale price.\nIt is better(and an expected behaviour) when Bob commits a more recent price(price at timestamp 101) because now, Protocol is using a less stale price(14 seconds stale).\nSo it is fair to liquidate Alice because even though the most recent price does not favour her, that's the rules.\n\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is an invalid issue.\n> >Malicious user Bob commits oracle version 101 with price = $980 (publish timestamp = 113) and immediately liquidates Alice.\n> \n> How is Bob malicious? He committed the more recent price.\n> >Timestamp = 116: Keeper commits requested price = $1000 (with publish timestamp = 115)\n> \n> If this price is used(which was requested at timestamp 100, when current timestamp is 115), it means that protocol is using a 15 seconds stale price.\n> It is better(and an expected behaviour) when Bob commits a more recent price(price at timestamp 101) because now, Protocol is using a less stale price(14 seconds stale).\n> So it is fair to liquidate Alice because even though the most recent price does not favour her, that's the rules.\n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**panprog**\n\nEscalate\n\nThis is a valid issue. Let me go into example in more details to explain. A few terms to better understand process:\n- `oracle version` - the timestamp keeper commits the price to. It doesn't mean the price *at this* timestamp. It means the price used to settle positions at this timestamp.\n- `pyth publish timestamp` - the timestamp of a price published and signed in the pyth network (actual time the price is observed). `publish timestamp` must come 12-15 seconds after `oracle version` (these are example settings in perennial tests).\n\nTimestamp = 100: Alice requests to open 1 ETH long position with $10 collateral. Oracle request is created (with `oracle version` = 100, meaning only `publish prices` in 112..115 range can be commited)\nTimestamp = 113: `pyth publish price` = $980\nTimestamp = 114: `pyth publish price` = $990\nTimestamp = 115: `pyth publish price` = $1000\nTimestamp = 116: Keeper commits requested price = $1000 (`oracle version` = 100, `publish timestamp` = 115)\nTimestamp = 117: Malicious user Bob commits (unrequested) `oracle version` = 101 with price = $980, `publish timestamp` = 113 and immediately liquidates Alice.\n\nWhat happens is:\n`oracle version` = 100 has `publish timestamp` = 115\n`oracle version` = 101 has `publish timestamp` = 113\n\nThis breaks invariant that publish timestamps must increase when oracle version increases.\n\nSo first position is opened using price $1000 (with `publish timestamp` = 115), then it is liquidated using the `publish timestamp = 113`, which is an earlier price than the price of when position was opened, which is unfair liquidation.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is a valid issue. Let me go into example in more details to explain. A few terms to better understand process:\n> - `oracle version` - the timestamp keeper commits the price to. It doesn't mean the price *at this* timestamp. It means the price used to settle positions at this timestamp.\n> - `pyth publish timestamp` - the timestamp of a price published and signed in the pyth network (actual time the price is observed). `publish timestamp` must come 12-15 seconds after `oracle version` (these are example settings in perennial tests).\n> \n> Timestamp = 100: Alice requests to open 1 ETH long position with $10 collateral. Oracle request is created (with `oracle version` = 100, meaning only `publish prices` in 112..115 range can be commited)\n> Timestamp = 113: `pyth publish price` = $980\n> Timestamp = 114: `pyth publish price` = $990\n> Timestamp = 115: `pyth publish price` = $1000\n> Timestamp = 116: Keeper commits requested price = $1000 (`oracle version` = 100, `publish timestamp` = 115)\n> Timestamp = 117: Malicious user Bob commits (unrequested) `oracle version` = 101 with price = $980, `publish timestamp` = 113 and immediately liquidates Alice.\n> \n> What happens is:\n> `oracle version` = 100 has `publish timestamp` = 115\n> `oracle version` = 101 has `publish timestamp` = 113\n> \n> This breaks invariant that publish timestamps must increase when oracle version increases.\n> \n> So first position is opened using price $1000 (with `publish timestamp` = 115), then it is liquidated using the `publish timestamp = 113`, which is an earlier price than the price of when position was opened, which is unfair liquidation.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Emedudu**\n\nThis assumption is predicated on the idea that there can be a rapid and significant change in the ETH/USD price, such as a $10 change as demonstrated in the example. Can we substantiate this assumption with historical data, demonstrating that the price of ETH can indeed fluctuate by $10 within a second, or even within 3 seconds?\n\nBesides, it's crucial for the protocol to utilize the price from the most recent oracle version. This underscores the importance for users to maintain healthy positions. Referring to the example Watson provided, Alice should not let her position teeter on the brink of liquidation.\n\nSo again, Bob is not acting maliciously. He is diligently fulfilling his role as a keeper, which involves updating oracle versions. He happened upon a careless trader, Alice, with an unhealthy position and executed a liquidation. This action benefits the protocol by reducing the number of unhealthy positions.\n\n\n**Minh-Trng**\n\nWhile it is true that `commitRequested` enforces publish time to increase monotonically, while `commit` doesnt, the example shows how Alice has at one point in those 3 seconds been be below her liquidation point, so its absolutely fine (and beneficial for the protocol) for her to be liquidated.\n\nBob has done a better job at playing the keeper than the other keeper\n\n**panprog**\n\n> While it is true that `commitRequested` enforces publish time to increase monotonically, while `commit` doesnt, the example shows how Alice has at one point in those 3 seconds been be below her liquidation point, so its absolutely fine (and beneficial for the protocol) for her to be liquidated.\n\nNo, this is not true. If the price of $980 was commited first, then Alice position would be opened at a price of $980 and will not be liquidatable. If Alice was opened at a price of $990, then she also won't be liquidatable.\n\n> This assumption is predicated on the idea that there can be a rapid and significant change in the ETH/USD price, such as a $10 change as demonstrated in the example. Can we substantiate this assumption with historical data, demonstrating that the price of ETH can indeed fluctuate by $10 within a second, or even within 3 seconds?\n\n1. Even 0.01% of a price change is enough to liquidate the account. Yes, the user may be careless with leverage, however this doesn't make this liquidation fair. I chose more extreme numbers just to better demonstrate the scenario.\n2. 3 seconds is just an example, it's a protocol setting and can be higher\n3. Here is an extreme example to better understand why such liquidation is unfair. If the publish timestamp window is, say, 200 seconds long and the price starts dropping sharply from $1000 to $980. User expects the price to keep dropping, so he opens a short position at close to max leverage (so that a price move of $20 will get it liquidated). The price keeps falling sharply to $960. The position is opened at a price of $960 (end of 200 seconds interval) and immediately liquidated at a price of $980 (start of 200 seconds interval). I don't think any reasonable user expects his position to be liquidated using prices which were well before the opening of the position.\n\nSo even with 3-seconds time interval and much smaller price change magnitude, the same scenario is still possible and is still unfair. The published (observed) prices must come in the same order they're observed from pyth, they can not go in a random order.\n\n**Emedudu**\n\n>Even 0.01% of a price change is enough to liquidate the account. Yes, the user may be careless with leverage, however this doesn't make this liquidation fair. I chose more extreme numbers just to better demonstrate the scenario.\n\nWhy should a user leave his position to be liquidatable when there is a price change of 0.01%? This shows that the position is indeed unhealthy. One thing about oracles is that they return approximate values, and have little deviation from other oracles' values. So no reasonable trader will make her position liquidatable on a 0.01% price change.\n\n>3 seconds is just an example, it's a protocol setting and can be higher\n\nFrom what I can see, they are CONSTANTS: [MIN_VALID_TIME_AFTER_VERSION](https://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L17) and [MAX_VALID_TIME_AFTER_VERSION](https://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L20)\n\n>Here is an extreme example to better understand why such liquidation is unfair. If the publish timestamp window is, say, 200 seconds long and the price starts dropping sharply from $1000 to $980. User expects the price to keep dropping, so he opens a short position at close to max leverage (so that a price move of $20 will get it liquidated). The price keeps falling sharply to $960. The position is opened at a price of $960 (end of 200 seconds interval) and immediately liquidated at a price of $980 (start of 200 seconds interval). I don't think any reasonable user expects his position to be liquidated using prices which were well before the opening of the position\n\nThis seems unrealistic\n\n\n\n**Minh-Trng**\n\nA core assumption of this issue is that a user opens a position close to the liquidation price and/or in a highly volatile period without enough buffer till liquidation, so that even a price deviation within 2 seconds would liquidate them. this is clearly a user mistake rather than a protocol error. And thats why a medium severity is imo not justified. \n\nA user does not know the oracle prices 12-15 seconds into the future, so they would not choose which price to be filled at and be mindful of having enough margin. The example might as well go like this:\n\nTimestamp = 113: pyth publish price = $980\nTimestamp = 114: pyth publish price = $990\nTimestamp = 115: pyth publish price = $1000\nTimestamp = 116: pyth publish price = $990\nTimestamp = 117: pyth publish price = $980\n\nIn this case Alice might get filled at t=115 and get liquidated at t=117 and there is no one to blame but her.\n\nTo sum up, the issue is hypothetically possible but requires a careless user AND enough volatility within 2 seconds time span\n\n**panprog**\n\n> To sum up, the issue is hypothetically possible but requires a careless user AND enough volatility within 2 seconds time span\n\nYes, it's unlikely but possible, thus should be a valid medium.\n\n**Emedudu**\n\nSeverity should be LOW because likelihood is low and impact is low\n\n\n\n\n**panprog**\n\n> Severity should be LOW because likelihood is low and impact is low\n\nImpact is unfair liquidation, so it's high. For example, if the price starts dropping quickly -> every second the price will be less than or equal to previous second's price, in such situation opening short position at max leverage can be valid strategy for the user expecting continuaton of the price fall, and being liquidated at earlier price is also extremely unfair.\n\n**arjun-io**\n\nFixed: https://github.com/equilibria-xyz/perennial-v2/pull/80\n\n**141345**\n\nMedium seems appropriate.\n\nAs per the discussion, it is plausible to commit prices out of order and cause loss, but with several conditions:\n- limited time span\n- high volatility\n- the position is already on the border of liquidation\n\n\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this issue a valid medium based on the above discussion and the comment from Lead Judge\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [panprog](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/44/#issuecomment-1694337978): accepted\n- [Emedudu](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/44/#issuecomment-1694206797): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/106",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/Kept.sol\";\nimport \"../interfaces/IPythFactory.sol\";\n\n/// @title PythOracle\n/// @notice Pyth implementation of the IOracle interface.\n/// @dev One instance per Pyth price feed should be deployed. Multiple products may use the same\n///      PythOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\ncontract PythOracle is IPythOracle, Instance, Kept {\n    /// @dev A Pyth update must come at least this long after a version to be valid\n    uint256 constant private MIN_VALID_TIME_AFTER_VERSION = 12 seconds;\n\n    /// @dev A Pyth update must come at most this long after a version to be valid\n    uint256 constant private MAX_VALID_TIME_AFTER_VERSION = 15 seconds;\n\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\n    uint256 constant private GRACE_PERIOD = 1 minutes;\n\n    /// @dev The multiplier for the keeper reward on top of cost\n    UFixed18 constant private KEEPER_REWARD_PREMIUM = UFixed18.wrap(1.5e18);\n\n    /// @dev The fixed gas buffer that is added to the keeper reward\n    uint256 constant private KEEPER_BUFFER = 80_000;\n\n    /// @dev Pyth contract\n    AbstractPyth public immutable pyth;\n\n    /// @dev Pyth price feed id\n    bytes32 public id;\n\n    /// @dev List of all requested oracle versions\n    uint256[] public versionList;\n\n    /// @dev Index in `versionList` of the next version a keeper should commit\n    uint256 public nextVersionIndexToCommit;\n\n    /// @dev Mapping from oracle version to oracle version data\n    mapping(uint256 => Fixed6) private _prices;\n\n    /// @dev Mapping from oracle version to when its VAA was published to Pyth\n    mapping(uint256 => uint256) private _publishTimes;\n\n    /// @dev The time when the last committed update was published to Pyth\n    uint256 private _lastCommittedPublishTime;\n\n    /// @dev The oracle version that was most recently committed\n    /// @dev We assume that we cannot commit an oracle version of 0, so `_latestVersion` being 0 means that no version has been committed yet\n    uint256 private _latestVersion;\n\n     /// @notice Initializes the immutable contract state\n     /// @param pyth_ Pyth contract\n    constructor(AbstractPyth pyth_) {\n        pyth = pyth_;\n    }\n\n    /// @notice Initializes the contract state\n    /// @param id_ price ID for Pyth price feed\n    /// @param chainlinkFeed_ Chainlink price feed for rewarding keeper in DSU\n    /// @param dsu_ Token to pay the keeper reward in\n    function initialize(bytes32 id_, AggregatorV3Interface chainlinkFeed_, Token18 dsu_) external initializer(1) {\n        __Instance__initialize();\n        __UKept__initialize(chainlinkFeed_, dsu_);\n\n        if (!pyth.priceFeedExists(id_)) revert PythOracleInvalidPriceIdError(id_);\n\n        id = id_;\n    }\n\n    /// @notice Records a request for a new oracle version\n    /// @dev Original sender to optionally use for callbacks\n    function request(address) external onlyAuthorized {\n        if (versionList.length == 0 || versionList[versionList.length - 1] != block.timestamp) {\n            versionList.push(block.timestamp);\n        }\n    }\n\n    /// @notice Returns the latest synced oracle version and the current oracle version\n    /// @return The latest synced oracle version\n    /// @return The current oracle version collecting new orders\n    function status() external view returns (OracleVersion memory, uint256) {\n        return (latest(), current());\n    }\n\n    /// @notice Returns the latest synced oracle version\n    /// @return latestVersion Latest oracle version\n    function latest() public view returns (OracleVersion memory latestVersion) {\n        if (_latestVersion == 0) return latestVersion;\n\n        return latestVersion = OracleVersion(_latestVersion, _prices[_latestVersion], true);\n    }\n\n    /// @notice Returns the current oracle version accepting new orders\n    /// @return Current oracle version\n    function current() public view returns (uint256) {\n        return IPythFactory(address(factory())).current();\n    }\n\n\n    /// @notice Returns the oracle version at version `version`\n    /// @param timestamp The timestamp of which to lookup\n    /// @return oracleVersion Oracle version at version `version`\n    function at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n        Fixed6 price = _prices[timestamp];\n        return OracleVersion(timestamp, price, !price.isZero());\n    }\n\n    /// @notice Returns the next oracle version to commit\n    /// @return version The next oracle version to commit\n    function nextVersionToCommit() external view returns (uint256 version) {\n        if (versionList.length == 0 || nextVersionIndexToCommit >= versionList.length) return 0;\n        return versionList[nextVersionIndexToCommit];\n    }\n\n    /// @notice Commits the price represented by `updateData` to the next version that needs to be committed\n    /// @dev Will revert if there is an earlier versionIndex that could be committed with `updateData`\n    /// @param versionIndex The index of the version to commit\n    /// @param updateData The update data to commit\n    function commitRequested(uint256 versionIndex, bytes calldata updateData)\n        public\n        payable\n        keep(KEEPER_REWARD_PREMIUM, KEEPER_BUFFER, \"\")\n    {\n        // This check isn't necessary since the caller would not be able to produce a valid updateData\n        // with an update time corresponding to a null version, but reverting with a specific error is\n        // clearer.\n        if (nextVersionIndexToCommit >= versionList.length) revert PythOracleNoNewVersionToCommitError();\n        if (versionIndex < nextVersionIndexToCommit) revert PythOracleVersionIndexTooLowError();\n\n        uint256 versionToCommit = versionList[versionIndex];\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(versionToCommit, updateData);\n\n        if (pythPrice.publishTime <= _lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n        _lastCommittedPublishTime = pythPrice.publishTime;\n\n        // Ensure that the keeper is committing the earliest possible version\n        if (versionIndex > nextVersionIndexToCommit) {\n            uint256 previousVersion = versionList[versionIndex - 1];\n            // We can only skip the previous version if the grace period has expired\n            if (block.timestamp <= previousVersion + GRACE_PERIOD) revert PythOracleGracePeriodHasNotExpiredError();\n\n            // If the update is valid for the previous version, we can't skip the previous version\n            if (\n                pythPrice.publishTime >= previousVersion + MIN_VALID_TIME_AFTER_VERSION &&\n                pythPrice.publishTime <= previousVersion + MAX_VALID_TIME_AFTER_VERSION\n            ) revert PythOracleUpdateValidForPreviousVersionError();\n        }\n\n        _recordPrice(versionToCommit, pythPrice);\n        nextVersionIndexToCommit = versionIndex + 1;\n        _latestVersion = versionToCommit;\n    }\n\n    /// @notice Commits the price to a non-requested version\n    /// @dev This commit function may pay out a keeper reward if the commited version is valid\n    ///      for the next requested version to commit.\n    /// @param oracleVersion The oracle version to commit\n    /// @param updateData The update data to commit\n    function commit(uint256 oracleVersion, bytes calldata updateData) external payable {\n        // Must be before the next requested version to commit, if it exists\n        // Otherwise, try to commit it as the next request version to commit\n        if (versionList.length > nextVersionIndexToCommit && oracleVersion >= versionList[nextVersionIndexToCommit]) {\n            commitRequested(nextVersionIndexToCommit, updateData);\n            return;\n        }\n\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(oracleVersion, updateData);\n\n        // Oracle version must be more recent than those of the most recently committed version\n        if (oracleVersion <= _latestVersion) revert PythOracleVersionTooOldError();\n\n        _recordPrice(oracleVersion, pythPrice);\n        _latestVersion = oracleVersion;\n    }\n\n    /// @notice Validates that update fees have been paid, and that the VAA represented by `updateData` is within `oracleVersion + MIN_VALID_TIME_AFTER_VERSION` and `oracleVersion + MAX_VALID_TIME_AFTER_VERSION`\n    /// @param oracleVersion The oracle version to validate against\n    /// @param updateData The update data to validate\n    function _validateAndGetPrice(uint256 oracleVersion, bytes calldata updateData) private returns (PythStructs.Price memory price) {\n        bytes[] memory updateDataList = new bytes[](1);\n        updateDataList[0] = updateData;\n        bytes32[] memory idList = new bytes32[](1);\n        idList[0] = id;\n\n        return pyth.parsePriceFeedUpdates{value: pyth.getUpdateFee(updateDataList)}(\n            updateDataList,\n            idList,\n            SafeCast.toUint64(oracleVersion + MIN_VALID_TIME_AFTER_VERSION),\n            SafeCast.toUint64(oracleVersion + MAX_VALID_TIME_AFTER_VERSION)\n        )[0].price;\n    }\n\n    /// @notice Records `price` as a Fixed6 at version `oracleVersion`\n    /// @param oracleVersion The oracle version to record the price at\n    /// @param price The price to record\n    function _recordPrice(uint256 oracleVersion, PythStructs.Price memory price) private {\n        _prices[oracleVersion] = Fixed6Lib.from(price.price)\n            .mul(Fixed6Lib.from(SafeCast.toInt256(10 ** SafeCast.toUint256(price.expo > 0 ? price.expo : -price.expo))));\n        _publishTimes[oracleVersion] = price.publishTime;\n    }\n\n    /// @notice Pulls funds from the factory to reward the keeper\n    /// @param keeperFee The keeper fee to pull\n    function _raiseKeeperFee(UFixed18 keeperFee, bytes memory) internal override {\n        IPythFactory(address(factory())).claim(UFixed6Lib.from(keeperFee, true));\n    }\n\n    /// @dev Only allow authorized callers\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender)) revert OracleProviderUnauthorizedError();\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/Kept.sol\";\nimport \"../interfaces/IPythFactory.sol\";\n\n/// @title PythOracle\n/// @notice Pyth implementation of the IOracle interface.\n/// @dev One instance per Pyth price feed should be deployed. Multiple products may use the same\n///      PythOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\ncontract PythOracle is IPythOracle, Instance, Kept {\n    /// @dev A Pyth update must come at least this long after a version to be valid\n    uint256 constant private MIN_VALID_TIME_AFTER_VERSION = 12 seconds;\n\n    /// @dev A Pyth update must come at most this long after a version to be valid\n    uint256 constant private MAX_VALID_TIME_AFTER_VERSION = 15 seconds;\n\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\n    uint256 constant private GRACE_PERIOD = 1 minutes;\n\n    /// @dev The multiplier for the keeper reward on top of cost\n    UFixed18 constant private KEEPER_REWARD_PREMIUM = UFixed18.wrap(1.5e18);\n\n    /// @dev The fixed gas buffer that is added to the keeper reward\n    uint256 constant private KEEPER_BUFFER = 80_000;\n\n    /// @dev Pyth contract\n    AbstractPyth public immutable pyth;\n\n    /// @dev Pyth price feed id\n    bytes32 public id;\n\n    /// @dev List of all requested oracle versions\n    uint256[] public versionList;\n\n    /// @dev Index in `versionList` of the next version a keeper should commit\n    uint256 public nextVersionIndexToCommit;\n\n    /// @dev Mapping from oracle version to oracle version data\n    mapping(uint256 => Fixed6) private _prices;\n\n    /// @dev Mapping from oracle version to when its VAA was published to Pyth\n    mapping(uint256 => uint256) private _publishTimes;\n\n    /// @dev The time when the last committed update was published to Pyth\n    uint256 private _lastCommittedPublishTime;\n\n    /// @dev The oracle version that was most recently committed\n    /// @dev We assume that we cannot commit an oracle version of 0, so `_latestVersion` being 0 means that no version has been committed yet\n    uint256 private _latestVersion;\n\n     /// @notice Initializes the immutable contract state\n     /// @param pyth_ Pyth contract\n    constructor(AbstractPyth pyth_) {\n        pyth = pyth_;\n    }\n\n    /// @notice Initializes the contract state\n    /// @param id_ price ID for Pyth price feed\n    /// @param chainlinkFeed_ Chainlink price feed for rewarding keeper in DSU\n    /// @param dsu_ Token to pay the keeper reward in\n    function initialize(bytes32 id_, AggregatorV3Interface chainlinkFeed_, Token18 dsu_) external initializer(1) {\n        __Instance__initialize();\n        __UKept__initialize(chainlinkFeed_, dsu_);\n\n        if (!pyth.priceFeedExists(id_)) revert PythOracleInvalidPriceIdError(id_);\n\n        id = id_;\n    }\n\n    /// @notice Records a request for a new oracle version\n    /// @dev Original sender to optionally use for callbacks\n    function request(address) external onlyAuthorized {\n        if (versionList.length == 0 || versionList[versionList.length - 1] != block.timestamp) {\n            versionList.push(block.timestamp);\n        }\n    }\n\n    /// @notice Returns the latest synced oracle version and the current oracle version\n    /// @return The latest synced oracle version\n    /// @return The current oracle version collecting new orders\n    function status() external view returns (OracleVersion memory, uint256) {\n        return (latest(), current());\n    }\n\n    /// @notice Returns the latest synced oracle version\n    /// @return latestVersion Latest oracle version\n    function latest() public view returns (OracleVersion memory latestVersion) {\n        if (_latestVersion == 0) return latestVersion;\n\n        return latestVersion = OracleVersion(_latestVersion, _prices[_latestVersion], true);\n    }\n\n    /// @notice Returns the current oracle version accepting new orders\n    /// @return Current oracle version\n    function current() public view returns (uint256) {\n        return IPythFactory(address(factory())).current();\n    }\n\n\n    /// @notice Returns the oracle version at version `version`\n    /// @param timestamp The timestamp of which to lookup\n    /// @return oracleVersion Oracle version at version `version`\n    function at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n        Fixed6 price = _prices[timestamp];\n        return OracleVersion(timestamp, price, !price.isZero());\n    }\n\n    /// @notice Returns the next oracle version to commit\n    /// @return version The next oracle version to commit\n    function nextVersionToCommit() external view returns (uint256 version) {\n        if (versionList.length == 0 || nextVersionIndexToCommit >= versionList.length) return 0;\n        return versionList[nextVersionIndexToCommit];\n    }\n\n    /// @notice Commits the price represented by `updateData` to the next version that needs to be committed\n    /// @dev Will revert if there is an earlier versionIndex that could be committed with `updateData`\n    /// @param versionIndex The index of the version to commit\n    /// @param updateData The update data to commit\n    function commitRequested(uint256 versionIndex, bytes calldata updateData)\n        public\n        payable\n        keep(KEEPER_REWARD_PREMIUM, KEEPER_BUFFER, \"\")\n    {\n        // This check isn't necessary since the caller would not be able to produce a valid updateData\n        // with an update time corresponding to a null version, but reverting with a specific error is\n        // clearer.\n        if (nextVersionIndexToCommit >= versionList.length) revert PythOracleNoNewVersionToCommitError();\n        if (versionIndex < nextVersionIndexToCommit) revert PythOracleVersionIndexTooLowError();\n\n        uint256 versionToCommit = versionList[versionIndex];\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(versionToCommit, updateData);\n\n        if (pythPrice.publishTime <= _lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n        _lastCommittedPublishTime = pythPrice.publishTime;\n\n        // Ensure that the keeper is committing the earliest possible version\n        if (versionIndex > nextVersionIndexToCommit) {\n            uint256 previousVersion = versionList[versionIndex - 1];\n            // We can only skip the previous version if the grace period has expired\n            if (block.timestamp <= previousVersion + GRACE_PERIOD) revert PythOracleGracePeriodHasNotExpiredError();\n\n            // If the update is valid for the previous version, we can't skip the previous version\n            if (\n                pythPrice.publishTime >= previousVersion + MIN_VALID_TIME_AFTER_VERSION &&\n                pythPrice.publishTime <= previousVersion + MAX_VALID_TIME_AFTER_VERSION\n            ) revert PythOracleUpdateValidForPreviousVersionError();\n        }\n\n        _recordPrice(versionToCommit, pythPrice);\n        nextVersionIndexToCommit = versionIndex + 1;\n        _latestVersion = versionToCommit;\n    }\n\n    /// @notice Commits the price to a non-requested version\n    /// @dev This commit function may pay out a keeper reward if the commited version is valid\n    ///      for the next requested version to commit.\n    /// @param oracleVersion The oracle version to commit\n    /// @param updateData The update data to commit\n    function commit(uint256 oracleVersion, bytes calldata updateData) external payable {\n        // Must be before the next requested version to commit, if it exists\n        // Otherwise, try to commit it as the next request version to commit\n        if (versionList.length > nextVersionIndexToCommit && oracleVersion >= versionList[nextVersionIndexToCommit]) {\n            commitRequested(nextVersionIndexToCommit, updateData);\n            return;\n        }\n\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(oracleVersion, updateData);\n\n        // Oracle version must be more recent than those of the most recently committed version\n        if (oracleVersion <= _latestVersion) revert PythOracleVersionTooOldError();\n\n        _recordPrice(oracleVersion, pythPrice);\n        _latestVersion = oracleVersion;\n    }\n\n    /// @notice Validates that update fees have been paid, and that the VAA represented by `updateData` is within `oracleVersion + MIN_VALID_TIME_AFTER_VERSION` and `oracleVersion + MAX_VALID_TIME_AFTER_VERSION`\n    /// @param oracleVersion The oracle version to validate against\n    /// @param updateData The update data to validate\n    function _validateAndGetPrice(uint256 oracleVersion, bytes calldata updateData) private returns (PythStructs.Price memory price) {\n        bytes[] memory updateDataList = new bytes[](1);\n        updateDataList[0] = updateData;\n        bytes32[] memory idList = new bytes32[](1);\n        idList[0] = id;\n\n        return pyth.parsePriceFeedUpdates{value: pyth.getUpdateFee(updateDataList)}(\n            updateDataList,\n            idList,\n            SafeCast.toUint64(oracleVersion + MIN_VALID_TIME_AFTER_VERSION),\n            SafeCast.toUint64(oracleVersion + MAX_VALID_TIME_AFTER_VERSION)\n        )[0].price;\n    }\n\n    /// @notice Records `price` as a Fixed6 at version `oracleVersion`\n    /// @param oracleVersion The oracle version to record the price at\n    /// @param price The price to record\n    function _recordPrice(uint256 oracleVersion, PythStructs.Price memory price) private {\n        _prices[oracleVersion] = Fixed6Lib.from(price.price)\n            .mul(Fixed6Lib.from(SafeCast.toInt256(10 ** SafeCast.toUint256(price.expo > 0 ? price.expo : -price.expo))));\n        _publishTimes[oracleVersion] = price.publishTime;\n    }\n\n    /// @notice Pulls funds from the factory to reward the keeper\n    /// @param keeperFee The keeper fee to pull\n    function _raiseKeeperFee(UFixed18 keeperFee, bytes memory) internal override {\n        IPythFactory(address(factory())).claim(UFixed6Lib.from(keeperFee, true));\n    }\n\n    /// @dev Only allow authorized callers\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender)) revert OracleProviderUnauthorizedError();\n        _;\n    }\n}"
    }
  ]
}