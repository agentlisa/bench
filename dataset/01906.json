{
  "Title": "H-7: Possible to liquidate past the debt outstanding above the min borrow without liquidating the entire debt outstanding",
  "Content": "# Issue H-7: Possible to liquidate past the debt outstanding above the min borrow without liquidating the entire debt outstanding \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/194 \n\n## Found by \nxiaoming90\n## Summary\n\nIt is possible to liquidate past the debt outstanding above the min borrow without liquidating the entire debt outstanding. Thus, leaving accounts with small debt that are not profitable to unwind if it needs to liquidate.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/vaults/VaultValuation.sol#L251\n\n```solidity\nFile: VaultValuation.sol\n250:         // NOTE: deposit amount is always positive in this method\n251:         if (depositUnderlyingInternal < maxLiquidatorDepositLocal) {\n252:             // If liquidating past the debt outstanding above the min borrow, then the entire\n253:             // debt outstanding must be liquidated.\n254: \n255:             // (debtOutstanding - depositAmountUnderlying) is the post liquidation debt. As an\n256:             // edge condition, when debt outstanding is discounted to present value, the account\n257:             // may be liquidated to zero while their debt outstanding is still greater than the\n258:             // min borrow size (which is normally enforced in notional terms -- i.e. non present\n259:             // value). Resolving this would require additional complexity for not much gain. An\n260:             // account within 20% of the minBorrowSize in a vault that has fCash discounting enabled\n261:             // may experience a full liquidation as a result.\n262:             require(\n263:                 h.debtOutstanding[currencyIndex].sub(depositUnderlyingInternal) < minBorrowSize,\n264:                 \"Must Liquidate All Debt\"\n265:             );\n```\n\n- `depositUnderlyingInternal` is always a positive value (Refer to comment on Line 250) that represents the amount of underlying deposited by the liquidator\n- `h.debtOutstanding[currencyIndex]` is always a negative value representing debt outstanding of a specific currency in a vault account\n- `minBorrowSize` is always a positive value that represents the minimal borrow size of a specific currency (It is stored as uint32 in storage)\n\nIf liquidating past the debt outstanding above the min borrow, then the entire debt outstanding must be liquidated.\n\nAssume the following scenario:\n\n- `depositUnderlyingInternal` = `70 USDC`\n- `h.debtOutstanding[currencyIndex]` = `-100 USDC`\n- `minBorrowSize` = `50 USDC`\n\nIf the liquidation is successful, the vault account should be left with `-30 USDC` debt outstanding because `70 USDC` has been paid off by the liquidator. However, this should not happen under normal circumstances because the debt outstanding (`-30`) does not meet the minimal borrow size of `50 USDC` and the liquidation should revert/fail.\n\nThe following piece of validation logic attempts to ensure that all outstanding debt is liquidated if post-liquidation debt does not meet the minimal borrowing size.\n\n```solidity\nrequire(\n    h.debtOutstanding[currencyIndex].sub(depositUnderlyingInternal) < minBorrowSize,\n    \"Must Liquidate All Debt\"\n);\n```\n\nPlugging in the values from our scenario to verify if the code will revert if the debt outstanding does not meet the minimal borrow size.\n\n```solidity\nrequire(\n\t(-100 USDC - 70 USDC) < 50 USDC\n);\n===>\nrequire(\n\t(-170 USDC) < 50 USDC\n);\n===>\nrequire(true) // no revert\n```\n\nThe above shows that it is possible for someone to liquidate past the debt outstanding above the min borrow without liquidating the entire debt outstanding. This shows that the math formula in the code is incorrect and not working as intended.\n\n## Impact\n\nA liquidation can bring an account below the minimum debt. Accounts smaller than the minimum debt are not profitable to unwind if it needs to liquidate [(Reference)](https://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/vaults/VaultAccount.sol#L329)\n\nAs a result, liquidators are not incentivized to liquidate those undercollateralized positions. This might leave the protocol with bad debts, potentially leading to insolvency if the bad debts accumulate.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/vaults/VaultValuation.sol#L251\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the formula to as follows:\n\n```diff\nrequire(\n-   h.debtOutstanding[currencyIndex].sub(depositUnderlyingInternal) < minBorrowSize,\n+   h.debtOutstanding[currencyIndex].neg().sub(depositUnderlyingInternal) > minBorrowSize,\n    \"Must Liquidate All Debt\"\n);\n```\n\nPlugging in the values from our scenario again to verify if the code will revert if the debt outstanding does not meet the minimal borrow size.\n\n```solidity\nrequire(\n\t((-100 USDC).neg() - 70 USDC) > 50 USDC\n);\n===>\nrequire(\n\t(100 USDC - 70 USDC) > 50 USDC\n);\n===>\nrequire(\n\t(30 USDC) > 50 USDC\n);\n===>\nrequire(false) // revert\n```\n\nThe above will trigger a revert as expected when the debt outstanding does not meet the minimal borrow size.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts-v2/contracts/internal/vaults/VaultValuation.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    VaultAccount,\n    VaultConfig,\n    VaultState,\n    VaultAccountHealthFactors,\n    PrimeRate,\n    CashGroupParameters,\n    MarketParameters,\n    Token\n} from \"../../global/Types.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\n\nimport {TokenHandler} from \"../balances/TokenHandler.sol\";\nimport {CashGroup} from \"../markets/CashGroup.sol\";\nimport {Market} from \"../markets/Market.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {AssetHandler} from \"../valuation/AssetHandler.sol\";\n\nimport {VaultSecondaryBorrow} from \"./VaultSecondaryBorrow.sol\";\nimport {VaultConfiguration} from \"./VaultConfiguration.sol\";\n\nimport {IStrategyVault} from \"../../../interfaces/notional/IStrategyVault.sol\";\nimport {IVaultAccountHealth} from \"../../../interfaces/notional/IVaultController.sol\";\n\n/// @notice Leveraged vaults have three components to the valuation of a position:\n///     - VaultShareValue: the value of a single vault share which can be transferred between\n///       leveraged vault accounts.\n///\n///     - DebtOutstanding: the value of debts held by the account, discounted to present value\n///       when fCash discounting is enabled.\n///\n///         debtOutstanding = presentValue(primaryDebt) + convertToPrimary(presentValue(secondaryDebt))\n///\n///     - AccountCashHeld: the value of cash held by the account against debt. Cash is only deposited to\n///       the account during liquidation and must be cleared on any subsequent non-liquidation transaction.\n///\n///         accountCashHeld = primaryCash + convertToPrimary(secondaryCash)\nlibrary VaultValuation {\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n    using VaultConfiguration for VaultConfig;\n    using CashGroup for CashGroupParameters;\n    using TokenHandler for Token;\n    using Market for MarketParameters;\n    using PrimeRateLib for PrimeRate;\n\n    /// @notice Returns the value in underlying of the primary borrow currency portion of vault shares.\n    function getPrimaryUnderlyingValueOfShare(\n        VaultState memory vaultState,\n        VaultConfig memory vaultConfig,\n        address account,\n        uint256 vaultShares\n    ) internal view returns (int256) {\n        if (vaultShares == 0) return 0;\n\n        Token memory token = TokenHandler.getUnderlyingToken(vaultConfig.borrowCurrencyId);\n        return token.convertToInternal(\n            IStrategyVault(vaultConfig.vault).convertStrategyToUnderlying(account, vaultShares, vaultState.maturity)\n        );\n    }\n\n    function getLiquidateCashDiscountFactor(\n        PrimeRate memory primeRate,\n        uint16 currencyId,\n        uint256 maturity\n    ) internal view returns (int256) {\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroup(currencyId, primeRate);\n        uint256 oracleRate = cashGroup.calculateOracleRate(maturity, block.timestamp);\n        uint256 buffer = cashGroup.getLiquidationDebtBuffer();\n        return AssetHandler.getDiscountFactor(\n            maturity.sub(block.timestamp),\n            oracleRate < buffer ? 0 : oracleRate.sub(buffer)\n        );\n    }\n\n    function getPresentValue(\n        PrimeRate memory primeRate,\n        uint16 currencyId,\n        uint256 maturity,\n        int256 debtUnderlying,\n        bool enableDiscount\n    ) internal view returns (int256) {\n        if (maturity <= block.timestamp) {\n            // Matured vaults will have a present value of the settled value of the fCash along\n            // with accrued prime cash debt. The value returned by this method is already in prime cash.\n            // Prime cash will never trip this if condition since PRIME_CASH_VAULT_MATURITY is in the\n            // distant future\n            return primeRate.convertToUnderlying(\n                primeRate.convertSettledfCashView(currencyId, maturity, debtUnderlying, block.timestamp)\n            );\n        } else if (enableDiscount && maturity != Constants.PRIME_CASH_VAULT_MATURITY) {\n            CashGroupParameters memory cashGroup = CashGroup.buildCashGroup(currencyId, primeRate);\n            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, block.timestamp);\n            // Use the risk adjusted present fCash value so that local currency liquidation has room to\n            // pay the liquidator.\n            debtUnderlying = AssetHandler.getRiskAdjustedPresentfCashValue(\n                cashGroup, debtUnderlying, maturity, block.timestamp, oracleRate\n            );\n        }\n\n        // If fCash discount is disabled, fCash is valued at its notional value. Prime cash is always\n        // valued at its current value.\n        return debtUnderlying;\n    }\n\n    function getCollateralRatioFactorsStateful(\n        VaultConfig memory vaultConfig,\n        VaultState memory vaultState,\n        address account,\n        uint256 vaultShares,\n        int256 debtUnderlying\n    ) internal returns (int256 collateralRatio, int256 vaultShareValue) {\n        vaultShareValue = getPrimaryUnderlyingValueOfShare(vaultState, vaultConfig, account, vaultShares);\n\n        int256 debtOutstanding = getPresentValue(\n            vaultConfig.primeRate,\n            vaultConfig.borrowCurrencyId,\n            vaultState.maturity,\n            debtUnderlying,\n            vaultConfig.getFlag(VaultConfiguration.ENABLE_FCASH_DISCOUNT)\n        );\n\n        if (vaultConfig.hasSecondaryBorrows()) {\n            PrimeRate[2] memory primeRates = VaultSecondaryBorrow.getSecondaryPrimeRateStateful(vaultConfig);\n            (int256 secondaryDebtInPrimary, /* */, /* */, /* */) =\n                VaultSecondaryBorrow.getSecondaryBorrowCollateralFactors(vaultConfig, primeRates, vaultState, account);\n            debtOutstanding = debtOutstanding.add(secondaryDebtInPrimary);\n        }\n\n        // All inputs into this method are underlying and in primary currency denomination\n        collateralRatio = calculateCollateralRatio(vaultShareValue, debtOutstanding);\n    }\n\n    /// @notice Calculates the collateral ratio of an account:\n    ///     vaultShareValue + (debtOutstanding + accountCashHeld)\n    ///     ----------------------------------------------------\n    ///            -1 * (debtOutstanding + accountCashHeld)\n    /// @param vaultShareValue vault share value in primary underlying denomination\n    /// @param netDebtOutstanding debt outstanding in primary currency underlying denomination\n    /// @return collateralRatio for an account, expressed in 1e9 \"RATE_PRECISION\"\n    function calculateCollateralRatio(\n        int256 vaultShareValue,\n        int256 netDebtOutstanding\n    ) internal pure returns (int256 collateralRatio) {\n        // netAssetValue includes the value held in vaultShares net off against the outstanding debt.\n        // netAssetValue can be either positive or negative here. If it is positive (normal condition)\n        // then the account has more value than debt, if it is negative then the account is insolvent\n        // (it cannot repay its debt if we sold all of its vault shares).\n        int256 netAssetValue = vaultShareValue.add(netDebtOutstanding);\n\n        // We calculate the collateral ratio (netAssetValue to debt ratio):\n        //  if netAssetValue > 0 and netDebtOutstanding < 0: collateralRatio > 0, closer to zero means more risk\n        //  if netAssetValue < 0 and netDebtOutstanding < 0: collateralRatio < 0, the account is insolvent\n        //  if debtOutstanding >= 0: collateralRatio is infinity, there is no risk at all (no debt left)\n        if (netDebtOutstanding >= 0)  {\n            // When there is no debt outstanding then we use a maximal collateral ratio to represent \"infinity\"\n            collateralRatio = type(int256).max;\n        } else {\n            // Negate debt outstanding in the denominator so collateral ratio is positive\n            collateralRatio = netAssetValue.divInRatePrecision(netDebtOutstanding.neg());\n        }\n    }\n\n    /// @notice Calculates account health factors for liquidation.\n    function calculateAccountHealthFactors(\n        VaultConfig memory vaultConfig,\n        VaultAccount memory vaultAccount,\n        VaultState memory vaultState,\n        PrimeRate[2] memory primeRates\n    ) internal view returns (\n        VaultAccountHealthFactors memory h,\n        VaultSecondaryBorrow.SecondaryExchangeRates memory er\n    ) {\n\n        h.vaultShareValueUnderlying = getPrimaryUnderlyingValueOfShare(\n            vaultState, vaultConfig, vaultAccount.account, vaultAccount.vaultShares\n        );\n\n        h.debtOutstanding[0] = getPresentValue(\n            vaultConfig.primeRate,\n            vaultConfig.borrowCurrencyId,\n            vaultState.maturity,\n            vaultAccount.accountDebtUnderlying,\n            vaultConfig.getFlag(VaultConfiguration.ENABLE_FCASH_DISCOUNT)\n        // During liquidation, it is possible that the vault account has a temp cash balance due to\n        // a previous liquidation.\n        ).add(vaultConfig.primeRate.convertToUnderlying(vaultAccount.tempCashBalance));\n        h.totalDebtOutstandingInPrimary = h.debtOutstanding[0];\n\n        if (vaultConfig.hasSecondaryBorrows()) {\n            int256 secondaryDebtInPrimary;\n            (secondaryDebtInPrimary, er, h.debtOutstanding[1], h.debtOutstanding[2]) = \n                VaultSecondaryBorrow.getSecondaryBorrowCollateralFactors(\n                    vaultConfig, primeRates, vaultState, vaultAccount.account\n                );\n\n            h.totalDebtOutstandingInPrimary = h.totalDebtOutstandingInPrimary.add(secondaryDebtInPrimary);\n        }\n\n        h.collateralRatio = calculateCollateralRatio(h.vaultShareValueUnderlying, h.totalDebtOutstandingInPrimary);\n    }\n\n    function getLiquidationFactors(\n        VaultConfig memory vaultConfig,\n        VaultAccountHealthFactors memory h,\n        VaultSecondaryBorrow.SecondaryExchangeRates memory er,\n        uint256 currencyIndex,\n        int256 vaultShares,\n        int256 depositUnderlyingInternal\n    ) internal pure returns (int256, uint256) {\n        // Short circuit all calculations if there is no vault share value\n        if (h.vaultShareValueUnderlying <= 0) return (0, 0);\n\n        int256 minBorrowSize;\n        if (currencyIndex == 0) {\n            minBorrowSize = vaultConfig.minAccountBorrowSize;\n        } else {\n            // Return zero if the secondary borrow currency is not defined\n            if (vaultConfig.secondaryBorrowCurrencies[currencyIndex - 1] == 0) return (0, 0);\n            // Otherwise set the min borrow size appropriately\n            minBorrowSize = vaultConfig.minAccountSecondaryBorrow[currencyIndex - 1];\n        }\n\n\n        // If currencyIndex == 0 then the exchange rate is the unit rate, this will be\n        // the case the vast majority of the time.\n        int256 exchangeRate;\n        // If there are no secondary borrows, the exchange rate may be unset, resulting in divide by\n        // zero errors so it is set to 1 here.\n        (exchangeRate, er.rateDecimals) = er.rateDecimals == 0 ? (1, 1) : (er.rateDecimals, er.rateDecimals);\n        if (currencyIndex == 1) exchangeRate = er.exchangeRateOne;\n        else if (currencyIndex == 2) exchangeRate = er.exchangeRateTwo;\n\n        int256 maxLiquidatorDepositLocal = _calculateDeleverageAmount(\n            vaultConfig,\n            h.vaultShareValueUnderlying,\n            h.totalDebtOutstandingInPrimary.neg(),\n            h.debtOutstanding[currencyIndex].neg(),\n            minBorrowSize,\n            exchangeRate,\n            er.rateDecimals\n        );\n\n        // NOTE: deposit amount is always positive in this method\n        if (depositUnderlyingInternal < maxLiquidatorDepositLocal) {\n            // If liquidating past the debt outstanding above the min borrow, then the entire\n            // debt outstanding must be liquidated.\n\n            // (debtOutstanding - depositAmountUnderlying) is the post liquidation debt. As an\n            // edge condition, when debt outstanding is discounted to present value, the account\n            // may be liquidated to zero while their debt outstanding is still greater than the\n            // min borrow size (which is normally enforced in notional terms -- i.e. non present\n            // value). Resolving this would require additional complexity for not much gain. An\n            // account within 20% of the minBorrowSize in a vault that has fCash discounting enabled\n            // may experience a full liquidation as a result.\n            require(\n                h.debtOutstanding[currencyIndex].sub(depositUnderlyingInternal) < minBorrowSize,\n                \"Must Liquidate All Debt\"\n            );\n        } else {\n            // If the deposit amount is greater than maxLiquidatorDeposit then limit it to the max\n            // amount here.\n            depositUnderlyingInternal = maxLiquidatorDepositLocal;\n        }\n\n        // Convert to primary denomination, same as vault shares\n        int256 depositAmountPrimary = depositUnderlyingInternal.mul(er.rateDecimals).div(exchangeRate);\n        uint256 vaultSharesToLiquidator = _calculateVaultSharesToLiquidator(\n            vaultShares,\n            vaultConfig.liquidationRate,\n            h.vaultShareValueUnderlying,\n            depositAmountPrimary\n        );\n\n        return (depositUnderlyingInternal, vaultSharesToLiquidator);\n    }\n\n    /// @notice Calculates the amount a liquidator can deposit in underlying terms to deleverage an account.\n    /// @param vaultConfig the vault configuration\n    /// @param vaultShareValueUnderlying value of the vault account's vault shares\n    /// @param totalDebtOutstanding total debt outstanding in the account\n    /// @param localDebtOutstanding value of the debt in the currency being liquidated\n    /// @param minAccountBorrowSizeLocal minimum amount the account must borrow in the local currency\n    /// @param exchangeRate exchange rate between the local currency and primary\n    /// @param rateDecimals precision of the exchange rate between local currency and primary\n    /// @return maxLiquidatorDepositLocal the maximum a liquidator can deposit in local underlying internal denomination\n    function _calculateDeleverageAmount(\n        VaultConfig memory vaultConfig,\n        // NOTE: vaultShareValueUnderlying is never zero or negative in this method due to the first if\n        // statement inside getLiquidationFactors\n        int256 vaultShareValueUnderlying,\n        int256 totalDebtOutstanding,\n        int256 localDebtOutstanding,\n        int256 minAccountBorrowSizeLocal,\n        int256 exchangeRate,\n        int256 rateDecimals\n    ) private pure returns (int256 maxLiquidatorDepositLocal) {\n        // In the base case, the liquidator can deleverage an account up to maxDeleverageCollateralRatio, this\n        // assures that a liquidator cannot over-purchase assets on an account.\n        int256 maxCollateralRatioPlusOne = vaultConfig.maxDeleverageCollateralRatio.add(Constants.RATE_PRECISION);\n\n        // The post liquidation collateral ratio is calculated as:\n        //                          (shareValue - (debtOutstanding - deposit * (1 - liquidationRate)))\n        //   postLiquidationRatio = ----------------------------------------------------------------\n        //                                          (debtOutstanding - deposit)\n        //\n        //   if we rearrange terms to put the deposit on one side we get:\n        //\n        //              (postLiquidationRatio + 1) * debtOutstanding - shareValue\n        //   deposit =  ---------------------------------------------------------- \n        //                  (postLiquidationRatio + 1) - liquidationRate\n\n        int256 maxLiquidatorDepositPrimary = (\n            totalDebtOutstanding.mulInRatePrecision(maxCollateralRatioPlusOne).sub(vaultShareValueUnderlying)\n        // Both denominators are in 1e9 precision\n        ).divInRatePrecision(maxCollateralRatioPlusOne.sub(vaultConfig.liquidationRate));\n\n        maxLiquidatorDepositLocal = maxLiquidatorDepositPrimary.mul(exchangeRate).div(rateDecimals);\n        int256 postLiquidationDebtRemaining = localDebtOutstanding.sub(maxLiquidatorDepositLocal);\n\n        // Cap the liquidator's deposit to the local debt outstanding under the two conditions:\n        //  - Liquidator cannot repay more than the debt outstanding\n        //  - If an account's (debtOutstanding - maxLiquidatorDeposit) < minAccountBorrowSize it may not be\n        //    profitable to liquidate a second time due to gas costs. If this occurs the liquidator must\n        //    liquidate the account such that it has no fCash debt.\n        if (\n            localDebtOutstanding < maxLiquidatorDepositLocal ||\n            postLiquidationDebtRemaining < minAccountBorrowSizeLocal\n        ) {\n            maxLiquidatorDepositLocal = localDebtOutstanding;\n            maxLiquidatorDepositPrimary = localDebtOutstanding.mul(rateDecimals).div(exchangeRate);\n        }\n\n        // Check that the maxLiquidatorDepositLocal does not exceed the total vault shares owned by\n        // the account:\n        //                               vaultShares * (deposit * liquidationRate)\n        //    vaultSharesToLiquidator =  -----------------------------------------\n        //                                   vaultShareValue * RATE_PRECISION\n        //\n        // If (deposit * liquidationRate) / vaultShareValue > RATE_PRECISION then the account may be\n        // insolvent (or unable to reach the maxDeleverageCollateralRatio) and we are over liquidating.\n        //\n        // In this case the liquidator's max deposit is:\n        //      (deposit * liquidationRate) / vaultShareValue == RATE_PRECISION, therefore:\n        //      deposit = (RATE_PRECISION * vaultShareValue / liquidationRate)\n        int256 depositRatio = maxLiquidatorDepositPrimary.mul(vaultConfig.liquidationRate).div(vaultShareValueUnderlying);\n\n        // Use equal to so we catch potential off by one issues, the deposit amount calculated inside the if statement\n        // below will round the maxLiquidatorDepositPrimeCash down\n        if (depositRatio >= Constants.RATE_PRECISION) {\n            maxLiquidatorDepositPrimary = vaultShareValueUnderlying.divInRatePrecision(vaultConfig.liquidationRate);\n            maxLiquidatorDepositLocal = maxLiquidatorDepositPrimary.mul(exchangeRate).div(rateDecimals);\n        }\n    }\n\n    /// @notice Returns how many vault shares the liquidator will receive given their deposit\n    /// @param vaultShares vault shares held on the account\n    /// @param liquidationRate the discount rate on the liquidation\n    /// @param vaultShareValueUnderlying the value in primary underlying of all of the account's vault shares\n    /// @param liquidatorDepositPrimaryUnderlying the amount of deposit in primary underlying\n    /// @return vaultSharesToLiquidator the number of vault shares to transfer to the liquidator\n    function _calculateVaultSharesToLiquidator(\n        int256 vaultShares,\n        int256 liquidationRate,\n        int256 vaultShareValueUnderlying,\n        int256 liquidatorDepositPrimaryUnderlying\n    ) private pure returns (uint256 vaultSharesToLiquidator) {\n        // Calculates the following:\n        //                liquidationRate * liquidatorDeposit\n        // vaultShares * -----------------------------------\n        //                RATE_PRECISION * vaultShareValue\n        vaultSharesToLiquidator = vaultShares\n            .mul(liquidationRate)\n            .mul(liquidatorDepositPrimaryUnderlying)\n            .div(vaultShareValueUnderlying)\n            .div(Constants.RATE_PRECISION)\n            .toUint();\n    }\n}"
    },
    {
      "filename": "contracts-v2/contracts/internal/vaults/VaultAccount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    VaultConfig,\n    VaultAccount,\n    VaultAccountStorage,\n    VaultState,\n    VaultStateStorage,\n    VaultAccountSecondaryDebtShareStorage,\n    PrimeRate\n} from \"../../global/Types.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\n\nimport {Emitter} from \"../Emitter.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {PrimeCashExchangeRate} from \"../pCash/PrimeCashExchangeRate.sol\";\nimport {TokenHandler} from \"../balances/TokenHandler.sol\";\n\nimport {VaultSecondaryBorrow} from \"./VaultSecondaryBorrow.sol\";\nimport {VaultConfiguration} from \"./VaultConfiguration.sol\";\nimport {VaultStateLib} from \"./VaultState.sol\";\n\nimport {IVaultAction} from \"../../../interfaces/notional/IVaultController.sol\";\n\nlibrary VaultAccountLib {\n    using VaultConfiguration for VaultConfig;\n    using VaultStateLib for VaultState;\n    using PrimeRateLib for PrimeRate;\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n\n    event VaultSettledAssetsRemaining(\n        address indexed vault,\n        uint256 indexed maturity,\n        int256 remainingPrimeCash,\n        uint256 remainingStrategyTokens\n    );\n\n    event VaultAccountLendAtZeroInterest(\n        address indexed vault,\n        uint256 indexed maturity,\n        address indexed account,\n        uint16 currencyId,\n        int256 fCashRepaid,\n        int256 primeCashCostToLend\n    );\n\n    /// @notice Returns a single account's vault position\n    function getVaultAccount(\n        address account, VaultConfig memory vaultConfig\n    ) internal view returns (VaultAccount memory vaultAccount) {\n        mapping(address => mapping(address => VaultAccountStorage)) storage store = LibStorage.getVaultAccount();\n        VaultAccountStorage storage s = store[account][vaultConfig.vault];\n\n        vaultAccount.maturity = s.maturity;\n        vaultAccount.vaultShares = s.vaultShares;\n        vaultAccount.account = account;\n        // Read any temporary cash balance onto the stack to be applied\n        vaultAccount.tempCashBalance = int256(uint256(s.primaryCash));\n        vaultAccount.lastUpdateBlockTime = s.lastUpdateBlockTime;\n\n        vaultAccount.accountDebtUnderlying = VaultStateLib.readDebtStorageToUnderlying(\n            vaultConfig.primeRate, vaultAccount.maturity, s.accountDebt\n        );\n    }\n\n    /// @notice Called when a vault account is liquidated and cash is deposited into its account and held\n    /// as collateral against fCash\n    function setVaultAccountForLiquidation(\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig,\n        uint256 currencyIndex,\n        int256 netCashBalanceChange,\n        bool checkMinBorrow\n    ) internal {\n        mapping(address => mapping(address => VaultAccountStorage)) storage store = LibStorage\n            .getVaultAccount();\n        VaultAccountStorage storage s = store[vaultAccount.account][vaultConfig.vault];\n        \n        if (currencyIndex == 0) {\n            s.primaryCash = int256(uint256(s.primaryCash)).add(netCashBalanceChange).toUint().toUint80();\n        } else if (currencyIndex == 1) {\n            s.secondaryCashOne = int256(uint256(s.secondaryCashOne)).add(netCashBalanceChange).toUint().toUint80();\n        } else if (currencyIndex == 2) {\n            s.secondaryCashTwo = int256(uint256(s.secondaryCashTwo)).add(netCashBalanceChange).toUint().toUint80();\n        } else {\n            // This should never occur\n            revert();\n        }\n\n        // Clear temp cash balance, it is not updated during liquidation\n        vaultAccount.tempCashBalance = 0;\n\n        _setVaultAccount(vaultAccount, vaultConfig, s, checkMinBorrow, true);\n    }\n\n    /// @notice Sets a single account's vault position in storage\n    function setVaultAccount(\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig,\n        bool checkMinBorrow \n    ) internal {\n        mapping(address => mapping(address => VaultAccountStorage)) storage store = LibStorage\n            .getVaultAccount();\n        VaultAccountStorage storage s = store[vaultAccount.account][vaultConfig.vault];\n\n        _setVaultAccount(vaultAccount, vaultConfig, s, checkMinBorrow, false);\n\n        // Cash balances should never be preserved after a non-liquidation transaction,\n        // during enter, exit, roll and settle any cash balances should be applied to\n        // the transaction. These cash balances are only set after liquidation.\n        s.primaryCash = 0;\n        require(s.secondaryCashOne == 0 && s.secondaryCashTwo == 0); // dev: secondary cash\n    }\n\n    function _setVaultAccount(\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig,\n        VaultAccountStorage storage s,\n        bool checkMinBorrow,\n        bool isLiquidation\n    ) private {\n        // The temporary cash balance must be cleared to zero by the end of the transaction\n        require(vaultAccount.tempCashBalance == 0); // dev: cash balance not cleared\n        // An account must maintain a minimum borrow size in order to enter the vault. If the account\n        // wants to exit under the minimum borrow size it must fully exit so that we do not have dust\n        // accounts that become insolvent.\n        if (\n            vaultAccount.accountDebtUnderlying.neg() < vaultConfig.minAccountBorrowSize &&\n            // During local currency liquidation and settlement, the min borrow check is skipped\n            checkMinBorrow\n        ) {\n            // NOTE: use 1 to represent the minimum amount of vault shares due to rounding in the\n            // vaultSharesToLiquidator calculation\n            require(vaultAccount.accountDebtUnderlying == 0 || vaultAccount.vaultShares <= 1, \"Min Borrow\");\n        }\n\n        if (vaultConfig.hasSecondaryBorrows()) {\n            VaultAccountSecondaryDebtShareStorage storage _s = \n                LibStorage.getVaultAccountSecondaryDebtShare()[vaultAccount.account][vaultConfig.vault];\n            uint256 secondaryMaturity = _s.maturity;\n            require(vaultAccount.maturity == secondaryMaturity || secondaryMaturity == 0); // dev: invalid maturity\n        }\n\n        uint256 newDebtStorageValue = VaultStateLib.calculateDebtStorage(\n            vaultConfig.primeRate,\n            vaultAccount.maturity,\n            vaultAccount.accountDebtUnderlying\n        ).neg().toUint();\n\n        if (!isLiquidation) {\n            // Liquidation will emit its own custom events\n            Emitter.emitVaultAccountChanges(vaultAccount, vaultConfig, s, newDebtStorageValue);\n        }\n\n        s.vaultShares = vaultAccount.vaultShares.toUint80();\n        s.maturity = vaultAccount.maturity.toUint40();\n        s.lastUpdateBlockTime = vaultAccount.lastUpdateBlockTime.toUint32();\n        s.accountDebt = newDebtStorageValue.toUint80();\n    }\n\n    /// @notice Updates the secondary cash held by the account, should only be updated in two places:\n    ///   - During liquidation of a secondary borrow\n    ///   - On vault exit when the secondary borrow currency is holding cash\n    /// In setVaultAccount, a vault account cannot end up with a secondary cash balance at the end of a\n    /// user initiated (non-liquidation) transaction. The vault must clearVaultAccountSecondaryCash during\n    /// the redemption of strategy tokens.\n    function setVaultAccountSecondaryCash(\n        address account,\n        address vault,\n        int256 netSecondaryPrimeCashOne,\n        int256 netSecondaryPrimeCashTwo\n    ) internal {\n        VaultAccountStorage storage s = LibStorage.getVaultAccount()[account][vault];\n        s.secondaryCashOne = int256(uint256(s.secondaryCashOne)).add(netSecondaryPrimeCashOne).toUint().toUint80();\n        s.secondaryCashTwo = int256(uint256(s.secondaryCashTwo)).add(netSecondaryPrimeCashTwo).toUint().toUint80();\n    }\n\n    function checkVaultAccountSecondaryCash(\n        address account,\n        address vault\n    ) internal view {\n        VaultAccountStorage storage s = LibStorage.getVaultAccount()[account][vault];\n        require(s.secondaryCashOne == 0);\n        require(s.secondaryCashTwo == 0);\n    }\n    \n    function clearVaultAccountSecondaryCash(\n        address account,\n        address vault\n    ) internal returns (int256 secondaryCashOne, int256 secondaryCashTwo) {\n        VaultAccountStorage storage s = LibStorage.getVaultAccount()[account][vault];\n        secondaryCashOne = int256(uint256(s.secondaryCashOne));\n        secondaryCashTwo = int256(uint256(s.secondaryCashTwo));\n\n        s.secondaryCashOne = 0;\n        s.secondaryCashTwo = 0;\n    }\n\n    /// @notice Updates an account's fCash position and the current vault state at the same time. Also updates\n    /// and checks the total borrow capacity\n    /// @param vaultAccount vault account\n    /// @param vaultState vault state matching the maturity\n    /// @param netUnderlyingDebt underlying debt change to the account, (borrowing < 0, lending > 0)\n    /// @param netPrimeCash amount of prime cash to charge or credit to the account, must be the oppositely\n    /// signed compared to the netfCash sign\n    function updateAccountDebt(\n        VaultAccount memory vaultAccount,\n        VaultState memory vaultState,\n        int256 netUnderlyingDebt,\n        int256 netPrimeCash\n    ) internal pure {\n        if (vaultAccount.maturity != vaultState.maturity) {\n            // If borrowing across maturities, ensure that the account does not have any\n            // debt in the old maturity remaining in their account.\n            require(vaultAccount.accountDebtUnderlying == 0);\n        }\n        vaultAccount.tempCashBalance = vaultAccount.tempCashBalance.add(netPrimeCash);\n\n        // Update debt state on the account and the vault\n        vaultAccount.accountDebtUnderlying = vaultAccount.accountDebtUnderlying.add(netUnderlyingDebt);\n        require(vaultAccount.accountDebtUnderlying <= 0);\n        vaultState.totalDebtUnderlying = vaultState.totalDebtUnderlying.add(netUnderlyingDebt);\n\n        // Truncate dust balances towards zero\n        if (0 < vaultState.totalDebtUnderlying && vaultState.totalDebtUnderlying < 10) vaultState.totalDebtUnderlying = 0;\n        require(vaultState.totalDebtUnderlying <= 0);\n    }\n\n\n    /// @notice Enters into a vault position, borrowing from Notional if required.\n    /// @param vaultAccount vault account entering the position\n    /// @param vaultConfig vault configuration\n    /// @param maturity maturity to enter into\n    /// @param underlyingToBorrow a positive amount of underlying to borrow, will be converted to a negative\n    /// amount inside the method\n    /// @param maxBorrowRate the maximum annualized interest rate to borrow at, a zero signifies no\n    /// slippage limit applied\n    /// @param vaultData arbitrary data to be passed to the vault\n    /// @param strategyTokenDeposit some amount of strategy tokens from a previous maturity that will\n    /// be carried over into the current maturity\n    /// @return vaultSharesAdded the total vault shares added to the maturity for the account,\n    /// including any strategy tokens transferred during a roll or settle\n    function borrowAndEnterVault(\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig,\n        uint256 maturity,\n        uint256 underlyingToBorrow,\n        uint32 maxBorrowRate,\n        bytes calldata vaultData,\n        uint256 strategyTokenDeposit\n    ) internal returns (uint256 vaultSharesAdded) {\n        // The vault account can only be increasing their borrow position or not have one set. If they\n        // are increasing their position they must be borrowing from the same maturity.\n        require(vaultAccount.maturity == maturity || vaultAccount.accountDebtUnderlying == 0);\n        VaultState memory vaultState = VaultStateLib.getVaultState(vaultConfig, maturity);\n\n        // Borrows fCash and puts the cash balance into the vault account's temporary cash balance\n        if (underlyingToBorrow > 0) {\n            _borrowIntoVault(\n                vaultAccount,\n                vaultConfig,\n                vaultState,\n                maturity,\n                underlyingToBorrow.toInt().neg(),\n                maxBorrowRate\n            );\n        } else if (maturity != Constants.PRIME_CASH_VAULT_MATURITY) {\n            // Ensure that the maturity is a valid one if we are not borrowing (borrowing will fail)\n            // against an invalid market.\n            VaultConfiguration.checkValidMaturity(\n                vaultConfig.borrowCurrencyId,\n                maturity,\n                vaultConfig.maxBorrowMarketIndex,\n                block.timestamp\n            );\n        }\n\n        // Sets the maturity on the vault account, deposits tokens into the vault, and"
    }
  ]
}