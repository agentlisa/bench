{
  "Title": "[L01] Deviation from ERC777 specification",
  "Content": "Pool Tokens are created in a non-conventional way. Whenever users deposit assets into the system, they are internally accounted for but the new balances are not accessible to the ERC777 token functions. At the end of the draw, when the balances become available, it is no longer practical to create the corresponding `Minted` and `Transfer` events for each user. Instead, these events are emitted once for all users, with the recipient set to the Pool contract.\n\n\nThis is a deviation from the ERC777 specification and makes it impossible to track balances using the event logs. [This is already acknowledged and documented by the PoolTogether team](https://github.com/pooltogether/pooltogether-contracts/blob/78ac6863f4616269f7d04a0ddd1d60bdfc454937/contracts/ERC777Pool.sol#L324-L327), but we believe it should be stated in this report anyway for the sake of transparency and community awareness.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/ERC777Pool.sol",
      "content": "/**\nCopyright 2019 PoolTogether LLC\n\nThis file is part of PoolTogether.\n\nPoolTogether is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation under version 3 of the License.\n\nPoolTogether is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.5.12;\n\nimport \"./BasePool.sol\";\nimport \"@openzeppelin/contracts/contracts/token/ERC777/IERC777.sol\";\nimport \"@openzeppelin/contracts/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts/contracts/token/ERC777/IERC777Sender.sol\";\nimport \"@openzeppelin/contracts/contracts/introspection/IERC1820Registry.sol\";\nimport \"@openzeppelin/contracts/contracts/utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * Largely taken from the OpenZeppelin ERC777 contract.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n *\n * It is important to note that no Mint events are emitted.  Tokens are minted in batches\n * by a state change in a tree data structure, so emitting a Mint event for each user\n * is not possible.\n *\n */\ncontract ERC777Pool is IERC20, IERC777, BasePool {\n  using SafeMath for uint256;\n  using Address for address;\n\n  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n  // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\n  // See https://github.com/ethereum/solidity/issues/4024.\n\n  // keccak256(\"ERC777TokensSender\")\n  bytes32 constant internal TOKENS_SENDER_INTERFACE_HASH =\n      0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\n\n  // keccak256(\"ERC777TokensRecipient\")\n  bytes32 constant internal TOKENS_RECIPIENT_INTERFACE_HASH =\n      0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n  string internal _name;\n  string internal _symbol;\n\n  // This isn't ever read from - it's only used to respond to the defaultOperators query.\n  address[] internal _defaultOperatorsArray;\n\n  // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n  mapping(address => bool) internal _defaultOperators;\n\n  // For each account, a mapping of its operators and revoked default operators.\n  mapping(address => mapping(address => bool)) internal _operators;\n  mapping(address => mapping(address => bool)) internal _revokedDefaultOperators;\n\n  // ERC20-allowances\n  mapping (address => mapping (address => uint256)) internal _allowances;\n\n  function init (\n    address _owner,\n    address _cToken,\n    uint256 _feeFraction,\n    address _feeBeneficiary,\n    string memory name,\n    string memory symbol,\n    address[] memory defaultOperators\n  ) public initializer {\n    init(_owner, _cToken, _feeFraction, _feeBeneficiary);\n    initERC777(name, symbol, defaultOperators);\n  }\n\n  /**\n    * @dev `defaultOperators` may be an empty array.\n    */\n  function initERC777 (\n      string memory name,\n      string memory symbol,\n      address[] memory defaultOperators\n  ) public {\n      require(bytes(name).length != 0, \"name must be defined\");\n      require(bytes(symbol).length != 0, \"symbol must be defined\");\n      require(bytes(_name).length == 0, \"ERC777 has already been initialized\");\n\n      _name = name;\n      _symbol = symbol;\n\n      _defaultOperatorsArray = defaultOperators;\n      for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n          _defaultOperators[_defaultOperatorsArray[i]] = true;\n      }\n\n      // register interfaces\n      ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n      ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n  }\n\n  /**\n    * @dev See {IERC777-name}.\n    */\n  function name() public view returns (string memory) {\n      return _name;\n  }\n\n  /**\n    * @dev See {IERC777-symbol}.\n    */\n  function symbol() public view returns (string memory) {\n      return _symbol;\n  }\n\n  /**\n    * @dev See {ERC20Detailed-decimals}.\n    *\n    * Always returns 18, as per the\n    * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n    */\n  function decimals() public pure returns (uint8) {\n      return 18;\n  }\n\n  /**\n    * @dev See {IERC777-granularity}.\n    *\n    * This implementation always returns `1`.\n    */\n  function granularity() public view returns (uint256) {\n      return 1;\n  }\n\n  /**\n    * @dev See {IERC777-totalSupply}.\n    */\n  function totalSupply() public view returns (uint256) {\n      return committedSupply();\n  }\n\n  /**\n    * @dev See {IERC777-send}.\n    *\n    * Also emits a {Transfer} event for ERC20 compatibility.\n    */\n  function send(address recipient, uint256 amount, bytes calldata data) external {\n      _send(msg.sender, msg.sender, recipient, amount, data, \"\");\n  }\n\n  /**\n    * @dev See {IERC20-transfer}.\n    *\n    * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n    * interface if it is a contract.\n    *\n    * Also emits a {Sent} event.\n    */\n  function transfer(address recipient, uint256 amount) external returns (bool) {\n      require(recipient != address(0), \"ERC777: transfer to the zero address\");\n\n      address from = msg.sender;\n\n      _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n\n      _move(from, from, recipient, amount, \"\", \"\");\n\n      _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n\n      return true;\n  }\n\n  /**\n    * @dev See {IERC777-burn}.\n    *\n    * Also emits a {Transfer} event for ERC20 compatibility.\n    */\n  function burn(uint256 amount, bytes calldata data) external {\n      _burn(msg.sender, msg.sender, amount, data, \"\");\n  }\n\n  /**\n    * @dev See {IERC777-isOperatorFor}.\n    */\n  function isOperatorFor(\n      address operator,\n      address tokenHolder\n  ) public view returns (bool) {\n      return operator == tokenHolder ||\n          (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n          _operators[tokenHolder][operator];\n  }\n\n  /**\n    * @dev See {IERC777-authorizeOperator}.\n    */\n  function authorizeOperator(address operator) external {\n      require(msg.sender != operator, \"ERC777: authorizing self as operator\");\n\n      if (_defaultOperators[operator]) {\n          delete _revokedDefaultOperators[msg.sender][operator];\n      } else {\n          _operators[msg.sender][operator] = true;\n      }\n\n      emit AuthorizedOperator(operator, msg.sender);\n  }\n\n  /**\n    * @dev See {IERC777-revokeOperator}.\n    */\n  function revokeOperator(address operator) external {\n      require(operator != msg.sender, \"ERC777: revoking self as operator\");\n\n      if (_defaultOperators[operator]) {\n          _revokedDefaultOperators[msg.sender][operator] = true;\n      } else {\n          delete _operators[msg.sender][operator];\n      }\n\n      emit RevokedOperator(operator, msg.sender);\n  }\n\n  /**\n    * @dev See {IERC777-defaultOperators}.\n    */\n  function defaultOperators() public view returns (address[] memory) {\n      return _defaultOperatorsArray;\n  }\n\n  /**\n    * @dev See {IERC777-operatorSend}.\n    *\n    * Emits {Sent} and {Transfer} events.\n    */\n  function operatorSend(\n      address sender,\n      address recipient,\n      uint256 amount,\n      bytes calldata data,\n      bytes calldata operatorData\n  )\n  external\n  {\n      require(isOperatorFor(msg.sender, sender), \"ERC777: caller is not an operator for holder\");\n      _send(msg.sender, sender, recipient, amount, data, operatorData);\n  }\n\n  /**\n    * @dev See {IERC777-operatorBurn}.\n    *\n    * Emits {Burned} and {Transfer} events.\n    */\n  function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\n      require(isOperatorFor(msg.sender, account), \"ERC777: caller is not an operator for holder\");\n      _burn(msg.sender, account, amount, data, operatorData);\n  }\n\n  /**\n    * @dev See {IERC20-allowance}.\n    *\n    * Note that operator and allowance concepts are orthogonal: operators may\n    * not have allowance, and accounts with allowance may not be operators\n    * themselves.\n    */\n  function allowance(address holder, address spender) public view returns (uint256) {\n      return _allowances[holder][spender];\n  }\n\n  /**\n    * @dev See {IERC20-approve}.\n    *\n    * Note that accounts cannot have allowance issued by their operators.\n    */\n  function approve(address spender, uint256 value) external returns (bool) {\n      address holder = msg.sender;\n      _approve(holder, spender, value);\n      return true;\n  }\n\n  /**\n  * @dev See {IERC20-transferFrom}.\n  *\n  * Note that operator and allowance concepts are orthogonal: operators cannot\n  * call `transferFrom` (unless they have allowance), and accounts with\n  * allowance cannot call `operatorSend` (unless they are operators).\n  *\n  * Emits {Sent}, {Transfer} and {Approval} events.\n  */\n  function transferFrom(address holder, address recipient, uint256 amount) external returns (bool) {\n      require(recipient != address(0), \"ERC777: transfer to the zero address\");\n      require(holder != address(0), \"ERC777: transfer from the zero address\");\n\n      address spender = msg.sender;\n\n      _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\n\n      _move(spender, holder, recipient, amount, \"\", \"\");\n      _approve(holder, spender, _allowances[holder][spender].sub(amount, \"ERC777: transfer amount exceeds allowance\"));\n\n      _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\n\n      return true;\n  }\n\n  /**\n   * @notice Commits the current draw.  Mints the open supply number of tokens.\n   * @dev This function deviates from the ERC 777 spec (https://eips.ethereum.org/EIPS/eip-777).  The spec\n   * says that:\n   *  - \"The balance of the recipient MUST be increased by the amount of tokens minted.\"\n   * However, for this contract it is not feasible to emit Minted for every open deposit.\n   */\n  function emitCommitted() internal {\n    super.emitCommitted();\n    uint256 mintingAmount = openSupply();\n    _mintEvents(address(this), address(this), mintingAmount, '', '');\n  }\n\n  /**\n   * @notice Awards the winnings to a user.  Ensures that the Minted event is fired\n   */\n  function awardWinnings(address winner, uint256 amount) internal {\n    super.awardWinnings(winner, amount);\n    _mint(address(this), winner, amount, '', '');\n  }\n\n  /**\n    * @dev Creates `amount` tokens and assigns them to `account`, increasing\n    * the total supply.\n    *\n    * If a send hook is registered for `account`, the corresponding function\n    * will be called with `operator`, `data` and `operatorData`.\n    *\n    * See {IERC777Sender} and {IERC777Recipient}.\n    *\n    * Emits {Minted} and {IERC20-Transfer} events.\n    *\n    * Requirements\n    *\n    * - `account` cannot be the zero address.\n    * - if `account` is a contract, it must implement the {IERC777Recipient}\n    * interface.\n    */\n  function _mint(\n      address operator,\n      address account,\n      uint256 amount,\n      bytes memory userData,\n      bytes memory operatorData\n  )\n  internal\n  {\n      _callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);\n      _mintEvents(operator, account, amount, userData, operatorData);\n  }\n\n  function _mintEvents(\n      address operator,\n      address account,\n      uint256 amount,\n      bytes memory userData,\n      bytes memory operatorData\n  )\n  internal\n  {\n      emit Minted(operator, account, amount, userData, operatorData);\n      emit Transfer(address(0), account, amount);\n  }\n\n  /**\n    * @dev Send tokens\n    * @param operator address operator requesting the transfer\n    * @param from address token holder address\n    * @param to address recipient address\n    * @param amount uint256 amount of tokens to transfer\n    * @param userData bytes extra information provided by the token holder (if any)\n    * @param operatorData bytes extra information provided by the operator (if any)\n    */\n  function _send(\n      address operator,\n      address from,\n      address to,\n      uint256 amount,\n      bytes memory userData,\n      bytes memory operatorData\n  )\n      private\n  {\n      require(from != address(0), \"ERC777: send from the zero address\");\n      require(to != address(0), \"ERC777: send to the zero address\");\n\n      _callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n      _move(operator, from, to, amount, userData, operatorData);\n\n      _callTokensReceived(operator, from, to, amount, userData, operatorData, true);\n  }\n\n  /**\n    * @dev Burn tokens\n    * @param operator address operator requesting the operation\n    * @param from address token holder address\n    * @param amount uint256 amount of tokens to burn\n    * @param data bytes extra information provided by the token holder\n    * @param operatorData bytes extra information provided by the operator (if any)\n    */\n  function _burn(\n      address operator,\n      address from,\n      uint256 amount,\n      bytes memory data,\n      bytes memory operatorData\n  )\n      private\n  {\n      require(from != address(0), \"ERC777: burn from the zero address\");\n      uint256 committedBalance = drawState.committedBalanceOf(from);\n      require(amount <= committedBalance, \"not enough funds\");\n\n      _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n      // Update state variables\n      drawState.withdrawCommitted(from, amount);\n      _withdraw(from, amount);\n\n      emit Burned(operator, from, amount, data, operatorData);\n      emit Transfer(from, address(0), amount);\n  }\n\n  function _move(\n      address operator,\n      address from,\n      address to,\n      uint256 amount,\n      bytes memory userData,\n      bytes memory operatorData\n  )\n      private\n  {\n      balances[from] = balances[from].sub(amount, \"move could not sub amount\");\n      balances[to] = balances[to].add(amount);\n      drawState.withdrawCommitted(from, amount);\n      drawState.depositCommitted(to, amount);\n\n      emit Sent(operator, from, to, amount, userData, operatorData);\n      emit Transfer(from, to, amount);\n  }\n\n  function _approve(address holder, address spender, uint256 value) private {\n      require(spender != address(0), \"ERC777: approve to the zero address\");\n\n      _allowances[holder][spender] = value;\n      emit Approval(holder, spender, value);\n  }\n\n  /**\n    * @dev Call from.tokensToSend() if the interface is registered\n    * @param operator address operator requesting the transfer\n    * @param from address token holder address\n    * @param to address recipient address\n    * @param amount uint256 amount of tokens to transfer\n    * @param userData bytes extra information provided by the token holder (if any)\n    * @param operatorData bytes extra information provided by the operator (if any)\n    */\n  function _callTokensToSend(\n      address operator,\n      address from,\n      address to,\n      uint256 amount,\n      bytes memory userData,\n      bytes memory operatorData\n  )\n      internal\n  {\n      address implementer = ERC1820_REGISTRY.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH);\n      if (implementer != address(0)) {\n          IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n      }\n  }\n\n  /**\n    * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n    * tokensReceived() was not registered for the recipient\n    * @param operator address operator requesting the transfer\n    * @param from address token holder address\n    * @param to address recipient address\n    * @param amount uint256 amount of tokens to transfer\n    * @param userData bytes extra information provided by the token holder (if any)\n    * @param operatorData bytes extra information provided by the operator (if any)\n    */\n  function _callTokensReceived(\n      address operator,\n      address from,\n      address to,\n      uint256 amount,\n      bytes memory userData,\n      bytes memory operatorData,\n      bool requireReceptionAck\n  )\n      private\n  {\n      address implementer = ERC1820_REGISTRY.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH);\n      if (implementer != address(0)) {\n          IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n      } else if (requireReceptionAck) {\n          require(!to.isContract(), \"ERC777: contract recipient has no implementer for ERC777TokensRecipient\");\n      }\n  }\n}"
    }
  ]
}