{
  "Title": "[G-11] Move owner checks to a modifier for gas efficant",
  "Content": "\nIt's better to use a modifier for simple owner checks for an easier inspection of functions. This is also more gas efficient as it does not control with external call.\n\n**The part where ``owner`` is defined:**\n\n```solidity\npackages/v2-library/src/Ownership.sol:\n  22:     function checkIfOwner(address owner) internal view {\n  23          if (msg.sender != owner) revert NotTheOwner(msg.sender, owner);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/Ownership.sol#L22-L23\n\n\n2 results 2 files:\n\n```solidity\npackages/v2-pool/src/TimeswapV2Pool.sol:\n  189:         ITimeswapV2PoolFactory(poolFactory).owner().checkIfOwner();\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/TimeswapV2Pool.sol#L189\n\n```solidity\npackages/v2-pool/src/base/OwnableTwoSteps.sol:\n  23      function setPendingOwner(address chosenPendingOwner) external override {\n  24:         Ownership.checkIfOwner(owner);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/base/OwnableTwoSteps.sol#L23-L24\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-library/src/Ownership.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nlibrary Ownership {\n    /// @dev Reverts when the caller is not the owner.\n    /// @param caller The caller of the function that is not the owner.\n    /// @param owner The actual owner.\n    error NotTheOwner(address caller, address owner);\n\n    /// @dev reverts when the caller is already the owner.\n    /// @param owner The owner.\n    error AlreadyTheOwner(address owner);\n\n    /// @dev revert when the caller is not the pending owner.\n    /// @param caller The caller of the function that is not the pending owner.\n    /// @param pendingOwner The actual pending owner.\n    error NotThePendingOwner(address caller, address pendingOwner);\n\n    /// @dev checks if the caller is the owner.\n    /// @notice Reverts when the msg.sender is not the owner.\n    /// @param owner The owner address.\n    function checkIfOwner(address owner) internal view {\n        if (msg.sender != owner) revert NotTheOwner(msg.sender, owner);\n    }\n\n    /// @dev checks if the caller is already the owner.\n    /// @notice Reverts when the chosen pending owner is already the owner.\n    /// @param chosenPendingOwner The chosen pending owner.\n    /// @param owner The current actual owner.\n    function checkIfAlreadyOwner(address chosenPendingOwner, address owner) internal pure {\n        if (chosenPendingOwner == owner) revert AlreadyTheOwner(owner);\n    }\n\n    /// @dev checks if the caller is the pending owner.\n    /// @notice Reverts when the caller is not the pending owner.\n    /// @param caller The address of the caller.\n    /// @param pendingOwner The current pending owner.\n    function checkIfPendingOwner(address caller, address pendingOwner) internal pure {\n        if (caller != pendingOwner) revert NotThePendingOwner(caller, pendingOwner);\n    }\n}"
    },
    {
      "filename": "packages/v2-pool/src/TimeswapV2Pool.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Ownership} from \"@timeswap-labs/v2-library/src/Ownership.sol\";\n\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {ITimeswapV2Option} from \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\n\nimport {TimeswapV2OptionPosition} from \"@timeswap-labs/v2-option/src/enums/Position.sol\";\n\nimport {StrikeAndMaturity} from \"@timeswap-labs/v2-option/src/structs/StrikeAndMaturity.sol\";\n\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\n\nimport {ITimeswapV2Pool} from \"./interfaces/ITimeswapV2Pool.sol\";\nimport {ITimeswapV2PoolFactory} from \"./interfaces/ITimeswapV2PoolFactory.sol\";\nimport {ITimeswapV2PoolDeployer} from \"./interfaces/ITimeswapV2PoolDeployer.sol\";\n\nimport {ITimeswapV2PoolMintCallback} from \"./interfaces/callbacks/ITimeswapV2PoolMintCallback.sol\";\nimport {ITimeswapV2PoolBurnCallback, ITimeswapV2PoolBurn2Callback} from \"./interfaces/callbacks/ITimeswapV2PoolBurnCallback.sol\";\nimport {ITimeswapV2PoolDeleverageCallback} from \"./interfaces/callbacks/ITimeswapV2PoolDeleverageCallback.sol\";\nimport {ITimeswapV2PoolLeverageCallback} from \"./interfaces/callbacks/ITimeswapV2PoolLeverageCallback.sol\";\nimport {ITimeswapV2PoolRebalanceCallback} from \"./interfaces/callbacks/ITimeswapV2PoolRebalanceCallback.sol\";\n\nimport {ReentrancyGuard} from \"./libraries/ReentrancyGuard.sol\";\n\nimport {LiquidityPosition, LiquidityPositionLibrary} from \"./structs/LiquidityPosition.sol\";\n\nimport {Pool, PoolLibrary} from \"./structs/Pool.sol\";\nimport {TimeswapV2PoolCollectParam, TimeswapV2PoolMintParam, TimeswapV2PoolBurnParam, TimeswapV2PoolDeleverageParam, TimeswapV2PoolLeverageParam, TimeswapV2PoolRebalanceParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2PoolMintChoiceCallbackParam, TimeswapV2PoolMintCallbackParam, TimeswapV2PoolBurnChoiceCallbackParam, TimeswapV2PoolBurnCallbackParam, TimeswapV2PoolDeleverageChoiceCallbackParam, TimeswapV2PoolDeleverageCallbackParam, TimeswapV2PoolLeverageCallbackParam, TimeswapV2PoolLeverageChoiceCallbackParam, TimeswapV2PoolRebalanceCallbackParam} from \"./structs/CallbackParam.sol\";\n\nimport {TimeswapV2PoolMint, TimeswapV2PoolBurn, TimeswapV2PoolDeleverage, TimeswapV2PoolLeverage, TimeswapV2PoolRebalance, TransactionLibrary} from \"./enums/Transaction.sol\";\n\ncontract TimeswapV2Pool is ITimeswapV2Pool, NoDelegateCall {\n    using PoolLibrary for Pool;\n    using Ownership for address;\n    using LiquidityPositionLibrary for LiquidityPosition;\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    address public immutable override poolFactory;\n    /// @inheritdoc ITimeswapV2Pool\n    address public immutable override optionPair;\n    /// @inheritdoc ITimeswapV2Pool\n    uint256 public immutable override transactionFee;\n    /// @inheritdoc ITimeswapV2Pool\n    uint256 public immutable override protocolFee;\n\n    mapping(uint256 => mapping(uint256 => uint96)) private reentrancyGuards;\n    mapping(uint256 => mapping(uint256 => Pool)) private pools;\n\n    StrikeAndMaturity[] private listOfPools;\n\n    function addPoolEnumerationIfNecessary(uint256 strike, uint256 maturity) private {\n        if (reentrancyGuards[strike][maturity] == ReentrancyGuard.NOT_INTERACTED) {\n            reentrancyGuards[strike][maturity] = ReentrancyGuard.NOT_ENTERED;\n            listOfPools.push(StrikeAndMaturity({strike: strike, maturity: maturity}));\n        }\n    }\n\n    /* ===== MODIFIER ===== */\n\n    function raiseGuard(uint256 strike, uint256 maturity) private {\n        ReentrancyGuard.check(reentrancyGuards[strike][maturity]);\n        reentrancyGuards[strike][maturity] = ReentrancyGuard.ENTERED;\n    }\n\n    function lowerGuard(uint256 strike, uint256 maturity) private {\n        reentrancyGuards[strike][maturity] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /* ===== INIT ===== */\n\n    constructor() NoDelegateCall() {\n        (poolFactory, optionPair, transactionFee, protocolFee) = ITimeswapV2PoolDeployer(msg.sender).parameter();\n    }\n\n    // Can be overidden for testing purposes.\n    function blockTimestamp(uint96 durationForward) internal view virtual returns (uint96) {\n        return uint96(block.timestamp + durationForward); // truncation is desired\n    }\n\n    /* ===== VIEW ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    function getByIndex(uint256 id) external view override returns (StrikeAndMaturity memory) {\n        return listOfPools[id];\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function numberOfPools() external view override returns (uint256) {\n        return listOfPools.length;\n    }\n\n    function hasLiquidity(uint256 strike, uint256 maturity) private view {\n        if (pools[strike][maturity].liquidity == 0) Error.requireLiquidity();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLiquidity(uint256 strike, uint256 maturity) external view override returns (uint160) {\n        return pools[strike][maturity].liquidity;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function sqrtInterestRate(uint256 strike, uint256 maturity) external view override returns (uint160) {\n        return pools[strike][maturity].sqrtInterestRate;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function liquidityOf(uint256 strike, uint256 maturity, address owner) external view override returns (uint160) {\n        return pools[strike][maturity].liquidityPositions[owner].liquidity;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function feeGrowth(uint256 strike, uint256 maturity) external view override returns (uint256 long0FeeGrowth, uint256 long1FeeGrowth, uint256 shortFeeGrowth) {\n        return pools[strike][maturity].feeGrowth();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function feesEarnedOf(uint256 strike, uint256 maturity, address owner) external view override returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees) {\n        return pools[strike][maturity].feesEarnedOf(owner);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function protocolFeesEarned(uint256 strike, uint256 maturity) external view override returns (uint256 long0ProtocolFees, uint256 long1ProtocolFees, uint256 shortProtocolFees) {\n        return pools[strike][maturity].protocolFeesEarned();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLongBalance(uint256 strike, uint256 maturity) external view override returns (uint256 long0Amount, uint256 long1Amount) {\n        Pool storage pool = pools[strike][maturity];\n        long0Amount = pool.long0Balance;\n        long1Amount = pool.long1Balance;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLongBalanceAdjustFees(uint256 strike, uint256 maturity) external view override returns (uint256 long0Amount, uint256 long1Amount) {\n        (long0Amount, long1Amount) = pools[strike][maturity].totalLongBalanceAdjustFees(transactionFee);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalPositions(uint256 strike, uint256 maturity) external view override returns (uint256 longAmount, uint256 shortAmount) {\n        (longAmount, shortAmount) = pools[strike][maturity].totalPositions(maturity, blockTimestamp(0));\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    function transferLiquidity(uint256 strike, uint256 maturity, address to, uint160 liquidityAmount) external override {\n        hasLiquidity(strike, maturity);\n\n        if (blockTimestamp(0) > maturity) Error.alreadyMatured(maturity, blockTimestamp(0));\n        if (to == address(0)) Error.zeroAddress();\n        if (liquidityAmount == 0) Error.zeroInput();\n\n        pools[strike][maturity].transferLiquidity(to, liquidityAmount, blockTimestamp(0));\n\n        emit TransferLiquidity(strike, maturity, msg.sender, to, liquidityAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function transferFees(uint256 strike, uint256 maturity, address to, uint256 long0Fees, uint256 long1Fees, uint256 shortFees) external override {\n        if (to == address(0)) Error.zeroAddress();\n        if (long0Fees == 0 && long1Fees == 0 && shortFees == 0) Error.zeroInput();\n\n        pools[strike][maturity].transferFees(maturity, to, long0Fees, long1Fees, shortFees, blockTimestamp(0));\n\n        emit TransferFees(strike, maturity, msg.sender, to, long0Fees, long1Fees, shortFees);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function initialize(uint256 strike, uint256 maturity, uint160 rate) external override noDelegateCall {\n        if (maturity < blockTimestamp(0)) Error.alreadyMatured(maturity, blockTimestamp(0));\n        if (rate == 0) Error.cannotBeZero();\n        addPoolEnumerationIfNecessary(strike, maturity);\n\n        pools[strike][maturity].initialize(rate);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function collectProtocolFees(TimeswapV2PoolCollectParam calldata param) external override noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {\n        ParamLibrary.check(param);\n        raiseGuard(param.strike, param.maturity);\n\n        // Can only be called by the TimeswapV2Pool factory owner.\n        ITimeswapV2PoolFactory(poolFactory).owner().checkIfOwner();\n\n        // Calculate the main logic of protocol fee.\n        (long0Amount, long1Amount, shortAmount) = pools[param.strike][param.maturity].collectProtocolFees(param.long0Requested, param.long1Requested, param.shortRequested);\n\n        collect(param.strike, param.maturity, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit CollectProtocolFees(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function collectTransactionFees(TimeswapV2PoolCollectParam calldata param) external override noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {\n        ParamLibrary.check(param);\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of transaction fee.\n        (long0Amount, long1Amount, shortAmount) = pools[param.strike][param.maturity].collectTransactionFees(\n            param.maturity,\n            param.long0Requested,\n            param.long1Requested,\n            param.shortRequested,\n            blockTimestamp(0)\n        );\n\n        collect(param.strike, param.maturity, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit CollectTransactionFee(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @dev Transfer long0 positions, long1 positions, and/or short positions to the receipients.\n    /// @param strike The strike price of the pool.\n    /// @param maturity The maturity of the pool.\n    /// @param long0To The receipient of long0 positions.\n    /// @param long1To The receipient of long1 positions.\n    /// @param shortTo The receipient of short positions.\n    /// @param long0Amount The amount of long0 positions wanted.\n    /// @param long1Amount The amount of long1 positions wanted.\n    /// @param shortAmount The amount of short positions wanted.\n    function collect(uint256 strike, uint256 maturity, address long0To, address long1To, address shortTo, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) private {\n        if (long0Amount != 0) ITimeswapV2Option(optionPair).transferPosition(strike, maturity, long0To, TimeswapV2OptionPosition.Long0, long0Amount);\n\n        if (long1Amount != 0) ITimeswapV2Option(optionPair).transferPosition(strike, maturity, long1To, TimeswapV2OptionPosition.Long1, long1Amount);\n\n        if (shortAmount != 0) ITimeswapV2Option(optionPair).transferPosition(strike, maturity, shortTo, TimeswapV2OptionPosition.Short, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function mint(TimeswapV2PoolMintParam calldata param) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return mint(param, false, 0);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function mint(\n        TimeswapV2PoolMintParam calldata param,\n        uint96 durationForward\n    ) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return mint(param, true, durationForward);\n    }\n\n    function mint(\n        TimeswapV2PoolMintParam calldata param,\n        bool isQuote,\n        uint96 durationForward\n    ) private noDelegateCall returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        ParamLibrary.check(param, blockTimestamp(durationForward));\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of mint function.\n        (liquidityAmount, long0Amount, long1Amount, shortAmount, data) = pools[param.strike][param.maturity].mint(param, blockTimestamp(durationForward));\n\n        // Calculate the amount of long0 position, long1 position, and short position required by the pool.\n\n        // long0Amount chosen could be zero. Skip the calculation for gas efficiency.\n        uint256 long0BalanceTarget;\n        if (long0Amount != 0) long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + long0Amount;\n\n        // long1Amount chosen could be zero. Skip the calculation for gas efficiency.\n        uint256 long1BalanceTarget;\n        if (long1Amount != 0) long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + long1Amount;\n\n        // shortAmount cannot be zero.\n        uint256 shortBalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + shortAmount;\n\n        // Ask the msg.sender to transfer the positions into this address.\n        data = ITimeswapV2PoolMintCallback(msg.sender).timeswapV2PoolMintCallback(\n            TimeswapV2PoolMintCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                long0Amount: long0Amount,\n                long1Amount: long1Amount,\n                shortAmount: shortAmount,\n                liquidityAmount: liquidityAmount,\n                data: data\n            })\n        );\n\n        if (isQuote) revert Quote();\n\n        // Check when the position balance targets are reached.\n\n        if (long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n\n        if (long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n\n        Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), shortBalanceTarget);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Mint(param.strike, param.maturity, msg.sender, param.to, liquidityAmount, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function burn(TimeswapV2PoolBurnParam calldata param) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return burn(param, false, 0);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function burn(\n        TimeswapV2PoolBurnParam calldata param,\n        uint96 durationForward\n    ) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return burn(param, true, durationForward);\n    }\n\n    function burn(\n        TimeswapV2PoolBurnParam calldata param,\n        bool isQuote,\n        uint96 durationForward\n    ) private noDelegateCall returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        hasLiquidity(param.strike, param.maturity);\n\n        ParamLibrary.check(param, blockTimestamp(durationForward));\n        raiseGuard(param.strike, param.maturity);\n\n        Pool storage pool = pools[param.strike][param.maturity];\n\n        // Calculate the main logic of burn function.\n        (liquidityAmount, long0Amount, long1Amount, shortAmount, data) = pool.burn(param, blockTimestamp(durationForward));\n\n        // Transfer the positions to the receipients.\n\n        // Long0 amount can be zero.\n        if (long0Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long0To, TimeswapV2OptionPosition.Long0, long0Amount);\n\n        // Long1 amount can be zero.\n        if (long1Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long1To, TimeswapV2OptionPosition.Long1, long1Amount);\n\n        // Short amount cannot be zero.\n        ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.shortTo, TimeswapV2OptionPosition.Short, shortAmount);\n\n        data = ITimeswapV2PoolBurn2Callback(msg.sender).timeswapV2PoolBurnCallback(\n            TimeswapV2PoolBurnCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                long0Amount: long0Amount,\n                long1Amount: long1Amount,\n                shortAmount: shortAmount,\n                liquidityAmount: liquidityAmount,\n                data: data\n            })\n        );\n\n        if (isQuote) revert Quote();\n\n        pool.liquidityPositions[msg.sender].burn(liquidityAmount);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Burn(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, liquidityAmount, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function deleverage(TimeswapV2PoolDeleverageParam calldata param) external override returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return deleverage(param, false, 0);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function deleverage(\n        TimeswapV2PoolDeleverageParam calldata param,\n        uint96 durationForward\n    ) external override returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return deleverage(param, true, durationForward);\n    }\n\n    function deleverage(\n        TimeswapV2PoolDeleverageParam calldata param,\n        bool isQuote,\n        uint96 durationForward\n    ) private noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        hasLiquidity(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp(durationForward));\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of deleverage function.\n        (long0Amount, long1Amount, shortAmount, data) = pools[param.strike][param.maturity].deleverage(param, transactionFee, protocolFee, blockTimestamp(durationForward));\n\n        // Calculate the amount of long0 position and long1 position required by the pool.\n\n        // long0Amount chosen could be zero. Skip the calculation for gas efficiency.\n        uint256 long0BalanceTarget;\n        if (long0Amount != 0) long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + long0Amount;\n\n        // long1Amount chosen could be zero. Skip the calculation for gas efficiency.\n        uint256 long1BalanceTarget;\n        if (long1Amount != 0) long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + long1Amount;\n\n        // Transfer short positions to the receipient.\n        ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.to, TimeswapV2OptionPosition.Short, shortAmount);\n\n        // Ask the msg.sender to transfer the positions into this address.\n        data = ITimeswapV2PoolDeleverageCallback(msg.sender).timeswapV2PoolDeleverageCallback(\n            TimeswapV2PoolDeleverageCallbackParam({strike: param.strike, maturity: param.maturity, long0Amount: long0Amount, long1Amount: long1Amount, shortAmount: shortAmount, data: data})\n        );\n\n        if (isQuote) revert Quote();\n\n        // Check when the position balance targets are reached.\n\n        if (long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n\n        if (long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Deleverage(param.strike, param.maturity, msg.sender, param.to, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function leverage(TimeswapV2PoolLeverageParam calldata param) external override returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return leverage(param, false, 0);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function leverage(TimeswapV2PoolLeverageParam calldata param, uint96 durationForward) external override returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return leverage(param, true, durationForward);\n    }\n\n    function leverage(\n        TimeswapV2PoolLeverageParam calldata param,\n        bool isQuote,\n        uint96 durationForward\n    ) private noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        hasLiquidity(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp(durationForward));\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of leverage function.\n        (long0Amount, long1Amount, shortAmount, data) = pools[param.strike][param.maturity].leverage(param, transactionFee, protocolFee, blockTimestamp(durationForward));\n\n        // Calculate the amount of short position required by the pool.\n\n        uint256 balanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + shortAmount;\n\n        // Transfer the positions to the receipients.\n\n        if (long0Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long0To, TimeswapV2OptionPosition.Long0, long0Amount);\n\n        if (long1Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long1To, TimeswapV2OptionPosition.Long1, long1Amount);\n\n        // Ask the msg.sender to transfer the positions into this address.\n        data = ITimeswapV2PoolLeverageCallback(msg.sender).timeswapV2PoolLeverageCallback(\n            TimeswapV2PoolLeverageCallbackParam({strike: param.strike, maturity: param.maturity, long0Amount: long0Amount, long1Amount: long1Amount, shortAmount: shortAmount, data: data})\n        );\n\n        if (isQuote) revert Quote();\n\n        // Check when the position balance targets are reached.\n\n        Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), balanceTarget);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Leverage(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function rebalance(TimeswapV2PoolRebalanceParam calldata param) external override noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, bytes memory data) {\n        hasLiquidity(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp(0));\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of rebalance function.\n        (long0Amount, long1Amount) = pools[param.strike][param.maturity].rebalance(param, transactionFee, protocolFee);\n\n        // Calculate the amount of long position required by the pool.\n\n        uint256 balanceTarget = ITimeswapV2Option(optionPair).positionOf(\n            param.strike,\n            param.maturity,\n            address(this),\n            param.isLong0ToLong1 ? TimeswapV2OptionPosition.Long0 : TimeswapV2OptionPosition.Long1\n        ) + (param.isLong0ToLong1 ? long0Amount : long1Amount);\n\n        // Transfer the positions to the receipients.\n\n        ITimeswapV2Option(optionPair).transferPosition(\n            param.strike,\n            param.maturity,\n            param.to,\n            param.isLong0ToLong1 ? TimeswapV2OptionPosition.Long1 : TimeswapV2OptionPosition.Long0,\n            param.isLong0ToLong1 ? long1Amount : long0Amount\n        );\n\n        // Ask the msg.sender to transfer the positions into this address.\n        data = ITimeswapV2PoolRebalanceCallback(msg.sender).timeswapV2PoolRebalanceCallback(\n            TimeswapV2PoolRebalanceCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                isLong0ToLong1: param.isLong0ToLong1,\n                long0Amount: long0Amount,\n                long1Amount: long1Amount,\n                data: param.data\n            })\n        );\n\n        // Check when the position balance targets are reached.\n\n        Error.checkEnough(\n            ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), param.isLong0ToLong1 ? TimeswapV2OptionPosition.Long0 : TimeswapV2OptionPosition.Long1),\n            balanceTarget\n        );\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Rebalance(param.strike, param.maturity, msg.sender, param.to, param.isLong0ToLong1, long0Amount, long1Amount);\n    }\n}"
    },
    {
      "filename": "packages/v2-pool/src/base/OwnableTwoSteps.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\nimport {Ownership} from \"@timeswap-labs/v2-library/src/Ownership.sol\";\n\nimport {IOwnableTwoSteps} from \"../interfaces/IOwnableTwoSteps.sol\";\n\n/// @dev contract for ownable implementation with a safety two step owner transfership.\ncontract OwnableTwoSteps is IOwnableTwoSteps {\n    using Ownership for address;\n\n    /// @dev The current owner of the contract.\n    address public override owner;\n    /// @dev The pending owner of the contract. Is zero when none is pending.\n    address public override pendingOwner;\n\n    constructor(address chosenOwner) {\n        owner = chosenOwner;\n    }\n\n    /// @inheritdoc IOwnableTwoSteps\n    function setPendingOwner(address chosenPendingOwner) external override {\n        Ownership.checkIfOwner(owner);\n\n        if (chosenPendingOwner == address(0)) Error.zeroAddress();\n        chosenPendingOwner.checkIfAlreadyOwner(owner);\n\n        pendingOwner = chosenPendingOwner;\n\n        emit SetOwner(pendingOwner);\n    }\n\n    /// @inheritdoc IOwnableTwoSteps\n    function acceptOwner() external override {\n        msg.sender.checkIfPendingOwner(pendingOwner);\n\n        owner = msg.sender;\n        delete pendingOwner;\n\n        emit AcceptOwner(msg.sender);\n    }\n}"
    }
  ]
}