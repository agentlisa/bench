{
  "Title": "[M-04] Many `create` methods are suspicious of the reorg attack",
  "Content": "\n### Proof of Concept\n\nThere are many instances of this; but to understand things better, take the example of the `createTalosV3Strategy` method.\n\nThe `createTalosV3Strategy` function deploys a new `TalosStrategyStaked` contract using the `create` method, where the address derivation depends only on the arguments passed.\n\nAt the same time, some of the chains like Arbitrum and Polygon are suspicious of the reorg attack.\n\n```solidity\nFile: TalosStrategyStaked.sol\n\n  function createTalosV3Strategy(\n        IUniswapV3Pool pool,\n        ITalosOptimizer optimizer,\n        BoostAggregator boostAggregator,\n        address strategyManager,\n        FlywheelCoreInstant flywheel,\n        address owner\n    ) public returns (TalosBaseStrategy) {\n        return new TalosStrategyStaked( // @audit-issue Reorg Attack\n                pool,\n                optimizer,\n                boostAggregator,\n                strategyManager,\n                flywheel,\n                owner\n            );\n    }\n\n```\n\n[Link to Code](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyStaked.sol#L28)\n\nEven more, the reorg can be a couple of minutes long. So, it is quite enough to create the `TalosStrategyStaked` and transfer funds to that address using the `deposit` method; especially when someone uses a script and not doing it by hand.\n\nOptimistic rollups (Optimism/Arbitrum) are also suspect to reorgs. If someone finds a fraud, the blocks will be reverted, even though the user receives a confirmation.\n\nThe same issue can affect factory contracts in Ulysses omnichain contracts as well, with more severe consequences.\n\nYou can refer to this issue previously reported, [here](https://code4rena.com/reports/2023-04-frankencoin#m-14-re-org-attack-in-factory), to have a better understanding of it.\n\n### Impact\n\nExploits involving the stealing of funds.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nDeploy such contracts via `create2` with `salt`.\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/861#issuecomment-1640083554)**\n\n**[T1MOH (warden) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/861#issuecomment-1651485343):**\n > In my opinion, low severity is more appropriate as there is no loss of funds when reorg attack happens.\n >\n> >So, it is quite enough to create the `TalosStrategyStaked` and transfer funds to that address using the `deposit` method; especially when someone uses a script and not doing it by hand.\n> \n> But in the described scenario, there is no loss of funds of users, as they deposit to `TalosStrategyStaked` and receive shares in exchange. So they don't lose funds, because anytime they can exchange shares back. The report lacks severe impact and is more of an informational type.\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/861#issuecomment-1708800852):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/861)\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/talos/TalosStrategyStaked.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {FlywheelCoreInstant} from \"@rewards/FlywheelCoreInstant.sol\";\nimport {MultiRewardsDepot} from \"@rewards/depots/MultiRewardsDepot.sol\";\nimport {FlywheelInstantRewards} from \"@rewards/rewards/FlywheelInstantRewards.sol\";\n\nimport {BoostAggregator} from \"./boost-aggregator/BoostAggregator.sol\";\nimport {TalosStrategySimple, TalosBaseStrategy} from \"./strategies/TalosStrategySimple.sol\";\n\nimport {ITalosOptimizer} from \"./interfaces/ITalosOptimizer.sol\";\nimport {ITalosStrategyStaked} from \"./interfaces/ITalosStrategyStaked.sol\";\n\nlibrary DeployStaked {\n    function createTalosV3Strategy(\n        IUniswapV3Pool pool,\n        ITalosOptimizer optimizer,\n        BoostAggregator boostAggregator,\n        address strategyManager,\n        FlywheelCoreInstant flywheel,\n        address owner\n    ) public returns (TalosBaseStrategy) {\n        return new TalosStrategyStaked(\n                pool,\n                optimizer,\n                boostAggregator,\n                strategyManager,\n                flywheel,\n                owner\n            );\n    }\n}\n\n/// @title Tokenized Vault implementation for a staked Uniswap V3 Non-Fungible Positions.\ncontract TalosStrategyStaked is TalosStrategySimple, ITalosStrategyStaked {\n    /*//////////////////////////////////////////////////////////////\n                        TALOS STAKED STRATEGY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosStrategyStaked\n    BoostAggregator public immutable override boostAggregator;\n\n    /// @notice flywheel core responsible for assigning strategy rewards to its respective users.\n    FlywheelCoreInstant public immutable flywheel;\n\n    /// @notice staking flag indicating if the NFT is staked or not.\n    bool private stakeFlag = false;\n\n    /**\n     * @notice Construct a new Talos Strategy Staked contract.\n     * @param _pool Uniswap V3 Pool to manage.\n     * @param _optimizer Talos Optimizer to use.\n     * @param _boostAggregator BoostAggregator to stake NFTs in Uniswap V3 Staker\n     * @param _strategyManager Strategy manager to use.\n     * @param _flywheel flywheel core responsible for assigning strategy rewards to its respective users.\n     * @param _owner Owner of the contract.\n     */\n    constructor(\n        IUniswapV3Pool _pool,\n        ITalosOptimizer _optimizer,\n        BoostAggregator _boostAggregator,\n        address _strategyManager,\n        FlywheelCoreInstant _flywheel,\n        address _owner\n    )\n        TalosStrategySimple(\n            _pool,\n            _optimizer,\n            _boostAggregator.nonfungiblePositionManager(),\n            _strategyManager,\n            _owner\n        )\n    {\n        flywheel = _flywheel;\n\n        boostAggregator = _boostAggregator;\n        _boostAggregator.setOwnRewardsDepot(address(FlywheelInstantRewards(_flywheel.flywheelRewards()).rewardsDepot()));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transfer(address _to, uint256 _amount) public override returns (bool) {\n        flywheel.accrue(ERC20(address(this)), msg.sender, _to);\n        return super.transfer(_to, _amount);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _amount) public override returns (bool) {\n        flywheel.accrue(ERC20(address(this)), _from, _to);\n        return super.transferFrom(_from, _to, _amount);\n    }\n\n    /// @notice Hook that is called before a position is redeemed.\n    /// @dev Responsible for collecting and accruing user rewards\n    function beforeRedeem(uint256 _tokenId, address _owner) internal override {\n        _earnFees(_tokenId);\n        flywheel.accrue(_owner);\n    }\n\n    /// @notice Hook that is called after a position is redeemed.\n    /// @dev Responsible for staking the position in the UniswapV3Staker\n    function afterRedeem(uint256 _tokenId) internal override {\n        _stake(_tokenId);\n    }\n\n    /// @notice Hook that is called before a position is deposited.\n    /// @dev Responsible for collecting and accruing user rewards\n    function beforeDeposit(uint256 _tokenId, address _receiver) internal override {\n        _earnFees(_tokenId);\n        flywheel.accrue(_receiver);\n    }\n\n    /// @notice Hook that is called after a position is deposited.\n    /// @dev Responsible for staking the position in the UniswapV3Staker\n    function afterDeposit(uint256 _tokenId) internal override {\n        _stake(_tokenId);\n    }\n\n    /// @notice Hook that is called before a position is reranged.\n    /// @dev Responsible for collecting and accruing strategy rewards\n    function beforeRerange(uint256 _tokenId) internal override {\n        _earnFees(_tokenId);\n        flywheel.accrue(msg.sender);\n    }\n\n    /// @notice Hook that is called after a position is reranged.\n    /// @dev Responsible for staking the position in the UniswapV3Staker\n    function afterRerange(uint256 _tokenId) internal override {\n        _stake(_tokenId);\n    }\n\n    /// @notice Collects fees from the pool\n    /// @param _tokenId where to collect fees from\n    function _earnFees(uint256 _tokenId) internal {\n        if (liquidity == 0) return; // can't unstake when liquidity is zero\n\n        // If not staked, collect fees from the pool\n        if (stakeFlag) {\n            _unstake(_tokenId);\n        } else {\n            (uint256 collect0, uint256 collect1) = nonfungiblePositionManager.collect(\n                INonfungiblePositionManager.CollectParams({\n                    tokenId: _tokenId,\n                    recipient: address(this),\n                    amount0Max: type(uint128).max,\n                    amount1Max: type(uint128).max\n                })\n            );\n\n            // Calculate protocol's fees\n            protocolFees0 += collect0;\n            protocolFees1 += collect1;\n        }\n    }\n\n    /// @notice Unstakes all tokens from a specific tokenId\n    /// @param _tokenId where to unstake from\n    function _unstake(uint256 _tokenId) internal {\n        // Unstaked, withdraws and sends fees to the rewards depot\n        boostAggregator.unstakeAndWithdraw(_tokenId);\n\n        stakeFlag = false;\n    }\n\n    /// @notice Stakes a specific pre existing position\n    /// @param _tokenId position that needs to be staked\n    function _stake(uint256 _tokenId) internal {\n        if (liquidity == 0) return; // can't stake when liquidity is zero\n\n        // try catch in case this position is not authorized to stake or current incentive does not have rewards\n        try nonfungiblePositionManager.safeTransferFrom(address(this), address(boostAggregator), _tokenId) {\n            stakeFlag = true; // flag to store staking state to avoid failing to unstake when it is not staked\n        } catch {}\n    }\n}"
    }
  ]
}