{
  "Title": "Artificial asset balance inflation",
  "Content": "All the contracts in scope are susceptible to an asset balance inflation attack, where a user might send ETH or any ERC20 token directly to the protocol contracts.\n\n\nFor ETH specifically, the only way to do so is by making use of an intermediate contract that uses `selfdestruct` to force funds directly into any protocol contract, bypassing the `receive` require statements in place.\n\n\nThe [`farm`](https://github.com/opynfinance/squeeth-monorepo/blob/521203dc26e5a2c3e26c6d4ad02d513e7df63237/packages/bull-vault/src/BullStrategy.sol#L99) function can recover stray ERC20 token balances (except the [excluded ones](https://github.com/opynfinance/squeeth-monorepo/blob/521203dc26e5a2c3e26c6d4ad02d513e7df63237/packages/bull-vault/src/BullStrategy.sol#L101-L102)), but there is no general way to withdraw ETH. One interesting side effect from the rebalancing mechanism is that `AuctionBull` is capable of [wrapping](https://github.com/opynfinance/squeeth-monorepo/blob/521203dc26e5a2c3e26c6d4ad02d513e7df63237/packages/bull-vault/src/BullStrategy.sol#L215) the entire ETH balance into `WETH` and then [transferring](https://github.com/opynfinance/squeeth-monorepo/blob/521203dc26e5a2c3e26c6d4ad02d513e7df63237/packages/bull-vault/src/BullStrategy.sol#L217) it out of `BullStrategy` during certain flows of a full rebalance. However, this does not solve the issue entirely. Moreover, the `farm` function is not present everywhere. For example, it is absent in [`AuctionBull`](https://github.com/opynfinance/squeeth-monorepo/blob/521203dc26e5a2c3e26c6d4ad02d513e7df63237/packages/bull-vault/src/AuctionBull.sol).\n\n\nHow this can be exploited by a malicious third party is unclear, since the team did not find any attack vector that could exploit that. However, heavily relying on [the use of `balanceOf(address(this))`](https://github.com/opynfinance/squeeth-monorepo/blob/521203dc26e5a2c3e26c6d4ad02d513e7df63237/packages/bull-vault/src/AuctionBull.sol#L504) in many instances across the codebase might pose some risk of an inflation attack.\n\n\nConsider whether it is safe to leave the doors open for such scenarios and whether it is relevant to include some mitigations, such as implementing a less strict `farm` function to be used across all contracts, or having a restricted function to retrieve stuck ETH.\n\n\n***Update:** Partially resolved in [PR #789](https://github.com/opynfinance/squeeth-monorepo/pull/789) by implementing a `farm` function that allows the contract `owner` to retrieve any asset balance from `AuctionBull`, and expanding the pre-existing `farm` function within `BullStrategy` so `ETH`, `WETH` and `USDC` can also be recovered by the owner if necessary.*\n\n\n*However, the `farm` function within `BullStrategy` should be restricted when attempting to recover `ETH` if the `Squeeth` controller is shut down, since all user funds will be sitting in `ETH` during that time.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/bull-vault/src/BullStrategy.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\n\npragma abicoder v2;\n\n// interface\nimport { IController } from \"squeeth-monorepo/interfaces/IController.sol\";\nimport { ICrabStrategyV2 } from \"./interface/ICrabStrategyV2.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport { IWETH9 } from \"squeeth-monorepo/interfaces/IWETH9.sol\";\n// contract\nimport { ERC20 } from \"openzeppelin/token/ERC20/ERC20.sol\";\nimport { LeverageBull } from \"./LeverageBull.sol\";\n// lib\nimport { Address } from \"openzeppelin/utils/Address.sol\";\nimport { StrategyMath } from \"squeeth-monorepo/strategy/base/StrategyMath.sol\"; // StrategyMath licensed under AGPL-3.0-only\nimport { VaultLib } from \"squeeth-monorepo/libs/VaultLib.sol\";\n\n/**\n * Error codes\n * BS1: Can't receive ETH from this sender\n * BS2: Strategy cap reached max\n * BS3: redeemShortShutdown must be called first\n * BS4: emergency shutdown contract needs to initiate the shutdownRepayAndWithdraw call\n * BS5: Can't farm token\n * BS6: invalid shutdownContract address set\n * BS7: wPowerPerp contract has been shutdown - withdrawals and deposits are not allowed\n * BS8: Caller is not auction address\n * BS9: deposited amount less than minimum\n * BS10: remaining amount of bull token should be more than minimum or zero\n */\n\n/**\n * @notice BullStrategy contract\n * @author opyn team\n */\ncontract BullStrategy is ERC20, LeverageBull {\n    using StrategyMath for uint256;\n    using Address for address payable;\n\n    /// @dev amount of crab token owned by bull strategy\n    uint256 private _crabBalance;\n    /// @dev crab contract address\n    address public immutable crab;\n    /// @dev powerToken controller\n    address public immutable powerTokenController;\n    /// @dev public emergency shutdown contract\n    address public shutdownContract;\n    /// @dev the cap in ETH for the strategy, above which deposits will be rejected\n    uint256 public strategyCap;\n    /// @dev set to true when redeemShortShutdown has been called\n    bool public hasRedeemedInShutdown;\n\n    event Withdraw(address from, uint256 bullAmount, uint256 wPowerPerpToRedeem);\n    event Deposit(address from, uint256 crabAmount);\n    event SetCap(uint256 oldCap, uint256 newCap);\n    event RedeemCrabAndWithdrawEth(\n        uint256 crabToRedeem, uint256 wPowerPerpRedeemed, uint256 wethBalanceReturned\n    );\n    event SetShutdownContract(address newShutdownContract, address oldShutdownContract);\n    event ShutdownRepayAndWithdraw(\n        uint256 wethToUniswap, uint256 shareToUnwind, uint256 crabToRedeem\n    );\n    /**\n     * @notice constructor for BullStrategy\n     * @dev this will open a vault in the power token contract and store the vault ID\n     * @param _owner bull strategy owner\n     * @param _crab crab address\n     * @param _powerTokenController wPowerPerp Controller address\n     * @param _euler euler address\n     * @param _eulerMarketsModule euler markets module address\n     */\n\n    constructor(\n        address _owner,\n        address _crab,\n        address _powerTokenController,\n        address _euler,\n        address _eulerMarketsModule\n    )\n        ERC20(\"Bull Vault\", \"BullVault\")\n        // LeverageBull handles Euler leverage trades\n        LeverageBull(_owner, _euler, _eulerMarketsModule, _powerTokenController)\n    {\n        crab = _crab;\n        powerTokenController = _powerTokenController;\n    }\n\n    receive() external payable {\n        require(msg.sender == weth || msg.sender == address(crab), \"BS1\");\n    }\n\n    /**\n     * @notice withdraw airdropped asset\n     * @dev can only be called by owner\n     * @param _asset asset address\n     * @param _receiver receiver address\n     */\n    function farm(address _asset, address _receiver) external onlyOwner {\n        require(\n            (_asset != crab) && (_asset != usdc) && (_asset != weth) && (_asset != eToken)\n                && (_asset != dToken) && (_asset != wPowerPerp),\n            \"BS5\"\n        );\n\n        IERC20(_asset).transfer(_receiver, IERC20(_asset).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice set strategy cap\n     * @param _cap strategy cap\n     */\n    function setCap(uint256 _cap) external onlyOwner {\n        emit SetCap(strategyCap, _cap);\n\n        strategyCap = _cap;\n    }\n\n    /**\n     * @notice set shutdown contract that can be used to unwind the strategy if squeeth contracts are shut down\n     * @param _shutdownContract shutdown contract address\n     */\n    function setShutdownContract(address _shutdownContract) external onlyOwner {\n        require(_shutdownContract != address(0), \"BS6\");\n\n        emit SetShutdownContract(shutdownContract, _shutdownContract);\n\n        shutdownContract = _shutdownContract;\n    }\n\n    /**\n     * @notice deposit to crab: deposits crab and ETH, receives USDC and wPowerPerp\n     * @param _crabAmount amount of crab token to deposit\n     */\n    function deposit(uint256 _crabAmount) external payable {\n        require(!IController(powerTokenController).isShutDown(), \"BS7\");\n\n        IERC20(crab).transferFrom(msg.sender, address(this), _crabAmount);\n        uint256 crabBalance = _increaseCrabBalance(_crabAmount);\n\n        uint256 share = ONE;\n        uint256 bullToMint = _crabAmount;\n\n        if (totalSupply() == 0) {\n            _mint(msg.sender, _crabAmount);\n        } else {\n            share = _crabAmount.wdiv(crabBalance);\n            bullToMint = share.wmul(totalSupply()).wdiv(ONE.sub(share));\n            _mint(msg.sender, bullToMint);\n        }\n\n        require(totalSupply() > 1e14, \"BS9\");\n\n        (uint256 ethInCrab, uint256 squeethInCrab) = _getCrabVaultDetails();\n        // deposit eth into leverage component and borrow USDC\n        (, uint256 usdcBorrowed, uint256 _totalWethInEuler) = _leverageDeposit(\n            msg.value, bullToMint, share, ethInCrab, squeethInCrab, IERC20(crab).totalSupply()\n        );\n\n        require(_totalWethInEuler <= strategyCap, \"BS2\");\n\n        IERC20(usdc).transfer(msg.sender, usdcBorrowed);\n\n        emit Deposit(msg.sender, _crabAmount);\n    }\n\n    /**\n     * @notice withdraw from crab: repay wPowerPerp and USDC and receive ETH\n     * @param _bullAmount amount of bull token to redeem\n     */\n    function withdraw(uint256 _bullAmount) external {\n        require(!IController(powerTokenController).isShutDown(), \"BS7\");\n\n        uint256 share = _bullAmount.wdiv(totalSupply());\n        uint256 crabToRedeem = share.wmul(_crabBalance);\n        uint256 crabTotalSupply = IERC20(crab).totalSupply();\n        (, uint256 squeethInCrab) = _getCrabVaultDetails();\n        uint256 wPowerPerpToRedeem = crabToRedeem.wmul(squeethInCrab).wdiv(crabTotalSupply);\n\n        IERC20(wPowerPerp).transferFrom(msg.sender, address(this), wPowerPerpToRedeem);\n        IERC20(wPowerPerp).approve(crab, wPowerPerpToRedeem);\n        _burn(msg.sender, _bullAmount);\n\n        require(totalSupply() == 0 || totalSupply() > 1e14, \"BS10\");\n\n        _decreaseCrabBalance(crabToRedeem);\n        ICrabStrategyV2(crab).withdraw(crabToRedeem);\n\n        _repayAndWithdrawFromLeverage(share);\n\n        payable(msg.sender).sendValue(address(this).balance);\n\n        emit Withdraw(msg.sender, _bullAmount, wPowerPerpToRedeem);\n    }\n\n    /**\n     * @notice auction strategy redeems some crab to withdraw eth\n     * @param _crabToRedeem amount of crab token redeemed by auction\n     * @param _wPowerPerpToRedeem amount of wPowerPerp sent back for crab redeem\n     */\n    function redeemCrabAndWithdrawWEth(uint256 _crabToRedeem, uint256 _wPowerPerpToRedeem)\n        external\n    {\n        require(msg.sender == auction, \"BS8\");\n\n        IERC20(wPowerPerp).transferFrom(msg.sender, address(this), _wPowerPerpToRedeem);\n        IERC20(wPowerPerp).approve(crab, _wPowerPerpToRedeem);\n\n        uint256 crabBalancebefore = IERC20(crab).balanceOf(address(this));\n\n        ICrabStrategyV2(crab).withdraw(_crabToRedeem);\n\n        _decreaseCrabBalance(crabBalancebefore.sub(IERC20(crab).balanceOf(address(this))));\n\n        IWETH9(weth).deposit{value: address(this).balance}();\n        uint256 wethBalanceToReturn = IERC20(weth).balanceOf(address(this));\n        IWETH9(weth).transfer(msg.sender, wethBalanceToReturn);\n\n        emit RedeemCrabAndWithdrawEth(_crabToRedeem, _wPowerPerpToRedeem, wethBalanceToReturn);\n    }\n\n    /**\n     * @notice auction strategy deposits into crab and receives some wPowerPerp\n     * @param _ethToDeposit amount of eth to deposit\n     */\n    function depositEthIntoCrab(uint256 _ethToDeposit) external {\n        require(msg.sender == auction, \"BS8\");\n\n        IWETH9(weth).transferFrom(msg.sender, address(this), _ethToDeposit);\n        IWETH9(weth).withdraw(_ethToDeposit);\n\n        uint256 crabBalancebefore = IERC20(crab).balanceOf(address(this));\n\n        ICrabStrategyV2(crab).deposit{value: _ethToDeposit}();\n\n        _increaseCrabBalance(IERC20(crab).balanceOf(address(this)).sub(crabBalancebefore));\n\n        IERC20(wPowerPerp).transfer(msg.sender, IERC20(wPowerPerp).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice close out Euler leverage position if contracts have been shut down\n     * @param wethToUniswap weth to repay to uniswap via auction contract\n     * @param shareToUnwind share of crab to redeem scaled by 1e18\n     */\n    function shutdownRepayAndWithdraw(uint256 wethToUniswap, uint256 shareToUnwind) external {\n        require(msg.sender == shutdownContract, \"BS4\");\n        if (shareToUnwind == ONE) {\n            hasRedeemedInShutdown = true;\n        }\n\n        uint256 crabToRedeem = shareToUnwind.wmul(ICrabStrategyV2(crab).balanceOf(address(this)));\n        _decreaseCrabBalance(crabToRedeem);\n        ICrabStrategyV2(crab).withdrawShutdown(crabToRedeem);\n\n        _repayAndWithdrawFromLeverage(shareToUnwind);\n        IWETH9(weth).deposit{value: wethToUniswap}();\n        IWETH9(weth).transfer(shutdownContract, wethToUniswap);\n\n        emit ShutdownRepayAndWithdraw(wethToUniswap, shareToUnwind, crabToRedeem);\n    }\n\n    /**\n     * @notice allows a user to withdraw their share of ETH if squeeth contracts have been shut down\n     * @dev redeemShortShutdown must have been called first\n     * @param _bullAmount bull amount to withdraw\n     */\n    function withdrawShutdown(uint256 _bullAmount) external {\n        require(hasRedeemedInShutdown, \"BS3\");\n        uint256 share = _bullAmount.wdiv(totalSupply());\n        uint256 ethToReceive = share.wmul(address(this).balance);\n        _burn(msg.sender, _bullAmount);\n        payable(msg.sender).sendValue(ethToReceive);\n    }\n\n    /**\n     * @notice return the internal accounting of the bull strategy's crab balance\n     * @return crab token amount hold by the bull strategy\n     */\n    function getCrabBalance() external view returns (uint256) {\n        return _crabBalance;\n    }\n\n    /**\n     * @notice get crab vault debt and collateral details\n     * @return vault eth collateral, vault wPowerPerp debt\n     */\n    function getCrabVaultDetails() external view returns (uint256, uint256) {\n        return _getCrabVaultDetails();\n    }\n\n    /**\n     * @notice increase internal accounting of bull stragtegy's crab balance\n     * @param _crabAmount crab amount\n     */\n    function _increaseCrabBalance(uint256 _crabAmount) private returns (uint256) {\n        _crabBalance = _crabBalance.add(_crabAmount);\n        return _crabBalance;\n    }\n\n    /**\n     * @notice decrease internal accounting of bull strategy's crab balance\n     * @param _crabAmount crab amount\n     */\n    function _decreaseCrabBalance(uint256 _crabAmount) private returns (uint256) {\n        _crabBalance = _crabBalance.sub(_crabAmount);\n        return _crabBalance;\n    }\n\n    /**\n     * @notice get crab vault debt and collateral details\n     * @return vault eth collateral, vault wPowerPerp debt\n     */\n    function _getCrabVaultDetails() internal view returns (uint256, uint256) {\n        VaultLib.Vault memory strategyVault =\n            IController(powerTokenController).vaults(ICrabStrategyV2(crab).vaultId());\n\n        return (strategyVault.collateralAmount, strategyVault.shortAmount);\n    }\n}"
    },
    {
      "filename": "packages/bull-vault/src/AuctionBull.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\n\npragma abicoder v2;\n\n// interface\nimport { IController } from \"squeeth-monorepo/interfaces/IController.sol\";\nimport { IBullStrategy } from \"./interface/IBullStrategy.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport { IEulerEToken } from \"./interface/IEulerEToken.sol\";\nimport { IEulerDToken } from \"./interface/IEulerDToken.sol\";\n// contract\nimport { Ownable } from \"openzeppelin/access/Ownable.sol\";\nimport { UniFlash } from \"./UniFlash.sol\";\nimport { UniOracle } from \"./UniOracle.sol\";\nimport { EIP712 } from \"openzeppelin/drafts/EIP712.sol\";\n// lib\nimport { StrategyMath } from \"squeeth-monorepo/strategy/base/StrategyMath.sol\"; // StrategyMath licensed under AGPL-3.0-only\nimport { ECDSA } from \"openzeppelin/cryptography/ECDSA.sol\";\n\n/**\n * Error code\n * AB0: caller is not auction manager\n * AB1: invalid delta after rebalance\n * AB2: invalid CR after rebalance\n * AB3: invalid CR lower and upper values\n * AB4: invalid delta lower and upper values\n * AB5: invalid clearing price\n * AB6: order is not taking the other side of the trade\n * AB7: current order price smaller than previous order price\n * AB8: current order price greater than previous order price\n * AB9: order price is less than clearing price\n * AB10: order price is greater than clearing price\n * AB11: order signer is different than order trader\n * AB12: order already expired\n * AB13: nonce already used\n * AB14: clearning price tolerance is too high\n * AB15: ETH limit price is out of tolerance range\n * AB16: WETH limit price tolerance is too high\n * AB17: price too low relative to Uniswap twap\n * AB18: price too high relative to Uniswap twap\n * AB19: auction manager can not be 0 address\n */\n\n/**\n * @notice AuctionBull contract\n * @author opyn team\n */\ncontract AuctionBull is UniFlash, Ownable, EIP712 {\n    using StrategyMath for uint256;\n\n    /// @dev typehash for signed orders\n    bytes32 private constant _FULL_REBALANCE_TYPEHASH = keccak256(\n        \"Order(uint256 bidId,address trader,uint256 quantity,uint256 price,bool isBuying,uint256 expiry,uint256 nonce)\"\n    );\n\n    /// @dev 1e18\n    uint256 internal constant ONE = 1e18;\n    /// @dev TWAP period\n    uint32 internal constant TWAP = 420;\n    /// @dev WETH decimals - USDC decimals\n    uint256 internal constant WETH_DECIMALS_DIFF = 1e12;\n\n    /// @dev full rebalance clearing price tolerance cannot exceed 20%\n    uint256 public constant MAX_FULL_REBALANCE_CLEARING_PRICE_TOLERANCE = 2e17; // 20%\n    /// @dev full rebalance WETH limit price tolerance cannot exceed 20%\n    uint256 public constant MAX_REBALANCE_WETH_LIMIT_PRICE_TOLERANCE = 2e17; // 20%\n\n    /// @dev USDC address\n    address private immutable usdc;\n    /// @dev WETH address\n    address private immutable weth;\n    address private immutable bullStrategy;\n    address private immutable ethWSqueethPool;\n    address private immutable ethUSDCPool;\n    address private immutable wPowerPerp;\n    address private immutable crab;\n    /// @dev euler eToken for WETH\n    address private immutable eToken;\n    /// @dev euler dToken for USDC\n    address private immutable dToken;\n\n    /// @dev highest delta the auction manager can rebalance to\n    uint256 public deltaUpper;\n    /// @dev lowest delta the auction manager can rebalance to\n    uint256 public deltaLower;\n    /// @dev highest CR the auction manager can rebalance to\n    uint256 public crUpper;\n    /// @dev lowest CR the auction manager can rebalance to\n    uint256 public crLower;\n    /// @dev full rebalance clearing price must be within this distance of the oSQTH:eth uniswap twap price\n    uint256 public fullRebalanceClearingPriceTolerance = 5e16; // 5%\n    /// @dev full rebalance WETH limit price must be within this distance of the eth:usd uniswap twap price\n    uint256 public rebalanceWethLimitPriceTolerance = 5e16; // 5%\n\n    /// @dev auction manager\n    address public auctionManager;\n\n    /// @dev store the used flag for a nonce for each address\n    mapping(address => mapping(uint256 => bool)) public nonces;\n\n    /// @dev enum to differentiate between Uniswap swap callback function source\n    enum FLASH_SOURCE {\n        LEVERAGE_REBALANCE_DECREASE_DEBT,\n        LEVERAGE_REBALANCE_INCREASE_DEBT,\n        FULL_REBALANCE_BORROW_USDC_BUY_WETH,\n        FULL_REBALANCE_REPAY_USDC_WITHDRAW_WETH,\n        FULL_REBALANCE_DEPOSIT_WETH_BORROW_USDC_DEPOSIT_INTO_CRAB,\n        FULL_REBALANCE_WITHDRAW_WETH_BORROW_USDC_DEPOSIT_INTO_CRAB\n    }\n\n    struct Order {\n        uint256 bidId;\n        address trader;\n        uint256 quantity;\n        uint256 price;\n        bool isBuying;\n        uint256 expiry;\n        uint256 nonce;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct ExecuteCrabDepositParams {\n        uint256 crabAmount;\n        uint256 wethTargetInEuler;\n        uint256 wethLimitPrice;\n        uint256 ethInCrab;\n        uint24 ethUsdcPoolFee;\n    }\n\n    struct ExecuteLeverageComponentRebalancingParams {\n        uint256 wethTargetInEuler;\n        uint256 wethLimitPrice;\n        uint24 ethUsdcPoolFee;\n    }\n\n    event SetCrUpperAndLower(\n        uint256 oldCrLower, uint256 oldCrUpper, uint256 newCrLower, uint256 newCrUpper\n    );\n    event SetDeltaUpperAndLower(\n        uint256 oldDeltaLower, uint256 oldDeltaUpper, uint256 newDeltaLower, uint256 newDeltaUpper\n    );\n    event LeverageRebalance(bool isSellingUsdc, uint256 usdcAmount, uint256 wethLimitAmount);\n\n    event FullRebalance(\n        uint256 crabAmount,\n        uint256 clearingPrice,\n        bool isDepositingInCrab,\n        uint256 wPowerPerpAmount,\n        uint256 wethTargetInEuler\n    );\n\n    event SetFullRebalanceClearingPriceTolerance(\n        uint256 _oldPriceTolerance, uint256 _newPriceTolerance\n    );\n    event SetRebalanceWethLimitPriceTolerance(\n        uint256 _oldWethLimitPriceTolerance, uint256 _newWethLimitPriceTolerance\n    );\n    event SetAuctionManager(address newAuctionManager, address oldAuctionManager);\n\n    event TransferToOrder(address trader, uint256 quanity, uint256 clearingPrice);\n\n    event TransferFromOrder(address trader, uint256 quanity, uint256 clearingPrice);\n\n    constructor(\n        address _auctionOwner,\n        address _auctionManager,\n        address _bull,\n        address _factory,\n        address _crab,\n        address _eToken,\n        address _dToken\n    ) UniFlash(_factory) Ownable() EIP712(\"AuctionBull\", \"1\") {\n        auctionManager = _auctionManager;\n        bullStrategy = _bull;\n        weth = IController(IBullStrategy(_bull).powerTokenController()).weth();\n        usdc = IController(IBullStrategy(_bull).powerTokenController()).quoteCurrency();\n        ethWSqueethPool = IController(IBullStrategy(_bull).powerTokenController()).wPowerPerpPool();\n        ethUSDCPool =\n            IController(IBullStrategy(_bull).powerTokenController()).ethQuoteCurrencyPool();\n        wPowerPerp = IController(IBullStrategy(_bull).powerTokenController()).wPowerPerp();\n        crab = _crab;\n        eToken = _eToken;\n        dToken = _dToken;\n\n        IERC20(IController(IBullStrategy(_bull).powerTokenController()).weth()).approve(\n            _bull, type(uint256).max\n        );\n        IERC20(IController(IBullStrategy(_bull).powerTokenController()).quoteCurrency()).approve(\n            _bull, type(uint256).max\n        );\n        IERC20(IController(IBullStrategy(_bull).powerTokenController()).wPowerPerp()).approve(\n            _bull, type(uint256).max\n        );\n\n        transferOwnership(_auctionOwner);\n    }\n\n    receive() external payable {\n        require(msg.sender == address(bullStrategy));\n    }\n\n    /**\n     * @notice sets the auction manager, who has permission to run fullRebalance() and leverageRebalance() functions to rebalance the strategy\n     * @param _auctionManager the new auction manager address\n     */\n    function setAuctionManager(address _auctionManager) external onlyOwner {\n        require(_auctionManager != address(0), \"AB19\");\n\n        emit SetAuctionManager(_auctionManager, auctionManager);\n\n        auctionManager = _auctionManager;\n    }\n\n    /**\n     * @notice owner can set a threshold, scaled by 1e18 that determines the maximum tolerance between a clearing sale price and the current uniswap twap price\n     * @param _fullRebalancePriceTolerance the OTC price tolerance, in percent, scaled by 1e18\n     */\n    function setFullRebalanceClearingPriceTolerance(uint256 _fullRebalancePriceTolerance)\n        external\n        onlyOwner\n    {\n        // tolerance cannot be more than 20%\n        require(_fullRebalancePriceTolerance <= MAX_FULL_REBALANCE_CLEARING_PRICE_TOLERANCE, \"AB14\");\n\n        emit SetFullRebalanceClearingPriceTolerance(\n            fullRebalanceClearingPriceTolerance, _fullRebalancePriceTolerance\n            );\n\n        fullRebalanceClearingPriceTolerance = _fullRebalancePriceTolerance;\n    }\n\n    /**\n     * @notice owner can set a threshold, scaled by 1e18 that determines the maximum tolerance between a WETH limit price and the current uniswap twap price\n     * @param _rebalanceWethLimitPriceTolerance the WETH limit price tolerance, in percent, scaled by 1e18\n     */\n    function setRebalanceWethLimitPriceTolerance(uint256 _rebalanceWethLimitPriceTolerance)\n        external\n        onlyOwner\n    {\n        // tolerance cannot be more than 20%\n        require(\n            _rebalanceWethLimitPriceTolerance <= MAX_REBALANCE_WETH_LIMIT_PRICE_TOLERANCE, \"AB16\"\n        );\n\n        emit SetRebalanceWethLimitPriceTolerance(\n            rebalanceWethLimitPriceTolerance, _rebalanceWethLimitPriceTolerance\n            );\n\n        rebalanceWethLimitPriceTolerance = _rebalanceWethLimitPriceTolerance;\n    }\n\n    /**\n     * @notice set strategy lower and upper collateral ratio\n     * @dev should only be callable by owner\n     * @param _crLower lower CR scaled by 1e18\n     * @param _crUpper upper CR scaled by 1e18\n     */\n    function setCrUpperAndLower(uint256 _crLower, uint256 _crUpper) external onlyOwner {\n        require(_crUpper > _crLower, \"AB3\");\n\n        emit SetCrUpperAndLower(crLower, crUpper, _crLower, _crUpper);\n\n        crLower = _crLower;\n        crUpper = _crUpper;\n    }\n\n    /**\n     * @notice set strategy lower and upper delta to ETH price\n     * @dev should only be callable by owner\n     * @param _deltaLower lower delta scaled by 1e18\n     * @param _deltaUpper upper delta scaled by 1e18\n     */\n    function setDeltaUpperAndLower(uint256 _deltaLower, uint256 _deltaUpper) external onlyOwner {\n        require(_deltaUpper > _deltaLower, \"AB4\");\n\n        emit SetDeltaUpperAndLower(deltaLower, deltaUpper, _deltaLower, _deltaUpper);\n\n        deltaLower = _deltaLower;\n        deltaUpper = _deltaUpper;\n    }\n\n    /**\n     * @dev rebalance delta and collateral ratio of strategy using an array of signed orders\n     * @param _orders list of orders\n     * @param _crabAmount amount of crab to withdraw or deposit\n     * @param _clearingPrice clearing price in WETH per oSQTH, in 1e18 units\n     * @param _wethTargetInEuler target WETH collateral amount in leverage component\n     * @param _wethLimitPrice limit price for WETH/USDC trade\n     * @param _isDepositingInCrab true if the rebalance will deposit into crab, false if withdrawing funds from crab\n     */\n    function fullRebalance(\n        Order[] memory _orders,\n        uint256 _crabAmount,\n        uint256 _clearingPrice,\n        uint256 _wethTargetInEuler,\n        uint256 _wethLimitPrice,\n        uint24 _ethUsdcPoolFee,\n        bool _isDepositingInCrab\n    ) external {\n        require(msg.sender == auctionManager, \"AB0\");\n        require(_clearingPrice > 0, \"AB5\");\n\n        _checkFullRebalanceClearingPrice(_clearingPrice, _isDepositingInCrab);\n        _checkRebalanceLimitPrice(_wethLimitPrice);\n\n        // get current crab vault state\n        (uint256 ethInCrab, uint256 squeethInCrab) =\n            IBullStrategy(bullStrategy).getCrabVaultDetails();\n        // total amount of oSQTH to trade given crab amount\n        uint256 wPowerPerpAmount = _calcWPowerPerpAmountFromCrab(\n            _isDepositingInCrab, _crabAmount, ethInCrab, squeethInCrab\n        );\n\n        _pullFundsFromOrders(_orders, wPowerPerpAmount, _clearingPrice, _isDepositingInCrab);\n\n        if (_isDepositingInCrab) {\n            /**\n             * if auction is depositing into crab:\n             * - if target WETH to have in Euler is greater than current amount in Euler, borrow USDC to buy more WETH and deposit in Euler\n             * - if target WETH to have in Euler is less than current amount in Euler, remove WETH from Euler\n             * - deposit into crab, pay auction traders wPowerPerp\n             */\n            _executeCrabDeposit(\n                ExecuteCrabDepositParams({\n                    crabAmount: _crabAmount,\n                    wethTargetInEuler: _wethTargetInEuler,\n                    wethLimitPrice: _wethLimitPrice,\n                    ethInCrab: ethInCrab,\n                    ethUsdcPoolFee: _ethUsdcPoolFee\n                })\n            );\n\n            _pushFundsFromOrders(_orders, wPowerPerpAmount, _clearingPrice, _isDepositingInCrab);\n        } else {\n            IBullStrategy(bullStrategy).redeemCrabAndWithdrawWEth(_crabAmount, wPowerPerpAmount);\n\n            _pushFundsFromOrders(_orders, wPowerPerpAmount, _clearingPrice, _isDepositingInCrab);\n\n            // rebalance bull strategy delta\n            _executeLeverageComponentRebalancing(\n                ExecuteLeverageComponentRebalancingParams({\n                    wethTargetInEuler: _wethTargetInEuler,\n                    wethLimitPrice: _wethLimitPrice,\n                    ethUsdcPoolFee: _ethUsdcPoolFee\n                })\n            );\n        }\n\n        // check that rebalance does not breach collateral ratio or delta tolerance\n        _isValidRebalance();\n\n        emit FullRebalance(\n            _crabAmount, _clearingPrice, _isDepositingInCrab, wPowerPerpAmount, _wethTargetInEuler\n            );\n    }\n\n    /**\n     * @notice change the strategy eth delta by increasing or decreasing USDC debt\n     * @dev can only be called by auction manager\n     * @param _isSellingUsdc true if strategy is selling USDC\n     * @param _usdcAmount USDC amount to trade\n     * @param _wethLimitPrice WETH/USDC limit price, scaled 1e18 units\n     * @param _poolFee USDC/WETH pool fee\n     */\n    function leverageRebalance(\n        bool _isSellingUsdc,\n        uint256 _usdcAmount,\n        uint256 _wethLimitPrice,\n        uint24 _poolFee\n    ) external {\n        require(msg.sender == auctionManager, \"AB0\");\n\n        _checkRebalanceLimitPrice(_wethLimitPrice);\n\n        if (_isSellingUsdc) {\n            // swap USDC to WETH\n            _exactInFlashSwap(\n                usdc,\n                weth,\n                _poolFee,\n                _usdcAmount,\n                _usdcAmount.mul(WETH_DECIMALS_DIFF).wdiv(_wethLimitPrice),\n                uint8(FLASH_SOURCE.LEVERAGE_REBALANCE_INCREASE_DEBT),\n                \"\"\n            );\n        } else {\n            // swap WETH to USDC\n            _exactOutFlashSwap(\n                weth,\n                usdc,\n                _poolFee,\n                _usdcAmount,\n                _usdcAmount.mul(WETH_DECIMALS_DIFF).wdiv(_wethLimitPrice),\n                uint8(FLASH_SOURCE.LEVERAGE_REBALANCE_DECREASE_DEBT),\n                abi.encodePacked(_usdcAmount)\n            );\n        }\n\n        _isValidRebalance();\n\n        emit LeverageRebalance(_isSellingUsdc, _usdcAmount, _wethLimitPrice);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @notice get current delta and bull collateral ratio\n     * @return delta and collateral ratio\n     */\n    function getCurrentDeltaAndCollatRatio() external view returns (uint256, uint256) {\n        return _getCurrentDeltaAndCollatRatio();\n    }\n\n    /**\n     * @notice allows an order to be cancelled by marking its nonce used for a given msg.sender\n     * @param _nonce the nonce to mark as used\n     */\n    function useNonce(uint256 _nonce) external {\n        _useNonce(msg.sender, _nonce);\n    }\n\n    /**\n     * @notice pulls funds from trader of auction orders (weth or wPowerPerp) depending on the direction of trade\n     * @param _orders list of orders\n     * @param remainingAmount amount of wPowerPerp to trade\n     * @param _clearingPrice clearing price weth/wPowerPerp, in 1e18 units\n     * @param _isDepositingInCrab true if the rebalance will deposit into Crab, false if withdrawing funds from crab\n     */\n    function _pullFundsFromOrders(\n        Order[] memory _orders,\n        uint256 remainingAmount,\n        uint256 _clearingPrice,\n        bool _isDepositingInCrab\n    ) internal {\n        // loop through orders, check each order validity\n        // pull funds from orders\n\n        uint256 prevPrice = _orders[0].price;\n        uint256 currentPrice;\n\n        uint256 ordersLength = _orders.length;\n        for (uint256 i; i < ordersLength; ++i) {\n            _verifyOrder(_orders[i], _clearingPrice, _isDepositingInCrab);\n\n            currentPrice = _orders[i].price;\n            // check that orders are in order\n            if (_isDepositingInCrab) {\n                require(currentPrice <= prevPrice, \"AB8\");\n            } else {\n                require(currentPrice >= prevPrice, \"AB7\");\n            }\n            prevPrice = currentPrice;\n\n            _transferFromOrder(_orders[i], remainingAmount, _clearingPrice);\n\n            if (remainingAmount > _orders[i].quantity) {\n                remainingAmount = remainingAmount.sub(_orders[i].quantity);\n            } else {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice pushes funds to trader of auction orders (weth or wPowerPerp) depending on the direction of trade\n     * @param _orders list of orders\n     * @param remainingAmount amount of wPowerPerp to trade\n     * @param _clearingPrice clearing price weth/wPowerPerp, in 1e18 units\n     * @param _isDepositingInCrab true if the rebalance will deposit into Crab, false if withdrawing funds from crab\n     */\n\n    function _pushFundsFromOrders(\n        Order[] memory _orders,\n        uint256 remainingAmount,\n        uint256 _clearingPrice,\n        bool _isDepositingInCrab\n    ) internal {\n        uint256 ordersLength = _orders.length;\n        for (uint256 i; i < ordersLength; ++i) {\n            _transferToOrder(_orders[i], remainingAmount, _clearingPrice);\n            if (remainingAmount > _orders[i].quantity) {\n                remainingAmount = remainingAmount.sub(_orders[i].quantity);\n            } else {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice execute crab deposit\n     * @param _params ExecuteCrabDepositParams struct\n     */\n    function _executeCrabDeposit(ExecuteCrabDepositParams memory _params) internal {\n        // total eth needed for this crab deposit\n        uint256 totalEthNeededForCrab =\n            _params.crabAmount.wdiv(IERC20(crab).totalSupply()).wmul(_params.ethInCrab);\n        // additional eth needed\n        uint256 ethNeededForCrab = totalEthNeededForCrab.sub(IERC20(weth).balanceOf(address(this)));\n        // WETH collateral in Euler\n        uint256 wethInCollateral = IEulerEToken(eToken).balanceOfUnderlying(address(bullStrategy));\n        if (_params.wethTargetInEuler > wethInCollateral) {\n            // crab deposit eth + collateral shortfall\n            uint256 wethToGet =\n                _params.wethTargetInEuler.sub(wethInCollateral).add(ethNeededForCrab);\n            // sell USDC to buy WETH\n            _exactOutFlashSwap(\n                usdc,\n                weth,\n                _params.ethUsdcPoolFee,\n                wethToGet,\n                wethToGet.wmul(_params.wethLimitPrice).div(WETH_DECIMALS_DIFF),\n                uint8(FLASH_SOURCE.FULL_REBALANCE_DEPOSIT_WETH_BORROW_USDC_DEPOSIT_INTO_CRAB),\n                abi.encodePacked(\n                    _params.wethTargetInEuler.sub(wethInCollateral), totalEthNeededForCrab\n                )\n            );\n        } else {\n            // WETH to take out of Euler\n            uint256 wethFromEuler = wethInCollateral.sub(_params.wethTargetInEuler);\n            // crab deposit eth - excess collateral\n            uint256 wethToGet = ethNeededForCrab.sub(wethFromEuler);\n            // sell USDC to buy WETH\n            _exactOutFlashSwap(\n                usdc,\n                weth,\n                _params.ethUsdcPoolFee,\n                wethToGet,\n                wethToGet.wmul(_params.wethLimitPrice).div(WETH_DECIMALS_DIFF),"
    }
  ]
}