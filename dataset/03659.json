{
  "Title": "[L02] Extraneous Events",
  "Content": "Many functions in the `Accounts` contract complete successfully and emit extraneous events when there is no operation to be performed. For example, it’s possible to [authorize a signer](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/common/Accounts.sol#L273) that already exists or [remove a signer](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/common/Accounts.sol#L559) that doesn’t exist. In such cases, the emitted event will not correspond to any executed action, which may intefere with offline processing. Consider validating that the contract state has changed before emitting events.\n\n\n**Update:** *The Celo team decided not to address this. In their words:*\n\n\n\n> \n> 1. Extraneous events should be considered no-ops from the perspective of indexing the chain\n> 2. The current behaviour is consistent with the other setters (e.g.`setName`, `setMetadataURL`, etc) in our `Accounts.sol` contract\n> 3. Calls to authorise signers remain idempotent which is desirable and correct\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/Accounts.sol",
      "content": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/InitializableV2.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  InitializableV2,\n  UsingRegistry\n{\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public InitializableV2(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 2, 0);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public onlyOwner {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender), \"Account exists\");\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Not an account\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (role == VoteSigner) {\n      account.signers.vote = signer;\n    } else if (role == AttestationSigner) {\n      account.signers.attestation = signer;\n    } else if (role == ValidatorSigner) {\n      account.signers.validator = signer;\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n    }\n\n    emit DefaultSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to as a signer on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account. \n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(isAccount(account), \"Unknown account\");\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or \n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    if (role == ValidatorSigner) {\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      account.signers.vote = address(0);\n    }\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer \n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and \n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"not an account\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or \n   * Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and \n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and \n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role. \n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return (stringLengths[] - the length of each string in bytes\n   *          data - all strings concatenated\n   *         )\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account a"
    }
  ]
}