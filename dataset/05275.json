{
  "Title": "[M-03] ERC4626 inflate issue mitigation is not sufficient",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/gate.cairo#L191-L223><br>\n<https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/absorber.cairo#L667-L705>\n\n### Impact\n\nBoth `absorber` and `gate` use the same mitigation for ERC4626 first depositor front-running vulnerability, but current implementation is not sufficient. By abusing the flaw, even though malicious attacker can't benefit from the mitigation, he can cause other normal users to lose assets.\n\n### Proof of Concept\n\nBecause of `absorber` and `gate` use the same mitigation, I will take `gate` as example.\n\nSuppose the yang's decimals is **18**:\n\nWhen [`sentinel.add_yang`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/sentinel.cairo#L174-L214) is called to add yang to shrine, `initial_yang_amt` is passed to [`shrine.add_yang`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/sentinel.cairo#L209) as mitigation to the inflate issue.\nAnd [`initial_yang_amt`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/sentinel.cairo#L202) is set as [`INITIAL_DEPOSIT_AMT`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/sentinel.cairo#L33) which is `const INITIAL_DEPOSIT_AMT: u128 = 1000;`.\n\nIn [sentinel.cairo#L204-L206](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/sentinel.cairo#L204-L206), `yang_erc20.transfer_from` is called to transfer 1000 wei `yang_erc` from caller to gate.\n\nAnd then the code flow will fall into [`shrine.add_yang`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/shrine.cairo#L565-L618). When the function is called, `initial_yang_amt` is still `1000`.\n\nIn `shrine.add_yang`, the `yang_total` will be set to `1000` in [shrine.cairo#L591](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/shrine.cairo#L591).\n\nSo when the admin (which is the first depositor) calls [`sentinel.add_yang`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/sentinel.cairo#L174-L214), he will transfer 1000 wei `yang_asset` and will receive 1000 `yang_amt` yang.\n\nAfter that, when the second user calls [`abbot.open_trove`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/abbot.cairo#L131-L161), [`gate.convert_to_yang_helper`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/gate.cairo#L208-L222) will calculate the `yang_amt` by [gate.cairo#L220](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/gate.cairo#L220):\n\n```rust\n        fn convert_to_yang_helper(self: @ContractState, asset_amt: u128) -> Wad {\n            let asset: IERC20Dispatcher = self.asset.read();\n            let total_yang: Wad = self.get_total_yang_helper(asset.contract_address);\n\n            if total_yang.is_zero() {\n                let decimals: u8 = asset.decimals();\n                // Otherwise, scale `asset_amt` up by the difference to match `Wad`\n                // precision of yang. If asset is of `Wad` precision, then the same\n                // value is returned\n                fixed_point_to_wad(asset_amt, decimals)\n            } else {\n                (asset_amt.into() * total_yang) / get_total_assets_helper(asset).into() <<<--- the second user calcuates the `yang_amout` using this code\n            }\n        }\n```\n\nAnd [`gate.get_total_assets_helper`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/gate.cairo#L230-L232) is using `asset.balance_of`:\n\n```rust\n    #[inline(always)]\n    fn get_total_assets_helper(asset: IERC20Dispatcher) -> u128 {\n        asset.balance_of(get_contract_address()).try_into().unwrap() <<<--- balance_of is used here\n    }\n```\n\nSo to sum up, in the current implementation:\n\n1. The first depositor (which is also the admin) will deposit 1000 wei ERC, and will receive 1000 `yang_amt`.\n2. The second depositor will get his `yang_amt` based off [`(asset_amt.into() * total_yang) / get_total_assets_helper(asset).into()`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/gate.cairo#L220C17-L220C88).\n\nSuppose in a case that the asset is DAI (18 decimals):\n\n1. When `yang_dai` is created, the admin calls `add_yang` to add DAI into the protocol, and he will transfer 1000 wei DAI to `gate`, and will receive 1000 `yang_amt`.\n2. A malicious tranfers (`100000 * 1e18 - 1000` wei) DAI (which is worth 100000 USD) to `gate`.\n3. Alice, a normal user, deposits `199 * 1e18` DAI (which is worth 199 USD) by calling [`abbot.open_trove`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/abbot.cairo#L131-L161), based on [gate.cairo#L220](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/gate.cairo#L220). Alice will get `199 * 1e18 * 1000 / (100000 * 1e18)` = 1 wei.\n4. If Alice wants to close her trove, [`gate.convert_to_assets`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/gate.cairo#L126-L128) will be used to calculate the asset amount, according to [gate.cairo#L191-L204](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/gate.cairo#L191-L204).\n\n[gate.cairo#L202](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/gate.cairo#L202) will be used: `((yang_amt * get_total_assets_helper(asset).into()) / total_yang).val`, because Alice has 1 wei `yang_amout`, and `get_total_assets_helper()` is `(100000 + 199) * 1e18` and `total_yang` will be 1001.\n\nSo Alice will get `1 * (100000 * 1e18 + 199 * 1e18) / (1000 + 1) = 100.0989010989011 * 1e18`, which is 100 USD. And the remaining `99 * 1e18` DAI will be in the gate.\n\nIn the above case, there will be two issues:\n\n1. Alice will lose her assets.\n2. After Alice closes her trove, the system's balance will be `(100000 + 99) *1e18`, which is becoming larger. And the balance will keep growing with time going, which will cause users to lose more assets.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nIn [`gate.get_total_assets_helper`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/gate.cairo#L230C8-L232), don't use `balance_of` to calculate the amount; instead, define a new variables and record the deposited asset amount by the variables\n\n### Assessed type\n\nERC4626\n\n**[tserg (Opus) confirmed via duplicate issue #196](https://github.com/code-423n4/2024-01-opus-findings/issues/196#issuecomment-1946399382)**\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-01-opus-findings/issues/179#issuecomment-1964655198):**\n > This submission details the vulnerability with a greater impact than [#196](https://github.com/code-423n4/2024-01-opus-findings/issues/196), and has thus been selected as primary.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-opus",
  "Code": [
    {
      "filename": "src/core/gate.cairo",
      "content": "#[starknet::contract]\nmod gate {\n    use opus::interfaces::IERC20::{IERC20Dispatcher, IERC20DispatcherTrait};\n    use opus::interfaces::IGate::IGate;\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::utils::math::{fixed_point_to_wad, pow};\n    use starknet::{ContractAddress, get_caller_address, get_contract_address};\n    use wadray::{Wad, WadZeroable, WAD_DECIMALS, WAD_ONE};\n\n    // As the Gate is similar to a ERC-4626 vault, it therefore faces a similar issue whereby\n    // the first depositor can artificially inflate a share price by depositing the smallest\n    // unit of an asset and then sending assets to the contract directly. This is addressed\n    // in the Sentinel, which enforces a minimum deposit before a yang and its Gate can be\n    // added to the Shrine.\n\n    #[storage]\n    struct Storage {\n        // the Shrine associated with this Gate\n        shrine: IShrineDispatcher,\n        // the ERC-20 asset that is the underlying asset of this Gate's yang\n        asset: IERC20Dispatcher,\n        // the address of the Sentinel associated with this Gate\n        // Also the only authorized caller of Gate\n        sentinel: ContractAddress,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        Enter: Enter,\n        Exit: Exit,\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Enter {\n        #[key]\n        user: ContractAddress,\n        #[key]\n        trove_id: u64,\n        asset_amt: u128,\n        yang_amt: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Exit {\n        #[key]\n        user: ContractAddress,\n        #[key]\n        trove_id: u64,\n        asset_amt: u128,\n        yang_amt: Wad\n    }\n\n    //\n    // Constructor\n    //\n\n    #[constructor]\n    fn constructor(\n        ref self: ContractState, shrine: ContractAddress, asset: ContractAddress, sentinel: ContractAddress\n    ) {\n        self.shrine.write(IShrineDispatcher { contract_address: shrine });\n        self.asset.write(IERC20Dispatcher { contract_address: asset });\n        self.sentinel.write(sentinel);\n    }\n\n    //\n    // External Gate functions\n    //\n\n    #[abi(embed_v0)]\n    impl IGateImpl of IGate<ContractState> {\n        //\n        // Getters\n        //\n\n        fn get_shrine(self: @ContractState) -> ContractAddress {\n            self.shrine.read().contract_address\n        }\n\n        fn get_sentinel(self: @ContractState) -> ContractAddress {\n            self.sentinel.read()\n        }\n\n        fn get_asset(self: @ContractState) -> ContractAddress {\n            self.asset.read().contract_address\n        }\n\n        fn get_total_assets(self: @ContractState) -> u128 {\n            get_total_assets_helper(self.asset.read())\n        }\n\n        fn get_total_yang(self: @ContractState) -> Wad {\n            self.get_total_yang_helper(self.asset.read().contract_address)\n        }\n\n        // Returns the amount of assets in Wad that corresponds to per Wad unit of yang.\n        // If the asset's decimals is less than `WAD_DECIMALS`, the amount is scaled up accordingly.\n        // Note that if there is no yang yet, this function will still return a positive value\n        // based on the asset amount being at parity with yang (with scaling where necessary). This is\n        // so that the yang price can be properly calculated by the oracle even if no assets have been\n        // deposited yet.\n        fn get_asset_amt_per_yang(self: @ContractState) -> Wad {\n            let amt: u128 = self.convert_to_assets_helper(WAD_ONE.into());\n            let decimals: u8 = self.asset.read().decimals();\n\n            if decimals == WAD_DECIMALS {\n                return amt.into();\n            }\n\n            fixed_point_to_wad(amt, decimals)\n        }\n\n        // This can be used to simulate the effects of `enter` at the current on-chain conditions.\n        // `asset_amt` is denoted in the asset's decimals.\n        fn convert_to_yang(self: @ContractState, asset_amt: u128) -> Wad {\n            self.convert_to_yang_helper(asset_amt)\n        }\n\n        // This can be used to simulate the effects of `exit` at the current on-chain conditions.\n        // The return value is denoted in the asset's decimals.\n        fn convert_to_assets(self: @ContractState, yang_amt: Wad) -> u128 {\n            self.convert_to_assets_helper(yang_amt)\n        }\n\n        //\n        // Core Functions - External\n        //\n\n        // Transfers the stipulated amount of assets, in the asset's decimals, from the given\n        // user to the Gate and returns the corresponding yang amount in Wad.\n        // `asset_amt` is denominated in the decimals of the asset.\n        fn enter(ref self: ContractState, user: ContractAddress, trove_id: u64, asset_amt: u128) -> Wad {\n            self.assert_sentinel();\n\n            let yang_amt: Wad = self.convert_to_yang_helper(asset_amt);\n            if yang_amt.is_zero() {\n                return WadZeroable::zero();\n            }\n\n            let success: bool = self.asset.read().transfer_from(user, get_contract_address(), asset_amt.into());\n            assert(success, 'GA: Asset transfer failed');\n            self.emit(Enter { user, trove_id, asset_amt, yang_amt });\n\n            yang_amt\n        }\n\n        // Transfers such amount of assets, in the asset's decimals, corresponding to the\n        // stipulated yang amount to the given user.\n        // The return value is denominated in the decimals of the asset.\n        fn exit(ref self: ContractState, user: ContractAddress, trove_id: u64, yang_amt: Wad) -> u128 {\n            self.assert_sentinel();\n\n            let asset_amt: u128 = self.convert_to_assets_helper(yang_amt);\n            if asset_amt.is_zero() {\n                return 0;\n            }\n\n            let success: bool = self.asset.read().transfer(user, asset_amt.into());\n            assert(success, 'GA: Asset transfer failed');\n\n            self.emit(Exit { user, trove_id, asset_amt, yang_amt });\n\n            asset_amt\n        }\n    }\n\n    //\n    // Internal Gate functions\n    //\n\n    #[generate_trait]\n    impl GateHelpers of GateHelpersTrait {\n        #[inline(always)]\n        fn assert_sentinel(self: @ContractState) {\n            assert(get_caller_address() == self.sentinel.read(), 'GA: Caller is not authorized');\n        }\n\n        #[inline(always)]\n        fn get_total_yang_helper(self: @ContractState, asset: ContractAddress) -> Wad {\n            self.shrine.read().get_yang_total(asset)\n        }\n\n        // Helper function to calculate the amount of assets corresponding to the given\n        // amount of yang.\n        // Return value is denominated in the decimals of the asset.\n        fn convert_to_assets_helper(self: @ContractState, yang_amt: Wad) -> u128 {\n            let asset: IERC20Dispatcher = self.asset.read();\n            let total_yang: Wad = self.get_total_yang_helper(asset.contract_address);\n\n            if total_yang.is_zero() {\n                let decimals: u8 = asset.decimals();\n                // Scale `yang_amt` down by the difference to match the decimal\n                // precision of the asset. If asset is of `Wad` precision, then\n                // the same value is returned\n                yang_amt.val / pow(10_u128, WAD_DECIMALS - decimals)\n            } else {\n                ((yang_amt * get_total_assets_helper(asset).into()) / total_yang).val\n            }\n        }\n\n        // Helper function to calculate the amount of yang corresponding to the given\n        // amount of assets.\n        // `asset_amt` is denominated in the decimals of the asset.\n        fn convert_to_yang_helper(self: @ContractState, asset_amt: u128) -> Wad {\n            let asset: IERC20Dispatcher = self.asset.read();\n            let total_yang: Wad = self.get_total_yang_helper(asset.contract_address);\n\n            if total_yang.is_zero() {\n                let decimals: u8 = asset.decimals();\n                // Otherwise, scale `asset_amt` up by the difference to match `Wad`\n                // precision of yang. If asset is of `Wad` precision, then the same\n                // value is returned\n                fixed_point_to_wad(asset_amt, decimals)\n            } else {\n                (asset_amt.into() * total_yang) / get_total_assets_helper(asset).into()\n            }\n        }\n    }\n\n    //\n    // Internal functions for Gate that do not access Gate's storage\n    //\n\n    #[inline(always)]\n    fn get_total_assets_helper(asset: IERC20Dispatcher) -> u128 {\n        asset.balance_of(get_contract_address()).try_into().unwrap()\n    }\n}"
    },
    {
      "filename": "src/core/absorber.cairo",
      "content": "// Note on fixed point math in Absorber:\n//\n// Non-Wad/Ray fixed-point values (i.e., values whose number of decimals is something other than 18 or 27)\n// are used extensively throughout the contract. However, these values also rely on\n// wadray-fixed-point arithmetic functions in their calculations. Consequently,\n// wadray's internal functions are used to perform these calculations.\n#[starknet::contract]\nmod absorber {\n    use access_control::access_control_component;\n    use cmp::min;\n    use integer::u256_safe_divmod;\n    use opus::core::roles::absorber_roles;\n    use opus::interfaces::IAbsorber::{IAbsorber, IBlesserDispatcher, IBlesserDispatcherTrait};\n    use opus::interfaces::IERC20::{IERC20Dispatcher, IERC20DispatcherTrait};\n    use opus::interfaces::ISentinel::{ISentinelDispatcher, ISentinelDispatcherTrait};\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::types::{AssetBalance, DistributionInfo, Provision, Request, Reward};\n    use starknet::{ContractAddress, get_block_timestamp, get_caller_address, get_contract_address};\n    use wadray::{Ray, RayZeroable, u128_wdiv, u128_wmul, Wad, WadZeroable};\n\n    //\n    // Components\n    //\n\n    component!(path: access_control_component, storage: access_control, event: AccessControlEvent);\n\n    #[abi(embed_v0)]\n    impl AccessControlPublic = access_control_component::AccessControl<ContractState>;\n    impl AccessControlHelpers = access_control_component::AccessControlHelpers<ContractState>;\n\n    //\n    // Constants\n    //\n\n    // If the amount of yin Wad per share drops below this threshold, the epoch is incremented\n    // to reset the yin per share ratio to 1 : 1 parity for accounting. Otherwise, there will\n    // eventually be an overflow when converting yin to shares (and vice versa)\n    // as yin per share approaches 0.\n    const YIN_PER_SHARE_THRESHOLD: u128 = 1000000000000000; // 10**15 = 0.001 (Wad)\n\n    // Shares to be minted without a provider to avoid first provider front-running\n    const INITIAL_SHARES: u128 = 1000; // 10 ** 3 (Wad);\n\n    // Minimum total shares, including the initial shares, for each epoch\n    // to prevent overflows in fixed point operations when the divisor (total shares)\n    // is a very small number\n    const MINIMUM_SHARES: u128 = 1000000; // 10 ** 6 (Wad);\n\n    // First epoch of the Absorber\n    const FIRST_EPOCH: u32 = 1;\n\n    // Amount of time, in seconds, that needs to elapse after request is submitted before removal\n    const REQUEST_BASE_TIMELOCK: u64 = 60;\n\n    // Upper bound of time, in seconds, that needs to elapse after request is submitted before removal\n    // 7 days * 24 hours per day * 60 minutes per hour * 60 seconds per minute\n    const REQUEST_MAX_TIMELOCK: u64 = consteval_int!(7 * 24 * 60 * 60);\n\n    // Multiplier for each request's timelock from the last value if a new request is submitted\n    // before the cooldown of the previous request has elapsed\n    const REQUEST_TIMELOCK_MULTIPLIER: u64 = 5;\n\n    // Amount of time, in seconds, for which a request is valid, starting from expiry of the timelock\n    // 60 minutes * 60 seconds per minute\n    const REQUEST_VALIDITY_PERIOD: u64 = consteval_int!(60 * 60);\n\n    // Amount of time that needs to elapse after a request is submitted before the timelock\n    // for the next request is reset to the base value.\n    // 7 days * 24 hours per day * 60 minutes per hour * 60 seconds per minute\n    const REQUEST_COOLDOWN: u64 = consteval_int!(7 * 24 * 60 * 60);\n\n    // Helper constant to set the starting index for iterating over the Rewards\n    // in the order they were added\n    const REWARDS_LOOP_START: u8 = 1;\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        access_control: access_control_component::Storage,\n        // Sentinel associated with the Shrine for this Absorber\n        sentinel: ISentinelDispatcher,\n        // Shrine associated with this Absorber\n        shrine: IShrineDispatcher,\n        // boolean flag indicating whether the Absorber is live or not\n        // once the Absorber is killed,\n        // 1. users can no longer `provide` yin\n        // 2. distribution of rewards via `bestow` stops\n        is_live: bool,\n        // epoch starts from 1\n        // both shares and absorptions are tied to an epoch\n        // the epoch is incremented when the amount of yin per share drops below the threshold.\n        // this includes when the absorber's yin balance is completely depleted.\n        current_epoch: u32,\n        // absorptions start from 1.\n        absorptions_count: u32,\n        // mapping from a provider to the last absorption ID accounted for\n        provider_last_absorption: LegacyMap::<ContractAddress, u32>,\n        // mapping of address to a struct of\n        // 1. epoch in which the provider's shares are issued\n        // 2. number of shares for the provider in the above epoch\n        provisions: LegacyMap::<ContractAddress, Provision>,\n        // mapping from an absorption to its epoch\n        absorption_epoch: LegacyMap::<u32, u32>,\n        // total number of shares for current epoch\n        total_shares: Wad,\n        // mapping of a tuple of asset and absorption ID to a struct of\n        // 1. the amount of that asset in its decimal precision absorbed per share Wad for an absorption\n        // 2. the rounding error from calculating (1) that is to be added to the next absorption\n        asset_absorption: LegacyMap::<(ContractAddress, u32), DistributionInfo>,\n        // conversion rate of an epoch's shares to the next\n        // if an update causes the yin per share to drop below the threshold,\n        // the epoch is incremented and yin per share is reset to one Ray.\n        // a provider with shares in that epoch will receive new shares in the next epoch\n        // based on this conversion rate.\n        // if the absorber's yin balance is wiped out, the conversion rate will be 0.\n        epoch_share_conversion_rate: LegacyMap::<u32, Ray>,\n        // total number of reward tokens, starting from 1\n        // a reward token cannot be removed once added.\n        rewards_count: u8,\n        // mapping from a reward token address to its id for iteration\n        reward_id: LegacyMap::<ContractAddress, u8>,\n        // mapping from a reward token ID to its Reward struct:\n        // 1. the ERC-20 token address\n        // 2. the address of the vesting contract (blesser) implementing `IBlesser` for the ERC-20 token\n        // 3. a boolean indicating if the blesser should be called\n        rewards: LegacyMap::<u8, Reward>,\n        // mapping from a reward token address and epoch to a struct of\n        // 1. the cumulative amount of that reward asset in its decimal precision per share Wad in that epoch\n        // 2. the rounding error from calculating (1) that is to be added to the next reward distribution\n        cumulative_reward_amt_by_epoch: LegacyMap::<(ContractAddress, u32), DistributionInfo>,\n        // mapping from a provider and reward token address to its last cumulative amount of that reward\n        // per share Wad in the epoch of the provider's Provision struct\n        provider_last_reward_cumulative: LegacyMap::<(ContractAddress, ContractAddress), u128>,\n        // Mapping from a provider to its latest request for removal\n        provider_request: LegacyMap::<ContractAddress, Request>,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        AccessControlEvent: access_control_component::Event,\n        RewardSet: RewardSet,\n        EpochChanged: EpochChanged,\n        Provide: Provide,\n        RequestSubmitted: RequestSubmitted,\n        Remove: Remove,\n        Reap: Reap,\n        Gain: Gain,\n        Bestow: Bestow,\n        Killed: Killed,\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct RewardSet {\n        #[key]\n        asset: ContractAddress,\n        #[key]\n        blesser: ContractAddress,\n        is_active: bool\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct EpochChanged {\n        old_epoch: u32,\n        new_epoch: u32\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Provide {\n        #[key]\n        provider: ContractAddress,\n        epoch: u32,\n        yin: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct RequestSubmitted {\n        #[key]\n        provider: ContractAddress,\n        timestamp: u64,\n        timelock: u64\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Remove {\n        #[key]\n        provider: ContractAddress,\n        epoch: u32,\n        yin: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Reap {\n        #[key]\n        provider: ContractAddress,\n        absorbed_assets: Span<AssetBalance>,\n        reward_assets: Span<AssetBalance>\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Gain {\n        assets: Span<AssetBalance>,\n        total_recipient_shares: Wad,\n        epoch: u32,\n        absorption_id: u32\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Bestow {\n        assets: Span<AssetBalance>,\n        total_recipient_shares: Wad,\n        epoch: u32\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Killed {}\n\n    //\n    // Constructor\n    //\n    #[constructor]\n    fn constructor(\n        ref self: ContractState, admin: ContractAddress, shrine: ContractAddress, sentinel: ContractAddress,\n    ) {\n        self.access_control.initializer(admin, Option::Some(absorber_roles::default_admin_role()));\n\n        self.shrine.write(IShrineDispatcher { contract_address: shrine });\n        self.sentinel.write(ISentinelDispatcher { contract_address: sentinel });\n        self.is_live.write(true);\n        self.current_epoch.write(FIRST_EPOCH);\n    }\n\n    //\n    // External Absorber functions\n    //\n\n    #[abi(embed_v0)]\n    impl IAbsorberImpl of IAbsorber<ContractState> {\n        //\n        // Getters\n        //\n\n        fn get_rewards_count(self: @ContractState) -> u8 {\n            self.rewards_count.read()\n        }\n\n        fn get_rewards(self: @ContractState) -> Span<Reward> {\n            let rewards_count: u8 = self.rewards_count.read();\n\n            let mut reward_id: u8 = REWARDS_LOOP_START;\n            let mut rewards: Array<Reward> = ArrayTrait::new();\n\n            loop {\n                if reward_id == REWARDS_LOOP_START + rewards_count {\n                    break rewards.span();\n                }\n\n                rewards.append(self.rewards.read(reward_id));\n                reward_id += 1;\n            }\n        }\n\n        fn get_current_epoch(self: @ContractState) -> u32 {\n            self.current_epoch.read()\n        }\n\n        fn get_absorptions_count(self: @ContractState) -> u32 {\n            self.absorptions_count.read()\n        }\n\n        fn get_absorption_epoch(self: @ContractState, absorption_id: u32) -> u32 {\n            self.absorption_epoch.read(absorption_id)\n        }\n\n        fn get_total_shares_for_current_epoch(self: @ContractState) -> Wad {\n            self.total_shares.read()\n        }\n\n        fn get_provision(self: @ContractState, provider: ContractAddress) -> Provision {\n            self.provisions.read(provider)\n        }\n\n        fn get_provider_last_absorption(self: @ContractState, provider: ContractAddress) -> u32 {\n            self.provider_last_absorption.read(provider)\n        }\n\n        fn get_provider_request(self: @ContractState, provider: ContractAddress) -> Request {\n            self.provider_request.read(provider)\n        }\n\n        fn get_asset_absorption(self: @ContractState, asset: ContractAddress, absorption_id: u32) -> DistributionInfo {\n            self.asset_absorption.read((asset, absorption_id))\n        }\n\n        fn get_cumulative_reward_amt_by_epoch(\n            self: @ContractState, asset: ContractAddress, epoch: u32\n        ) -> DistributionInfo {\n            self.cumulative_reward_amt_by_epoch.read((asset, epoch))\n        }\n\n        fn get_provider_last_reward_cumulative(\n            self: @ContractState, provider: ContractAddress, asset: ContractAddress\n        ) -> u128 {\n            self.provider_last_reward_cumulative.read((provider, asset))\n        }\n\n        fn get_live(self: @ContractState) -> bool {\n            self.is_live.read()\n        }\n\n\n        //\n        // View\n        //\n\n        // Returns true if the total shares in current epoch is at least `MINIMUM_SHARES`, so as\n        // to prevent underflows when distributing absorbed assets and rewards.\n        fn is_operational(self: @ContractState) -> bool {\n            is_operational_helper(self.total_shares.read())\n        }\n\n        // Returns the maximum amount of yin removable by a provider.\n        fn preview_remove(self: @ContractState, provider: ContractAddress) -> Wad {\n            let provision: Provision = self.provisions.read(provider);\n            let current_epoch: u32 = self.current_epoch.read();\n            let current_provider_shares: Wad = self\n                .convert_epoch_shares(provision.epoch, current_epoch, provision.shares);\n\n            self.convert_to_yin(current_provider_shares)\n        }\n\n\n        // Returns the absorbed assets and rewards that a provider will receive based on\n        // the current on-chain conditions\n        fn preview_reap(self: @ContractState, provider: ContractAddress) -> (Span<AssetBalance>, Span<AssetBalance>) {\n            let provision: Provision = self.provisions.read(provider);\n            let current_epoch: u32 = self.current_epoch.read();\n\n            let total_shares: Wad = self.total_shares.read();\n            let current_provider_shares: Wad = self\n                .convert_epoch_shares(provision.epoch, current_epoch, provision.shares);\n            let include_pending_rewards: bool = is_operational_helper(total_shares)\n                && current_provider_shares.is_non_zero();\n            let (absorbed_assets, rewarded_assets) = self\n                .get_absorbed_and_rewarded_assets_for_provider(provider, provision, include_pending_rewards);\n\n            // NOTE: both absorbed assets and rewarded assets will be empty arrays\n            // if `provision.shares` is zero.\n            (absorbed_assets, rewarded_assets)\n        }\n\n\n        //\n        // Setters\n        //\n\n        // Note: rewards ID start from index 1. This allows `set_reward` to be used for both\n        // adding a new reward and updating an existing reward based on whether the initial\n        // reward ID is zero (new reward) or non-zero (existing reward).\n        fn set_reward(ref self: ContractState, asset: ContractAddress, blesser: ContractAddress, is_active: bool) {\n            self.access_control.assert_has_role(absorber_roles::SET_REWARD);\n\n            assert(asset.is_non_zero() && blesser.is_non_zero(), 'ABS: Address cannot be 0');\n\n            let reward: Reward = Reward { asset, blesser: IBlesserDispatcher { contract_address: blesser }, is_active };\n\n            // If this reward token hasn't been added yet, add it to the list\n            let reward_id: u8 = self.reward_id.read(asset);\n\n            if reward_id == 0 {\n                let current_count: u8 = self.rewards_count.read();\n                let new_count = current_count + 1;\n\n                self.rewards_count.write(new_count);\n                self.reward_id.write(asset, new_count);\n                self.rewards.write(new_count, reward);\n            } else {\n                // Otherwise, update the existing reward\n                self.rewards.write(reward_id, reward);\n            }\n\n            // Emit event\n            self.emit(RewardSet { asset, blesser, is_active });\n        }\n\n        //\n        // Core Absorber functions\n        //\n\n        // Supply yin to the absorber.\n        // Requires the caller to have approved spending by the absorber.\n        fn provide(ref self: ContractState, amount: Wad) {\n            self.assert_live();\n\n            let provider: ContractAddress = get_caller_address();\n\n            // Withdraw absorbed collateral before updating shares\n            let provision: Provision = self.provisions.read(provider);\n            self.reap_helper(provider, provision);\n\n            // Calculate number of shares to issue to provider and to add to total for current epoch\n            // The two values deviate only when it is the first provision of an epoch and\n            // total shares is below the minimum initial shares.\n            let (new_provision_shares, issued_shares) = self.convert_to_shares(amount, false);\n\n            // If epoch has changed, convert shares in previous epoch to new epoch's shares\n            let current_epoch: u32 = self.current_epoch.read();\n            let converted_shares: Wad = self.convert_epoch_shares(provision.epoch, current_epoch, provision.shares);\n\n            let new_shares: Wad = converted_shares + new_provision_shares;\n            self.provisions.write(provider, Provision { epoch: current_epoch, shares: new_shares });\n\n            // Update total shares for current epoch\n            self.total_shares.write(self.total_shares.read() + issued_shares);\n\n            // Perform transfer of yin\n            let absorber: ContractAddress = get_contract_address();\n\n            let success: bool = self.yin_erc20().transfer_from(provider, absorber, amount.into());\n            assert(success, 'ABS: Transfer failed');\n\n            // Event emission\n            self.emit(Provide { provider, epoch: current_epoch, yin: amount });\n        }\n\n\n        // Submit a request to `remove` that is valid for a fixed period of time after a variable timelock.\n        // - This is intended to prevent atomic removals to avoid risk-free yield (from rewards and interest)\n        //   frontrunning tactics.\n        //   The timelock increases if another request is submitted before the previous has cooled down.\n        // - A request is expended by either (1) a removal; (2) expiry; or (3) submitting a new request.\n        // - Note: A request may become valid in the next epoch if a provider in the previous epoch\n        //         submitted a request, a draining absorption occurs, and the provider provides again\n        //         in the next epoch. This is expected to be rare, and the maximum risk-free profit is\n        //         in any event greatly limited.\n        fn request(ref self: ContractState) {\n            let provider: ContractAddress = get_caller_address();\n            assert_provider(self.provisions.read(provider));\n\n            let request: Request = self.provider_request.read(provider);\n            let current_timestamp: u64 = get_block_timestamp();\n\n            let mut timelock: u64 = REQUEST_BASE_TIMELOCK;\n            if request.timestamp + REQUEST_COOLDOWN > current_timestamp {\n                timelock = request.timelock * REQUEST_TIMELOCK_MULTIPLIER;\n            }\n\n            let capped_timelock: u64 = min(timelock, REQUEST_MAX_TIMELOCK);\n            self\n                .provider_request\n                .write(\n                    provider, Request { timestamp: current_timestamp, timelock: capped_timelock, has_removed: false }\n                );\n            self.emit(RequestSubmitted { provider, timestamp: current_timestamp, timelock: capped_timelock });\n        }\n\n        // Withdraw yin (if any) and all absorbed collateral assets from the absorber.\n        fn remove(ref self: ContractState, amount: Wad) {\n            let provider: ContractAddress = get_caller_address();\n            let provision: Provision = self.provisions.read(provider);\n            assert_provider(provision);\n\n            let mut request: Request = self.provider_request.read(provider);\n            self.assert_can_remove(request);\n\n            // Withdraw absorbed collateral before updating shares\n            self.reap_helper(provider, provision);\n\n            // Fetch the shares for current epoch\n            let current_epoch: u32 = self.current_epoch.read();\n            let current_provider_shares: Wad = self\n                .convert_epoch_shares(provision.epoch, current_epoch, provision.shares);\n\n            if current_provider_shares.is_zero() {\n                // If no remaining shares after converting across epochs,\n                // provider's deposit has been completely absorbed.\n                // Since absorbed collateral have been reaped,\n                // we can update the provision to current epoch and shares.\n                self.provisions.write(provider, Provision { epoch: current_epoch, shares: WadZeroable::zero() });\n\n                request.has_removed = true;\n                self.provider_request.write(provider, request);\n\n                // Event emission\n                self.emit(Remove { provider, epoch: current_epoch, yin: WadZeroable::zero() });\n            } else {\n                // Calculations for yin need to be performed before updating total shares.\n                // Cap `amount` to maximum removable for provider, then derive the number of shares.\n                let max_removable_yin: Wad = self.convert_to_yin(current_provider_shares);\n                let yin_amt: Wad = min(amount, max_removable_yin);\n\n                // Due to precision loss, if the amount to remove is the max removable,\n                // set the shares to be removed as the provider's balance to avoid\n                // any remaining dust shares.\n                let mut shares_to_remove = current_provider_shares;\n                if yin_amt != max_removable_yin {\n                    let (shares_to_remove_ceiled, _) = self.convert_to_shares(yin_amt, true);\n                    shares_to_remove = shares_to_remove_ceiled;\n                }\n\n                self.total_shares.write(self.total_shares.read() - shares_to_remove);\n\n                // Update provision\n                let new_provider_shares: Wad = current_provider_shares - shares_to_remove;\n                self.provisions.write(provider, Provision { epoch: current_epoch, shares: new_provider_shares });\n\n                self\n                    .provider_request\n                    .write(\n                        provider,\n                        Request { timestamp: request.timestamp, timelock: request.timelock, has_removed: true }\n                    );\n\n                let success: bool = self.yin_erc20().transfer(provider, yin_amt.into());\n                assert(success, 'ABS: Transfer failed');\n\n                // Event emission\n                self.emit(Remove { provider, epoch: current_epoch, yin: yin_amt });\n            }\n        }\n\n        // Withdraw absorbed collateral only from the absorber\n        // Note that `reap` alone will not update a caller's Provision in storage\n        fn reap(ref self: ContractState) {\n            let provider: ContractAddress = get_caller_address();\n            let provision: Provision = self.provisions.read(provider);\n            assert_provider(provision);\n\n            self.reap_helper(provider, provision);\n\n            // Update provider's epoch and shares to current epoch's\n            // Epoch must be updated to prevent provider from repeatedly claiming rewards\n            let current_epoch: u32 = self.current_epoch.read();\n            let current_provider_shares: Wad = self\n                .convert_epoch_shares(provision.epoch, current_epoch, provision.shares);\n            self.provisions.write(provider, Provision { epoch: current_epoch, shares: current_provider_shares });\n        }\n\n        // Update assets received after an absorption\n        fn update(ref self: ContractState, asset_balances: Span<AssetBalance>) {\n            self.access_control.assert_has_role(absorber_roles::UPDATE);\n\n            let current_epoch: u32 = self.current_epoch.read();\n\n            // Trigger issuance of rewards\n            self.bestow();\n\n            // Increment absorption ID\n            let current_absorption_id: u32 = self.absorptions_count.read() + 1;\n            self.absorptions_count.write(current_absorption_id);\n\n            // Update epoch for absorption ID\n            self.absorption_epoc"
    }
  ]
}