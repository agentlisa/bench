{
  "Title": "M-15: Protocol is will not work on most of the supported blockchains due to hardcoded WETH contract address.",
  "Content": "# Issue M-15: Protocol is will not work on most of the supported blockchains due to hardcoded WETH contract address. \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/308 \n\n## Found by \nHonorLt, gogo\n\n## Summary\n\nThe WETH address is hardcoded in the `Swap` library.\n\n## Vulnerability Detail\n\nAs stated in the README.md, the protocol will be deployed on the following EVM blockchains - Ethereum Mainnet, Arbitrum, Optimism, Polygon, Binance Smart Chain. While the project has integration tests with an ethereum mainnet RPC, they don't catch that on different chains like for example Polygon saveral functionallities will not actually work because of the hardcoded WETH address in the Swap.sol library:\n\n```solidity\naddress internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n```\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/libraries/Swap.sol#L28\n\n## Impact\n\nProtocol will not work on most of the supported blockchains.\n\n## Code Snippet\n\n```solidity\naddress internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n```\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/libraries/Swap.sol#L28\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe WETH variable should be immutable in the Vault contract instead of a constant in the Swap library and the Wrapped Native Token contract address should be passed in the Vault constructor on each separate deployment.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/libraries/Swap.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../Interfaces/IController.sol\";\r\n\r\nimport \"../Interfaces/ExternalInterfaces/ISwapRouter.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IUniswapV3Factory.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IUniswapV3Pool.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IStableSwap3Pool.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IWETH.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IQuoter.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\nlibrary Swap {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct SwapInOut {\r\n    uint256 amount;\r\n    address tokenIn;\r\n    address tokenOut;\r\n  }\r\n\r\n  address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n  uint256 internal constant gasUsedForSwap = 210000;\r\n\r\n  /// @notice Swap stable coins on Curve\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _tokenInUScale Scale of tokenIn e.g 1E6\r\n  /// @param _tokenOutUScale Scale of tokenOut e.g 1E6\r\n  /// @param _curve Curve pool index number of TokenIn address, tokenOut address, pool address and pool fee\r\n  function swapStableCoins(\r\n    SwapInOut memory _swap,\r\n    uint256 _tokenInUScale,\r\n    uint256 _tokenOutUScale,\r\n    IController.CurveParams memory _curve\r\n  ) public returns (uint256) {\r\n    uint256 amountOutMin = (((_swap.amount * (10000 - _curve.poolFee)) / 10000) * _tokenOutUScale) /\r\n      _tokenInUScale;\r\n    IERC20(_swap.tokenIn).safeIncreaseAllowance(_curve.pool, _swap.amount);\r\n\r\n    uint256 balanceBefore = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    IStableSwap3Pool(_curve.pool).exchange(\r\n      _curve.indexTokenIn,\r\n      _curve.indexTokenOut,\r\n      _swap.amount,\r\n      amountOutMin\r\n    );\r\n\r\n    uint256 balanceAfter = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    return balanceAfter - balanceBefore;\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswap Address of uniswapRouter, uniswapQuoter and poolfee\r\n  /// @return Amountout Number of tokens received\r\n  function swapTokensMulti(\r\n    SwapInOut memory _swap,\r\n    IController.UniswapParams memory _uniswap,\r\n    bool _rewardSwap\r\n  ) public returns (uint256) {\r\n    IERC20(_swap.tokenIn).safeIncreaseAllowance(_uniswap.router, _swap.amount);\r\n\r\n    uint256 amountOutMinimum = IQuoter(_uniswap.quoter).quoteExactInput(\r\n      abi.encodePacked(_swap.tokenIn, _uniswap.poolFee, WETH, _uniswap.poolFee, _swap.tokenOut),\r\n      _swap.amount\r\n    );\r\n\r\n    uint256 balanceBefore = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n    if (_rewardSwap && balanceBefore > amountOutMinimum) return amountOutMinimum;\r\n\r\n    ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\r\n      path: abi.encodePacked(\r\n        _swap.tokenIn,\r\n        _uniswap.poolFee,\r\n        WETH,\r\n        _uniswap.poolFee,\r\n        _swap.tokenOut\r\n      ),\r\n      recipient: address(this),\r\n      deadline: block.timestamp,\r\n      amountIn: _swap.amount,\r\n      amountOutMinimum: amountOutMinimum\r\n    });\r\n\r\n    ISwapRouter(_uniswap.router).exactInput(params);\r\n    uint256 balanceAfter = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    return balanceAfter - balanceBefore;\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap Multi route\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswapQuoter Address of uniswapQuoter\r\n  /// @param _poolFee Current uniswap pool fee set in router e.g 3000\r\n  /// @return amountOutMin minimum amount out of tokens to receive when executing swap\r\n  function amountOutMultiSwap(\r\n    SwapInOut memory _swap,\r\n    address _uniswapQuoter,\r\n    uint24 _poolFee\r\n  ) public returns (uint256) {\r\n    return\r\n      IQuoter(_uniswapQuoter).quoteExactInput(\r\n        abi.encodePacked(_swap.tokenIn, _poolFee, WETH, _poolFee, _swap.tokenOut),\r\n        _swap.amount\r\n      );\r\n  }\r\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/libraries/Swap.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../Interfaces/IController.sol\";\r\n\r\nimport \"../Interfaces/ExternalInterfaces/ISwapRouter.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IUniswapV3Factory.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IUniswapV3Pool.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IStableSwap3Pool.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IWETH.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IQuoter.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\nlibrary Swap {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct SwapInOut {\r\n    uint256 amount;\r\n    address tokenIn;\r\n    address tokenOut;\r\n  }\r\n\r\n  address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n  uint256 internal constant gasUsedForSwap = 210000;\r\n\r\n  /// @notice Swap stable coins on Curve\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _tokenInUScale Scale of tokenIn e.g 1E6\r\n  /// @param _tokenOutUScale Scale of tokenOut e.g 1E6\r\n  /// @param _curve Curve pool index number of TokenIn address, tokenOut address, pool address and pool fee\r\n  function swapStableCoins(\r\n    SwapInOut memory _swap,\r\n    uint256 _tokenInUScale,\r\n    uint256 _tokenOutUScale,\r\n    IController.CurveParams memory _curve\r\n  ) public returns (uint256) {\r\n    uint256 amountOutMin = (((_swap.amount * (10000 - _curve.poolFee)) / 10000) * _tokenOutUScale) /\r\n      _tokenInUScale;\r\n    IERC20(_swap.tokenIn).safeIncreaseAllowance(_curve.pool, _swap.amount);\r\n\r\n    uint256 balanceBefore = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    IStableSwap3Pool(_curve.pool).exchange(\r\n      _curve.indexTokenIn,\r\n      _curve.indexTokenOut,\r\n      _swap.amount,\r\n      amountOutMin\r\n    );\r\n\r\n    uint256 balanceAfter = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    return balanceAfter - balanceBefore;\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswap Address of uniswapRouter, uniswapQuoter and poolfee\r\n  /// @return Amountout Number of tokens received\r\n  function swapTokensMulti(\r\n    SwapInOut memory _swap,\r\n    IController.UniswapParams memory _uniswap,\r\n    bool _rewardSwap\r\n  ) public returns (uint256) {\r\n    IERC20(_swap.tokenIn).safeIncreaseAllowance(_uniswap.router, _swap.amount);\r\n\r\n    uint256 amountOutMinimum = IQuoter(_uniswap.quoter).quoteExactInput(\r\n      abi.encodePacked(_swap.tokenIn, _uniswap.poolFee, WETH, _uniswap.poolFee, _swap.tokenOut),\r\n      _swap.amount\r\n    );\r\n\r\n    uint256 balanceBefore = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n    if (_rewardSwap && balanceBefore > amountOutMinimum) return amountOutMinimum;\r\n\r\n    ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\r\n      path: abi.encodePacked(\r\n        _swap.tokenIn,\r\n        _uniswap.poolFee,\r\n        WETH,\r\n        _uniswap.poolFee,\r\n        _swap.tokenOut\r\n      ),\r\n      recipient: address(this),\r\n      deadline: block.timestamp,\r\n      amountIn: _swap.amount,\r\n      amountOutMinimum: amountOutMinimum\r\n    });\r\n\r\n    ISwapRouter(_uniswap.router).exactInput(params);\r\n    uint256 balanceAfter = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    return balanceAfter - balanceBefore;\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap Multi route\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswapQuoter Address of uniswapQuoter\r\n  /// @param _poolFee Current uniswap pool fee set in router e.g 3000\r\n  /// @return amountOutMin minimum amount out of tokens to receive when executing swap\r\n  function amountOutMultiSwap(\r\n    SwapInOut memory _swap,\r\n    address _uniswapQuoter,\r\n    uint24 _poolFee\r\n  ) public returns (uint256) {\r\n    return\r\n      IQuoter(_uniswapQuoter).quoteExactInput(\r\n        abi.encodePacked(_swap.tokenIn, _poolFee, WETH, _poolFee, _swap.tokenOut),\r\n        _swap.amount\r\n      );\r\n  }\r\n}"
    }
  ]
}