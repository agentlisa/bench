{
  "Title": "M-4: Some curve pools can not be used as a single sided strategy",
  "Content": "# Issue M-4: Some curve pools can not be used as a single sided strategy \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/40 \n\n## Found by \nmstpr-brainbot\n## Summary\nFor single sided curve strategy contest docs says that any curve pool should be ok to be used. However, some pools are not adaptable to the Curve2TokenPoolMixin abstract contract. \n## Vulnerability Detail\nThe contract assumes the existence of three types of pool scenarios. In one scenario, the pool address itself serves as the LP token. In another scenario, the LP token is obtained by querying the lp_token() or token() function. However, in some cases where potential integration with Notional is possible, certain pools lack a direct method to retrieve the underlying LP token. For instance, the sETH-ETH pool, which presents a promising option for a single-sided strategy in ETH vaults, does not offer public variables to access the underlying LP token. Although the pool contract contains the token variable that returns the LP token of the pool, this variable is not publicly accessible. Consequently, in such cases, querying the LP token directly from the pool is not feasible, and it becomes necessary to provide the LP token address as input.\n\nHere the example contracts where neither of the options are available:\nsETH-ETH: https://etherscan.io/address/0xc5424b857f758e906013f3555dad202e4bdb4567\nhBTC-WBTC: https://etherscan.io/address/0x4ca9b3063ec5866a4b82e437059d2c43d1be596f\n\n## Impact\nAll curve pools that can be used as a single sided strategy for notional leveraged vaults considered to be used but some pools are not adaptable thus I will label this as medium.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-10-notional/blob/7aadd254da5f645a7e1b718e7f9128f845e10f02/leveraged-vaults/contracts/vaults/curve/Curve2TokenPoolMixin.sol#L73-L78\n## Tool used\n\nManual Review\n\n## Recommendation\nCurve contracts are pretty different and it is very hard to make a generic template for it. I would suggest make the LP token also an input and remove the necessary code for setting it in the constructor. Since the owner is trusted this should not be a problem. \n\n\n\n## Discussion\n\n**jeffywu**\n\nValid suggestion.\n\n**jeffywu**\n\nhttps://github.com/notional-finance/leveraged-vaults/pull/70\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/Curve2TokenPoolMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {TokenUtils} from \"../../utils/TokenUtils.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {\n    ICurvePool,\n    ICurvePoolV1,\n    ICurvePoolV2,\n    ICurve2TokenPool\n} from \"../../../interfaces/curve/ICurvePool.sol\";\nimport {SingleSidedLPVaultBase} from \"../common/SingleSidedLPVaultBase.sol\";\nimport {ITradingModule} from \"../../../interfaces/trading/ITradingModule.sol\";\n\nstruct DeploymentParams {\n    uint16 primaryBorrowCurrencyId;\n    address pool;\n    ITradingModule tradingModule;\n    bool isSelfLPToken;\n}\n\nabstract contract Curve2TokenPoolMixin is SingleSidedLPVaultBase {\n    uint256 internal constant _NUM_TOKENS = 2;\n    uint256 internal constant CURVE_PRECISION = 1e18;\n\n    address internal immutable CURVE_POOL;\n    IERC20 internal immutable CURVE_POOL_TOKEN;\n    bool internal immutable IS_CURVE_V2;\n\n    uint8 internal immutable _PRIMARY_INDEX;\n    uint8 internal immutable SECONDARY_INDEX;\n    address internal immutable TOKEN_1;\n    address internal immutable TOKEN_2;\n    uint8 internal immutable DECIMALS_1;\n    uint8 internal immutable DECIMALS_2;\n    uint8 internal immutable PRIMARY_DECIMALS;\n    uint8 internal immutable SECONDARY_DECIMALS;\n\n    function NUM_TOKENS() internal pure override returns (uint256) { return _NUM_TOKENS; }\n    function PRIMARY_INDEX() internal view override returns (uint256) { return _PRIMARY_INDEX; }\n    function POOL_TOKEN() internal view override returns (IERC20) { return CURVE_POOL_TOKEN; }\n    function POOL_PRECISION() internal pure override returns (uint256) { return CURVE_PRECISION; }\n    function TOKENS() internal view override returns (IERC20[] memory, uint8[] memory) {\n        IERC20[] memory tokens = new IERC20[](_NUM_TOKENS);\n        uint8[] memory decimals = new uint8[](_NUM_TOKENS);\n\n        (tokens[0], decimals[0]) = (IERC20(TOKEN_1), DECIMALS_1);\n        (tokens[1], decimals[1]) = (IERC20(TOKEN_2), DECIMALS_2);\n\n        return (tokens, decimals);\n    }\n\n    constructor(\n        NotionalProxy notional_,\n        DeploymentParams memory params\n    ) SingleSidedLPVaultBase(notional_, params.tradingModule) {\n        CURVE_POOL = params.pool;\n\n        bool isCurveV2 = false;\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            address[10] memory handlers = \n                Deployments.CURVE_META_REGISTRY.get_registry_handlers_from_pool(address(CURVE_POOL));\n\n            require(\n                handlers[0] == Deployments.CURVE_V1_HANDLER ||\n                handlers[0] == Deployments.CURVE_V2_HANDLER\n            ); // @dev unknown Curve version\n            isCurveV2 = (handlers[0] == Deployments.CURVE_V2_HANDLER);\n        }\n        IS_CURVE_V2 = isCurveV2;\n        CURVE_POOL_TOKEN = params.isSelfLPToken ? IERC20(CURVE_POOL) : (\n            IS_CURVE_V2 ? \n                IERC20(ICurvePoolV2(address(CURVE_POOL)).token()) :\n                IERC20(ICurvePoolV1(address(CURVE_POOL)).lp_token())\n        );\n\n        address primaryToken = _getNotionalUnderlyingToken(params.primaryBorrowCurrencyId);\n\n        // We interact with curve pools directly so we never pass the token addresses back\n        // to the curve pools. The amounts are passed back based on indexes instead. Therefore\n        // we can rewrite the token addresses from ALT Eth (0xeeee...) back to (0x0000...) which\n        // is used by the vault internally to represent ETH.\n        TOKEN_1 = _rewriteAltETH(ICurvePool(CURVE_POOL).coins(0));\n        TOKEN_2 = _rewriteAltETH(ICurvePool(CURVE_POOL).coins(1));\n        _PRIMARY_INDEX = TOKEN_1 == primaryToken ? 0 : 1;\n        SECONDARY_INDEX = 1 - _PRIMARY_INDEX;\n        \n        DECIMALS_1 = TokenUtils.getDecimals(TOKEN_1);\n        DECIMALS_2 = TokenUtils.getDecimals(TOKEN_2);\n        PRIMARY_DECIMALS = _PRIMARY_INDEX == 0 ? DECIMALS_1 : DECIMALS_2;\n        SECONDARY_DECIMALS = _PRIMARY_INDEX == 0 ? DECIMALS_2 : DECIMALS_1;\n    }\n\n    function _rewriteAltETH(address token) private pure returns (address) {\n        return token == address(Deployments.ALT_ETH_ADDRESS) ? Deployments.ETH_ADDRESS : address(token);\n    }\n\n    function _checkReentrancyContext() internal override {\n        // We need to set the LP token amount to 1 for Curve V2 pools to bypass\n        // the underflow check\n        uint256[2] memory minAmounts;\n        ICurve2TokenPool(address(CURVE_POOL)).remove_liquidity(IS_CURVE_V2 ? 1 : 0, minAmounts);\n    }\n}"
    }
  ]
}