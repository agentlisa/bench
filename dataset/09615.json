{
  "Title": "[05] `valid` in `OraclePassThrough/read()` always returns true",
  "Content": "\nIn `OraclePassThrough.sol`, `valid` is always true in `read()`. Since `OracleRef` uses `valid` to determine validity. There should be a invalid case. Otherwise, the validity check is meaningless.\n\n### Proof of Concept\n\n[OraclePassThrough.sol#L41](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/oracle/OraclePassThrough.sol#L41)<br>\n\n[OracleRef.sol#L102](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/refs/OracleRef.sol#L102)<br>\n\n### Recommended Mitigation Steps\n\nDefine the invalid case.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-03-volt",
  "Code": [
    {
      "filename": "contracts/oracle/OraclePassThrough.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {Decimal} from \"../external/Decimal.sol\";\nimport {CoreRef} from \"./../refs/CoreRef.sol\";\nimport {IScalingPriceOracle} from \"./IScalingPriceOracle.sol\";\nimport {IOraclePassThrough} from \"./IOraclePassThrough.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @notice contract that passes all price calls to the Scaling Price Oracle\n/// The Scaling Price Oracle can be changed if there is a decision to change how data is interpolated\n/// without needing all contracts in the system to be upgraded, only this contract will have to change where it points\n/// @author Elliot Friedman\ncontract OraclePassThrough is IOraclePassThrough, Ownable {\n    using Decimal for Decimal.D256;\n\n    /// @notice reference to the scaling price oracle\n    IScalingPriceOracle public override scalingPriceOracle;\n\n    constructor(IScalingPriceOracle _scalingPriceOracle) Ownable() {\n        scalingPriceOracle = _scalingPriceOracle;\n    }\n\n    /// @notice updates the oracle price\n    /// @dev no-op, ScalingPriceOracle is updated automatically\n    /// added for backwards compatibility with OracleRef\n    function update() public {}\n\n    // ----------- Getters -----------\n\n    /// @notice function to get the current oracle price for the OracleRef contract\n    function read()\n        external\n        view\n        override\n        returns (Decimal.D256 memory price, bool valid)\n    {\n        uint256 currentPrice = scalingPriceOracle.getCurrentOraclePrice();\n\n        price = Decimal.from(currentPrice).div(1e18);\n        valid = true;\n    }\n\n    /// @notice function to get the current oracle price for the entire system\n    function getCurrentOraclePrice() external view override returns (uint256) {\n        return scalingPriceOracle.getCurrentOraclePrice();\n    }\n\n    // ----------- Governance only state changing api -----------\n\n    /// @notice function to update the pointer to the scaling price oracle\n    /// requires approval from all parties on multisig to update\n    function updateScalingPriceOracle(IScalingPriceOracle newScalingPriceOracle)\n        external\n        override\n        onlyOwner\n    {\n        IScalingPriceOracle oldScalingPriceOracle = scalingPriceOracle;\n        scalingPriceOracle = newScalingPriceOracle;\n\n        emit ScalingPriceOracleUpdate(\n            oldScalingPriceOracle,\n            newScalingPriceOracle\n        );\n    }\n}"
    },
    {
      "filename": "contracts/refs/OracleRef.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./IOracleRef.sol\";\nimport \"./CoreRef.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/// @title Reference to an Oracle\n/// @author Fei Protocol\n/// @notice defines some utilities around interacting with the referenced oracle\nabstract contract OracleRef is IOracleRef, CoreRef {\n    using Decimal for Decimal.D256;\n    using SafeCast for int256;\n\n    /// @notice the oracle reference by the contract\n    IOracle public override oracle;\n\n    /// @notice the backup oracle reference by the contract\n    IOracle public override backupOracle;\n\n    /// @notice number of decimals to scale oracle price by, i.e. multiplying by 10^(decimalsNormalizer)\n    int256 public override decimalsNormalizer;\n\n    bool public override doInvert;\n\n    /// @notice OracleRef constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle oracle to reference\n    /// @param _backupOracle backup oracle to reference\n    /// @param _decimalsNormalizer number of decimals to normalize the oracle feed if necessary\n    /// @param _doInvert invert the oracle price if this flag is on\n    constructor(\n        address _core,\n        address _oracle,\n        address _backupOracle,\n        int256 _decimalsNormalizer,\n        bool _doInvert\n    ) CoreRef(_core) {\n        _setOracle(_oracle);\n        if (_backupOracle != address(0) && _backupOracle != _oracle) {\n            _setBackupOracle(_backupOracle);\n        }\n        _setDoInvert(_doInvert);\n        _setDecimalsNormalizer(_decimalsNormalizer);\n    }\n\n    /// @notice sets the referenced oracle\n    /// @param newOracle the new oracle to reference\n    function setOracle(address newOracle) external override onlyGovernor {\n        _setOracle(newOracle);\n    }\n\n    /// @notice sets the flag for whether to invert or not\n    /// @param newDoInvert the new flag for whether to invert\n    function setDoInvert(bool newDoInvert) external override onlyGovernor {\n        _setDoInvert(newDoInvert);\n    }\n\n    /// @notice sets the new decimalsNormalizer\n    /// @param newDecimalsNormalizer the new decimalsNormalizer\n    function setDecimalsNormalizer(int256 newDecimalsNormalizer)\n        external\n        override\n        onlyGovernor\n    {\n        _setDecimalsNormalizer(newDecimalsNormalizer);\n    }\n\n    /// @notice sets the referenced backup oracle\n    /// @param newBackupOracle the new backup oracle to reference\n    function setBackupOracle(address newBackupOracle)\n        external\n        override\n        onlyGovernorOrAdmin\n    {\n        _setBackupOracle(newBackupOracle);\n    }\n\n    /// @notice invert a peg price\n    /// @param price the peg price to invert\n    /// @return the inverted peg as a Decimal\n    /// @dev the inverted peg would be X per FEI\n    function invert(Decimal.D256 memory price)\n        public\n        pure\n        override\n        returns (Decimal.D256 memory)\n    {\n        return Decimal.one().div(price);\n    }\n\n    /// @notice updates the referenced oracle\n    function updateOracle() public override {\n        oracle.update();\n    }\n\n    /// @notice the peg price of the referenced oracle\n    /// @return the peg as a Decimal\n    /// @dev the peg is defined as FEI per X with X being ETH, dollars, etc\n    function readOracle() public view override returns (Decimal.D256 memory) {\n        (Decimal.D256 memory _peg, bool valid) = oracle.read();\n        if (!valid && address(backupOracle) != address(0)) {\n            (_peg, valid) = backupOracle.read();\n        }\n        require(valid, \"OracleRef: oracle invalid\");\n\n        // Scale the oracle price by token decimals delta if necessary\n        uint256 scalingFactor;\n        if (decimalsNormalizer < 0) {\n            scalingFactor = 10**(-1 * decimalsNormalizer).toUint256();\n            _peg = _peg.div(scalingFactor);\n        } else {\n            scalingFactor = 10**decimalsNormalizer.toUint256();\n            _peg = _peg.mul(scalingFactor);\n        }\n\n        // Invert the oracle price if necessary\n        if (doInvert) {\n            _peg = invert(_peg);\n        }\n        return _peg;\n    }\n\n    function _setOracle(address newOracle) internal {\n        require(newOracle != address(0), \"OracleRef: zero address\");\n        address oldOracle = address(oracle);\n        oracle = IOracle(newOracle);\n        emit OracleUpdate(oldOracle, newOracle);\n    }\n\n    // Supports zero address if no backup\n    function _setBackupOracle(address newBackupOracle) internal {\n        address oldBackupOracle = address(backupOracle);\n        backupOracle = IOracle(newBackupOracle);\n        emit BackupOracleUpdate(oldBackupOracle, newBackupOracle);\n    }\n\n    function _setDoInvert(bool newDoInvert) internal {\n        bool oldDoInvert = doInvert;\n        doInvert = newDoInvert;\n\n        if (oldDoInvert != newDoInvert) {\n            _setDecimalsNormalizer(-1 * decimalsNormalizer);\n        }\n\n        emit InvertUpdate(oldDoInvert, newDoInvert);\n    }\n\n    function _setDecimalsNormalizer(int256 newDecimalsNormalizer) internal {\n        int256 oldDecimalsNormalizer = decimalsNormalizer;\n        decimalsNormalizer = newDecimalsNormalizer;\n        emit DecimalsNormalizerUpdate(\n            oldDecimalsNormalizer,\n            newDecimalsNormalizer\n        );\n    }\n\n    function _setDecimalsNormalizerFromToken(address token) internal {\n        int256 feiDecimals = 18;\n        int256 _decimalsNormalizer = feiDecimals -\n            int256(uint256(IERC20Metadata(token).decimals()));\n\n        if (doInvert) {\n            _decimalsNormalizer = -1 * _decimalsNormalizer;\n        }\n\n        _setDecimalsNormalizer(_decimalsNormalizer);\n    }\n}"
    }
  ]
}