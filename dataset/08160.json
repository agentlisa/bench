{
  "Title": "[G-14] `revert` operator should be in the code as early as reasonably possible (3 instances)",
  "Content": "\nDeployment Gas Saved: **200**<br>\nMethod Call Gas Saved: **1 559+**<br>\n\n*   src/modules/INSTR.sol:[43-48](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/INSTR.sol#L43-L48)\n\n```solidity\n43        uint256 length = instructions_.length;\n44        uint256 instructionsId = ++totalInstructions;\n45\n46        Instruction[] storage instructions = storedInstructions[instructionsId];\n47\n48        if (length == 0) revert INSTR_InstructionsCannotBeEmpty(); // @note after 43\n```\n\n*   src/policies/Governance.sol:[180-191](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L180-L191), [241-249](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L241-L249)\n\n```solidity\n180    function endorseProposal(uint256 proposalId_) external {\n181        uint256 userVotes = VOTES.balanceOf(msg.sender); // @note put after revert\n182\n183        if (proposalId_ == 0) {\n184            revert CannotEndorseNullProposal();\n185        }\n186\n187        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n188        if (instructions.length == 0) {\n189            revert CannotEndorseInvalidProposal();\n190        }\n191\n```\n\n```solidity\n241        uint256 userVotes = VOTES.balanceOf(msg.sender); // @note put after revert\n242\n243        if (activeProposal.proposalId == 0) {\n244            revert NoActiveProposalDetected();\n245        }\n246\n247        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n248            revert UserAlreadyVoted();\n249        }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/modules/INSTR.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"src/Kernel.sol\";\n\nerror INSTR_InstructionsCannotBeEmpty();\nerror INSTR_InvalidChangeExecutorAction();\n\n/// @notice Caches and executes batched instructions for protocol upgrades in the Kernel.\ncontract OlympusInstructions is Module {\n    event InstructionsStored(uint256 instructionsId);\n\n    uint256 public totalInstructions;\n    mapping(uint256 => Instruction[]) public storedInstructions;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    /// @inheritdoc Module\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"INSTR\");\n    }\n\n    /// @inheritdoc Module\n    function VERSION() public pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice View function for retrieving a list of Instructions in an outside contract.\n    function getInstructions(uint256 instructionsId_) public view returns (Instruction[] memory) {\n        return storedInstructions[instructionsId_];\n    }\n\n    /// @notice Store a list of Instructions to be executed in the future.\n    function store(Instruction[] calldata instructions_) external permissioned returns (uint256) {\n        uint256 length = instructions_.length;\n        uint256 instructionsId = ++totalInstructions;\n\n        Instruction[] storage instructions = storedInstructions[instructionsId];\n\n        if (length == 0) revert INSTR_InstructionsCannotBeEmpty();\n\n        for (uint256 i; i < length; ) {\n            Instruction calldata instruction = instructions_[i];\n            ensureContract(instruction.target);\n\n            // If the instruction deals with a module, make sure the module has a valid keycode (UPPERCASE A-Z ONLY)\n            if (\n                instruction.action == Actions.InstallModule ||\n                instruction.action == Actions.UpgradeModule\n            ) {\n                Module module = Module(instruction.target);\n                ensureValidKeycode(module.KEYCODE());\n            } else if (instruction.action == Actions.ChangeExecutor && i != length - 1) {\n                // Throw an error if ChangeExecutor exists and is not the last Action in the instruction list.\n                // This exists because if ChangeExecutor is not the last item in the list of instructions,\n                // the Kernel will not recognize any of the following instructions as valid, since the policy\n                // executing the list of instructions no longer has permissions in the Kernel. To avoid this issue\n                // and prevent invalid proposals from being saved, we perform this check.\n                revert INSTR_InvalidChangeExecutorAction();\n            }\n\n            instructions.push(instructions_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit InstructionsStored(instructionsId);\n\n        return instructionsId;\n    }\n}"
    },
    {
      "filename": "src/policies/Governance.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// The Governance Policy submits & activates instructions in a INSTR module\n\nimport {OlympusInstructions} from \"modules/INSTR.sol\";\nimport {OlympusVotes} from \"modules/VOTES.sol\";\nimport \"src/Kernel.sol\";\n\n// proposing\nerror NotEnoughVotesToPropose();\n\n// endorsing\nerror CannotEndorseNullProposal();\nerror CannotEndorseInvalidProposal();\n\n// activating\nerror NotAuthorizedToActivateProposal();\nerror NotEnoughEndorsementsToActivateProposal();\nerror ProposalAlreadyActivated();\nerror ActiveProposalNotExpired();\nerror SubmittedProposalHasExpired();\n\n// voting\nerror NoActiveProposalDetected();\nerror UserAlreadyVoted();\n\n// executing\nerror NotEnoughVotesToExecute();\nerror ExecutionTimelockStillActive();\n\n// claiming\nerror VotingTokensAlreadyReclaimed();\nerror CannotReclaimTokensForActiveVote();\nerror CannotReclaimZeroVotes();\n\nstruct ProposalMetadata {\n    bytes32 title;\n    address submitter;\n    uint256 submissionTimestamp;\n    string proposalURI;\n}\n\nstruct ActivatedProposal {\n    uint256 proposalId;\n    uint256 activationTimestamp;\n}\n\n/// @notice OlympusGovernance\n/// @dev The Governor Policy is also the Kernel's Executor.\ncontract OlympusGovernance is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    OlympusInstructions public INSTR;\n    OlympusVotes public VOTES;\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](2);\n        dependencies[0] = toKeycode(\"INSTR\");\n        dependencies[1] = toKeycode(\"VOTES\");\n\n        INSTR = OlympusInstructions(getModuleAddress(dependencies[0]));\n        VOTES = OlympusVotes(getModuleAddress(dependencies[1]));\n    }\n\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);\n        requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                             Policy Variables                                //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    event ProposalSubmitted(uint256 proposalId);\n    event ProposalEndorsed(uint256 proposalId, address voter, uint256 amount);\n    event ProposalActivated(uint256 proposalId, uint256 timestamp);\n    event WalletVoted(uint256 proposalId, address voter, bool for_, uint256 userVotes);\n    event ProposalExecuted(uint256 proposalId);\n\n    /// @notice The currently activated proposal in the governance system.\n    ActivatedProposal public activeProposal;\n\n    /// @notice Return a proposal metadata object for a given proposal id.\n    mapping(uint256 => ProposalMetadata) public getProposalMetadata;\n\n    /// @notice Return the total endorsements for a proposal id.\n    mapping(uint256 => uint256) public totalEndorsementsForProposal;\n\n    /// @notice Return the number of endorsements a user has given a proposal id.\n    mapping(uint256 => mapping(address => uint256)) public userEndorsementsForProposal;\n\n    /// @notice Return whether a proposal id has been activated. Once this is true, it should never be flipped false.\n    mapping(uint256 => bool) public proposalHasBeenActivated;\n\n    /// @notice Return the total yes votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public yesVotesForProposal;\n\n    /// @notice Return the total no votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public noVotesForProposal;\n\n    /// @notice Return the amount of votes a user has applied to a proposal id. This does not record how the user voted.\n    mapping(uint256 => mapping(address => uint256)) public userVotesForProposal;\n\n    /// @notice Return the amount of tokens reclaimed by a user after voting on a proposal id.\n    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal;\n\n    /// @notice The amount of votes a proposer needs in order to submit a proposal as a percentage of total supply (in basis points).\n    /// @dev    This is set to 1% of the total supply.\n    uint256 public constant SUBMISSION_REQUIREMENT = 100;\n\n    /// @notice Amount of time a submitted proposal has to activate before it expires.\n    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;\n\n    /// @notice Amount of time an activated proposal must stay up before it can be replaced by a new activated proposal.\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    /// @notice Endorsements required to activate a proposal as percentage of total supply.\n    uint256 public constant ENDORSEMENT_THRESHOLD = 20;\n\n    /// @notice Net votes required to execute a proposal on chain as a percentage of total supply.\n    uint256 public constant EXECUTION_THRESHOLD = 33;\n\n    /// @notice Required time for a proposal to be active before it can be executed.\n    /// @dev    This amount should be greater than 0 to prevent flash loan attacks.\n    uint256 public constant EXECUTION_TIMELOCK = 3 days;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                               User Actions                                  //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Return the metadata for a proposal.\n    /// @dev    Used to return & access the entire metadata struct in solidity\n    function getMetadata(uint256 proposalId_) public view returns (ProposalMetadata memory) {\n        return getProposalMetadata[proposalId_];\n    }\n\n    /// @notice Return the currently active proposal in governance.\n    /// @dev    Used to return & access the entire struct active proposal struct in solidity.\n    function getActiveProposal() public view returns (ActivatedProposal memory) {\n        return activeProposal;\n    }\n\n    /// @notice Submit an on chain governance proposal.\n    /// @param  instructions_ - an array of Instruction objects each containing a Kernel Action and a target Contract address.\n    /// @param  title_ - a human-readable title of the proposal â€” i.e. \"OIP XX - My Proposal Title\".\n    /// @param  proposalURI_ - an arbitrary url linking to a human-readable description of the proposal - i.e. Snapshot, Discourse, Google Doc.\n    function submitProposal(\n        Instruction[] calldata instructions_,\n        bytes32 title_,\n        string memory proposalURI_\n    ) external {\n        if (VOTES.balanceOf(msg.sender) * 10000 < VOTES.totalSupply() * SUBMISSION_REQUIREMENT)\n            revert NotEnoughVotesToPropose();\n\n        uint256 proposalId = INSTR.store(instructions_);\n        getProposalMetadata[proposalId] = ProposalMetadata(\n            title_,\n            msg.sender,\n            block.timestamp,\n            proposalURI_\n        );\n\n        emit ProposalSubmitted(proposalId);\n    }\n\n    /// @notice Endorse a proposal.\n    /// @param  proposalId_ - The ID of the proposal being endorsed.\n    function endorseProposal(uint256 proposalId_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (proposalId_ == 0) {\n            revert CannotEndorseNullProposal();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n        if (instructions.length == 0) {\n            revert CannotEndorseInvalidProposal();\n        }\n\n        // undo any previous endorsement the user made on these instructions\n        uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender];\n        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;\n\n        // reapply user endorsements with most up-to-date votes\n        userEndorsementsForProposal[proposalId_][msg.sender] = userVotes;\n        totalEndorsementsForProposal[proposalId_] += userVotes;\n\n        emit ProposalEndorsed(proposalId_, msg.sender, userVotes);\n    }\n\n    /// @notice Activate a proposal.\n    /// @param  proposalId_ - The ID of the proposal being activated.\n    function activateProposal(uint256 proposalId_) external {\n        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n\n        if (msg.sender != proposal.submitter) {\n            revert NotAuthorizedToActivateProposal();\n        }\n\n        if (block.timestamp > proposal.submissionTimestamp + ACTIVATION_DEADLINE) {\n            revert SubmittedProposalHasExpired();\n        }\n\n        if (\n            (totalEndorsementsForProposal[proposalId_] * 100) <\n            VOTES.totalSupply() * ENDORSEMENT_THRESHOLD\n        ) {\n            revert NotEnoughEndorsementsToActivateProposal();\n        }\n\n        if (proposalHasBeenActivated[proposalId_] == true) {\n            revert ProposalAlreadyActivated();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + GRACE_PERIOD) {\n            revert ActiveProposalNotExpired();\n        }\n\n        activeProposal = ActivatedProposal(proposalId_, block.timestamp);\n\n        proposalHasBeenActivated[proposalId_] = true;\n\n        emit ProposalActivated(proposalId_, block.timestamp);\n    }\n\n    /// @notice Cast a vote for the currently active proposal.\n    /// @param  for_ - A boolean representing the vote: true for yes, false for no.\n    function vote(bool for_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (activeProposal.proposalId == 0) {\n            revert NoActiveProposalDetected();\n        }\n\n        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n            revert UserAlreadyVoted();\n        }\n\n        if (for_) {\n            yesVotesForProposal[activeProposal.proposalId] += userVotes;\n        } else {\n            noVotesForProposal[activeProposal.proposalId] += userVotes;\n        }\n\n        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;\n\n        VOTES.transferFrom(msg.sender, address(this), userVotes);\n\n        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);\n    }\n\n    /// @notice Execute the currently active proposal.\n    function executeProposal() external {\n        uint256 netVotes = yesVotesForProposal[activeProposal.proposalId] -\n            noVotesForProposal[activeProposal.proposalId];\n        if (netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD) {\n            revert NotEnoughVotesToExecute();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_TIMELOCK) {\n            revert ExecutionTimelockStillActive();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(activeProposal.proposalId);\n\n        for (uint256 step; step < instructions.length; ) {\n            kernel.executeAction(instructions[step].action, instructions[step].target);\n            unchecked {\n                ++step;\n            }\n        }\n\n        emit ProposalExecuted(activeProposal.proposalId);\n\n        // deactivate the active proposal\n        activeProposal = ActivatedProposal(0, 0);\n    }\n\n    /// @notice Reclaim locked votes from the contract after the proposal is no longer active.\n    /// @dev    The governance contract locks casted votes into the contract until the proposal\n    ///         is no longer active to prevent repeated voting with the same tokens.\n    /// @param  proposalId_ - The proposal that the user is reclaiming tokens for.\n    function reclaimVotes(uint256 proposalId_) external {\n        uint256 userVotes = userVotesForProposal[proposalId_][msg.sender];\n\n        if (userVotes == 0) {\n            revert CannotReclaimZeroVotes();\n        }\n\n        if (proposalId_ == activeProposal.proposalId) {\n            revert CannotReclaimTokensForActiveVote();\n        }\n\n        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {\n            revert VotingTokensAlreadyReclaimed();\n        }\n\n        tokenClaimsForProposal[proposalId_][msg.sender] = true;\n\n        VOTES.transferFrom(address(this), msg.sender, userVotes);\n    }\n}"
    }
  ]
}