{
  "Title": "M-8: Redeeming all UXD tokens is not possible if some have been minted via Perp quote minting",
  "Content": "# Issue M-8: Redeeming all UXD tokens is not possible if some have been minted via Perp quote minting \n\nSource: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/338 \n\n## Found by \nberndartmueller\n\n## Summary\n\nIf some UXD tokens have been minted via Perp quote minting (i.e. `USDC` - due to negative PnL), rather than asset minting (i.e. `WETH`), redeeming all UXD tokens is not possible anymore due to not accounting for quote minting in the `netAssetDeposits` variable.\n\n## Vulnerability Detail\n\nThe Perp integration allows users to deposit assets and return the redeemable (UXD) amount that can be minted. Assets can be deposited in two ways: either `assetToken` or `quoteToken`. `quoteToken` (i.e., `USDC`) can only be deposited if there's a negative PnL > `amount` to pay off the negative PnL.\n\nDepositing `assetToken` (i.e., `WETH`) increases the internal accounting variable `netAssetDeposits`, which is the amount of `assetToken` deposited minus the amount of `assetToken` withdrawn. Withdrawing `assetToken` decreases `netAssetDeposits` by the amount withdrawn.\n\nHowever, depositing `quoteToken` (if available) does not increase the `netAssetDeposits` variable. This leads to more `UXD` tokens being minted than `assetToken` deposited.\n\nThus, redeeming all `UXD` tokens is not possible anymore if some `UXD` tokens have been minted via quote minting. Users who are left last with redeeming their UXD tokens cannot do so.\n\n**Consider the following example:**\n\n- `assetToken` = `WETH`\n- `quoteToken` = `USDC`\n- `1 ether` of `WETH` = `1_000e6` `USDC` = `1_000e18` UXD\n- Negative PnL occurs during deposits because of market volatility\n\n| Time | Action                                                                 | `netAssetDeposits` | UXD supply  |\n| ---- | ---------------------------------------------------------------------- | ------------------ | ----------- |\n| T0   | Alice deposits `10 ether` of `assetToken`                              | `10 ether`         | `10_000e18` |\n| T1   | Bob deposits `10 ether` of `assetToken`                                | `20 ether`         | `20_000e18` |\n| T2   | Caroline deposits `1_000e6` of `quoteToken` (due to negative PnL)      | `20 ether`         | `21_000e18` |\n| T10  | Caroline redeems `1_000e18 UXD` via `1 ether` `assetToken`             | `19 ether`         | `20_000e18` |\n| T11  | Bob redeems `10_000e18 UXD` via `10 ether` `assetToken`                | `9 ether`          | `10_000e18` |\n| T12  | Alice redeems `10_000e18 UXD` via `10 ether` `assetToken` -> **fails** | `9 ether`          | `10_000e18` |\n\nAlice is not able to redeem her balance of `10_000e18 UXD` because `netAssetDeposits = 9 ether` is insufficient to redeem `10_000e18 UXD = 10 ether`.\n\n## Impact\n\nUXD tokens can not be fully redeemed via the Perp depository if some have been minted via quote minting.\n\n## Code Snippet\n\n[integrations/perp/PerpDepository.sol#L284](https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L284)\n\nAsset token deposits increase the internal accounting variable `netAssetDeposits` by the amount deposited.\n\n```solidity\n/// @notice Deposits collateral to back the delta-neutral position\n/// @dev Only called by the controller\n/// @param amount The amount to deposit\nfunction _depositAsset(uint256 amount) private {\n    netAssetDeposits += amount;\n\n    IERC20(assetToken).approve(address(vault), amount);\n    vault.deposit(assetToken, amount);\n}\n```\n\n[integrations/perp/PerpDepository.sol#L298](https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L298)\n\nWithdrawing asset tokens (i.e. `WETH`) decreases the internal accounting variable `netAssetDeposits` by the amount withdrawn and thus limits the amount of redeemable UXD tokens to `netAssetDeposits`.\n\n```solidity\n/// @notice Withdraws collateral to used in the delta-neutral position.\n/// @dev This should only happen when redeeming UXD for collateral.\n/// Only called by the controller.\n/// @param amount The amount to deposit\nfunction _withdrawAsset(uint256 amount, address to) private {\n    if (amount > netAssetDeposits) {\n        revert InsufficientAssetDeposits(netAssetDeposits, amount);\n    }\n    netAssetDeposits -= amount;\n\n    vault.withdraw(address(assetToken), amount);\n    IERC20(assetToken).transfer(to, amount);\n}\n```\n\n[integrations/perp/PerpDepository.redeem](https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L264)\n\nRedeeming via quote tokens is disabled. Only redeeming via `assetToken` is possible. Thus, leaving no other option than to redeem via `assetToken`.\n\n```solidity\nfunction redeem(\n        address asset,\n    uint256 amount\n) external onlyController returns (uint256) {\n    if (asset == assetToken) {\n        (uint256 base, ) = _openLong(amount);\n        _withdrawAsset(base, address(controller));\n        return base;\n    } else if (asset == quoteToken) {\n        revert QuoteRedeemDisabled(msg.sender);\n        // return _processQuoteRedeem(amount);\n    } else {\n        revert UnsupportedAsset(asset);\n    }\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider changing the internal accounting of `netAssetDeposits` to include `quoteToken` deposits.\n\n\n## Discussion\n\n**berndartmueller**\n\nEscalate for 25 USDC\n\nI think this issue is wrongly duped. The duped issues mention a similar issue in the context of the **rebalancing** functions. This issue demonstrated here is about **quote minting** in the case of a negative PnL.\n\nI think it's justified to leave this issue on its own without the duplicate issues. The duped issues should be left as a separate issue (Please note that #434 does not mention the real impact of not being able to redeem fully).\n\n(https://github.com/sherlock-audit/2023-01-uxd-judging/issues/97 has also been considered a separate issue)\n\n**sherlock-admin**\n\n > Escalate for 25 USDC\n> \n> I think this issue is wrongly duped. The duped issues mention a similar issue in the context of the **rebalancing** functions. This issue demonstrated here is about **quote minting** in the case of a negative PnL.\n> \n> I think it's justified to leave this issue on its own without the duplicate issues. The duped issues should be left as a separate issue (Please note that #434 does not mention the real impact of not being able to redeem fully).\n> \n> (https://github.com/sherlock-audit/2023-01-uxd-judging/issues/97 has also been considered a separate issue)\n\nYou've created a valid escalation for 25 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nAgreed that the issues is different from its dupes. \nSeparating from the rest of the issues #178, #262, #141 as they are considered as low together, since not updating `netAssetDeposits` on rebalance does not cause any real issues. \nAlso, issue #434 touches upon the issue partially, but does not fully describe the complete issue & its impact. Hence considering it a low. \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Agreed that the issues is different from its dupes. \n> Separating from the rest of the issues #178, #262, #141 as they are considered as low together, since not updating `netAssetDeposits` on rebalance does not cause any real issues. \n> Also, issue #434 touches upon the issue partially, but does not fully describe the complete issue & its impact. Hence considering it a low. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/33",
  "Code": [
    {
      "filename": "contracts/integrations/perp/PerpDepository.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IDepository, DepositoryState} from \"../IDepository.sol\";\nimport {IVault} from \"../../external/perp/IVault.sol\";\nimport {IClearingHouse} from \"../../external/perp/IClearingHouse.sol\";\nimport {IMarketRegistry} from \"../../external/perp/IMarketRegistry.sol\";\nimport {IAccountBalance} from \"../../external/perp/IAccountBalance.sol\";\nimport {IExchange} from \"../../external/perp/IExchange.sol\";\nimport {IUXDRouter} from \"../../core/IUXDRouter.sol\";\nimport {ERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ErrZeroAddress} from \"../../common/Constants.sol\";\nimport {FixedPointMathLib} from \"../../libraries/FixedPointMath.sol\";\nimport {MathLib} from \"../../libraries/MathLib.sol\";\nimport {ISwapper, SwapParams} from \"../ISwapper.sol\";\nimport {PerpDepositoryStorage} from \"./PerpDepositoryStorage.sol\";\n\n/// @title PerpDepository\n/// @notice Handles interactions with Perpetual Protocol Curie smart congtracts.\n/// @dev Collateral deposits, withdrawals and open positions are managed by this contract.\ncontract PerpDepository is\n    UUPSUpgradeable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    PerpDepositoryStorage\n{\n    using FixedPointMathLib for uint256;\n    using MathLib for uint256;\n    using MathLib for uint160;\n    using AddressUpgradeable for address;\n\n    ///////////////////////////////////////////////////////////////////\n    ///                         Errors\n    ///////////////////////////////////////////////////////////////////\n    error NotController(address caller);\n    error NotApproved(uint256 allowance, uint256 amount);\n    error ZeroAmount();\n    error RedeemableSoftCapHit(uint256 softcap, uint256 newBasePosition);\n    error InsufficientPnl(int256 allowance, uint256 amount);\n    error InvalidRebalance(int8 polarity);\n    error InvalidQuoteTokenBalance(int256 balance);\n    error AddressNotContract(address addr);\n    error PositivePnlRebalanceDisabled(address caller);\n    error QuoteRedeemDisabled(address account);\n    error UnsupportedAsset(address asset);\n    error InsufficientAssetDeposits(uint256 assetDeposits, uint256 amount);\n\n    ///////////////////////////////////////////////////////////////////\n    ///                         Events\n    ///////////////////////////////////////////////////////////////////\n    event InsuranceDeposited(\n        address indexed caller,\n        address indexed from,\n        uint256 amount\n    );\n    event InsuranceWithdrawn(\n        address indexed caller,\n        address indexed to,\n        uint256 amount\n    );\n    event RedeemableSoftCapUpdated(address indexed caller, uint256 newSoftCap);\n    event PositionOpened(\n        bool isShort,\n        uint256 amount,\n        bool amountIsInput,\n        uint160 sqrtPriceLimitX96\n    );\n\n    event Rebalanced(uint256 baseAmount, uint256 quoteAmount, int256 shortfall);\n\n    ///////////////////////////////////////////////////////////////////\n    ///                     Constants\n    ///////////////////////////////////////////////////////////////////\n\n    /// @dev For Perpetual protocol fee calculations\n    uint256 public constant HUNDRED_PERCENT = 1e6;\n\n    uint256 private constant WAD = 1e18;\n\n    modifier onlyController() {\n        if (msg.sender != address(controller)) {\n            revert NotController(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Initializer\n    /// @param _clearingHouse Perp curie clearing house\n    /// @param _marketRegistry Perp curie market registry\n    /// @param _futuresMarket The market this depository opens positions in\n    /// @param _assetToken The asset/collateral token address\n    /// @param _quoteToken The insurance token address\n    /// @param _controller UXD Controller. Used for access control\n    function initialize(\n        address _vault,\n        address _clearingHouse,\n        address _marketRegistry,\n        address _futuresMarket,\n        address _assetToken,\n        address _quoteToken,\n        address _controller\n    ) external virtual initializer {\n        __UUPSUpgradeable_init();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        address[] memory contractAddresses = new address[](7);\n        contractAddresses[0] = _vault;\n        contractAddresses[1] = _clearingHouse;\n        contractAddresses[2] = _marketRegistry;\n        contractAddresses[3] = _futuresMarket;\n        contractAddresses[4] = _assetToken;\n        contractAddresses[5] = _quoteToken;\n        contractAddresses[6] = _controller;\n        _checkContractAddresses(contractAddresses);\n\n        vault = IVault(_vault);\n        clearingHouse = IClearingHouse(_clearingHouse);\n        marketRegistry = IMarketRegistry(_marketRegistry);\n        market = _futuresMarket;\n        assetToken = _assetToken;\n        quoteToken = _quoteToken;\n        controller = _controller;\n    }\n\n    function _checkContractAddresses(address[] memory addresses) private view {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (!addresses[i].isContract()) {\n                revert AddressNotContract(addresses[i]);\n            }\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////\n    ///                 Admin functions\n    //////////////////////////////////////////////////////////////////\n\n    /// @notice Sets the controller address\n    /// @param _controller The new controller address\n    function setController(address _controller) external onlyOwner {\n        if (!_controller.isContract()) {\n            revert AddressNotContract(_controller);\n        }\n        controller = _controller;\n    }\n\n    /// @notice Sets the spot market swapping contract address.\n    /// @dev This updates the contract that performs the spot market swap as part of rebalancing.\n    /// @param _swapper The new contract address\n    function setSpotSwapper(address _swapper) external onlyOwner {\n        if (!_swapper.isContract()) {\n            revert AddressNotContract(_swapper);\n        }\n        spotSwapper = ISwapper(_swapper);\n    }\n\n    /// @notice Sets the redeemable soft cap\n    /// @dev Can only be called by owner\n    /// @param softCap The new redeemable soft cap\n    function setRedeemableSoftCap(uint256 softCap) external onlyOwner {\n        if (softCap == 0) {\n            revert ZeroAmount();\n        }\n        redeemableSoftCap = softCap;\n\n        emit RedeemableSoftCapUpdated(msg.sender, softCap);\n    }\n\n    /// @notice Deposits insurance to this depository\n    /// @dev Insurance token is set at contract initialization.\n    /// Only called by the owner\n    /// @param amount the amount to deposit\n    /// @param from the account to deposit from. This account must have approved this contract to\n    // spend >= amount.\n    function depositInsurance(uint256 amount, address from)\n        external\n        nonReentrant\n        onlyOwner\n    {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n        uint256 allowance = IERC20(insuranceToken()).allowance(\n            from,\n            address(this)\n        );\n        if (allowance < amount) {\n            revert NotApproved(allowance, amount);\n        }\n\n        insuranceDeposited += amount;\n\n        IERC20(insuranceToken()).transferFrom(from, address(this), amount);\n        IERC20(insuranceToken()).approve(address(vault), amount);\n        vault.deposit(insuranceToken(), amount);\n\n        emit InsuranceDeposited(msg.sender, from, amount);\n    }\n\n    /// @notice Withdraws insurance from this depository\n    /// @dev Can only be called by Owner (governance).\n    /// @param amount The amount to withdraw.\n    /// @param to The account to withdraw to.\n    function withdrawInsurance(uint256 amount, address to)\n        external\n        nonReentrant\n        onlyOwner\n    {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n\n        insuranceDeposited -= amount;\n\n        vault.withdraw(insuranceToken(), amount);\n        IERC20(insuranceToken()).transfer(to, amount);\n\n        emit InsuranceWithdrawn(msg.sender, to, amount);\n    }\n\n    ///////////////////////////////////////////////////////////////////\n    ///                 Mint and redeem\n    ///////////////////////////////////////////////////////////////////\n\n    /// @notice Deposit asset and return the amount of redeemable that can be minted.\n    /// @dev This is set up to handle either `assetToken` or `quoteToken` deposits.\n    /// If `assetToken` is deposted, we use the delta-neutral strategy and open additional\n    /// short position. The amount returned is the `quote` amount from opening the short.\n    /// If `quoteToken` is deposited, we use the \"quote mint\" strategy whereby we deposit\n    /// quote token and return an equivalant amount redeemable.\n    /// Quote minting is only possible if we have a negative PnL > `amount`. The amount deposited\n    /// is used to pay off part of this negative PnL.\n    /// @param asset The token to deposit\n    /// @param amount The amount to deposit\n    /// @return amountOut The amount of redeemable that can be added to the total supply.\n    function deposit(\n        address asset,\n        uint256 amount\n    ) external onlyController returns (uint256) {\n        if (asset == assetToken) {\n            _depositAsset(amount);\n            (, uint256 quoteAmount) = _openShort(amount);\n            return quoteAmount;\n        } else if (asset == quoteToken) {\n            return _processQuoteMint(amount);\n        } else {\n            revert UnsupportedAsset(asset);\n        }\n    }\n\n    /// @notice Redeem an amount of redeemable token.\n    /// @dev This handles redeeming for either `assetToken` or `quoteToken`.\n    /// If `assetToken` is specified, we use the delta-neutral strategy and close part of the\n    /// short position. This frees up asset collateral which can then be returned to the user.\n    /// If `quoteToken` is specified, we use the quote redeem strategy where we withdraw quote token\n    /// which can be returned to the caller. This is only possible if we have a positive PnL > amount being redeemed.\n    /// @param asset The asset to receive from this redemption\n    /// @param amount The amount of redeemable to redeem\n    /// @return amountOut The amount of `asset` released from this redemption\n    function redeem(\n        address asset,\n        uint256 amount\n    ) external onlyController returns (uint256) {\n        if (asset == assetToken) {\n            (uint256 base, ) = _openLong(amount);\n            _withdrawAsset(base, address(controller));\n            return base;\n        } else if (asset == quoteToken) {\n            revert QuoteRedeemDisabled(msg.sender);\n            // return _processQuoteRedeem(amount);\n        } else {\n            revert UnsupportedAsset(asset);\n        }\n    }\n\n    /// @notice Deposits collateral to back the delta-neutral position\n    /// @dev Only called by the controller\n    /// @param amount The amount to deposit\n    function _depositAsset(uint256 amount) private {\n        netAssetDeposits += amount;\n\n        IERC20(assetToken).approve(address(vault), amount);\n        vault.deposit(assetToken, amount);\n    }\n\n    /// @notice Withdraws collateral to used in the delta-neutral position.\n    /// @dev This should only happen when redeeming UXD for collateral.\n    /// Only called by the controller.\n    /// @param amount The amount to deposit\n    function _withdrawAsset(uint256 amount, address to) private {\n        if (amount > netAssetDeposits) {\n            revert InsufficientAssetDeposits(netAssetDeposits, amount);\n        }\n        netAssetDeposits -= amount;\n\n        vault.withdraw(address(assetToken), amount);\n        IERC20(assetToken).transfer(to, amount);\n    }\n\n    /// @notice Opens a long position on the perpetual DEX.\n    /// @dev This closes a portion of the previously open short backing the delta-neutral position.\n    /// Only called by the controller\n    /// @param amount The amount to open long position for.\n    /// `isBaseToQuote == false`, `exactInput == true`, so this is the quote amount.\n    function _openLong(uint256 amount)\n        private\n        returns (uint256, uint256)\n    {\n        (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n            amount,\n            false, // isShort\n            true, // isExactInput\n            0 // sqrtPriceLimitX96\n        );\n        redeemableUnderManagement -= quoteAmount;\n\n        return (baseAmount, quoteAmount);\n    }\n\n    /// @notice Opens a short position on the perpetual DEX.\n    /// @dev This increases the size of the delta-neutral position.\n    /// Can only be called by the controller\n    /// @param amount The amount of short position to open. THis is opened with `exactInput = true`,\n    /// thus, this is the input/base token amount.\n    /// @return base, quote\n    function _openShort(uint256 amount)\n        private\n        returns (uint256, uint256)\n    {\n        (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n            amount,\n            true, // short\n            true, // exactInput\n            0\n        );\n        redeemableUnderManagement += quoteAmount;\n        _checkSoftCap();\n        // emit event here\n        return (baseAmount, quoteAmount);\n    }\n\n    function _placePerpOrder(\n        uint256 amount,\n        bool isShort,\n        bool amountIsInput,\n        uint160 sqrtPriceLimit\n    ) private returns (uint256, uint256) {\n        uint256 upperBound = 0; // 0 = no limit, limit set by sqrtPriceLimit\n\n        IClearingHouse.OpenPositionParams memory params = IClearingHouse\n            .OpenPositionParams({\n                baseToken: market,\n                isBaseToQuote: isShort, // true for short\n                isExactInput: amountIsInput, // we specify exact input amount\n                amount: amount, // collateral amount - fees\n                oppositeAmountBound: upperBound, // output upper bound\n                // solhint-disable-next-line not-rely-on-time\n                deadline: block.timestamp,\n                sqrtPriceLimitX96: sqrtPriceLimit, // max slippage\n                referralCode: 0x0\n            });\n\n        (uint256 baseAmount, uint256 quoteAmount) = clearingHouse.openPosition(\n            params\n        );\n        uint256 feeAmount = _calculatePerpOrderFeeAmount(quoteAmount);\n        totalFeesPaid += feeAmount;\n\n        emit PositionOpened(isShort, amount, amountIsInput, sqrtPriceLimit);\n        return (baseAmount, quoteAmount);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    ///                     Quote mint and redeem\n    ///////////////////////////////////////////////////////////////////////////\n    /// @notice Process minting with quote token\n    /// @dev Deposits quote token to offset open noitional. Only possible if unrealizedPnl() > quoteAmount (normalized to 10^18).\n    /// Only called by controller.\n    /// @param quoteAmount The amount of quote amount being deposited.\n    /// @return normalizedAmount The amount of redeemable that can be minted.\n    function _processQuoteMint(uint256 quoteAmount) private returns (uint256) {\n        uint256 normalizedAmount = quoteAmount.fromDecimalToDecimal(\n            ERC20(quoteToken).decimals(),\n            18\n        );\n        _checkNegativePnl(normalizedAmount);\n        quoteMinted += int256(normalizedAmount);\n        redeemableUnderManagement += normalizedAmount;\n        _checkSoftCap();\n        IERC20(quoteToken).approve(address(vault), quoteAmount);\n        vault.deposit(quoteToken, quoteAmount);\n        return normalizedAmount;\n    }\n\n\n    /// NOTE: Quote redeem disabled (rebalances positive PnL)\n    /// @notice Process redeeming quote token on this depository.\n    /// @dev Withdraws quote token from the vault and returns it to the user.\n    /// Only called by controller.\n    //// @param redeemableAmount The amount being redeemed.\n    /// @return quoteAmout The amount of quote token withdrawn.\n    // function _processQuoteRedeem(uint256 redeemableAmount)\n    //     private\n    //     onlyController\n    //     returns (uint256)\n    // {\n    //     _checkPositivePnl(redeemableAmount);\n    //     quoteMinted -= int256(redeemableAmount);\n    //     redeemableUnderManagement -= redeemableAmount;\n    //     uint256 quoteAmount = redeemableAmount.fromDecimalToDecimal(\n    //         18,\n    //         ERC20(quoteToken).decimals()\n    //     );\n    //     vault.withdraw(quoteToken, quoteAmount);\n    //     IERC20(quoteToken).transfer(address(controller), quoteAmount);\n    //     return quoteAmount;\n    // }\n\n    /// @notice The unrealized Pnl from the delta neutral position.\n    /// @dev A positive value means the `redeemableUnderManagement` is larger than the delta neutral position\n    /// thus, we quote redeem or rebalance positive PnL.\n    /// A negative value means the `redeemableUnderManagement` is smaller than the delta neutral position value\n    /// thus, we can quote mint and/or rebalance negative PnL.\n    /// @return pnl The differnce between the `redeemableUnderManagement` and current perp position size.\n    function getUnrealizedPnl() public view returns (int256) {\n        return int256(redeemableUnderManagement) - int256(getPositionValue());\n    }\n\n    ////////////////////////////////////////////////////////////////////////\n    ///                        Rebalancing\n    ////////////////////////////////////////////////////////////////////////\n\n    /// @notice Rebalance PnL\n    /// @param amount The amount in quote token to rebalance.\n    /// @param amountOutMinimum The minimum amount of base token to receive in the swap to proceed with rebalancing.\n    /// @param polarity the direction of the rebalance. -1 to rebalance negative PnL, +1 for positive PnL\n    /// @param sqrtPriceLimitX96 The target price when performing the swap on the spot DEX, and also when placing the perp order.\n    /// @param account If there is any shortfall in the swap `account` covers the difference.\n    /// For negative PnL, account must have pre-approved this contract to spend quoteToken.\n    /// For positive PnL, account must have pre-approved this contract to spend assetToken.\n    /// The maximum amount that must be transferred from account = swap fees + slippage.\n    function rebalance(\n        uint256 amount,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint24 swapPoolFee,\n        int8 polarity,\n        address account\n    ) external nonReentrant returns (uint256, uint256) {\n        if (polarity == -1) {\n            return\n                _rebalanceNegativePnlWithSwap(\n                    amount,\n                    amountOutMinimum,\n                    sqrtPriceLimitX96,\n                    swapPoolFee,\n                    account\n                );\n        } else if (polarity == 1) {\n            // disable rebalancing positive PnL\n            revert PositivePnlRebalanceDisabled(msg.sender);\n            // return _rebalancePositivePnlWithSwap(amount, amountOutMinimum, sqrtPriceLimitX96, swapPoolFee, account);\n        } else {\n            revert InvalidRebalance(polarity);\n        }\n    }\n\n    // Collateral price has increased, thus, positionValue > supply. close part of open position\n    // close (amount quote) part of position => (baseAmount, quoteAmount)\n    // withdraw baseAmount base token.\n    // swap base => quote\n    // Transfer shortfall from swap from `account`\n    // deposit USDC to cover negative PnL\n    function _rebalanceNegativePnlWithSwap(\n        uint256 amount,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint24 swapPoolFee,\n        address account\n    ) private returns (uint256, uint256) {\n        uint256 normalizedAmount = amount.fromDecimalToDecimal(\n            ERC20(quoteToken).decimals(),\n            18\n        );\n        _checkNegativePnl(normalizedAmount);\n        bool isShort = false;\n        bool amountIsInput = true;\n        (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n            normalizedAmount,\n            isShort,\n            amountIsInput,\n            sqrtPriceLimitX96\n        );\n        vault.withdraw(assetToken, baseAmount);\n        SwapParams memory params = SwapParams({\n            tokenIn: assetToken,\n            tokenOut: quoteToken,\n            amountIn: baseAmount,\n            amountOutMinimum: amountOutMinimum,\n            sqrtPriceLimitX96: sqrtPriceLimitX96,\n            poolFee: swapPoolFee\n        });\n        uint256 quoteAmountOut = spotSwapper.swapExactInput(params);\n        int256 shortFall = int256(\n            quoteAmount.fromDecimalToDecimal(18, ERC20(quoteToken).decimals())\n        ) - int256(quoteAmountOut);\n        if (shortFall > 0) {\n            IERC20(quoteToken).transferFrom(\n                account,\n                address(this),\n                uint256(shortFall)\n            );\n        } else if (shortFall < 0) {\n            // we got excess tokens in the spot swap. Send them to the account paying for rebalance\n            IERC20(quoteToken).transfer(\n                account,\n                _abs(shortFall)\n            );\n        }\n        vault.deposit(quoteToken, quoteAmount);\n\n        emit Rebalanced(baseAmount, quoteAmount, shortFall);\n        return (baseAmount, quoteAmount);\n    }\n\n    /// NOTE: Rebalancing positive PnL disabled.\n    // Collateral price has fallen, thus, openNotional < supply. Open more DNP.\n    // withdraw quote profit\n    // swap quote => base\n    // deposit base\n    // open more DNP amount\n    // function _rebalancePositivePnlWithSwap(\n    //     uint256 amount,\n    //     uint256 amountOutMinimum,\n    //     uint160 sqrtPriceLimitX96,\n    //     uint24 swapPoolFee,\n    //     address account\n    // ) private returns (uint256, uint256) {\n    //     uint256 normalizedAmount = amount.fromDecimalToDecimal(\n    //         ERC20(quoteToken).decimals(),\n    //         18\n    //     );\n    //     _checkPositivePnl(normalizedAmount);\n    //     vault.withdraw(quoteToken, amount);\n    //     SwapParams memory params = SwapParams({\n    //         tokenIn: quoteToken,\n    //         tokenOut: assetToken,\n    //         amountIn: normalizedAmount,\n    //         amountOutMinimum: amountOutMinimum,\n    //         sqrtPriceLimitX96: sqrtPriceLimitX96,\n    //         poolFee: swapPoolFee\n    //     });\n    //     uint256 baseAmountFromSwap = spotSwapper.swapExactInput(params);\n    //     // can we wait to deposit this after we know the shortfall?\n    //     vault.deposit(assetToken, baseAmountFromSwap);\n    //     (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n    //         normalizedAmount,\n    //         true, // expand position\n    //         false, // amount is input\n    //         sqrtPriceLimitX96\n    //     );\n    //     int256 shortFall = int256(baseAmount) - int256(baseAmountFromSwap);\n    //     if (shortFall > 0) {\n    //         IERC20(assetToken).transferFrom(\n    //             account,\n    //             address(this),\n    //             uint256(shortFall)\n    //         );\n    //         vault.deposit(assetToken, uint256(shortFall));\n    //     } else if (shortFall < 0) {\n    //         // we got excess tokens from swap. Send them to account paying for rebalance\n    //         IERC20(assetToken).transfer(\n    //             account,\n    //             _abs(shortFall)\n    //         );\n    //     }\n\n    //     emit Rebalanced(baseAmount, quoteAmount, shortFall);\n    //     return (baseAmount, quoteAmount);\n    // }\n\n    /// @notice Rebalance unrealized PnL lite.\n    /// @dev Lite rebalancing requires the caller to provide the amount to rebalance.\n    /// For negative PnL, `account` provides amount in quote token.\n    /// For this call to succeed the account must have approved this contract to spend amount (for negative PnL),\n    /// or equivalent amount in assetToken (for positive PnL).\n    /// @param amount The amount of PnL to rebalance in quote token decimals.\n    /// @param polarity The direction of the rebalance. -1 for negative PnL, +1 for positive PnL.\n    /// @param sqrtPriceLimitX96 The target price when placing the perp order to resize the delta neutral position.\n    /// @param account The account doing the rebalancing. This account must provide the collateral\n    /// or quote amount and receives the other side after the swap.\n    /// @return (baseAmount, quoteAmount) the amount rebalanced in baseAmount and quoteAmount.\n    function rebalanceLite(\n        uint256 amount,\n        int8 polarity,\n        uint160 sqrtPriceLimitX96,\n        address account\n    ) external nonReentrant returns (uint256, uint256) {\n        if (polarity == -1) {\n            return\n                _rebalanceNegativePnlLite(amount, sqrtPriceLimitX96, account);\n        } else if (polarity == 1) {\n            // disable rebalancing positive PnL\n            revert PositivePnlRebalanceDisabled(msg.sender);\n            // return _rebalancePositivePnlLite(amount, sqrtPriceLimitX96, account);\n        } else {\n            revert InvalidRebalance(polarity);\n        }\n    }\n\n    function _rebalanceNegativePnlLite(\n        uint256 amount,\n        uint160 sqrtPriceLimitX96,\n        address account\n    ) private returns (uint256, uint256) {\n        uint256 normalizedAmount = amount.fromDecimalToDecimal(\n            ERC20(quoteToken).decimals(),\n            18\n        );\n\n        _checkNegativePnl(normalizedAmount);\n        IERC20(quoteToken).transferFrom(account, address(this), amount);\n        IERC20(quoteToken).approve(address(vault), amount);\n        vault.deposit(quoteToken, amount);\n\n        bool isShort = false;\n        bool amountIsInput = true;\n        (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n            normalizedAmount,\n            isShort,\n            amountIsInput,\n            sqrtPriceLimitX96\n        );\n        vault.withdraw(assetToken, baseAmount);\n        IERC20(assetToken).transfer(account, baseAmount);\n\n        emit Rebalanced(baseAmount, quoteAmount, 0);\n\n        return (baseAmount, quoteAmount);\n    }\n\n    /// NOTE: Rebalance positive PnL disabled\n    // function _rebalancePositivePnlLite(\n    //     uint256 amount,\n    //     uint160 sqrtPriceLimitX96,\n    //     address account\n    // ) private returns (uint256, uint256) {\n    //     uint256 normalizedAmount = amount.fromDecimalToDecimal(\n    //         ERC20(quoteToken).decimals(),\n    //         18\n    //     );\n    //     _checkPositivePnl(normalizedAmount);\n    //     bool isShort = true;\n    //     bool amountIsInput = false;\n    //     (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n    //         normalizedAmount,\n    //         isShort,\n    //         amountIsInput,\n    //         sqrtPriceLimitX96\n    //     );\n    //     uint256 baseIncludingFee = baseAmount +\n    //         baseAmount.mulWadUp(getExchangeFeeWad());\n    //     IERC20(assetToken).transferFrom(\n    //         account,\n    //         address(this),\n    //         baseIncludingFee\n    //     );\n    //     IERC20(assetToken).approve(address(vault), baseIncludingFee);\n    //     vault.deposit(assetToken, baseIncludingFee);\n    //     vault.withdraw(quoteToken, amount);\n    //     IERC20(quoteToken).transfer(account, amount);\n\n    //     emit Rebalanced(baseAmount, quoteAmount, 0);\n    //     return (baseAmount, quoteAmount);\n    // }\n\n    /// @dev check if negative Pnl exists > amount\n    function _checkNegativePnl(uint256 amount) private view {\n        int256 pnl = getUnrealizedPnl();\n        if (pnl >= 0 || _abs(pnl) < amount) {\n            revert InsufficientPnl(pnl, amount);\n        }\n    }\n\n    /// NOTE: Rebalance positive PnL disabled\n    /// @dev check if positive Pnl exists > amount\n    // function _checkPositivePnl(uint256 amount) private view {\n    //     int256 pnl = getUnrealizedPnl();\n    //     if (pnl <= 0 || uint256(pnl) < amount) {\n    //         revert InsufficientPnl(pnl, amount);\n    //     }\n    // }\n\n    ///////////////////////////////////////////////////////////////////////\n    ///                       State view functions\n    ///////////////////////////////////////////////////////////////////////\n\n    function insuranceToken() public view returns (address) {\n        return quoteToken;\n    }\n\n    /// @notice Returns the current size of the short position in quote amount.\n    /// @return Position size\n    function getPositionValue() public view returns (uint256) {\n        uint256 markPrice = getMarkPriceTwap(15);\n        int256 positionSize = IAccountBalance(clearingHouse.getAccountBalance())\n            .getTakerPositionSize(address(this), market);\n        return markPrice.mulWadUp(_abs(positionSize));\n    }\n\n    function getMarkPriceTwap(uint32 twapInterval)\n        public\n        view\n        returns (uint256)\n    {\n        IExchange exchange = IExchange(clearingHouse.getExchange());\n        uint256 markPrice = exchange\n            .getSqrtMarkTwapX96(market, twapInterval)\n            .formatSqrtPriceX96ToPriceX96()\n            .formatX96ToX10_18();\n        return markPrice;\n    }\n\n    /// @notice Gets the available free colalteral.\n    /// @return amount the free colalteral available not locked in open positions.\n    function getFreeCollateral() external view returns (uint256) {\n        return vault.getFreeCollateral(address(this));\n    }\n\n    /// @notice Get the current accounting state of the depository.\n    /// @return state `DepositoryState` instance representing the current state of this depository.\n    function getCurrentState() external view returns (DepositoryState memory) {\n        return\n            DepositoryState({\n                netAssetDeposits: netAssetDeposits,\n                insuranceDeposited: insuranceDeposited,\n                redeemableUnderManagement: redeemableUnderManagement,\n                totalFeesPaid: totalFeesPaid,\n                redeemableSoftCap: redeemableSoftCap\n            });\n    }\n\n    /// @notice Returns the total value of this depository's an account with the DEX.\n    /// @return value The total account value\n    function getAccountValue() external view returns (int256) {\n        return clearingHouse.getAccountValue(address(this));\n    }\n\n    /// @notice Get the quote token balance of this user\n    /// @dev THe total debt is computed as:\n    ///     quote token balance + unrealized PnL - Pending fee - pending funding payments\n    /// @param account The account to return the debt for\n    /// @return debt The account debt, or zero if no debt.\n    function getDebtValue(address account) external view returns (uint256) {\n        IAccountBalance perpAccountBalance = IAccountBalance(\n            clearingHouse.getAccountBalance()\n        );\n        IExchange perpExchange = IExchange(clearingHouse.getExchange());\n        int256 accountQuoteTokenBalance = vault.getBalance(account);\n        if (accountQuoteTokenBalance < 0) {\n            revert InvalidQuoteTokenBalance(accountQuoteTokenBalance);\n        }\n        int256 fundingPayment = perpExchange.getAllPendingFundingPayment(\n            account\n        );\n        uint256 quoteTokenBalance = uint256(accountQuoteTokenBalance)\n            .fromDecimalToDecimal(ERC20(quoteToken).decimals(), 18);\n        (\n            ,\n            int256 perpUnrealizedPnl,\n            uint256 perpPendingFee\n        ) = perpAccountBalance.getPnlAndPendingFee(account);\n        int256 debt = int256(quoteTokenBalance) +\n            perpUnrealizedPnl -\n            int256(perpPendingFee) -\n            fundingPayment;\n        return (debt > 0) ? 0 : _abs(debt);\n    }\n\n    /// @notice Returns the exchange fee as returned by the exchange\n    /// @dev This is in quote token decimals\n    /// @return uint256 The exchange fee\n    function getExchangeFee() external view returns (uint256) {\n        return marketRegistry.getFeeRatio(market);\n    }\n\n    /// @notice Returns the exchange fee normalized to WAD 10^18\n    /// @dev 100% = 10^18\n    /// @return uint256 The exchange fee normalized to a WAD.\n    function getExchangeFeeWad() public view returns (uint256) {\n        uint256 feeRatio = marketRegistry.getFeeRatio(market);\n        return feeRatio.mulWadUp(WAD).divWadDown(HUNDRED_PERCENT);\n    }\n\n    /// @notice Returns the PERP fee for a given amount\n    /// @dev This is calculated using the fee ratio from the PERP\n    /// `MarketRegistry` contract."
    }
  ]
}