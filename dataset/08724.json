{
  "Title": "[N-01] Missing checks for `address(0x0)` when assigning values to address state variables",
  "Content": "\nThere are 2 instances of this issue:\n\n```solidity\nFile: contracts/operators/Yearn/YearnCurveVaultOperator.sol   #1\n\n48:           eth = _eth;\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48\n\n```solidity\nFile: contracts/abstracts/OwnableProxyDelegation.sol   #2\n\n65:           _owner = newOwner;\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L65\n\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-06-nested",
  "Code": [
    {
      "filename": "contracts/operators/Yearn/YearnCurveVaultOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./../../Withdrawer.sol\";\nimport \"./YearnVaultStorage.sol\";\n\nimport \"./../../libraries/OperatorHelpers.sol\";\nimport \"./../../libraries/ExchangeHelpers.sol\";\nimport \"./../../interfaces/external/IWETH.sol\";\nimport \"../../libraries/StakingLPVaultHelpers.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./../../libraries/CurveHelpers/CurveHelpers.sol\";\nimport \"./../../interfaces/external/ICurvePool/ICurvePoolETH.sol\";\nimport \"./../../interfaces/external/IStakingVault/IYearnVault.sol\";\nimport \"./../../interfaces/external/ICurvePool/ICurvePoolNonETH.sol\";\n\n/// @title Yearn Curve Vault Operator\n/// @notice Deposit/Withdraw in a Yearn Curve vault.\ncontract YearnCurveVaultOperator {\n    YearnVaultStorage public immutable operatorStorage;\n\n    /// @dev ETH address\n    address public immutable eth;\n\n    /// @dev WETH contract\n    IWETH private immutable weth;\n\n    /// @dev Withdrawer\n    Withdrawer private immutable withdrawer;\n\n    constructor(\n        address[] memory vaults,\n        CurvePool[] memory pools,\n        Withdrawer _withdrawer,\n        address _eth,\n        address _weth\n    ) {\n        uint256 vaultsLength = vaults.length;\n        require(vaultsLength == pools.length, \"YCVO: INVALID_VAULTS_LENGTH\");\n        operatorStorage = new YearnVaultStorage();\n\n        for (uint256 i; i < vaultsLength; i++) {\n            operatorStorage.addVault(vaults[i], pools[i]);\n        }\n\n        operatorStorage.transferOwnership(msg.sender);\n\n        eth = _eth;\n        weth = IWETH(_weth);\n        withdrawer = _withdrawer;\n    }\n\n    /// @notice Add liquidity in a Curve pool that includes ETH,\n    ///         deposit the LP token in a Yearn vault and receive\n    ///         the Yearn vault shares\n    /// @param vault The Yearn vault address to deposit into\n    /// @param amount The amount of token to add liquidity\n    /// @param minVaultAmount The minimum of Yearn vault shares expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function depositETH(\n        address vault,\n        uint256 amount,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 ethBalanceBefore = weth.balanceOf(address(this));\n\n        ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer));\n\n        // withdraw ETH from WETH\n        withdrawer.withdraw(amount);\n\n        StakingLPVaultHelpers._addLiquidityAndDepositETH(\n            vault,\n            ICurvePoolETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            eth,\n            amount\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(address(weth)),\n            ethBalanceBefore,\n            amount,\n            IERC20(vault),\n            vaultBalanceBefore,\n            minVaultAmount\n        );\n    }\n\n    /// @notice Add liquidity in a Curve pool, deposit\n    ///         the LP token in a Yearn vault and receive\n    ///         the Yearn vault shares\n    /// @param vault The Yearn vault address to deposit into\n    /// @param token The token to add liquidity\n    /// @param amount The amount of token to add liquidity\n    /// @param minVaultAmount The minimum of Yearn vault shares expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function deposit(\n        address vault,\n        address token,\n        uint256 amount,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = IERC20(token).balanceOf(address(this));\n\n        StakingLPVaultHelpers._addLiquidityAndDeposit(\n            vault,\n            ICurvePoolNonETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            token,\n            amount\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(token),\n            tokenBalanceBefore,\n            amount,\n            IERC20(vault),\n            vaultBalanceBefore,\n            minVaultAmount\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove ETH liquidity from the Curve pool\n    ///         and receive one of the curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdrawETH(\n        address vault,\n        uint256 amount,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = weth.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity128(\n            vault,\n            amount,\n            ICurvePool(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            eth\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            IERC20(address(weth)),\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove the liquidity from the Curve pool\n    ///         (using int128 for the curvePool.remove_liquidity_one_coin\n    ///         coin index parameter) and receive one of the\n    ///         curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param outputToken Output token to receive\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw128(\n        address vault,\n        uint256 amount,\n        IERC20 outputToken,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity128(\n            vault,\n            amount,\n            ICurvePool(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            address(outputToken)\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            outputToken,\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove the liquidity from the Curve pool\n    ///         (using uint256 for the curvePool.remove_liquidity_one_coin\n    ///         coin index parameter) and receive one of the\n    ///         curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param outputToken Output token to receive\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw256(\n        address vault,\n        uint256 amount,\n        IERC20 outputToken,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity256(\n            vault,\n            amount,\n            ICurvePoolNonETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            address(outputToken)\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            outputToken,\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n}"
    },
    {
      "filename": "contracts/abstracts/OwnableProxyDelegation.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\n\n/// @notice Ownable re-implementation to initialize the owner in the\n///         proxy storage after an \"upgradeToAndCall()\" (delegatecall).\n/// @dev The implementation contract owner will be address zero (by removing the constructor)\nabstract contract OwnableProxyDelegation is Context {\n    /// @dev The contract owner\n    address private _owner;\n\n    /// @dev Storage slot with the proxy admin (see TransparentUpgradeableProxy from OZ)\n    bytes32 internal constant _ADMIN_SLOT = bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1);\n\n    /// @dev True if the owner is setted\n    bool public initialized;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Initialize the owner (by the proxy admin)\n    /// @param ownerAddr The owner address\n    function initialize(address ownerAddr) external {\n        require(ownerAddr != address(0), \"OPD: INVALID_ADDRESS\");\n        require(!initialized, \"OPD: INITIALIZED\");\n        require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, \"OPD: FORBIDDEN\");\n\n        _setOwner(ownerAddr);\n\n        initialized = true;\n    }\n\n    /// @dev Returns the address of the current owner.\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /// @dev Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"OPD: NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Leaves the contract without owner. It will not be possible to call\n    /// `onlyOwner` functions anymore. Can only be called by the current owner.\n    ///\n    /// NOTE: Renouncing ownership will leave the contract without an owner,\n    /// thereby removing any functionality that is only available to the owner.\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`).\n    /// Can only be called by the current owner.\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"OPD: INVALID_ADDRESS\");\n        _setOwner(newOwner);\n    }\n\n    /// @dev Update the owner address\n    /// @param newOwner The new owner address\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"
    }
  ]
}