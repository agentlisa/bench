{
  "Title": "[L-10] Even with the `onlyOwner` or `owner_only` modifier, it is best practice to use the re-entrancy pattern",
  "Content": "\nIt's still good practice to apply the reentry model as a precautionary measure in case the code is changed in the future to remove the onlyOwner modifier or the contract is used as a base contract for other contracts.\n\nUsing the reentry modifier provides an additional layer of security and ensures that your code is protected from potential reentry attacks regardless of any other security measures you take.\n\nSo even if you followed the \"check-effects-interactions\" pattern correctly, it's still considered good practice to use the reentry modifier\n\n\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/DNSRegistrar.sol\n\n80: function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n    }\n\n```\n[DNSRegistrar.sol#L80-L83](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L80-L83)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/DNSSECImpl.sol\n\n64: function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\n        algorithms[id] = algo;\n        emit AlgorithmUpdated(id, address(algo));\n    }\n\n75: function setDigest(uint8 id, Digest digest) public owner_only {\n        digests[id] = digest;\n        emit DigestUpdated(id, address(digest));\n    }\n\n```\n[DNSSECImpl.sol#L64-L67](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/DNSSECImpl.sol#L64-L67)\n\n### Recommended Mitigation\n\n```solidity\n\n  modifier noReentrant() {\n        require(!locked, \"Reentrant call\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\nfunction setPublicSuffixList(PublicSuffixList _suffixes) public  onlyOwner noReentrant  {\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-ens",
  "Code": [
    {
      "filename": "contracts/dnsregistrar/DNSRegistrar.sol",
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\nimport \"../dnssec-oracle/BytesUtils.sol\";\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../registry/ENSRegistry.sol\";\nimport \"../root/Root.sol\";\nimport \"../resolvers/profiles/AddrResolver.sol\";\nimport \"./DNSClaimChecker.sol\";\nimport \"./PublicSuffixList.sol\";\nimport \"./IDNSRegistrar.sol\";\n\n/**\n * @dev An ENS registrar that allows the owner of a DNS name to claim the\n *      corresponding name in ENS.\n */\ncontract DNSRegistrar is IDNSRegistrar, IERC165 {\n    using BytesUtils for bytes;\n    using Buffer for Buffer.buffer;\n    using RRUtils for *;\n\n    ENS public immutable ens;\n    DNSSEC public immutable oracle;\n    PublicSuffixList public suffixes;\n    address public immutable previousRegistrar;\n    address public immutable resolver;\n    // A mapping of the most recent signatures seen for each claimed domain.\n    mapping(bytes32 => uint32) public inceptions;\n\n    error NoOwnerRecordFound();\n    error PermissionDenied(address caller, address owner);\n    error PreconditionNotMet();\n    error StaleProof();\n    error InvalidPublicSuffix(bytes name);\n\n    struct OwnerRecord {\n        bytes name;\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    event Claim(\n        bytes32 indexed node,\n        address indexed owner,\n        bytes dnsname,\n        uint32 inception\n    );\n    event NewPublicSuffixList(address suffixes);\n\n    constructor(\n        address _previousRegistrar,\n        address _resolver,\n        DNSSEC _dnssec,\n        PublicSuffixList _suffixes,\n        ENS _ens\n    ) {\n        previousRegistrar = _previousRegistrar;\n        resolver = _resolver;\n        oracle = _dnssec;\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n        ens = _ens;\n    }\n\n    /**\n     * @dev This contract's owner-only functions can be invoked by the owner of the ENS root.\n     */\n    modifier onlyOwner() {\n        Root root = Root(ens.owner(bytes32(0)));\n        address owner = root.owner();\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n    }\n\n    /**\n     * @dev Submits proofs to the DNSSEC oracle, then claims a name using those proofs.\n     * @param name The name to claim, in DNS wire format.\n     * @param input A chain of signed DNS RRSETs ending with a text record.\n     */\n    function proveAndClaim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) public override {\n        (bytes32 rootNode, bytes32 labelHash, address addr) = _claim(\n            name,\n            input\n        );\n        ens.setSubnodeOwner(rootNode, labelHash, addr);\n    }\n\n    function proveAndClaimWithResolver(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input,\n        address resolver,\n        address addr\n    ) public override {\n        (bytes32 rootNode, bytes32 labelHash, address owner) = _claim(\n            name,\n            input\n        );\n        if (msg.sender != owner) {\n            revert PermissionDenied(msg.sender, owner);\n        }\n        ens.setSubnodeRecord(rootNode, labelHash, owner, resolver, 0);\n        if (addr != address(0)) {\n            if (resolver == address(0)) {\n                revert PreconditionNotMet();\n            }\n            bytes32 node = keccak256(abi.encodePacked(rootNode, labelHash));\n            // Set the resolver record\n            AddrResolver(resolver).setAddr(node, addr);\n        }\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure override returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IDNSRegistrar).interfaceId;\n    }\n\n    function _claim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) internal returns (bytes32 parentNode, bytes32 labelHash, address addr) {\n        (bytes memory data, uint32 inception) = oracle.verifyRRSet(input);\n\n        // Get the first label\n        uint256 labelLen = name.readUint8(0);\n        labelHash = name.keccak(1, labelLen);\n\n        bytes memory parentName = name.substring(\n            labelLen + 1,\n            name.length - labelLen - 1\n        );\n\n        // Make sure the parent name is enabled\n        parentNode = enableNode(parentName);\n\n        bytes32 node = keccak256(abi.encodePacked(parentNode, labelHash));\n        if (!RRUtils.serialNumberGte(inception, inceptions[node])) {\n            revert StaleProof();\n        }\n        inceptions[node] = inception;\n\n        bool found;\n        (addr, found) = DNSClaimChecker.getOwnerAddress(name, data);\n        if (!found) {\n            revert NoOwnerRecordFound();\n        }\n\n        emit Claim(node, addr, name, inception);\n    }\n\n    function enableNode(bytes memory domain) public returns (bytes32 node) {\n        // Name must be in the public suffix list.\n        if (!suffixes.isPublicSuffix(domain)) {\n            revert InvalidPublicSuffix(domain);\n        }\n        return _enableNode(domain, 0);\n    }\n\n    function _enableNode(\n        bytes memory domain,\n        uint256 offset\n    ) internal returns (bytes32 node) {\n        uint256 len = domain.readUint8(offset);\n        if (len == 0) {\n            return bytes32(0);\n        }\n\n        bytes32 parentNode = _enableNode(domain, offset + len + 1);\n        bytes32 label = domain.keccak(offset + 1, len);\n        node = keccak256(abi.encodePacked(parentNode, label));\n        address owner = ens.owner(node);\n        if (owner == address(0) || owner == previousRegistrar) {\n            if (parentNode == bytes32(0)) {\n                Root root = Root(ens.owner(bytes32(0)));\n                root.setSubnodeOwner(label, address(this));\n                ens.setResolver(node, resolver);\n            } else {\n                ens.setSubnodeRecord(\n                    parentNode,\n                    label,\n                    address(this),\n                    resolver,\n                    0\n                );\n            }\n        } else if (owner != address(this)) {\n            revert PreconditionNotMet();\n        }\n        return node;\n    }\n}"
    },
    {
      "filename": "contracts/dnssec-oracle/DNSSECImpl.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport \"./Owned.sol\";\nimport \"./BytesUtils.sol\";\nimport \"./RRUtils.sol\";\nimport \"./DNSSEC.sol\";\nimport \"./algorithms/Algorithm.sol\";\nimport \"./digests/Digest.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/*\n * @dev An oracle contract that verifies and stores DNSSEC-validated DNS records.\n * @note This differs from the DNSSEC spec defined in RFC4034 and RFC4035 in some key regards:\n *       - NSEC & NSEC3 are not supported; only positive proofs are allowed.\n *       - Proofs involving wildcard names will not validate.\n *       - TTLs on records are ignored, as data is not stored persistently.\n *       - Canonical form of names is not checked; in ENS this is done on the frontend, so submitting\n *         proofs with non-canonical names will only result in registering unresolvable ENS names.\n */\ncontract DNSSECImpl is DNSSEC, Owned {\n    using Buffer for Buffer.buffer;\n    using BytesUtils for bytes;\n    using RRUtils for *;\n\n    uint16 constant DNSCLASS_IN = 1;\n\n    uint16 constant DNSTYPE_DS = 43;\n    uint16 constant DNSTYPE_DNSKEY = 48;\n\n    uint256 constant DNSKEY_FLAG_ZONEKEY = 0x100;\n\n    error InvalidLabelCount(bytes name, uint256 labelsExpected);\n    error SignatureNotValidYet(uint32 inception, uint32 now);\n    error SignatureExpired(uint32 expiration, uint32 now);\n    error InvalidClass(uint16 class);\n    error InvalidRRSet();\n    error SignatureTypeMismatch(uint16 rrsetType, uint16 sigType);\n    error InvalidSignerName(bytes rrsetName, bytes signerName);\n    error InvalidProofType(uint16 proofType);\n    error ProofNameMismatch(bytes signerName, bytes proofName);\n    error NoMatchingProof(bytes signerName);\n\n    mapping(uint8 => Algorithm) public algorithms;\n    mapping(uint8 => Digest) public digests;\n\n    /**\n     * @dev Constructor.\n     * @param _anchors The binary format RR entries for the root DS records.\n     */\n    constructor(bytes memory _anchors) {\n        // Insert the 'trust anchors' - the key hashes that start the chain\n        // of trust for all other records.\n        anchors = _anchors;\n    }\n\n    /**\n     * @dev Sets the contract address for a signature verification algorithm.\n     *      Callable only by the owner.\n     * @param id The algorithm ID\n     * @param algo The address of the algorithm contract.\n     */\n    function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\n        algorithms[id] = algo;\n        emit AlgorithmUpdated(id, address(algo));\n    }\n\n    /**\n     * @dev Sets the contract address for a digest verification algorithm.\n     *      Callable only by the owner.\n     * @param id The digest ID\n     * @param digest The address of the digest contract.\n     */\n    function setDigest(uint8 id, Digest digest) public owner_only {\n        digests[id] = digest;\n        emit DigestUpdated(id, address(digest));\n    }\n\n    /**\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\n     * @param input A list of signed RRSets.\n     * @return rrs The RRData from the last RRSet in the chain.\n     * @return inception The inception time of the signed record set.\n     */\n    function verifyRRSet(\n        RRSetWithSignature[] memory input\n    )\n        external\n        view\n        virtual\n        override\n        returns (bytes memory rrs, uint32 inception)\n    {\n        return verifyRRSet(input, block.timestamp);\n    }\n\n    /**\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\n     * @param input A list of signed RRSets.\n     * @param now The Unix timestamp to validate the records at.\n     * @return rrs The RRData from the last RRSet in the chain.\n     * @return inception The inception time of the signed record set.\n     */\n    function verifyRRSet(\n        RRSetWithSignature[] memory input,\n        uint256 now\n    )\n        public\n        view\n        virtual\n        override\n        returns (bytes memory rrs, uint32 inception)\n    {\n        bytes memory proof = anchors;\n        for (uint256 i = 0; i < input.length; i++) {\n            RRUtils.SignedSet memory rrset = validateSignedSet(\n                input[i],\n                proof,\n                now\n            );\n            proof = rrset.data;\n            inception = rrset.inception;\n        }\n        return (proof, inception);\n    }\n\n    /**\n     * @dev Validates an RRSet against the already trusted RR provided in `proof`.\n     *\n     * @param input The signed RR set. This is in the format described in section\n     *        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\n     *        data, followed by a series of canonicalised RR records that the signature\n     *        applies to.\n     * @param proof The DNSKEY or DS to validate the signature against.\n     * @param now The current timestamp.\n     */\n    function validateSignedSet(\n        RRSetWithSignature memory input,\n        bytes memory proof,\n        uint256 now\n    ) internal view returns (RRUtils.SignedSet memory rrset) {\n        rrset = input.rrset.readSignedSet();\n\n        // Do some basic checks on the RRs and extract the name\n        bytes memory name = validateRRs(rrset, rrset.typeCovered);\n        if (name.labelCount(0) != rrset.labels) {\n            revert InvalidLabelCount(name, rrset.labels);\n        }\n        rrset.name = name;\n\n        // All comparisons involving the Signature Expiration and\n        // Inception fields MUST use \"serial number arithmetic\", as\n        // defined in RFC 1982\n\n        // o  The validator's notion of the current time MUST be less than or\n        //    equal to the time listed in the RRSIG RR's Expiration field.\n        if (!RRUtils.serialNumberGte(rrset.expiration, uint32(now))) {\n            revert SignatureExpired(rrset.expiration, uint32(now));\n        }\n\n        // o  The validator's notion of the current time MUST be greater than or\n        //    equal to the time listed in the RRSIG RR's Inception field.\n        if (!RRUtils.serialNumberGte(uint32(now), rrset.inception)) {\n            revert SignatureNotValidYet(rrset.inception, uint32(now));\n        }\n\n        // Validate the signature\n        verifySignature(name, rrset, input, proof);\n\n        return rrset;\n    }\n\n    /**\n     * @dev Validates a set of RRs.\n     * @param rrset The RR set.\n     * @param typecovered The type covered by the RRSIG record.\n     */\n    function validateRRs(\n        RRUtils.SignedSet memory rrset,\n        uint16 typecovered\n    ) internal pure returns (bytes memory name) {\n        // Iterate over all the RRs\n        for (\n            RRUtils.RRIterator memory iter = rrset.rrs();\n            !iter.done();\n            iter.next()\n        ) {\n            // We only support class IN (Internet)\n            if (iter.class != DNSCLASS_IN) {\n                revert InvalidClass(iter.class);\n            }\n\n            if (name.length == 0) {\n                name = iter.name();\n            } else {\n                // Name must be the same on all RRs. We do things this way to avoid copying the name\n                // repeatedly.\n                if (\n                    name.length != iter.data.nameLength(iter.offset) ||\n                    !name.equals(0, iter.data, iter.offset, name.length)\n                ) {\n                    revert InvalidRRSet();\n                }\n            }\n\n            // o  The RRSIG RR's Type Covered field MUST equal the RRset's type.\n            if (iter.dnstype != typecovered) {\n                revert SignatureTypeMismatch(iter.dnstype, typecovered);\n            }\n        }\n    }\n\n    /**\n     * @dev Performs signature verification.\n     *\n     * Throws or reverts if unable to verify the record.\n     *\n     * @param name The name of the RRSIG record, in DNS label-sequence format.\n     * @param data The original data to verify.\n     * @param proof A DS or DNSKEY record that's already verified by the oracle.\n     */\n    function verifySignature(\n        bytes memory name,\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        bytes memory proof\n    ) internal view {\n        // o  The RRSIG RR's Signer's Name field MUST be the name of the zone\n        //    that contains the RRset.\n        if (!name.isSubdomainOf(rrset.signerName)) {\n            revert InvalidSignerName(name, rrset.signerName);\n        }\n\n        RRUtils.RRIterator memory proofRR = proof.iterateRRs(0);\n        // Check the proof\n        if (proofRR.dnstype == DNSTYPE_DS) {\n            verifyWithDS(rrset, data, proofRR);\n        } else if (proofRR.dnstype == DNSTYPE_DNSKEY) {\n            verifyWithKnownKey(rrset, data, proofRR);\n        } else {\n            revert InvalidProofType(proofRR.dnstype);\n        }\n    }\n\n    /**\n     * @dev Attempts to verify a signed RRSET against an already known public key.\n     * @param rrset The signed set to verify.\n     * @param data The original data the signed set was read from.\n     * @param proof The serialized DS or DNSKEY record to use as proof.\n     */\n    function verifyWithKnownKey(\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        RRUtils.RRIterator memory proof\n    ) internal view {\n        // Check the DNSKEY's owner name matches the signer name on the RRSIG\n        for (; !proof.done(); proof.next()) {\n            bytes memory proofName = proof.name();\n            if (!proofName.equals(rrset.signerName)) {\n                revert ProofNameMismatch(rrset.signerName, proofName);\n            }\n\n            bytes memory keyrdata = proof.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n                0,\n                keyrdata.length\n            );\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                return;\n            }\n        }\n        revert NoMatchingProof(rrset.signerName);\n    }\n\n    /**\n     * @dev Attempts to verify some data using a provided key and a signature.\n     * @param dnskey The dns key record to verify the signature with.\n     * @param rrset The signed RRSET being verified.\n     * @param data The original data `rrset` was decoded from.\n     * @return True iff the key verifies the signature.\n     */\n    function verifySignatureWithKey(\n        RRUtils.DNSKEY memory dnskey,\n        bytes memory keyrdata,\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data\n    ) internal view returns (bool) {\n        // TODO: Check key isn't expired, unless updating key itself\n\n        // The Protocol Field MUST have value 3 (RFC4034 2.1.2)\n        if (dnskey.protocol != 3) {\n            return false;\n        }\n\n        // o The RRSIG RR's Signer's Name, Algorithm, and Key Tag fields MUST\n        //   match the owner name, algorithm, and key tag for some DNSKEY RR in\n        //   the zone's apex DNSKEY RRset.\n        if (dnskey.algorithm != rrset.algorithm) {\n            return false;\n        }\n        uint16 computedkeytag = keyrdata.computeKeytag();\n        if (computedkeytag != rrset.keytag) {\n            return false;\n        }\n\n        // o The matching DNSKEY RR MUST be present in the zone's apex DNSKEY\n        //   RRset, and MUST have the Zone Flag bit (DNSKEY RDATA Flag bit 7)\n        //   set.\n        if (dnskey.flags & DNSKEY_FLAG_ZONEKEY == 0) {\n            return false;\n        }\n\n        Algorithm algorithm = algorithms[dnskey.algorithm];\n        if (address(algorithm) == address(0)) {\n            return false;\n        }\n        return algorithm.verify(keyrdata, data.rrset, data.sig);\n    }\n\n    /**\n     * @dev Attempts to verify a signed RRSET against an already known hash. This function assumes\n     *      that the record\n     * @param rrset The signed set to verify.\n     * @param data The original data the signed set was read from.\n     * @param proof The serialized DS or DNSKEY record to use as proof.\n     */\n    function verifyWithDS(\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        RRUtils.RRIterator memory proof\n    ) internal view {\n        uint256 proofOffset = proof.offset;\n        for (\n            RRUtils.RRIterator memory iter = rrset.rrs();\n            !iter.done();\n            iter.next()\n        ) {\n            if (iter.dnstype != DNSTYPE_DNSKEY) {\n                revert InvalidProofType(iter.dnstype);\n            }\n\n            bytes memory keyrdata = iter.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n                0,\n                keyrdata.length\n            );\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                // It's self-signed - look for a DS record to verify it.\n                if (\n                    verifyKeyWithDS(rrset.signerName, proof, dnskey, keyrdata)\n                ) {\n                    return;\n                }\n                // Rewind proof iterator to the start for the next loop iteration.\n                proof.nextOffset = proofOffset;\n                proof.next();\n            }\n        }\n        revert NoMatchingProof(rrset.signerName);\n    }\n\n    /**\n     * @dev Attempts to verify a key using DS records.\n     * @param keyname The DNS name of the key, in DNS label-sequence format.\n     * @param dsrrs The DS records to use in verification.\n     * @param dnskey The dnskey to verify.\n     * @param keyrdata The RDATA section of the key.\n     * @return True if a DS record verifies this key.\n     */\n    function verifyKeyWithDS(\n        bytes memory keyname,\n        RRUtils.RRIterator memory dsrrs,\n        RRUtils.DNSKEY memory dnskey,\n        bytes memory keyrdata\n    ) internal view returns (bool) {\n        uint16 keytag = keyrdata.computeKeytag();\n        for (; !dsrrs.done(); dsrrs.next()) {\n            bytes memory proofName = dsrrs.name();\n            if (!proofName.equals(keyname)) {\n                revert ProofNameMismatch(keyname, proofName);\n            }\n\n            RRUtils.DS memory ds = dsrrs.data.readDS(\n                dsrrs.rdataOffset,\n                dsrrs.nextOffset - dsrrs.rdataOffset\n            );\n            if (ds.keytag != keytag) {\n                continue;\n            }\n            if (ds.algorithm != dnskey.algorithm) {\n                continue;\n            }\n\n            Buffer.buffer memory buf;\n            buf.init(keyname.length + keyrdata.length);\n            buf.append(keyname);\n            buf.append(keyrdata);\n            if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Attempts to verify a DS record's hash value against some data.\n     * @param digesttype The digest ID from the DS record.\n     * @param data The data to digest.\n     * @param digest The digest data to check against.\n     * @return True iff the digest matches.\n     */\n    function verifyDSHash(\n        uint8 digesttype,\n        bytes memory data,\n        bytes memory digest\n    ) internal view returns (bool) {\n        if (address(digests[digesttype]) == address(0)) {\n            return false;\n        }\n        return digests[digesttype].verify(data, digest);\n    }\n}"
    }
  ]
}