{
  "Title": "[M-03] Token:mint: infinite loop if the foundersâ€™ shares sum up to 100",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L179\n\n\n# Vulnerability details\n\n## Impact\n\nThe Token as well as Auction cannot be used if the sum of `ownershipPct` is 100\n\n## Proof of Concept\n\n```solidity\n    function test_poc_mintforever() public {\n        createUsers(2, 1 ether);\n\n        address[] memory wallets = new address[](2);\n        uint256[] memory percents = new uint256[](2);\n        uint256[] memory vestExpirys = new uint256[](2);\n\n        uint256 pct = 50;\n        uint256 end = 4 weeks;\n\n        unchecked {\n            for (uint256 i; i < 2; ++i) {\n                wallets[i] = otherUsers[i];\n                percents[i] = pct;\n                vestExpirys[i] = end;\n            }\n        }\n\n        deployWithCustomFounders(wallets, percents, vestExpirys);\n\n        assertEq(token.totalFounders(), 2);\n        assertEq(token.totalFounderOwnership(), 100);\n\n        Founder memory founder;\n\n        unchecked {\n            for (uint256 i; i < 100; ++i) {\n                founder = token.getScheduledRecipient(i);\n\n                if (i % 2 == 0) assertEq(founder.wallet, otherUsers[0]);\n                else assertEq(founder.wallet, otherUsers[1]);\n            }\n        }\n\n// // commented out as it will not stop\n//         vm.prank(otherUsers[0]);\n//         auction.unpause();\n\n    }\n```\n\nIn the proof of concept, there are two founders and they both share 50% of ownership. If the `Auction` should be `unpause`d, and therefore triggers to mint tokens, it will go into the infinite loop and eventually revert for out of gas.\n\n```solidity\n// Token.sol\n\n143     function mint() external nonReentrant returns (uint256 tokenId) {\n144         // Cache the auction address\n145         address minter = settings.auction;\n146\n147         // Ensure the caller is the auction\n148         if (msg.sender != minter) revert ONLY_AUCTION();\n149\n150         // Cannot realistically overflow\n151         unchecked {\n152             do {\n153                 // Get the next token to mint\n154                 tokenId = settings.totalSupply++;\n155\n156                 // Lookup whether the token is for a founder, and mint accordingly if so\n157             } while (_isForFounder(tokenId));\n158         }\n159\n160         // Mint the next available token to the auction house for bidding\n161         _mint(minter, tokenId);\n162     }\n\n177     function _isForFounder(uint256 _tokenId) private returns (bool) {\n178         // Get the base token id\n179         uint256 baseTokenId = _tokenId % 100;\n180\n181         // If there is no scheduled recipient:\n182         if (tokenRecipient[baseTokenId].wallet == address(0)) {\n183             return false;\n184\n185             // Else if the founder is still vesting:\n186         } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) {\n187             // Mint the token to the founder\n188             _mint(tokenRecipient[baseTokenId].wallet, _tokenId);\n189\n190             return true;\n191\n192             // Else the founder has finished vesting:\n193         } else {\n194             // Remove them from future lookups\n195             delete tokenRecipient[baseTokenId];\n196\n197             return false;\n198         }\n199     }\n```\n\nIn the `Token::mint`, there is a while loop which will keep looping as long as `_isForFounder` returns true. The `_isForFounder` function will return true is the given `_tokenId`'s recipient is still vesting. However, to check the recipient it is checking the `baseTokenId` which is `_tokenId % 100` (in line 179 above snippet). Which means, if the `tokenRecipient` of 0 to 99 are currently vesting, it will keep returning true and the while loop in the `mint` function will not stop. The `tokenRecipient` was set in the `_addFounders` and if the sum of all founders' ownership percent is 100, the `tokenRecipient` will be filled up to 100.\n\n\n## Tools Used\n\nNone\n\n## Recommended Mitigation Steps\n\nuse `_tokenId` instead of `baseTokenId`.\n\n<!-- zzzitron H01 -->\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-nouns-builder-contest",
  "Code": [
    {
      "filename": "src/token/Token.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { ERC721Votes } from \"../lib/token/ERC721Votes.sol\";\nimport { ERC721 } from \"../lib/token/ERC721.sol\";\n\nimport { TokenStorageV1 } from \"./storage/TokenStorageV1.sol\";\nimport { IBaseMetadata } from \"./metadata/interfaces/IBaseMetadata.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IToken } from \"./IToken.sol\";\n\n/// @title Token\n/// @author Rohan Kulkarni\n/// @notice A DAO's ERC-721 governance token\ncontract Token is IToken, UUPS, ReentrancyGuard, ERC721Votes, TokenStorageV1 {\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's ERC-721 token contract\n    /// @param _founders The DAO founders\n    /// @param _initStrings The encoded token and metadata initialization strings\n    /// @param _metadataRenderer The token's metadata renderer\n    /// @param _auction The token's auction house\n    function initialize(\n        IManager.FounderParams[] calldata _founders,\n        bytes calldata _initStrings,\n        address _metadataRenderer,\n        address _auction\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Store the founders and compute their allocations\n        _addFounders(_founders);\n\n        // Decode the token name and symbol\n        (string memory _name, string memory _symbol, , , ) = abi.decode(_initStrings, (string, string, string, string, string));\n\n        // Initialize the ERC-721 token\n        __ERC721_init(_name, _symbol);\n\n        // Store the metadata renderer and auction house\n        settings.metadataRenderer = IBaseMetadata(_metadataRenderer);\n        settings.auction = _auction;\n    }\n\n    /// @dev Called upon initialization to add founders and compute their vesting allocations\n    /// @param _founders The list of DAO founders\n    function _addFounders(IManager.FounderParams[] calldata _founders) internal {\n        // Cache the number of founders\n        uint256 numFounders = _founders.length;\n\n        // Used to store the total percent ownership among the founders\n        uint256 totalOwnership;\n\n        unchecked {\n            // For each founder:\n            for (uint256 i; i < numFounders; ++i) {\n                // Cache the percent ownership\n                uint256 founderPct = _founders[i].ownershipPct;\n\n                // Continue if no ownership is specified\n                if (founderPct == 0) continue;\n\n                // Update the total ownership and ensure it's valid\n                if ((totalOwnership += uint8(founderPct)) > 100) revert INVALID_FOUNDER_OWNERSHIP();\n\n                // Compute the founder's id\n                uint256 founderId = settings.numFounders++;\n\n                // Get the pointer to store the founder\n                Founder storage newFounder = founder[founderId];\n\n                // Store the founder's vesting details\n                newFounder.wallet = _founders[i].wallet;\n                newFounder.vestExpiry = uint32(_founders[i].vestExpiry);\n                newFounder.ownershipPct = uint8(founderPct);\n\n                // Compute the vesting schedule\n                uint256 schedule = 100 / founderPct;\n\n                // Used to store the base token id the founder will recieve\n                uint256 baseTokenId;\n\n                // For each token to vest:\n                for (uint256 j; j < founderPct; ++j) {\n                    // Get the available token id\n                    baseTokenId = _getNextTokenId(baseTokenId);\n\n                    // Store the founder as the recipient\n                    tokenRecipient[baseTokenId] = newFounder;\n\n                    emit MintScheduled(baseTokenId, founderId, newFounder);\n\n                    // Update the base token id\n                    (baseTokenId += schedule) % 100;\n                }\n            }\n\n            // Store the founders' details\n            settings.totalOwnership = uint8(totalOwnership);\n            settings.numFounders = uint8(numFounders);\n        }\n    }\n\n    /// @dev Finds the next available base token id for a founder\n    /// @param _tokenId The ERC-721 token id\n    function _getNextTokenId(uint256 _tokenId) internal view returns (uint256) {\n        unchecked {\n            while (tokenRecipient[_tokenId].wallet != address(0)) ++_tokenId;\n\n            return _tokenId;\n        }\n    }\n\n    ///                                                          ///\n    ///                             MINT                         ///\n    ///                                                          ///\n\n    /// @notice Mints tokens to the auction house for bidding and handles founder vesting\n    function mint() external nonReentrant returns (uint256 tokenId) {\n        // Cache the auction address\n        address minter = settings.auction;\n\n        // Ensure the caller is the auction\n        if (msg.sender != minter) revert ONLY_AUCTION();\n\n        // Cannot realistically overflow\n        unchecked {\n            do {\n                // Get the next token to mint\n                tokenId = settings.totalSupply++;\n\n                // Lookup whether the token is for a founder, and mint accordingly if so\n            } while (_isForFounder(tokenId));\n        }\n\n        // Mint the next available token to the auction house for bidding\n        _mint(minter, tokenId);\n    }\n\n    /// @dev Overrides _mint to include attribute generation\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _mint(address _to, uint256 _tokenId) internal override {\n        // Mint the token\n        super._mint(_to, _tokenId);\n\n        // Generate the token attributes\n        if (!settings.metadataRenderer.onMinted(_tokenId)) revert NO_METADATA_GENERATED();\n    }\n\n    /// @dev Checks if a given token is for a founder and mints accordingly\n    /// @param _tokenId The ERC-721 token id\n    function _isForFounder(uint256 _tokenId) private returns (bool) {\n        // Get the base token id\n        uint256 baseTokenId = _tokenId % 100;\n\n        // If there is no scheduled recipient:\n        if (tokenRecipient[baseTokenId].wallet == address(0)) {\n            return false;\n\n            // Else if the founder is still vesting:\n        } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) {\n            // Mint the token to the founder\n            _mint(tokenRecipient[baseTokenId].wallet, _tokenId);\n\n            return true;\n\n            // Else the founder has finished vesting:\n        } else {\n            // Remove them from future lookups\n            delete tokenRecipient[baseTokenId];\n\n            return false;\n        }\n    }\n\n    ///                                                          ///\n    ///                             BURN                         ///\n    ///                                                          ///\n\n    /// @notice Burns a token that did not see any bids\n    /// @param _tokenId The ERC-721 token id\n    function burn(uint256 _tokenId) external {\n        // Ensure the caller is the auction house\n        if (msg.sender != settings.auction) revert ONLY_AUCTION();\n\n        // Burn the token\n        _burn(_tokenId);\n    }\n\n    ///                                                          ///\n    ///                           METADATA                       ///\n    ///                                                          ///\n\n    /// @notice The URI for a token\n    /// @param _tokenId The ERC-721 token id\n    function tokenURI(uint256 _tokenId) public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.tokenURI(_tokenId);\n    }\n\n    /// @notice The URI for the contract\n    function contractURI() public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.contractURI();\n    }\n\n    ///                                                          ///\n    ///                           FOUNDERS                       ///\n    ///                                                          ///\n\n    /// @notice The number of founders\n    function totalFounders() external view returns (uint256) {\n        return settings.numFounders;\n    }\n\n    /// @notice The founders total percent ownership\n    function totalFounderOwnership() external view returns (uint256) {\n        return settings.totalOwnership;\n    }\n\n    /// @notice The vesting details of a founder\n    /// @param _founderId The founder id\n    function getFounder(uint256 _founderId) external view returns (Founder memory) {\n        return founder[_founderId];\n    }\n\n    /// @notice The vesting details of all founders\n    function getFounders() external view returns (Founder[] memory) {\n        // Cache the number of founders\n        uint256 numFounders = settings.numFounders;\n\n        // Get a temporary array to hold all founders\n        Founder[] memory founders = new Founder[](numFounders);\n\n        // Cannot realistically overflow\n        unchecked {\n            // Add each founder to the array\n            for (uint256 i; i < numFounders; ++i) founders[i] = founder[i];\n        }\n\n        return founders;\n    }\n\n    /// @notice The founder scheduled to receive the given token id\n    /// NOTE: If a founder is returned, there's no guarantee they'll receive the token as vesting expiration is not considered\n    /// @param _tokenId The ERC-721 token id\n    function getScheduledRecipient(uint256 _tokenId) external view returns (Founder memory) {\n        return tokenRecipient[_tokenId % 100];\n    }\n\n    ///                                                          ///\n    ///                           SETTINGS                       ///\n    ///                                                          ///\n\n    /// @notice The total supply of tokens\n    function totalSupply() external view returns (uint256) {\n        return settings.totalSupply;\n    }\n\n    /// @notice The address of the auction house\n    function auction() external view returns (address) {\n        return settings.auction;\n    }\n\n    /// @notice The address of the metadata renderer\n    function metadataRenderer() external view returns (address) {\n        return address(settings.metadataRenderer);\n    }\n\n    /// @notice The address of the owner\n    function owner() public view returns (address) {\n        return settings.metadataRenderer.owner();\n    }\n\n    ///                                                          ///\n    ///                         TOKEN UPGRADE                    ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override {\n        // Ensure the caller is the shared owner of the token and metadata renderer\n        if (msg.sender != owner()) revert ONLY_OWNER();\n\n        // Ensure the implementation is valid\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    }
  ]
}