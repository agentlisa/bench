{
  "Title": "[Nâ€‘06] Redundant cast",
  "Content": "\nThe type of the variable is the same as the type to which the variable is being cast.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/registry/ReverseRegistrar.sol\n\n/// @audit address(resolver)\n53:               address(resolver) != address(0),\n\n```\n\n<https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/registry/ReverseRegistrar.sol#L53>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-07-ens",
  "Code": [
    {
      "filename": "contracts/registry/ReverseRegistrar.sol",
      "content": "pragma solidity >=0.8.4;\n\nimport \"./ENS.sol\";\nimport \"./IReverseRegistrar.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../root/Controllable.sol\";\n\nabstract contract NameResolver {\n    function setName(bytes32 node, string memory name) public virtual;\n}\n\nbytes32 constant lookup = 0x3031323334353637383961626364656600000000000000000000000000000000;\n\nbytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n// namehash('addr.reverse')\n\ncontract ReverseRegistrar is Ownable, Controllable, IReverseRegistrar {\n    ENS public immutable ens;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     */\n    constructor(ENS ensAddr) {\n        ens = ensAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ensAddr.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n                controllers[msg.sender] ||\n                ens.isApprovedForAll(addr, msg.sender) ||\n                ownsContract(addr),\n            \"ReverseRegistrar: Caller is not a controller or authorised by address or the address itself\"\n        );\n        _;\n    }\n\n    function setDefaultResolver(address resolver) public override onlyOwner {\n        require(\n            address(resolver) != address(0),\n            \"ReverseRegistrar: Resolver address must not be 0\"\n        );\n        defaultResolver = NameResolver(resolver);\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, address(defaultResolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, labelHash)\n        );\n        emit ReverseClaimed(addr, reverseNode);\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);\n        return reverseNode;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(address owner, address resolver)\n        public\n        override\n        returns (bytes32)\n    {\n        return claimForAddr(msg.sender, owner, resolver);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public override returns (bytes32) {\n        return\n            setNameForAddr(\n                msg.sender,\n                msg.sender,\n                address(defaultResolver),\n                name\n            );\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the account provided. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * Only callable by controllers and authorised users\n     * @param addr The reverse record to set\n     * @param owner The owner of the reverse node\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) public override returns (bytes32) {\n        bytes32 node = claimForAddr(addr, owner, resolver);\n        NameResolver(resolver).setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account's reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public pure override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}"
    }
  ]
}