{
  "Title": "[L08] Mechanism to change child messengers",
  "Content": "The [`GovernorSpoke`](https://github.com/UMAprotocol/protocol/blob/0c14d8fa6634da8e4fedd9a4e3caba591d2fca07/packages/core/contracts/cross-chain-oracle/GovernorSpoke.sol#L19) and [`OracleSpoke`](https://github.com/UMAprotocol/protocol/blob/0c14d8fa6634da8e4fedd9a4e3caba591d2fca07/packages/core/contracts/cross-chain-oracle/OracleSpoke.sol#L35) contract each initialize the child messenger in the constructor, with no mechanism to update it. This means that when the [child messenger is changed](https://github.com/UMAprotocol/protocol/blob/0c14d8fa6634da8e4fedd9a4e3caba591d2fca07/packages/core/contracts/cross-chain-oracle/chain-adapters/ParentMessengerBase.sol#L46), both spoke contracts become obsolete.\n\n\nSince the spoke contract are likely more stable than the messengers, consider including a mechanism to update the messenger on the spokes.\n\n\n**Update:** *Fixed as of commit [`7c9e061`](https://github.com/UMAprotocol/protocol/pull/3688/commits/7c9e06175802f9f6b1c66eb321b6fc583343fd11) in [PR3688](https://github.com/UMAprotocol/protocol/pull/3688).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/cross-chain-oracle/GovernorSpoke.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./interfaces/ChildMessengerConsumerInterface.sol\";\nimport \"../common/implementation/Lockable.sol\";\n\n/**\n * @title Cross-chain Oracle L2 Governor Spoke.\n * @notice Governor contract deployed on L2 that receives governance actions from Ethereum.\n */\ncontract GovernorSpoke is Lockable, ChildMessengerConsumerInterface {\n    // Messenger contract that receives messages from root chain.\n    ChildMessengerConsumerInterface public messenger;\n\n    event ExecutedGovernanceTransaction(address indexed to, bytes data);\n    event SetChildMessenger(address indexed childMessenger);\n\n    constructor(ChildMessengerConsumerInterface _messengerAddress) {\n        messenger = _messengerAddress;\n        emit SetChildMessenger(address(messenger));\n    }\n\n    modifier onlyMessenger() {\n        require(msg.sender == address(messenger), \"Caller must be messenger\");\n        _;\n    }\n\n    /**\n     * @notice Executes governance transaction created on Ethereum.\n     * @dev Can only called by ChildMessenger contract that wants to execute governance action on this child chain that\n     * originated from DVM voters on root chain. ChildMessenger should only receive communication from ParentMessenger\n     * on mainnet.\n\n     * @param data Contains the target address and the encoded function selector + ABI encoded params to include in\n     * delegated transaction.\n     */\n    function processMessageFromParent(bytes memory data) public override nonReentrant() onlyMessenger() {\n        (address to, bytes memory inputData) = abi.decode(data, (address, bytes));\n        // TODO: Consider calling this via <address>.call(): https://docs.soliditylang.org/en/v0.8.10/units-and-global-variables.html?highlight=low%20level%20call#members-of-address-types\n        // to avoid inline assembly.\n\n        require(_executeCall(to, inputData), \"execute call failed\");\n        emit ExecutedGovernanceTransaction(to, inputData);\n    }\n\n    // Note: this snippet of code is copied from Governor.sol.\n    function _executeCall(address to, bytes memory data) private returns (bool) {\n        // Note: this snippet of code is copied from Governor.sol.\n        // solhint-disable-next-line max-line-length\n        // https://github.com/gnosis/safe-contracts/blob/59cfdaebcd8b87a0a32f87b50fead092c10d3a05/contracts/base/Executor.sol#L23-L31\n        // solhint-disable-next-line no-inline-assembly\n\n        bool success;\n        assembly {\n            let inputData := add(data, 0x20)\n            let inputDataSize := mload(data)\n            // Hardcode value to be 0 for relayed governance calls in order to avoid addressing complexity of bridging\n            // value cross-chain.\n            success := call(gas(), to, 0, inputData, inputDataSize, 0, 0)\n        }\n        return success;\n    }\n}"
    }
  ]
}