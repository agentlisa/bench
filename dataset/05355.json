{
  "Title": "[M-09] If wLP is blacklisted, then user will not be able to withdraw it",
  "Content": "\nWhen users deposit wLP tokens as collateral, then they are checked [to be whitelisted](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L255).\n\nLater, it's possible that for some reason wLP token [will be blacklisted](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/Config.sol#L145) by governor. And once it's done, then users who already used that wLP token as collateral [will not be able to withdraw them](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L275).\n\nAlso same thing exists for the `liquidateWLp` function, which means that in case if position, that is collateralized with wLP that is blacklisted, will become unhealthy, then liquidators [will not be able to liquidate it](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L327).\n\nSponsor said that blacklisting flow will be as following.\n\n*   Decrease collateral factor for blacklisted wLp until it becomes 0\n*   then blacklist wLp\n\nConsidering this fact I realize that for liquidation this will not be an issue as wLp will have 0 collateralization power when it will be blacklisted. However it's still possible that some users will not decollateralize their wLp tokens yet for some reasom and thus they will not be able to withdraw them later.\n\n### Impact\n\nUser can't withdraw previously deposited wLP tokens after they were blacklisted.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nEven if wLP token is blacklisted now, you still should allow user to withdraw them. After all you have health check function that will guarantee that position has enough collateral.\n\n**[fez-init (INIT) acknowledged and commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/13#issuecomment-1870294773):**\n > We will use unwhitelisting with care.\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-initcapital",
  "Code": [
    {
      "filename": "contracts/core/InitCore.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport {Multicall} from '../common/Multicall.sol';\nimport '../common/library/InitErrors.sol';\nimport '../common/library/UncheckedIncrement.sol';\nimport {UnderACM} from '../common/UnderACM.sol';\n\nimport {IInitCore} from '../interfaces/core/IInitCore.sol';\nimport {IPosManager} from '../interfaces/core/IPosManager.sol';\nimport {ModeConfig, PoolConfig, TokenFactors, ModeStatus, IConfig} from '../interfaces/core/IConfig.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IBaseWrapLp} from '../interfaces/wrapper/IBaseWrapLp.sol';\nimport {IInitOracle} from '../interfaces/oracle/IInitOracle.sol';\nimport {ILiqIncentiveCalculator} from '../interfaces/core/ILiqIncentiveCalculator.sol';\nimport {ICallbackReceiver} from '../interfaces/receiver/ICallbackReceiver.sol';\nimport {IFlashReceiver} from '../interfaces/receiver/IFlashReceiver.sol';\nimport {IRiskManager} from '../interfaces/risk_manager/IRiskManager.sol';\n\nimport {ReentrancyGuardUpgradeable} from '@openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport {SafeCast} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {MathUpgradeable} from '@openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol';\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {IERC721} from '@openzeppelin-contracts/token/ERC721/IERC721.sol';\nimport {EnumerableSet} from '@openzeppelin-contracts/utils/structs/EnumerableSet.sol';\n\ncontract InitCore is IInitCore, Multicall, ReentrancyGuardUpgradeable, UnderACM {\n    using SafeCast for uint;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using MathUpgradeable for uint;\n    using UncheckedIncrement for uint;\n\n    // constants\n    uint private constant ONE_E18 = 1e18;\n    bytes32 private constant GUARDIAN = keccak256('guardian');\n    bytes32 private constant GOVERNOR = keccak256('governor');\n\n    // immutables\n    address public immutable POS_MANAGER;\n\n    // storages\n    address public config; // @inheritdoc IInitCore\n    address public oracle; // @inheritdoc IInitCore\n    address public liqIncentiveCalculator; // @inheritdoc IInitCore\n    address public riskManager; // @inheritdoc IInitCore\n    bool internal isMulticallTx;\n    EnumerableSet.UintSet internal uncheckedPosIds; // posIds that need to be checked after multicall\n\n    // modifiers\n    modifier onlyGuardian() {\n        ACM.checkRole(GUARDIAN, msg.sender);\n        _;\n    }\n\n    modifier onlyGovernor() {\n        ACM.checkRole(GOVERNOR, msg.sender);\n        _;\n    }\n\n    modifier onlyAuthorized(uint _posId) {\n        _require(IPosManager(POS_MANAGER).isAuthorized(msg.sender, _posId), Errors.NOT_AUTHORIZED);\n        _;\n    }\n\n    /// @dev keep track of the position and ensure that the position is healthy at the very end\n    /// @param _posId pos id to ensure health\n    modifier ensurePositionHealth(uint _posId) {\n        if (isMulticallTx) uncheckedPosIds.add(_posId);\n        _;\n        if (!isMulticallTx) _require(_isPosHealthy(_posId), Errors.POSITION_NOT_HEALTHY);\n    }\n\n    // constructor\n    constructor(address _posManager, address _accessControlManager) UnderACM(_accessControlManager) {\n        POS_MANAGER = _posManager;\n        _disableInitializers();\n    }\n\n    // initalize\n    /// @dev initialize contract and setup config, oracle, incentive calculator and risk manager addresses\n    /// @param _config config address\n    /// @param _oracle oracle address\n    /// @param _liqIncentiveCalculator liquidation incentive calculator address\n    /// @param _riskManager risk manager address\n    function initialize(address _config, address _oracle, address _liqIncentiveCalculator, address _riskManager)\n        external\n        initializer\n    {\n        __ReentrancyGuard_init();\n        _setConfig(_config);\n        _setOracle(_oracle);\n        _setLiqIncentiveCalculator(_liqIncentiveCalculator);\n        _setRiskManager(_riskManager);\n    }\n\n    // functions\n    /// @inheritdoc IInitCore\n    function mintTo(address _pool, address _to) public virtual nonReentrant returns (uint shares) {\n        // check pool status\n        PoolConfig memory poolConfig = IConfig(config).getPoolConfig(_pool);\n        _require(poolConfig.canMint, Errors.MINT_PAUSED);\n        // call mint at pool using _to\n        shares = ILendingPool(_pool).mint(_to);\n        // check supply cap after mint\n        _require(ILendingPool(_pool).totalAssets() <= poolConfig.supplyCap, Errors.SUPPLY_CAP_REACHED);\n    }\n\n    /// @inheritdoc IInitCore\n    function burnTo(address _pool, address _to) public virtual nonReentrant returns (uint amt) {\n        // check pool status\n        PoolConfig memory poolConfig = IConfig(config).getPoolConfig(_pool);\n        _require(poolConfig.canBurn, Errors.REDEEM_PAUSED);\n        // call burn at pool using _to\n        amt = ILendingPool(_pool).burn(_to);\n    }\n\n    /// @inheritdoc IInitCore\n    function borrow(address _pool, uint _amt, uint _posId, address _to)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n        returns (uint shares)\n    {\n        IConfig _config = IConfig(config);\n        // check pool and mode status\n        PoolConfig memory poolConfig = _config.getPoolConfig(_pool);\n        uint16 mode = _getPosMode(_posId);\n        _require(poolConfig.canBorrow && _config.getModeStatus(mode).canBorrow, Errors.BORROW_PAUSED);\n        // check if the position mode supports _pool\n        _require(_config.isAllowedForBorrow(mode, _pool), Errors.INVALID_MODE);\n        // get borrow shares (accrue interest)\n        shares = ILendingPool(_pool).debtAmtToShareCurrent(_amt);\n        // check shares != 0\n        _require(shares != 0, Errors.ZERO_VALUE);\n        // check borrow cap after borrow\n        _require(ILendingPool(_pool).totalDebt() + _amt <= poolConfig.borrowCap, Errors.BORROW_CAP_REACHED);\n        // update debt on the position\n        IPosManager(POS_MANAGER).updatePosDebtShares(_posId, _pool, shares.toInt256());\n        // call borrow from the pool with target _to\n        ILendingPool(_pool).borrow(_to, _amt);\n        // update debt on mode\n        IRiskManager(riskManager).updateModeDebtShares(mode, _pool, shares.toInt256());\n        emit Borrow(_pool, _posId, _to, _amt, shares);\n    }\n\n    /// @inheritdoc IInitCore\n    function repay(address _pool, uint _shares, uint _posId)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        nonReentrant\n        returns (uint amt)\n    {\n        (, amt) = _repay(IConfig(config), _getPosMode(_posId), _posId, _pool, _shares);\n    }\n\n    /// @inheritdoc IInitCore\n    function createPos(uint16 _mode, address _viewer) public virtual nonReentrant returns (uint posId) {\n        _require(_mode != 0, Errors.INVALID_MODE);\n        posId = IPosManager(POS_MANAGER).createPos(msg.sender, _mode, _viewer);\n        emit CreatePosition(msg.sender, posId, _mode, _viewer);\n    }\n\n    /// @inheritdoc IInitCore\n    function setPosMode(uint _posId, uint16 _mode)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        // get current collaterals in the position\n        (address[] memory pools,, address[] memory wLps, uint[][] memory ids,) =\n            IPosManager(POS_MANAGER).getPosCollInfo(_posId);\n        uint16 currentMode = _getPosMode(_posId);\n        ModeStatus memory currentModeStatus = _config.getModeStatus(currentMode);\n        ModeStatus memory newModeStatus = _config.getModeStatus(_mode);\n        if (pools.length != 0 || wLps.length != 0) {\n            _require(newModeStatus.canCollateralize, Errors.COLLATERALIZE_PAUSED);\n            _require(currentModeStatus.canDecollateralize, Errors.DECOLLATERALIZE_PAUSED);\n        }\n        // check that each position collateral belongs to the _mode\n        for (uint i; i < pools.length; i = i.uinc()) {\n            _require(_config.isAllowedForCollateral(_mode, pools[i]), Errors.INVALID_MODE);\n        }\n        for (uint i; i < wLps.length; i = i.uinc()) {\n            for (uint j; j < ids[i].length; j = j.uinc()) {\n                _require(_config.isAllowedForCollateral(_mode, IBaseWrapLp(wLps[i]).lp(ids[i][j])), Errors.INVALID_MODE);\n            }\n        }\n        // get current debts in the position\n        uint[] memory shares;\n        (pools, shares) = IPosManager(POS_MANAGER).getPosBorrInfo(_posId);\n        IRiskManager _riskManager = IRiskManager(riskManager);\n        // check that each position debt belongs to the _mode\n        for (uint i; i < pools.length; i = i.uinc()) {\n            _require(_config.isAllowedForBorrow(_mode, pools[i]), Errors.INVALID_MODE);\n            _require(newModeStatus.canBorrow, Errors.BORROW_PAUSED);\n            _require(currentModeStatus.canRepay, Errors.REPAY_PAUSED);\n            // update debt on current mode\n            _riskManager.updateModeDebtShares(currentMode, pools[i], -shares[i].toInt256());\n            // update debt on new mode\n            _riskManager.updateModeDebtShares(_mode, pools[i], shares[i].toInt256());\n        }\n        // update position mode\n        IPosManager(POS_MANAGER).updatePosMode(_posId, _mode);\n        emit SetPositionMode(_posId, _mode);\n    }\n\n    /// @inheritdoc IInitCore\n    function collateralize(uint _posId, address _pool) public virtual onlyAuthorized(_posId) nonReentrant {\n        IConfig _config = IConfig(config);\n        // check mode status\n        uint16 mode = _getPosMode(_posId);\n        _require(_config.getModeStatus(mode).canCollateralize, Errors.COLLATERALIZE_PAUSED);\n        // check if the position mode supports _pool\n        _require(_config.isAllowedForCollateral(mode, _pool), Errors.INVALID_MODE);\n        // update collateral on the position\n        uint amtColl = IPosManager(POS_MANAGER).addCollateral(_posId, _pool);\n        emit Collateralize(_posId, _pool, amtColl);\n    }\n\n    /// @inheritdoc IInitCore\n    function decollateralize(uint _posId, address _pool, uint _shares, address _to)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n    {\n        // check mode status\n        _require(IConfig(config).getModeStatus(_getPosMode(_posId)).canDecollateralize, Errors.DECOLLATERALIZE_PAUSED);\n        // take _pool from position to _to\n        uint amtDecoll = IPosManager(POS_MANAGER).removeCollateralTo(_posId, _pool, _shares, _to);\n        emit Decollateralize(_posId, _pool, _to, amtDecoll);\n    }\n\n    /// @inheritdoc IInitCore\n    function collateralizeWLp(uint _posId, address _wLp, uint _tokenId)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        uint16 mode = _getPosMode(_posId);\n        // check mode status\n        _require(_config.getModeStatus(mode).canCollateralize, Errors.COLLATERALIZE_PAUSED);\n        // check if the wLp is whitelisted\n        _require(_config.whitelistedWLps(_wLp), Errors.TOKEN_NOT_WHITELISTED);\n        // check if the position mode supports _wLp\n        _require(_config.isAllowedForCollateral(mode, IBaseWrapLp(_wLp).lp(_tokenId)), Errors.INVALID_MODE);\n        // update collateral on the position\n        uint amtColl = IPosManager(POS_MANAGER).addCollateralWLp(_posId, _wLp, _tokenId);\n        emit CollateralizeWLp(_wLp, _tokenId, _posId, amtColl);\n    }\n\n    /// @inheritdoc IInitCore\n    function decollateralizeWLp(uint _posId, address _wLp, uint _tokenId, uint _amt, address _to)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        // check mode status\n        _require(_config.getModeStatus(_getPosMode(_posId)).canDecollateralize, Errors.DECOLLATERALIZE_PAUSED);\n        // check wLp is whitelisted\n        _require(_config.whitelistedWLps(_wLp), Errors.TOKEN_NOT_WHITELISTED);\n        // update and take _wLp from position to _to\n        uint amtDecoll = IPosManager(POS_MANAGER).removeCollateralWLpTo(_posId, _wLp, _tokenId, _amt, _to);\n        emit Decollateralize(_wLp, _posId, _to, amtDecoll);\n    }\n\n    /// @inheritdoc IInitCore\n    function liquidate(uint _posId, address _poolToRepay, uint _repayShares, address _poolOut, uint _minShares)\n        public\n        virtual\n        nonReentrant\n        returns (uint shares)\n    {\n        LiquidateLocalVars memory vars = _liquidateInternal(_posId, _poolToRepay, _repayShares);\n\n        _require(vars.config.isAllowedForCollateral(vars.mode, _poolOut), Errors.TOKEN_NOT_WHITELISTED); // config and mode are already stored\n\n        vars.collToken = ILendingPool(_poolOut).underlyingToken();\n        vars.liqIncentive_e18 = ILiqIncentiveCalculator(liqIncentiveCalculator).getLiqIncentiveMultiplier_e18(\n            vars.mode, vars.health_e18, vars.repayToken, vars.collToken\n        );\n        vars.repayAmtWithLiqIncentive = (vars.repayAmt * vars.liqIncentive_e18) / ONE_E18;\n        {\n            uint[] memory prices_e36; // prices = [repayTokenPrice, collToken]\n            address[] memory tokens = new address[](2);\n            (tokens[0], tokens[1]) = (vars.repayToken, vars.collToken);\n            prices_e36 = IInitOracle(oracle).getPrices_e36(tokens);\n            // calculate _tokenOut amt to return to liquidator\n            shares = ILendingPool(_poolOut).toShares((vars.repayAmtWithLiqIncentive * prices_e36[0]) / prices_e36[1]);\n            // take min of what's available (for bad debt repayment)\n            shares = shares.min(IPosManager(POS_MANAGER).getCollAmt(_posId, _poolOut)); // take min of what's available\n            _require(shares >= _minShares, Errors.SLIPPAGE_CONTROL);\n        }\n        // take _tokenOut from position to msg.sender\n        IPosManager(POS_MANAGER).removeCollateralTo(_posId, _poolOut, shares, msg.sender);\n        // check that position's health <= maxHealth\n        // NOTE: bypass this for underwater position\n        if (vars.health_e18 != 0) _ensurePosHealthAfterLiq(vars.config, _posId, vars.mode);\n        emit Liquidate(_posId, msg.sender, _poolOut, shares);\n    }\n\n    /// @inheritdoc IInitCore\n    function liquidateWLp(\n        uint _posId,\n        address _poolToRepay,\n        uint _repayShares,\n        address _wLp,\n        uint _tokenId,\n        uint _minlpOut\n    ) external virtual nonReentrant returns (uint lpAmtOut) {\n        LiquidateLocalVars memory vars = _liquidateInternal(_posId, _poolToRepay, _repayShares);\n\n        _require(vars.config.whitelistedWLps(_wLp), Errors.TOKEN_NOT_WHITELISTED); // config is already stored\n\n        vars.collToken = IBaseWrapLp(_wLp).lp(_tokenId);\n\n        vars.liqIncentive_e18 = ILiqIncentiveCalculator(liqIncentiveCalculator).getLiqIncentiveMultiplier_e18(\n            vars.mode, vars.health_e18, vars.repayToken, vars.collToken\n        );\n        vars.repayAmtWithLiqIncentive = (vars.repayAmt * vars.liqIncentive_e18) / ONE_E18;\n\n        uint wLpAmtToBurn;\n        {\n            address _oracle = oracle;\n            uint wLpAmt = IPosManager(POS_MANAGER).getCollWLpAmt(_posId, _wLp, _tokenId);\n            wLpAmtToBurn = IInitOracle(_oracle).getPrice_e36(vars.repayToken).mulDiv(\n                vars.repayAmtWithLiqIncentive, IBaseWrapLp(_wLp).calculatePrice_e36(_tokenId, _oracle)\n            );\n            // take min of what's available (for bad debt repayment)\n            wLpAmtToBurn = wLpAmtToBurn.min(wLpAmt);\n        }\n        // reduce and burn wLp to underlying for liquidator\n        lpAmtOut = IPosManager(POS_MANAGER).removeCollateralWLpTo(_posId, _wLp, _tokenId, wLpAmtToBurn, msg.sender);\n        _require(lpAmtOut >= _minlpOut, Errors.SLIPPAGE_CONTROL);\n        // check that position's health <= maxHealth\n        // NOTE: bypass this for underwater position\n        if (vars.health_e18 != 0) _ensurePosHealthAfterLiq(vars.config, _posId, vars.mode);\n        emit LiquidateWLp(_posId, msg.sender, _wLp, _tokenId, wLpAmtToBurn);\n    }\n\n    /// @inheritdoc IInitCore\n    function flash(address[] calldata _pools, uint[] calldata _amts, bytes calldata _data)\n        public\n        virtual\n        nonReentrant\n    {\n        // validate _pools and _amts length & validate _pools contain distinct addresses to avoid paying less flash fees\n        _require(_validateFlash(_pools, _amts), Errors.INVALID_FLASHLOAN);\n        // check that is not multicall tx\n        _require(!isMulticallTx, Errors.LOCKED_MULTICALL);\n        uint[] memory balanceBefores = new uint[](_pools.length);\n        uint[] memory fees = new uint[](_pools.length);\n        IConfig _config = IConfig(config);\n        for (uint i; i < _pools.length; i = i.uinc()) {\n            PoolConfig memory poolConfig = _config.getPoolConfig(_pools[i]);\n            // check that flash is enabled\n            _require(poolConfig.canFlash, Errors.FLASH_PAUSED);\n            address token = ILendingPool(_pools[i]).underlyingToken();\n            // calculate return amt\n            balanceBefores[i] = IERC20(token).balanceOf(_pools[i]);\n            fees[i] = (_amts[i] * poolConfig.flashFee_e18).ceilDiv(ONE_E18); // round up\n            // take _amts[i] of _pools[i] to msg.sender\n            IERC20(token).safeTransferFrom(_pools[i], msg.sender, _amts[i]);\n        }\n        // execute callback\n        IFlashReceiver(msg.sender).flashCallback(_pools, _amts, fees, _data);\n        // sync cash\n        for (uint i; i < _pools.length; i = i.uinc()) {\n            uint poolCash = ILendingPool(_pools[i]).syncCash();\n            _require(poolCash >= balanceBefores[i] + fees[i], Errors.INVALID_AMOUNT_TO_REPAY);\n        }\n    }\n\n    /// @dev multicall function with health check after all call\n    function multicall(bytes[] calldata data) public payable virtual override returns (bytes[] memory results) {\n        _require(!isMulticallTx, Errors.LOCKED_MULTICALL);\n        isMulticallTx = true;\n        // multicall\n        results = super.multicall(data);\n        // === loop uncheckedPosIds ===\n        uint[] memory posIds = uncheckedPosIds.values();\n        for (uint i; i < posIds.length; i = i.uinc()) {\n            // check position health\n            _require(_isPosHealthy(posIds[i]), Errors.POSITION_NOT_HEALTHY);\n            uncheckedPosIds.remove(posIds[i]);\n        }\n        // clear uncheckedPosIds\n        isMulticallTx = false;\n    }\n\n    /// @inheritdoc IInitCore\n    function setConfig(address _config) external onlyGovernor {\n        _setConfig(_config);\n    }\n\n    /// @inheritdoc IInitCore\n    function setOracle(address _oracle) external onlyGovernor {\n        _setOracle(_oracle);\n    }\n\n    /// @inheritdoc IInitCore\n    function setLiqIncentiveCalculator(address _liqIncentiveCalculator) external onlyGuardian {\n        _setLiqIncentiveCalculator(_liqIncentiveCalculator);\n    }\n\n    /// @inheritdoc IInitCore\n    function setRiskManager(address _riskManager) external onlyGuardian {\n        _setRiskManager(_riskManager);\n    }\n\n    /// @dev set config\n    function _setConfig(address _config) internal {\n        config = _config;\n        emit SetConfig(_config);\n    }\n\n    /// @dev set oracle\n    function _setOracle(address _oracle) internal {\n        oracle = _oracle;\n        emit SetOracle(_oracle);\n    }\n\n    /// @dev set liquidation incentive calculator\n    function _setLiqIncentiveCalculator(address _liqIncentiveCalculator) internal {\n        liqIncentiveCalculator = _liqIncentiveCalculator;\n        emit SetIncentiveCalculator(_liqIncentiveCalculator);\n    }\n\n    /// @dev set risk manager\n    function _setRiskManager(address _riskManager) internal {\n        riskManager = _riskManager;\n        emit SetRiskManager(_riskManager);\n    }\n\n    /// @inheritdoc IInitCore\n    function getCollateralCreditCurrent_e36(uint _posId) public virtual returns (uint collCredit_e36) {\n        address _oracle = oracle;\n        IConfig _config = IConfig(config);\n        uint16 mode = _getPosMode(_posId);\n        // get position collateral\n        (address[] memory pools, uint[] memory shares, address[] memory wLps, uint[][] memory ids, uint[][] memory amts)\n        = IPosManager(POS_MANAGER).getPosCollInfo(_posId);\n        // calculate collateralCredit\n        uint collCredit_e54;\n        for (uint i; i < pools.length; i = i.uinc()) {\n            address token = ILendingPool(pools[i]).underlyingToken();\n            uint tokenPrice_e36 = IInitOracle(_oracle).getPrice_e36(token);\n            uint tokenValue_e36 = ILendingPool(pools[i]).toAmtCurrent(shares[i]) * tokenPrice_e36;\n            TokenFactors memory factors = _config.getTokenFactors(mode, pools[i]);\n            collCredit_e54 += tokenValue_e36 * factors.collFactor_e18;\n        }\n        for (uint i; i < wLps.length; i = i.uinc()) {\n            for (uint j; j < ids[i].length; j = j.uinc()) {\n                uint wLpPrice_e36 = IBaseWrapLp(wLps[i]).calculatePrice_e36(ids[i][j], _oracle);\n                uint wLpValue_e36 = amts[i][j] * wLpPrice_e36;\n                TokenFactors memory factors = _config.getTokenFactors(mode, IBaseWrapLp(wLps[i]).lp(ids[i][j]));\n                collCredit_e54 += wLpValue_e36 * factors.collFactor_e18;\n            }\n        }\n        collCredit_e36 = collCredit_e54 / ONE_E18;\n    }\n\n    /// @inheritdoc IInitCore\n    function getBorrowCreditCurrent_e36(uint _posId) public virtual returns (uint borrowCredit_e36) {\n        IConfig _config = IConfig(config);\n        uint16 mode = _getPosMode(_posId);\n        // get position debtShares\n        (address[] memory pools, uint[] memory debtShares) = IPosManager(POS_MANAGER).getPosBorrInfo(_posId);\n        uint borrowCredit_e54;\n        address _oracle = oracle;\n        for (uint i; i < pools.length; i = i.uinc()) {\n            address token = ILendingPool(pools[i]).underlyingToken();\n            uint tokenPrice_e36 = IInitOracle(_oracle).getPrice_e36(token);\n            // calculate position debt\n            uint tokenValue_e36 = tokenPrice_e36 * ILendingPool(pools[i]).debtShareToAmtCurrent(debtShares[i]);\n            TokenFactors memory factors = _config.getTokenFactors(mode, pools[i]);\n            borrowCredit_e54 += (tokenValue_e36 * factors.borrFactor_e18);\n        }\n        borrowCredit_e36 = borrowCredit_e54.ceilDiv(ONE_E18);\n    }\n\n    /// @inheritdoc IInitCore\n    function getPosHealthCurrent_e18(uint _posId) public virtual returns (uint health_e18) {\n        uint borrowCredit_e36 = getBorrowCreditCurrent_e36(_posId);\n        health_e18 = borrowCredit_e36 > 0\n            ? (getCollateralCreditCurrent_e36(_posId) * ONE_E18) / borrowCredit_e36\n            : type(uint).max;\n    }\n\n    /// @inheritdoc IInitCore\n    function callback(address _to, uint _value, bytes memory _data)\n        public\n        payable\n        virtual\n        returns (bytes memory result)\n    {\n        _require(_to != address(this), Errors.INVALID_CALLBACK_ADDRESS);\n        // call _to with _data\n        return ICallbackReceiver(_to).coreCallback{value: _value}(msg.sender, _data);\n    }\n\n    /// @inheritdoc IInitCore\n    function transferToken(address _token, address _to, uint _amt) public virtual nonReentrant {\n        // transfer _amt of token to _to from msg.sender\n        IERC20(_token).safeTransferFrom(msg.sender, _to, _amt);\n    }\n\n    /// @dev repay borrowed tokens\n    /// @param _config config\n    /// @param _mode position mode\n    /// @param _posId position id\n    /// @param _pool pool address to repay\n    /// @param _shares amount of shares to repay\n    /// @return tokenToRepay token address to repay\n    ///         amt          amt of token to repay\n    function _repay(IConfig _config, uint16 _mode, uint _posId, address _pool, uint _shares)\n        internal\n        returns (address tokenToRepay, uint amt)\n    {\n        // check status\n        _require(_config.getPoolConfig(_pool).canRepay && _config.getModeStatus(_mode).canRepay, Errors.REPAY_PAUSED);\n        // get position debt share\n        uint positionDebtShares = IPosManager(POS_MANAGER).getPosDebtShares(_posId, _pool);\n        uint sharesToRepay = _shares < positionDebtShares ? _shares : positionDebtShares;\n        // get amtToRepay (accrue interest)\n        uint amtToRepay = ILendingPool(_pool).debtShareToAmtCurrent(sharesToRepay);\n        // take token from msg.sender to pool\n        tokenToRepay = ILendingPool(_pool).underlyingToken();\n        IERC20(tokenToRepay).safeTransferFrom(msg.sender, _pool, amtToRepay);\n        // update debt on the position\n        IPosManager(POS_MANAGER).updatePosDebtShares(_posId, _pool, -sharesToRepay.toInt256());\n        // call repay on the pool\n        amt = ILendingPool(_pool).repay(sharesToRepay);\n        // update debt on mode\n        IRiskManager(riskManager).updateModeDebtShares(_mode, _pool, -sharesToRepay.toInt256());\n        emit Repay(_pool, _posId, msg.sender, _shares, amt);\n    }\n\n    /// @dev get position mode\n    function _getPosMode(uint _posId) internal view returns (uint16 mode) {\n        mode = IPosManager(POS_MANAGER).getPosMode(_posId);\n    }\n\n    /// @dev get whether the position is healthy\n    function _isPosHealthy(uint _posId) internal returns (bool isHealthy) {\n        isHealthy = getPosHealthCurrent_e18(_posId) >= ONE_E18;\n    }\n\n    /// @dev validate flash data\n    function _validateFlash(address[] calldata _pools, uint[] calldata _amts) internal pure returns (bool) {\n        if (_pools.length != _amts.length) return false;\n\n        for (uint i; i < _pools.length; i = i.uinc()) {\n            for (uint j = i.uinc(); j < _pools.length; j = j.uinc()) {\n                if (_pools[i] == _pools[j]) return false;\n            }\n        }\n        return true;\n    }\n\n    /// @dev check that the position health after liquidation does not exceed the threshold\n    function _ensurePosHealthAfterLiq(IConfig _config, uint _posId, uint16 _mode) internal {\n        uint healthAfterLiquidation_e18 = _config.getMaxHealthAfterLiq_e18(_mode);\n        // if healthAfterLiquidation_e18 == uint64.max, then no need to check\n        if (healthAfterLiquidation_e18 != type(uint64).max) {\n            _require(\n                getPosHealthCurrent_e18(_posId) <= healthAfterLiquidation_e18, Errors.INVALID_HEALTH_AFTER_LIQUIDATION\n            );\n        }\n    }\n\n    /// @dev liquidation internal logic\n    function _liquidateInternal(uint _posId, address _poolToRepay, uint _repayShares)\n        internal\n        returns (LiquidateLocalVars memory vars)\n    {\n        vars.config = IConfig(config);\n        vars.mode = _getPosMode(_posId);\n\n        // check position must be unhealthy\n        vars.health_e18 = getPosHealthCurrent_e18(_posId);\n        _require(vars.health_e18 < ONE_E18, Errors.POSITION_HEALTHY);\n\n        (vars.repayToken, vars.repayAmt) = _repay(vars.config, vars.mode, _posId, _poolToRepay, _repayShares);\n    }\n}"
    },
    {
      "filename": "contracts/core/Config.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport '../common/library/InitErrors.sol';\nimport '../common/library/UncheckedIncrement.sol';\n\nimport {\n    TokenFactors, IConfig, ModeConfig, ModeStatus, PoolConfig, EnumerableSet\n} from '../interfaces/core/IConfig.sol';\nimport {UnderACM} from '../common/UnderACM.sol';\n\nimport {Initializable} from '@openzeppelin-contracts-upgradeable/proxy/utils/Initializable.sol';\n\ncontract Config is IConfig, UnderACM, Initializable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using UncheckedIncrement for uint;\n\n    // constants\n    uint private constant ONE_E18 = 1e18;\n    bytes32 private constant GUARDIAN_ROLE = keccak256('guardian');\n    bytes32 private constant GOVERNOR_ROLE = keccak256('governor');\n\n    // storages\n    mapping(address => bool) public whitelistedWLps; // @inheritdoc IConfig\n    mapping(address => PoolConfig) private __poolConfigs;\n    mapping(uint16 => ModeConfig) private __modeConfigs;\n\n    // modifiers\n    modifier onlyGuardian() {\n        ACM.checkRole(GUARDIAN_ROLE, msg.sender);\n        _;\n    }\n\n    modifier onlyGovernor() {\n        ACM.checkRole(GOVERNOR_ROLE, msg.sender);\n        _;\n    }\n\n    // constructor\n    constructor(address _acm) UnderACM(_acm) {\n        _disableInitializers();\n    }\n\n    // initializer\n    /// @dev initialize the contract\n    function initialize() external initializer {}\n\n    // functions\n    /// @inheritdoc IConfig\n    function getModeConfig(uint16 _mode)\n        external\n        view\n        returns (address[] memory collTokens, address[] memory borrTokens, uint maxHealthAfterLiq_e18)\n    {\n        collTokens = __modeConfigs[_mode].collTokens.values();\n        borrTokens = __modeConfigs[_mode].borrTokens.values();\n        maxHealthAfterLiq_e18 = __modeConfigs[_mode].maxHealthAfterLiq_e18;\n    }\n\n    /// @inheritdoc IConfig\n    function getPoolConfig(address _pool) external view returns (PoolConfig memory config) {\n        config = __poolConfigs[_pool];\n    }\n\n    /// @inheritdoc IConfig\n    function isAllowedForBorrow(uint16 _mode, address _pool) external view returns (bool flag) {\n        flag = __modeConfigs[_mode].borrTokens.contains(_pool);\n    }\n\n    /// @inheritdoc IConfig\n    function isAllowedForCollateral(uint16 _mode, address _pool) external view returns (bool flag) {\n        flag = __modeConfigs[_mode].collTokens.contains(_pool);\n    }\n\n    /// @inheritdoc IConfig\n    function getTokenFactors(uint16 _mode, address _pool) external view returns (TokenFactors memory factors) {\n        factors = __modeConfigs[_mode].factors[_pool];\n    }\n\n    function getMaxHealthAfterLiq_e18(uint16 _mode) external view returns (uint maxHealthAfterLiq_e18) {\n        maxHealthAfterLiq_e18 = __modeConfigs[_mode].maxHealthAfterLiq_e18;\n    }\n\n    /// @inheritdoc IConfig\n    function getModeStatus(uint16 _mode) external view returns (ModeStatus memory modeStatus) {\n        modeStatus = __modeConfigs[_mode].status;\n    }\n\n    /// @inheritdoc IConfig\n    function setPoolConfig(address _pool, PoolConfig calldata _config) external onlyGuardian {\n        __poolConfigs[_pool] = _config;\n        emit SetPoolConfig(_pool, _config);\n    }\n\n    /// @inheritdoc IConfig\n    function setCollFactors_e18(uint16 _mode, address[] calldata _pools, uint128[] calldata _factors_e18)\n        external\n        onlyGovernor\n    {\n        _require(_mode != 0, Errors.INVALID_MODE);\n        _require(_pools.length == _factors_e18.length, Errors.ARRAY_LENGTH_MISMATCHED);\n        EnumerableSet.AddressSet storage collTokens = __modeConfigs[_mode].collTokens;\n        for (uint i; i < _pools.length; i = i.uinc()) {\n            _require(_factors_e18[i] <= ONE_E18, Errors.INVALID_FACTOR);\n            collTokens.add(_pools[i]);\n            __modeConfigs[_mode].factors[_pools[i]].collFactor_e18 = _factors_e18[i];\n        }\n        emit SetCollFactors_e18(_mode, _pools, _factors_e18);\n    }\n\n    /// @inheritdoc IConfig\n    function setBorrFactors_e18(uint16 _mode, address[] calldata _pools, uint128[] calldata _factors_e18)\n        external\n        onlyGovernor\n    {\n        _require(_mode != 0, Errors.INVALID_MODE);\n        _require(_pools.length == _factors_e18.length, Errors.ARRAY_LENGTH_MISMATCHED);\n        EnumerableSet.AddressSet storage borrTokens = __modeConfigs[_mode].borrTokens;\n        for (uint i; i < _pools.length; i = i.uinc()) {\n            borrTokens.add(_pools[i]);\n            _require(_factors_e18[i] >= ONE_E18, Errors.INVALID_FACTOR);\n            __modeConfigs[_mode].factors[_pools[i]].borrFactor_e18 = _factors_e18[i];\n        }\n        emit SetBorrFactors_e18(_mode, _pools, _factors_e18);\n    }\n\n    /// @inheritdoc IConfig\n    function setModeStatus(uint16 _mode, ModeStatus calldata _status) external onlyGuardian {\n        _require(_mode != 0, Errors.INVALID_MODE);\n        __modeConfigs[_mode].status = _status;\n        emit SetModeStatus(_mode, _status);\n    }\n\n    /// @inheritdoc IConfig\n    function setMaxHealthAfterLiq_e18(uint16 _mode, uint64 _maxHealthAfterLiq_e18) external onlyGuardian {\n        _require(_mode != 0, Errors.INVALID_MODE);\n        _require(_maxHealthAfterLiq_e18 > ONE_E18, Errors.INPUT_TOO_LOW);\n        __modeConfigs[_mode].maxHealthAfterLiq_e18 = _maxHealthAfterLiq_e18;\n        emit SetMaxHealthAfterLiq_e18(_mode, _maxHealthAfterLiq_e18);\n    }\n\n    /// @inheritdoc IConfig\n    function setWhitelistedWLps(address[] calldata _wLps, bool _status) external onlyGovernor {\n        for (uint i; i < _wLps.length; i = i.uinc()) {\n            whitelistedWLps[_wLps[i]] = _status;\n        }\n        emit SetWhitelistedWLps(_wLps, _status);\n    }\n}"
    },
    {
      "filename": "contracts/core/InitCore.sol",
      "content": "/"
    }
  ]
}