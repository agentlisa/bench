{
  "Title": "[H02] Sponsors can force liquidation of insolvent positions",
  "Content": "Liquidators specify a maximum [collateral-to-token ratio](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/Liquidatable.sol#L190) to ensure they do not accidentally liquidate a position that is collateralized. However, they cannot indicate a minimum collateral-to-token ratio. If the liquidation is front-run in such a way that the target position becomes insolvent (not just under-collateralized), the liquidator will end up [burning their tokens](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/Liquidatable.sol#L267-L268) with insufficient compensation. We have identified two possible attack vectors:\n\n\n* A) If the position about to be liquidated is the only open position, the sponsor can [redeem their tokens](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/PricelessPositionManager.sol#L336) (which reduces the [global collateralization ratio](https://docs.umaproject.org/uma/synthetic_tokens/glossary.html#_global_collateralization_ratio_gcr) to zero) and then [create an insolvent position](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/PricelessPositionManager.sol#L303).\n* B) If the liquidation is processed late enough, the sponsor might simply complete a slow withdrawal before being liquidated.\n\n\nConsider including a minimum collateral-to-token ratio to prevent liquidators from accidentally liquidating an insolvent position.\n\n\n**Update:** *Fixed in [PR#1351](https://github.com/UMAprotocol/protocol/pull/1351).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "core/contracts/financial-templates/implementation/Liquidatable.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"./PricelessPositionManager.sol\";\n\n\n/**\n@title Liquidatable\n@notice Adds logic to a position-managing contract that enables callers to\nliquidate an undercollateralized position.\n@dev The liquidation has a liveness period before expiring successfully, during which\nsomeone can \"dispute\" the liquidation, which sends a price request to the relevant\nOracle to settle the final collateralization ratio based on a DVM price. The\ncontract enforces dispute rewards in order to incentivize disputers to correctly\ndispute false liquidations and compensate position sponsors who had their position\nincorrectly liquidated. Importantly, a prospective disputer must deposit a dispute\nbond that they can lose in the case of an unsuccessful dispute.\n*/\ncontract Liquidatable is PricelessPositionManager {\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    /****************************************\n     *     LIQUIDATION DATA STRUCTURES      *\n     ****************************************/\n\n    // Because of the check in withdrawable(), the order of these enum values should not change.\n    enum Status { Uninitialized, PreDispute, PendingDispute, DisputeSucceeded, DisputeFailed }\n\n    struct LiquidationData {\n        // Following variables set upon creation of liquidation:\n        address sponsor; // Address of the liquidated position's sponsor\n        address liquidator; // Address who created this liquidation\n        Status state; // Liquidated (and expired or not), Pending a Dispute, or Dispute has resolved\n        uint liquidationTime; // Time when liquidation is initiated, needed to get price from Oracle\n        // Following variables determined by the position that is being liquidated:\n        FixedPoint.Unsigned tokensOutstanding; // Synthetic Tokens required to be burned by liquidator to initiate dispute\n        FixedPoint.Unsigned lockedCollateral; // Collateral locked by contract and released upon expiry or post-dispute\n        // Amount of collateral being liquidated, which could be different from\n        // lockedCollateral if there were pending withdrawals at the time of liquidation\n        FixedPoint.Unsigned liquidatedCollateral;\n        // Unit value (starts at 1) that is used to track the fees per unit of collateral over the course of the liquidation.\n        FixedPoint.Unsigned rawUnitCollateral;\n        // Following variable set upon initiation of a dispute:\n        address disputer; // Person who is disputing a liquidation\n        // Following variable set upon a resolution of a dispute:\n        FixedPoint.Unsigned settlementPrice; // Final price as determined by an Oracle following a dispute\n        FixedPoint.Unsigned finalFee;\n    }\n\n    // Define the contract's constructor parameters as a struct to enable more variables to be specified.\n    // This is required to enable more params, over and above Solidity's limits.\n    struct ConstructorParams {\n        // Params for PricelessPositionManager only.\n        bool isTest;\n        uint expirationTimestamp;\n        uint withdrawalLiveness;\n        address collateralAddress;\n        address finderAddress;\n        address tokenFactoryAddress;\n        bytes32 priceFeedIdentifier;\n        string syntheticName;\n        string syntheticSymbol;\n        // Params specifically for Liquidatable.\n        uint liquidationLiveness;\n        FixedPoint.Unsigned collateralRequirement;\n        FixedPoint.Unsigned disputeBondPct;\n        FixedPoint.Unsigned sponsorDisputeRewardPct;\n        FixedPoint.Unsigned disputerDisputeRewardPct;\n        FixedPoint.Unsigned minSponsorTokens;\n    }\n\n    // Liquidations are unique by ID per sponsor\n    mapping(address => LiquidationData[]) public liquidations;\n\n    // Total collateral in liquidation.\n    FixedPoint.Unsigned public rawLiquidationCollateral;\n\n    // Immutable contract parameters.\n\n    // Amount of time for pending liquidation before expiry\n    uint public liquidationLiveness;\n    // Required collateral:TRV ratio for a position to be considered sufficiently collateralized.\n    FixedPoint.Unsigned public collateralRequirement;\n    // Percent of a Liquidation/Position's lockedCollateral to be deposited by a potential disputer\n    // Represented as a multiplier, for example 1.5e18 = \"150%\" and 0.05e18 = \"5%\"\n    FixedPoint.Unsigned public disputeBondPct;\n    // Percent of oraclePrice paid to sponsor in the Disputed state (i.e. following a successful dispute)\n    // Represented as a multipler, see above\n    FixedPoint.Unsigned public sponsorDisputeRewardPct;\n    // Percent of oraclePrice paid to disputer in the Disputed state (i.e. following a successful dispute)\n    // Represented as a multipler, see above\n    FixedPoint.Unsigned public disputerDisputeRewardPct;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event LiquidationCreated(\n        address indexed sponsor,\n        address indexed liquidator,\n        uint indexed liquidationId,\n        uint tokensOutstanding,\n        uint lockedCollateral,\n        uint liquidatedCollateral\n    );\n    event LiquidationDisputed(\n        address indexed sponsor,\n        address indexed liquidator,\n        address indexed disputer,\n        uint liquidationId,\n        uint disputeBondAmount\n    );\n    event DisputeSettled(\n        address indexed caller,\n        address indexed sponsor,\n        address indexed liquidator,\n        address disputer,\n        uint liquidationId,\n        bool DisputeSucceeded\n    );\n    event LiquidationWithdrawn(address caller, uint256 withdrawalAmount, Status liquidationStatus);\n\n    /****************************************\n     *              MODIFIERS               *\n     ****************************************/\n\n    modifier disputable(uint liquidationId, address sponsor) {\n        _disputable(liquidationId, sponsor);\n        _;\n    }\n\n    modifier withdrawable(uint liquidationId, address sponsor) {\n        _withdrawable(liquidationId, sponsor);\n        _;\n    }\n\n    /**\n     * @notice Constructs the liquidatable contract.\n     * @param params struct to define input parameters for construction of Liquidatable. Some params\n     * are fed directly into the `PricelessPositionManager's constructor within the inheritance tree.\n     */\n    constructor(ConstructorParams memory params)\n        public\n        PricelessPositionManager(\n            params.isTest,\n            params.expirationTimestamp,\n            params.withdrawalLiveness,\n            params.collateralAddress,\n            params.finderAddress,\n            params.priceFeedIdentifier,\n            params.syntheticName,\n            params.syntheticSymbol,\n            params.tokenFactoryAddress,\n            params.minSponsorTokens\n        )\n    {\n        require(params.collateralRequirement.isGreaterThan(1));\n        require(params.sponsorDisputeRewardPct.add(params.disputerDisputeRewardPct).isLessThan(1));\n\n        // Set liquidatable specific variables.\n        liquidationLiveness = params.liquidationLiveness;\n        collateralRequirement = params.collateralRequirement;\n        disputeBondPct = params.disputeBondPct;\n        sponsorDisputeRewardPct = params.sponsorDisputeRewardPct;\n        disputerDisputeRewardPct = params.disputerDisputeRewardPct;\n    }\n\n    /****************************************\n     *        LIQUIDATION FUNCTIONS         *\n     ****************************************/\n\n    /**\n     * @notice Liquidates the sponsor's position if the caller has enough\n     * synthetic tokens to retire the position's outstanding tokens.\n     * @dev This method generates an ID that will uniquely identify liquidation for the sponsor.\n     * @param sponsor address to liquidate.\n     * @param collateralPerToken abort the liquidation if the position's collateral per token exceeds this value.\n     * @param maxTokensToLiquidate max number of tokes to liquidate.\n     * @return liquidationId of the newly created liquidation.\n     */\n    function createLiquidation(\n        address sponsor,\n        FixedPoint.Unsigned calldata collateralPerToken,\n        FixedPoint.Unsigned calldata maxTokensToLiquidate\n    )\n        external\n        fees()\n        onlyPreExpiration()\n        returns (\n            uint liquidationId,\n            FixedPoint.Unsigned memory tokensLiquidated,\n            FixedPoint.Unsigned memory finalFeeBond\n        )\n    {\n        // Retrieve Position data for sponsor\n        PositionData storage positionToLiquidate = _getPositionData(sponsor);\n\n        tokensLiquidated = FixedPoint.min(maxTokensToLiquidate, positionToLiquidate.tokensOutstanding);\n        // TODO: Limit liquidations from being too small or very close to 100% without being exactly 100%.\n        FixedPoint.Unsigned memory ratio = tokensLiquidated.div(positionToLiquidate.tokensOutstanding);\n\n        // Starting values for the Position being liquidated.\n        // If withdrawal request amount is > position's collateral, then set this to 0, otherwise set it to (startCollateral - withdrawal request amount).\n        FixedPoint.Unsigned memory startCollateral = _getCollateral(positionToLiquidate.rawCollateral);\n        FixedPoint.Unsigned memory startCollateralNetOfWithdrawal = FixedPoint.fromUnscaledUint(0);\n        if (positionToLiquidate.withdrawalRequestAmount.isLessThanOrEqual(startCollateral)) {\n            startCollateralNetOfWithdrawal = startCollateral.sub(positionToLiquidate.withdrawalRequestAmount);\n        }\n\n        // Scoping to get rid of a stack too deep error.\n        {\n            FixedPoint.Unsigned memory startTokens = positionToLiquidate.tokensOutstanding;\n\n            // Check the max price constraint to ensure that the Position's collateralization ratio hasn't increased beyond\n            // what the liquidator was willing to liquidate at.\n            // collateralPerToken >= startCollateralNetOfWithdrawal / startTokens.\n            require(collateralPerToken.mul(startTokens).isGreaterThanOrEqual(startCollateralNetOfWithdrawal));\n        }\n\n        // The actual amount of collateral that gets moved to the liquidation.\n        FixedPoint.Unsigned memory lockedCollateral = startCollateral.mul(ratio);\n        // For purposes of disputes, it's actually this liquidatedCollateral value that's used. This value is net of\n        // withdrawal requests.\n        FixedPoint.Unsigned memory liquidatedCollateral = startCollateralNetOfWithdrawal.mul(ratio);\n        // Part of the withdrawal request is also removed. Ideally:\n        // liquidatedCollateral + withdrawalAmountToRemove = lockedCollateral.\n        FixedPoint.Unsigned memory withdrawalAmountToRemove = positionToLiquidate.withdrawalRequestAmount.mul(ratio);\n\n        // Compute final fee at time of liquidation.\n        finalFeeBond = _computeFinalFees();\n\n        // Construct liquidation object.\n        // Note: all dispute-related values are just zeroed out until a dispute occurs.\n        // liquidationId is the index of the new LiquidationData that we will push into the array,\n        // which is equal to the current length of the array pre-push.\n        liquidationId = liquidations[sponsor].length;\n        liquidations[sponsor].push(\n            LiquidationData({\n                sponsor: sponsor,\n                liquidator: msg.sender,\n                state: Status.PreDispute,\n                liquidationTime: getCurrentTime(),\n                tokensOutstanding: tokensLiquidated,\n                lockedCollateral: lockedCollateral,\n                liquidatedCollateral: liquidatedCollateral,\n                rawUnitCollateral: _convertCollateral(FixedPoint.fromUnscaledUint(1)),\n                disputer: address(0),\n                settlementPrice: FixedPoint.fromUnscaledUint(0),\n                finalFee: finalFeeBond\n            })\n        );\n\n        // Adjust the sponsor's remaining position.\n        _reduceSponsorPosition(sponsor, tokensLiquidated, lockedCollateral, withdrawalAmountToRemove);\n\n        // Add to the global liquidation collateral count.\n        _addCollateral(rawLiquidationCollateral, lockedCollateral.add(finalFeeBond));\n\n        // Destroy tokens\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensLiquidated.rawValue);\n        tokenCurrency.burn(tokensLiquidated.rawValue);\n\n        // Pull final fee from liquidator.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), finalFeeBond.rawValue);\n\n        emit LiquidationCreated(\n            sponsor,\n            msg.sender,\n            liquidationId,\n            tokensLiquidated.rawValue,\n            lockedCollateral.rawValue,\n            liquidatedCollateral.rawValue\n        );\n    }\n\n    /**\n     * @notice Disputes a liquidation, if the caller has enough collateral to post a dispute bond\n     * and pay a fixed final fee charged on each price request.\n     * @dev Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes.\n     * @param liquidationId of the disputed liquidation.\n     * @param sponsor the address of the sponsor who's liquidation is being disputed.\n     */\n    function dispute(uint liquidationId, address sponsor)\n        external\n        disputable(liquidationId, sponsor)\n        fees()\n        returns (FixedPoint.Unsigned memory totalPaid)\n    {\n        LiquidationData storage disputedLiquidation = _getLiquidationData(sponsor, liquidationId);\n\n        // Multiply by the unit collateral so the dispute bond is a percentage of the locked collateral after fees.\n        FixedPoint.Unsigned memory disputeBondAmount = disputedLiquidation.lockedCollateral.mul(disputeBondPct).mul(\n            _getCollateral(disputedLiquidation.rawUnitCollateral)\n        );\n        _addCollateral(rawLiquidationCollateral, disputeBondAmount);\n\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), disputeBondAmount.rawValue);\n\n        // Request a price from DVM,\n        // Liquidation is pending dispute until DVM returns a price\n        disputedLiquidation.state = Status.PendingDispute;\n        disputedLiquidation.disputer = msg.sender;\n\n        // Enqueue a request with the DVM.\n        _requestOraclePrice(disputedLiquidation.liquidationTime);\n\n        // Pay a final fee.\n        _payFinalFees(msg.sender, disputedLiquidation.finalFee);\n\n        emit LiquidationDisputed(\n            sponsor,\n            disputedLiquidation.liquidator,\n            msg.sender,\n            liquidationId,\n            disputeBondAmount.rawValue\n        );\n\n        return disputeBondAmount.add(disputedLiquidation.finalFee);\n    }\n\n    /**\n     * @notice After a dispute has settled or after a non-disputed liquidation has expired,\n     * the sponsor, liquidator, and/or disputer can call this method to receive payments.\n     * @dev If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment\n     * If the dispute FAILED: only the liquidator can receive payment\n     * Once all collateral is withdrawn, delete the liquidation data.\n     * @param liquidationId uniquely identifies the sponsor's liquidation.\n     * @param sponsor address of the sponsor associated with the liquidation.\n     * @return amountWithdrawn the total amount of underlying returned from the liquidation.\n     */\n    function withdrawLiquidation(uint liquidationId, address sponsor)\n        public\n        withdrawable(liquidationId, sponsor)\n        fees()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n        require(\n            (msg.sender == liquidation.disputer) ||\n                (msg.sender == liquidation.liquidator) ||\n                (msg.sender == liquidation.sponsor)\n        );\n\n        // Settles the liquidation if necessary.\n        // Note: this will fail if the price has not resolved yet.\n        _settle(liquidationId, sponsor);\n\n        // Calculate rewards as a function of the TRV. Note: all payouts are scaled by the unit collateral value so\n        // all payouts are charged the fees pro rata.\n        FixedPoint.Unsigned memory feeAttenuation = _getCollateral(liquidation.rawUnitCollateral);\n        FixedPoint.Unsigned memory tokenRedemptionValue = liquidation\n            .tokensOutstanding\n            .mul(liquidation.settlementPrice)\n            .mul(feeAttenuation);\n        FixedPoint.Unsigned memory collateral = liquidation.lockedCollateral.mul(feeAttenuation);\n        FixedPoint.Unsigned memory disputerDisputeReward = disputerDisputeRewardPct.mul(tokenRedemptionValue);\n        FixedPoint.Unsigned memory sponsorDisputeReward = sponsorDisputeRewardPct.mul(tokenRedemptionValue);\n        FixedPoint.Unsigned memory disputeBondAmount = collateral.mul(disputeBondPct);\n        FixedPoint.Unsigned memory finalFee = liquidation.finalFee.mul(feeAttenuation);\n\n        // There are three main outcome states: either the dispute succeeded, failed or was not updated.\n        // Based on the state, different parties of a liquidation can withdraw different amounts.\n        // Once a caller has been paid their address deleted from the struct.\n        // This prevents them from being paid multiple from times the same liquidation.\n        FixedPoint.Unsigned memory withdrawalAmount;\n        if (liquidation.state == Status.DisputeSucceeded) {\n            // If the dispute is successful then all three users can withdraw from the contract.\n            if (msg.sender == liquidation.disputer) {\n                // Pay DISPUTER: disputer reward + dispute bond + returned final fee\n                FixedPoint.Unsigned memory payToDisputer = disputerDisputeReward.add(disputeBondAmount).add(finalFee);\n                withdrawalAmount = withdrawalAmount.add(payToDisputer);\n                delete liquidation.disputer;\n            }\n\n            if (msg.sender == liquidation.sponsor) {\n                // Pay SPONSOR: remaining collateral (collateral - TRV) + sponsor reward\n                FixedPoint.Unsigned memory remainingCollateral = collateral.sub(tokenRedemptionValue);\n                FixedPoint.Unsigned memory payToSponsor = sponsorDisputeReward.add(remainingCollateral);\n                withdrawalAmount = withdrawalAmount.add(payToSponsor);\n                delete liquidation.sponsor;\n            }\n\n            if (msg.sender == liquidation.liquidator) {\n                // Pay LIQUIDATOR: TRV - dispute reward - sponsor reward\n                // If TRV > Collateral, then subtract rewards from collateral\n                // NOTE: This should never be below zero since we prevent (sponsorDisputePct+disputerDisputePct) >= 0 in\n                // the constructor when these params are set\n                FixedPoint.Unsigned memory payToLiquidator = tokenRedemptionValue.sub(sponsorDisputeReward).sub(\n                    disputerDisputeReward\n                );\n                withdrawalAmount = withdrawalAmount.add(payToLiquidator);\n                delete liquidation.liquidator;\n            }\n\n            // Free up space once all collateral is withdrawn\n            if (\n                liquidation.disputer == address(0) &&\n                liquidation.sponsor == address(0) &&\n                liquidation.liquidator == address(0)\n            ) {\n                delete liquidations[sponsor][liquidationId];\n            }\n            // In the case of a failed dispute only the liquidator can withdraw.\n        } else if (liquidation.state == Status.DisputeFailed && msg.sender == liquidation.liquidator) {\n            // Pay LIQUIDATOR: collateral + dispute bond + returned final fee\n            withdrawalAmount = collateral.add(disputeBondAmount).add(finalFee);\n            delete liquidations[sponsor][liquidationId];\n            // If the state is pre-dispute but time has passed liveness then the dispute failed and the liquidator can withdraw\n        } else if (liquidation.state == Status.PreDispute && msg.sender == liquidation.liquidator) {\n            // Pay LIQUIDATOR: collateral + returned final fee\n            withdrawalAmount = collateral.add(finalFee);\n            delete liquidations[sponsor][liquidationId];\n        }\n\n        require(withdrawalAmount.isGreaterThan(0));\n        amountWithdrawn = _removeCollateral(rawLiquidationCollateral, withdrawalAmount);\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n\n        emit LiquidationWithdrawn(msg.sender, amountWithdrawn.rawValue, liquidation.state);\n    }\n\n    /**\n     * @dev This overrides pfc() so the Liquidatable contract can report its profit from corruption.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function pfc() public override view returns (FixedPoint.Unsigned memory) {\n        return super.pfc().add(_getCollateral(rawLiquidationCollateral));\n    }\n\n    function getLiquidations(address sponsor) external view returns (LiquidationData[] memory) {\n        return liquidations[sponsor];\n    }\n\n    /****************************************\n     *          INTERNAL FUNCTIONS          *\n     ****************************************/\n\n    // This settles a liquidation if it is in the PendingDispute state. If not, it will immediately return.\n    // If the liquidation is in the PendingDispute state, but a price is not available, this will revert.\n    function _settle(uint liquidationId, address sponsor) internal {\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n\n        // Settlement only happens when state == PendingDispute and will only happen once per liquidation.\n        // If this liquidation is not ready to be settled, this method should return immediately.\n        if (liquidation.state != Status.PendingDispute) {\n            return;\n        }\n\n        // Get the returned price from the oracle. If this has not yet resolved will revert.\n        liquidation.settlementPrice = _getOraclePrice(liquidation.liquidationTime);\n\n        // Find the value of the tokens in the underlying collateral.\n        FixedPoint.Unsigned memory tokenRedemptionValue = liquidation.tokensOutstanding.mul(\n            liquidation.settlementPrice\n        );\n\n        // The required collateral is the value of the tokens in underlying * required collateral ratio.\n        FixedPoint.Unsigned memory requiredCollateral = tokenRedemptionValue.mul(collateralRequirement);\n\n        // If the position has more than the required collateral it is solvent and the dispute is valid(liquidation is invalid)\n        // Note that this check uses the liquidatedCollateral not the lockedCollateral as this considers withdrawals.\n        bool disputeSucceeded = liquidation.liquidatedCollateral.isGreaterThanOrEqual(requiredCollateral);\n        liquidation.state = disputeSucceeded ? Status.DisputeSucceeded : Status.DisputeFailed;\n\n        emit DisputeSettled(\n            msg.sender,\n            sponsor,\n            liquidation.liquidator,\n            liquidation.disputer,\n            liquidationId,\n            disputeSucceeded\n        );\n    }\n\n    function _getLiquidationData(address sponsor, uint liquidationId)\n        internal\n        view\n        returns (LiquidationData storage liquidation)\n    {\n        LiquidationData[] storage liquidationArray = liquidations[sponsor];\n\n        // Revert if the caller is attempting to access an invalid liquidation (one that has never been created or one\n        // has never been initialized).\n        require(\n            liquidationId < liquidationArray.length && liquidationArray[liquidationId].state != Status.Uninitialized\n        );\n        return liquidationArray[liquidationId];\n    }\n\n    function _getLiquidationExpiry(LiquidationData storage liquidation) internal view returns (uint) {\n        return liquidation.liquidationTime.add(liquidationLiveness);\n    }\n\n    /**\n     * @dev These internal functions are supposed to act identically to modifiers, but re-used modifiers\n     * unnecessarily increase contract bytecode size.\n     * source: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6\n     */\n    function _disputable(uint liquidationId, address sponsor) internal view {\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n        require((getCurrentTime() < _getLiquidationExpiry(liquidation)) && (liquidation.state == Status.PreDispute));\n    }\n\n    function _withdrawable(uint liquidationId, address sponsor) internal view {\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n        Status state = liquidation.state;\n\n        // Must be disputed or the liquidation has passed expiry.\n        require(\n            (state > Status.PreDispute) ||\n                ((_getLiquidationExpiry(liquidation) <= getCurrentTime()) && (state == Status.PreDispute))\n        );\n    }\n}"
    },
    {
      "filename": "core/contracts/financial-templates/implementation/PricelessPositionManager.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\nimport \"../../oracle/interfaces/OracleInterface.sol\";\nimport \"../../oracle/interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../../oracle/interfaces/AdministrateeInterface.sol\";\nimport \"./TokenFactory.sol\";\nimport \"./FeePayer.sol\";\n\n\n/**\n * @title Financial contract with priceless position management.\n * @notice Handles positions for multiple sponsors in an optimistic (i.e., priceless) way without relying\n * on a price feed. On construction, deploys a new ERC20, managed by this contract, that is the synthetic token.\n */\n\ncontract PricelessPositionManager is FeePayer, AdministrateeInterface {\n    using SafeMath for uint;\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for ExpandedIERC20;\n\n    /****************************************\n     *  PRICELESS POSITION DATA STRUCTURES  *\n     ****************************************/\n\n    // Enum to store the state of the PricelessPositionManager. Set on expiration or emergency shutdown.\n    enum ContractState { Open, ExpiredPriceRequested, ExpiredPriceReceived }\n    ContractState public contractState;\n\n    // Represents a single sponsor's position. All collateral is held by this contract.\n    // This struct acts is bookkeeping for how much of that collateral is allocated to each sponsor.\n    struct PositionData {\n        FixedPoint.Unsigned tokensOutstanding;\n        // Tracks pending withdrawal requests. A withdrawal request is pending if `requestPassTimestamp != 0`.\n        uint requestPassTimestamp;\n        FixedPoint.Unsigned withdrawalRequestAmount;\n        // Raw collateral value. This value should never be accessed directly -- always use _getCollateral().\n        // To add or remove collateral, use _addCollateral() and _removeCollateral().\n        FixedPoint.Unsigned rawCollateral;\n    }\n\n    // Maps sponsor addresses to their positions. Each sponsor can have only one position.\n    mapping(address => PositionData) public positions;\n\n    // Keep track of the total collateral and tokens across all positions to enable calculating the\n    // global collateralization ratio without iterating over all positions.\n    FixedPoint.Unsigned public totalTokensOutstanding;\n\n    // Similar to the rawCollateral in PositionData, this value should not be used directly.\n    // _getCollateral(), _addCollateral() and _removeCollateral() must be used to access and adjust.\n    FixedPoint.Unsigned public rawTotalPositionCollateral;\n\n    // Synthetic token created by this contract.\n    ExpandedIERC20 public tokenCurrency;\n\n    // Unique identifier for DVM price feed ticker.\n    bytes32 public priceIdentifer;\n    // Time that this contract expires. Should not change post-construction unless a emergency shutdown occurs.\n    uint public expirationTimestamp;\n    // Time that has to elapse for a withdrawal request to be considered passed, if no liquidations occur.\n    uint public withdrawalLiveness;\n\n    // Minimum number of tokens in a sponsor's position.\n    FixedPoint.Unsigned public minSponsorTokens;\n\n    // The expiry price pulled from the DVM.\n    FixedPoint.Unsigned public expiryPrice;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event Transfer(address indexed oldSponsor, address indexed newSponsor);\n    event Deposit(address indexed sponsor, uint indexed collateralAmount);\n    event Withdrawal(address indexed sponsor, uint indexed collateralAmount);\n    event RequestWithdrawal(address indexed sponsor, uint indexed collateralAmount);\n    event RequestWithdrawalExecuted(address indexed sponsor, uint indexed collateralAmount);\n    event RequestWithdrawalCanceled(address indexed sponsor, uint indexed collateralAmount);\n    event PositionCreated(address indexed sponsor, uint indexed collateralAmount, uint indexed tokenAmount);\n    event NewSponsor(address indexed sponsor);\n    event EndedSponsor(address indexed sponsor);\n    event Redeem(address indexed sponsor, uint indexed collateralAmount, uint indexed tokenAmount);\n    event ContractExpired(address indexed caller);\n    event SettleExpiredPosition(address indexed caller, uint indexed collateralReturned, uint indexed tokensBurned);\n    event EmergencyShutdown(address indexed caller, uint originalExpirationTimestamp, uint shutdownTimestamp);\n\n    /****************************************\n     *               MODIFIERS              *\n     ****************************************/\n\n    modifier onlyPreExpiration() {\n        _onlyPreExpiration();\n        _;\n    }\n\n    modifier onlyPostExpiration() {\n        _onlyPostExpiration();\n        _;\n    }\n\n    modifier onlyCollateralizedPosition(address sponsor) {\n        _onlyCollateralizedPosition(sponsor);\n        _;\n    }\n\n    // Check that the current state of the pricelessPositionManager is Open.\n    // This prevents multiple calls to `expire` and `EmergencyShutdown` post expiration.\n    modifier onlyOpenState() {\n        _onlyOpenState();\n        _;\n    }\n\n    /**\n     * @notice Construct the PricelessPositionManager\n     * @param _isTest whether this contract is being constructed for the purpose of running tests.\n     * @param _expirationTimestamp unix timestamp of when the contract will expire.\n     * @param _withdrawalLiveness liveness delay, in seconds, for pending withdrawals.\n     * @param _collateralAddress ERC20 token used as collateral for all positions.\n     * @param _finderAddress UMA protocol Finder used to discover other protocol contracts.\n     * @param _priceIdentifier registered in the DVM for the synthetic.\n     * @param _syntheticName name for the token contract that will be deployed.\n     * @param _syntheticSymbol symbol for the token contract that will be deployed.\n     * @param _tokenFactoryAddress deployed UMA token factory to create the synthetic token.\n     */\n    constructor(\n        bool _isTest,\n        uint _expirationTimestamp,\n        uint _withdrawalLiveness,\n        address _collateralAddress,\n        address _finderAddress,\n        bytes32 _priceIdentifier,\n        string memory _syntheticName,\n        string memory _syntheticSymbol,\n        address _tokenFactoryAddress,\n        FixedPoint.Unsigned memory _minSponsorTokens\n    ) public FeePayer(_collateralAddress, _finderAddress, _isTest) {\n        expirationTimestamp = _expirationTimestamp;\n        withdrawalLiveness = _withdrawalLiveness;\n        TokenFactory tf = TokenFactory(_tokenFactoryAddress);\n        tokenCurrency = tf.createToken(_syntheticName, _syntheticSymbol, 18);\n        minSponsorTokens = _minSponsorTokens;\n\n        require(_getIdentifierWhitelist().isIdentifierSupported(_priceIdentifier));\n\n        priceIdentifer = _priceIdentifier;\n    }\n\n    /****************************************\n     *          POSITION FUNCTIONS          *\n     ****************************************/\n\n    /**\n     * @notice Transfers ownership of the caller's current position to `newSponsorAddre"
    }
  ]
}