{
  "Title": "Unsafe support of non-standard ERC-20 tokens",
  "Content": "##### Description\nWhen retrieving the underlying tokens from the liquidator, the code does not perform checks for the return value. Although standard implementations of ERC-20 will revert on a failed [transferFrom](https://github.com/Gearbox-protocol/bots-v3/blob/405ec3afab3b9bedce77f5f0faa9979dfe2acb41/contracts/bots/PartialLiquidationBotV3.sol#L202C33-L202C45), some implementations (e.g., USDT) may just return false instead. This could be passed without generating the appropriate exception. Consequently, no tokens would actually be retrieved from the liquidator, yet the collateral might still be withdrawn to the liquidator's account.\nThis issue is rated as MEDIUM severity because it is unlikely that it could be exploited in the current code base, given the other checks in place after liquidation. However, future development of the code could potentially increase the impact of this issue.\n\n##### Recommendation\nWe recommend using `safeTransferFrom` instead to ensure that various ERC-20 implementations are correctly handled.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/bots/PartialLiquidationBotV3.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IUpdatablePriceFeed} from \"@gearbox-protocol/core-v2/contracts/interfaces/IPriceFeed.sol\";\nimport {IVersion} from \"@gearbox-protocol/core-v2/contracts/interfaces/IVersion.sol\";\nimport {PERCENTAGE_FACTOR} from \"@gearbox-protocol/core-v2/contracts/libraries/Constants.sol\";\nimport {MultiCall} from \"@gearbox-protocol/core-v2/contracts/libraries/MultiCall.sol\";\n\nimport {\n    AP_TREASURY,\n    IAddressProviderV3,\n    NO_VERSION_CONTROL\n} from \"@gearbox-protocol/core-v3/contracts/interfaces/IAddressProviderV3.sol\";\nimport {ICreditAccountV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditAccountV3.sol\";\nimport {ICreditFacadeV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3.sol\";\nimport {ICreditFacadeV3Multicall} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditFacadeV3Multicall.sol\";\nimport {\n    CollateralCalcTask,\n    CollateralDebtData,\n    ICreditManagerV3\n} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditManagerV3.sol\";\nimport {\n    CreditAccountNotLiquidatableException,\n    IncorrectParameterException,\n    PriceFeedDoesNotExistException\n} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\nimport {IPriceOracleV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/IPriceOracleV3.sol\";\nimport {ContractsRegisterTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ContractsRegisterTrait.sol\";\nimport {ReentrancyGuardTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ReentrancyGuardTrait.sol\";\n\nimport {IPartialLiquidationBotV3} from \"../interfaces/IPartialLiquidationBotV3.sol\";\n\n/// @title Partial liquidation bot V3\n/// @author Gearbox Foundation\n/// @notice Partial liquidation bot helps to bring credit accounts back to solvency in conditions when liquidity\n///         on the market is not enough to convert all account's collateral to underlying for full liquidation.\n///         Thanks to special permissons in the bot list, it extends the core system by allowing anyone to repay\n///         a fraction of liquidatable credit account's debt in exchange for discounted collateral, as long as\n///         account passes a collateral check after the operation.\n/// @notice There are certain limitations that liquidators, configurators and account owners should be aware of:\n///         - since operation repays debt, an account can't be partially liquidated if its debt is near minimum\n///         - due to `withdrawCollateral` inside the liquidation, collateral check with safe prices is triggered,\n///           which would only succeed if reserve price feeds for collateral tokens are set in the price oracle\n///         - health factor range check is made using normal prices, which, under certain circumstances, may be\n///           mutually exclusive with the former\n///         - liquidator premium and DAO fee are the same as for the full liquidation in a given credit manager\n///           (although fees are sent to the treasury instead of being deposited into pools)\n///         - this implementation can't handle fee-on-transfer underlyings\n/// @dev Requires permissions for `withdrawCollateral` and `decreaseDebt` calls in the bot list\ncontract PartialLiquidationBotV3 is IPartialLiquidationBotV3, ContractsRegisterTrait, ReentrancyGuardTrait {\n    /// @dev Internal liquidation variables\n    struct LiquidationVars {\n        address creditManager;\n        address creditFacade;\n        address priceOracle;\n        address underlying;\n        uint256 feeLiquidation;\n        uint256 liquidationDiscount;\n    }\n\n    /// @inheritdoc IVersion\n    uint256 public constant override version = 3_00;\n\n    /// @inheritdoc IPartialLiquidationBotV3\n    address public immutable override treasury;\n\n    /// @inheritdoc IPartialLiquidationBotV3\n    uint16 public immutable override minHealthFactor;\n\n    /// @inheritdoc IPartialLiquidationBotV3\n    uint16 public immutable override maxHealthFactor;\n\n    /// @inheritdoc IPartialLiquidationBotV3\n    uint16 public immutable override premiumScaleFactor;\n\n    /// @inheritdoc IPartialLiquidationBotV3\n    uint16 public immutable override feeScaleFactor;\n\n    /// @notice Constructor\n    /// @param addressProvider Address provider contract address\n    /// @param minHealthFactor_ Minimum health factor to trigger the liquidation\n    /// @param maxHealthFactor_ Maximum health factor to allow after the liquidation\n    /// @param premiumScaleFactor_ Factor to scale credit manager's liquidation premium\n    /// @param feeScaleFactor_ Factor to scale credit manager's liquidation fee\n    /// @dev This bot can be set up in a liquidation prevention mode, which triggers earlier (if min HF is > 1),\n    ///      limits size (if max HF is < `type(uint16).max`) and charges less (if premium and fee scale are < 1)\n    constructor(\n        address addressProvider,\n        uint16 minHealthFactor_,\n        uint16 maxHealthFactor_,\n        uint16 premiumScaleFactor_,\n        uint16 feeScaleFactor_\n    ) ContractsRegisterTrait(addressProvider) {\n        treasury = IAddressProviderV3(addressProvider).getAddressOrRevert(AP_TREASURY, NO_VERSION_CONTROL);\n        if (maxHealthFactor_ < PERCENTAGE_FACTOR || maxHealthFactor_ < minHealthFactor_) {\n            revert IncorrectParameterException();\n        }\n        minHealthFactor = minHealthFactor_;\n        maxHealthFactor = maxHealthFactor_;\n        premiumScaleFactor = premiumScaleFactor_;\n        feeScaleFactor = feeScaleFactor_;\n    }\n\n    // ----------- //\n    // LIQUIDATION //\n    // ----------- //\n\n    /// @inheritdoc IPartialLiquidationBotV3\n    function liquidateExactDebt(\n        address creditAccount,\n        address token,\n        uint256 repaidAmount,\n        uint256 minSeizedAmount,\n        address to,\n        PriceUpdate[] calldata priceUpdates\n    ) external override nonReentrant returns (uint256 seizedAmount) {\n        LiquidationVars memory vars = _initVars(creditAccount);\n        _applyOnDemandPriceUpdates(vars, priceUpdates);\n        _validateLiquidation(vars, creditAccount, token);\n\n        seizedAmount = IPriceOracleV3(vars.priceOracle).convert(repaidAmount, vars.underlying, token)\n            * PERCENTAGE_FACTOR / vars.liquidationDiscount;\n        if (seizedAmount < minSeizedAmount) revert SeizedLessThanRequiredException();\n\n        _executeLiquidation(vars, creditAccount, token, repaidAmount, seizedAmount, to);\n        _checkHealthFactor(vars, creditAccount);\n    }\n\n    /// @inheritdoc IPartialLiquidationBotV3\n    function liquidateExactCollateral(\n        address creditAccount,\n        address token,\n        uint256 seizedAmount,\n        uint256 maxRepaidAmount,\n        address to,\n        PriceUpdate[] calldata priceUpdates\n    ) external override nonReentrant returns (uint256 repaidAmount) {\n        LiquidationVars memory vars = _initVars(creditAccount);\n        _applyOnDemandPriceUpdates(vars, priceUpdates);\n        _validateLiquidation(vars, creditAccount, token);\n\n        repaidAmount = IPriceOracleV3(vars.priceOracle).convert(seizedAmount, token, vars.underlying)\n            * vars.liquidationDiscount / PERCENTAGE_FACTOR;\n        if (repaidAmount > maxRepaidAmount) revert RepaidMoreThanAllowedException();\n\n        _executeLiquidation(vars, creditAccount, token, repaidAmount, seizedAmount, to);\n        _checkHealthFactor(vars, creditAccount);\n    }\n\n    // --------- //\n    // INTERNALS //\n    // --------- //\n\n    /// @dev Loads state variables used in `creditAccount` liquidation\n    function _initVars(address creditAccount) internal view returns (LiquidationVars memory vars) {\n        vars.creditManager = ICreditAccountV3(creditAccount).creditManager();\n        vars.creditFacade = ICreditManagerV3(vars.creditManager).creditFacade();\n        vars.priceOracle = ICreditManagerV3(vars.creditManager).priceOracle();\n        vars.underlying = ICreditManagerV3(vars.creditManager).underlying();\n        (, uint256 feeLiquidation, uint256 liquidationDiscount,,) = ICreditManagerV3(vars.creditManager).fees();\n        vars.liquidationDiscount =\n            PERCENTAGE_FACTOR - (PERCENTAGE_FACTOR - liquidationDiscount) * premiumScaleFactor / PERCENTAGE_FACTOR;\n        vars.feeLiquidation = feeLiquidation * feeScaleFactor / PERCENTAGE_FACTOR;\n    }\n\n    /// @dev Applies on-demand price feed updates, reverts if trying to update unknown price feeds\n    function _applyOnDemandPriceUpdates(LiquidationVars memory vars, PriceUpdate[] calldata priceUpdates) internal {\n        uint256 len = priceUpdates.length;\n        for (uint256 i; i < len; ++i) {\n            PriceUpdate calldata update = priceUpdates[i];\n            address priceFeed = IPriceOracleV3(vars.priceOracle).priceFeedsRaw(update.token, update.reserve);\n            if (priceFeed == address(0)) revert PriceFeedDoesNotExistException();\n            IUpdatablePriceFeed(priceFeed).updatePrice(update.data);\n        }\n    }\n\n    /// @dev Ensures that `creditAccount` is liquidatable, its credit manager is registered and `token` is not underlying\n    function _validateLiquidation(LiquidationVars memory vars, address creditAccount, address token) internal view {\n        _ensureRegisteredCreditManager(vars.creditManager);\n        if (token == vars.underlying) revert UnderlyingNotLiquidatableException();\n        if (!_isLiquidatable(_calcDebtAndCollateral(vars.creditManager, creditAccount), minHealthFactor)) {\n            revert CreditAccountNotLiquidatableException();\n        }\n    }\n\n    /// @dev Executes partial liquidation:\n    ///      - transfers `repaidAmount` of underlying from the caller to `creditAccount`\n    ///      - performs a multicall on `creditAccount` that repays debt, withdraws fee to the treasury,\n    ///        and withdraws `seizedAmount` of `token` to `to`\n    function _executeLiquidation(\n        LiquidationVars memory vars,\n        address creditAccount,\n        address token,\n        uint256 repaidAmount,\n        uint256 seizedAmount,\n        address to\n    ) internal {\n        IERC20(vars.underlying).transferFrom(msg.sender, creditAccount, repaidAmount);\n        uint256 fee = repaidAmount * vars.feeLiquidation / PERCENTAGE_FACTOR;\n        repaidAmount -= fee;\n\n        MultiCall[] memory calls = new MultiCall[](3);\n        calls[0] = MultiCall({\n            target: vars.creditFacade,\n            callData: abi.encodeCall(ICreditFacadeV3Multicall.decreaseDebt, (repaidAmount))\n        });\n        calls[1] = MultiCall({\n            target: vars.creditFacade,\n            callData: abi.encodeCall(ICreditFacadeV3Multicall.withdrawCollateral, (vars.underlying, fee, treasury))\n        });\n        calls[2] = MultiCall({\n            target: vars.creditFacade,\n            callData: abi.encodeCall(ICreditFacadeV3Multicall.withdrawCollateral, (token, seizedAmount, to))\n        });\n        ICreditFacadeV3(vars.creditFacade).botMulticall(creditAccount, calls);\n\n        emit LiquidatePartial(vars.creditManager, creditAccount, token, repaidAmount, seizedAmount, fee);\n    }\n\n    /// @dev Ensures that `creditAccount`'s health factor is within allowed range after partial liquidation\n    function _checkHealthFactor(LiquidationVars memory vars, address creditAccount) internal view {\n        if (minHealthFactor <= PERCENTAGE_FACTOR && maxHealthFactor == type(uint16).max) return;\n        CollateralDebtData memory cdd = _calcDebtAndCollateral(vars.creditManager, creditAccount);\n        if (minHealthFactor > PERCENTAGE_FACTOR && _isLiquidatable(cdd, minHealthFactor)) {\n            revert LiquidatedLessThanNeededException();\n        }\n        if (maxHealthFactor != type(uint16).max && !_isLiquidatable(cdd, maxHealthFactor + 1)) {\n            revert LiquidatedMoreThanNeededException();\n        }\n    }\n\n    /// @dev Returns `creditAccount`'s collateral and debt data\n    function _calcDebtAndCollateral(address creditManager, address creditAccount)\n        internal\n        view\n        returns (CollateralDebtData memory)\n    {\n        return ICreditManagerV3(creditManager).calcDebtAndCollateral(creditAccount, CollateralCalcTask.DEBT_COLLATERAL);\n    }\n\n    /// @dev Checks whether account's health factor is below `healthFactor`\n    function _isLiquidatable(CollateralDebtData memory cdd, uint16 healthFactor) internal pure returns (bool) {\n        return cdd.twvUSD < cdd.totalDebtUSD * healthFactor / PERCENTAGE_FACTOR;\n    }\n}"
    }
  ]
}