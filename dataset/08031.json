{
  "Title": "[H-03] A majority attack can easily bypass Zora auction stage in OpenseaProposal and steal the NFT from the party.",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ListOnZoraProposal.sol#L176-L183\n\n\n# Vulnerability details\n\n## Description\nThe PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. One of the main protections is that before listing the NFT on Opensea for a proposal-supplied price, it must first try to be auctioned off on Zora. To move from Zora stage to Opensea stage, _settleZoraAuction() is called when executing ListedOnZora step in ListOnOpenseaProposal.sol. If the function returns false, the next step is executed which lists the item on Opensea. It is assumed that if majority attack proposal reaches this stage, it can steal the NFT for free, because it can list the item for negligible price and immediately purchase it from a contract that executes the Opensea proposal. \n\nIndeed, attacker can always make settleZoraAuction() return false. Looking at  the code:\n```\ntry ZORA.endAuction(auctionId) {\n            // Check whether auction cancelled due to a failed transfer during\n            // settlement by seeing if we now possess the NFT.\n            if (token.safeOwnerOf(tokenId) == address(this)) {\n                emit ZoraAuctionFailed(auctionId);\n                return false;\n            }\n        } catch (bytes memory errData) {\n```\nAs the comment already hints, an auction can be cancelled if the NFT transfer to the bidder fails. This is the relevant AuctionHouse code (endAuction):\n```\n{\n            // transfer the token to the winner and pay out the participants below\n            try IERC721(auctions[auctionId].tokenContract).safeTransferFrom(address(this), auctions[auctionId].bidder, auctions[auctionId].tokenId) {} catch {\n                _handleOutgoingBid(auctions[auctionId].bidder, auctions[auctionId].amount, auctions[auctionId].auctionCurrency);\n                _cancelAuction(auctionId);\n                return;\n }\n```\nAs most NFTs inherit from OpenZeppelin's ERC721.sol code, safeTransferFrom will run:\n```\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n```\nSo, attacker can bid a very high amount on the NFT to ensure it is the winning bid. When AuctionHouse tries to send the NFT to attacker, the safeTransferFrom will fail because attack will not implement an ERC721Receiver. This will force the AuctionHouse to return the bid amount to the bidder and cancel the auction. Importantly, it will lead to a graceful return from endAuction(), which will make settleZoraAuction() return false and progress to the OpenSea stage.\n\n## Impact\nA majority attack can easily bypass Zora auction stage and steal the NFT from the party.\n\n## Proof of Concept\n1. Pass a ListOnOpenseaProposal with a tiny list price and execute it\n2. Create an attacker contract which bids on the NFT an overpriced amount, but does not implement ERC721Receiver. Call its bid() function\n3. Wait for the auction to end ( timeout after the bid() call)\n4. Create a contract with a function which calls execute() on the proposal and immediately buys the item on Seaport. Call the attack function.\n\n## Tools Used\nManual audit.\n\n## Recommended Mitigation Steps\n_settleZoraAuction is called from both ListOnZoraProposal and ListOnOpenseaProposal. If the auction was cancelled due to a failed transfer, as is described in the comment, we would like to handle it differently for each proposal type. For ListOnZoraProposal, it should indeed return false, in order to finish executing the proposal and not to hang the engine. For ListOnOpenseaProposal, the desired behavior is to *revert* in the case of a failed transfer. This is because the next stage is risky and defense against the mentioned attack is required. Therefore, pass a revertOnFail flag to _settleZoraAuction, which will be used like so:\n```\n// Check whether auction cancelled due to a failed transfer during\n// settlement by seeing if we now possess the NFT.\nif (token.safeOwnerOf(tokenId) == address(this)) {\n\tif (revertOnFail) {\n\t\trevert(\"Zora auction failed because of transfer to bidder\")\n\t}\n           emit ZoraAuctionFailed(auctionId);\n           return false;\n}\n```\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/proposals/ListOnZoraProposal.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../utils/LibSafeCast.sol\";\n\nimport \"../vendor/markets/IZoraAuctionHouse.sol\";\nimport \"./IProposalExecutionEngine.sol\";\nimport \"./ZoraHelpers.sol\";\n\n// Implements proposals auctioning an NFT on Zora. Inherited by the `ProposalExecutionEngine`.\n// This contract will be delegatecall'ed into by `Party` proxy instances.\ncontract ListOnZoraProposal is ZoraHelpers {\n    using LibRawResult for bytes;\n    using LibSafeERC721 for IERC721;\n    using LibSafeCast for uint256;\n\n    enum ZoraStep {\n        // Proposal has not been executed yet and should be listed on Zora.\n        None,\n        // Proposal was previously executed and the NFT is already listed on Zora.\n        ListedOnZora\n    }\n\n    // ABI-encoded `proposalData` passed into execute.\n    struct ZoraProposalData {\n        // The minimum bid (ETH) for the NFT.\n        uint256 listPrice;\n        // How long before the auction can be cancelled if no one bids.\n        uint40 timeout;\n        // How long the auction lasts once a person bids on it.\n        uint40 duration;\n        // The token contract of the NFT being listed.\n        IERC721 token;\n        // The token ID of the NFT being listed.\n        uint256 tokenId;\n    }\n\n    error ZoraListingNotExpired(uint256 auctionId, uint40 expiry);\n\n    event ZoraAuctionCreated(\n        uint256 auctionId,\n        IERC721 token,\n        uint256 tokenId,\n        uint256 startingPrice,\n        uint40 duration,\n        uint40 timeoutTime\n    );\n    event ZoraAuctionExpired(uint256 auctionId, uint256 expiry);\n    event ZoraAuctionSold(uint256 auctionId);\n    event ZoraAuctionFailed(uint256 auctionId);\n\n    // keccak256(abi.encodeWithSignature('Error(string)', \"Auction hasn't begun\"))\n    bytes32 constant internal AUCTION_HASNT_BEGUN_ERROR_HASH =\n        0x54a53788b7942d79bb6fcd40012c5e867208839fa1607e1f245558ee354e9565;\n    // keccak256(abi.encodeWithSignature('Error(string)', \"Auction doesn't exit\"))\n    bytes32 constant internal AUCTION_DOESNT_EXIST_ERROR_HASH =\n        0x474ba0184a7cd5de777156a56f3859150719340a6974b6ee50f05c58139f4dc2;\n    /// @notice Zora auction house contract.\n    IZoraAuctionHouse public immutable ZORA;\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and itâ€™s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    // Set immutables.\n    constructor(IGlobals globals, IZoraAuctionHouse zoraAuctionHouse) {\n        ZORA = zoraAuctionHouse;\n        _GLOBALS = globals;\n    }\n\n    // Auction an NFT we hold on Zora.\n    // Calling this the first time will create a Zora auction.\n    // Calling this the second time will either cancel or finalize the auction.\n    function _executeListOnZora(\n        IProposalExecutionEngine.ExecuteProposalParams memory params\n    )\n        internal\n        returns (bytes memory nextProgressData)\n    {\n        (ZoraProposalData memory data) = abi.decode(params.proposalData, (ZoraProposalData));\n        // If there is progressData passed in, we're on the first step,\n        // otherwise parse the first word of the progressData as the current step.\n        ZoraStep step = params.progressData.length == 0\n            ? ZoraStep.None\n            : abi.decode(params.progressData, (ZoraStep));\n        if (step == ZoraStep.None) {\n            // Proposal hasn't executed yet.\n            {\n                // Clamp the Zora auction duration to the global minimum and maximum.\n                uint40 minDuration = uint40(_GLOBALS.getUint256(LibGlobals.GLOBAL_ZORA_MIN_AUCTION_DURATION));\n                uint40 maxDuration = uint40(_GLOBALS.getUint256(LibGlobals.GLOBAL_ZORA_MAX_AUCTION_DURATION));\n                if (minDuration != 0 && data.duration < minDuration) {\n                    data.duration = minDuration;\n                } else if (maxDuration != 0 && data.duration > maxDuration) {\n                    data.duration = maxDuration;\n                }\n                // Clamp the Zora auction timeout to the global maximum.\n                uint40 maxTimeout = uint40(_GLOBALS.getUint256(LibGlobals.GLOBAL_ZORA_MAX_AUCTION_TIMEOUT));\n                if (maxTimeout != 0 && data.timeout > maxTimeout) {\n                    data.timeout = maxTimeout;\n                }\n            }\n            // Create a Zora auction for the NFT.\n            uint256 auctionId = _createZoraAuction(\n                data.listPrice,\n                data.timeout,\n                data.duration,\n                data.token,\n                data.tokenId\n            );\n            return abi.encode(ZoraStep.ListedOnZora, ZoraProgressData({\n                auctionId: auctionId,\n                minExpiry: (block.timestamp + data.timeout).safeCastUint256ToUint40()\n            }));\n        }\n        assert(step == ZoraStep.ListedOnZora);\n        (, ZoraProgressData memory pd) =\n            abi.decode(params.progressData, (ZoraStep, ZoraProgressData));\n        _settleZoraAuction(pd.auctionId, pd.minExpiry, data.token, data.tokenId);\n        // Nothing left to do.\n        return \"\";\n    }\n\n    // Transfer and create a Zora auction for the `token` + `tokenId`.\n    function _createZoraAuction(\n        // The minimum bid.\n        uint256 listPrice,\n        // How long the auction must wait for the first bid.\n        uint40 timeout,\n        // How long the auction will run for once a bid has been placed.\n        uint40 duration,\n        IERC721 token,\n        uint256 tokenId\n    )\n        internal\n        override\n        returns (uint256 auctionId)\n    {\n        token.approve(address(ZORA), tokenId);\n        auctionId = ZORA.createAuction(\n            tokenId,\n            token,\n            duration,\n            listPrice,\n            payable(address(0)),\n            0,\n            IERC20(address(0)) // Indicates ETH sale\n        );\n        emit ZoraAuctionCreated(\n            auctionId,\n            token,\n            tokenId,\n            listPrice,\n            uint40(duration),\n            uint40(block.timestamp + timeout)\n        );\n    }\n\n    // Either cancel or finalize a Zora auction.\n    function _settleZoraAuction(\n        uint256 auctionId,\n        uint40 minExpiry,\n        IERC721 token,\n        uint256 tokenId\n    )\n        internal\n        override\n        returns (bool sold)\n    {\n        // Getting the state of an auction is super expensive so it seems\n        // cheaper to just let `endAuction()` fail and react to the error.\n        try ZORA.endAuction(auctionId) {\n            // Check whether auction cancelled due to a failed transfer during\n            // settlement by seeing if we now possess the NFT.\n            if (token.safeOwnerOf(tokenId) == address(this)) {\n                emit ZoraAuctionFailed(auctionId);\n                return false;\n            }\n        } catch (bytes memory errData) {\n            bytes32 errHash = keccak256(errData);\n            if (errHash == AUCTION_HASNT_BEGUN_ERROR_HASH) {\n                // No bids placed.\n                // Cancel if we're past the timeout.\n                if (minExpiry > uint40(block.timestamp)) {\n                    revert ZoraListingNotExpired(auctionId, minExpiry);\n                }\n                ZORA.cancelAuction(auctionId);\n                emit ZoraAuctionExpired(auctionId, minExpiry);\n                return false;\n            } else if (errHash != AUCTION_DOESNT_EXIST_ERROR_HASH) {\n                // Otherwise, we should get an auction doesn't exist error,\n                // because someone else must have called `endAuction()`.\n                // If we didn't then something is wrong, so revert.\n                errData.rawRevert();\n            }\n            // Already ended by someone else. Nothing to do.\n        }\n        emit ZoraAuctionSold(auctionId);\n        return true;\n    }\n}"
    }
  ]
}