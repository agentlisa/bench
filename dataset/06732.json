{
  "Title": "[L-02] Not validating `MIN_APPLICATION_PERIOD` can lead to stolen funds",
  "Content": "\n`MIN_APPLICATION_PERIOD` is defined on the `Frankencoin` constructor and is immutable. In case the contracts are deployed with `_minApplicationPeriod = 0`, an attacker can become a minter, burn the token and steal assets on other contracts like the `StablecoinBridge`.\n\n```solidity\n   constructor(uint256 _minApplicationPeriod) ERC20(18){\n      MIN_APPLICATION_PERIOD = _minApplicationPeriod;\n      reserve = new Equity(this);\n   }\n```\n\n[Link to code](https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Frankencoin.sol#L59-L62)\n\n### Recommended Mitigation Steps\n\nValidate that the `MIN_APPLICATION_PERIOD` is greater than some minimum value in the constructor.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-frankencoin",
  "Code": [
    {
      "filename": "contracts/Frankencoin.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC20PermitLight.sol\";\nimport \"./Equity.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\n\n/**\n * The Frankencoin (ZCHF) is an ERC-20 token that is designed to track the value of the Swiss franc.\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\n *\n * The underlying assumption is that there is one or more qualified pool share (FPS) holders that watch the proposals\n * and veto if necessary. At the same time, it is also assumed that no one vetoes all of them, thereby starving the\n * system. The system can only function as long as all the qualified shareholders act in the interest of the system\n * or at least do not actively sabotage it. As long as everyone believes that the governance works well, no one will\n * ever make an unsound proposal and it won't be necessary to ever cast a veto, making the system self-governing.\n */\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\n\n   /**\n    * Minimal fee and application period when suggesting a new minter.\n    */\n   uint256 public constant MIN_FEE = 1000 * (10**18);\n   uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\n\n   /**\n    * The contract that holds the reserve.\n    */\n   IReserve override public immutable reserve;\n\n   /**\n    * How much of the reserve belongs to the minters.\n    * Everything else belongs to the pool share holders.\n    * Stored with 6 additional digits of accuracy so no rounding is necessary\n    * when dealing with parts per million (ppm) in reserve calculations.\n    */\n   uint256 private minterReserveE6;\n\n   /**\n    * Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\n    * to mint Frankencoins.\n    */\n   mapping (address => uint256) public minters;\n\n   /**\n    * List of positions that are allowed to mint and the minter that registered them.\n    */\n   mapping (address => address) public positions;\n\n   event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\n   event MinterDenied(address indexed minter, string message);\n\n   /**\n    * Initiates the Frankencoin with the provided minimum application period for new plugins\n    * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\n    */\n   constructor(uint256 _minApplicationPeriod) ERC20(18){\n      MIN_APPLICATION_PERIOD = _minApplicationPeriod;\n      reserve = new Equity(this);\n   }\n\n   function name() override external pure returns (string memory){\n      return \"Frankencoin\";\n   }\n\n   function symbol() override external pure returns (string memory){\n      return \"ZCHF\";\n   }\n\n   /**\n    * Publicly accessible method to suggest a new way of minting Frankencoins.\n    *\n    * The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\n    *\n    * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\n    * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees above\n    * the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message parameter\n    * might be useful for initiating further communication. Maybe it contains a link to a website describing the proposed\n    * minter.\n    */\n   function suggestMinter(address _minter, uint256 _applicationPeriod, uint256 _applicationFee, string calldata _message) override external {\n      if (_applicationPeriod < MIN_APPLICATION_PERIOD && totalSupply() > 0) revert PeriodTooShort();\n      if (_applicationFee < MIN_FEE  && totalSupply() > 0) revert FeeTooLow();\n      if (minters[_minter] != 0) revert AlreadyRegistered();\n      _transfer(msg.sender, address(reserve), _applicationFee);\n      minters[_minter] = block.timestamp + _applicationPeriod;\n      emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\n   }\n\n   error PeriodTooShort();\n   error FeeTooLow();\n   error AlreadyRegistered();\n\n   /**\n    * Make the system more user friendly by skipping the allowance in many cases.\n    *\n    * We trust minters and the positions they have created to mint and burn as they please, so\n    * giving them arbitraty allowances does not pose an additional risk.\n    */\n   function allowanceInternal(address owner, address spender) internal view override returns (uint256) {\n      uint256 explicit = super.allowanceInternal(owner, spender);\n      if (explicit > 0){\n         return explicit; // don't waste gas checking minter\n      } else if (isMinter(spender) || isMinter(isPosition(spender))){\n         return INFINITY;\n      } else {\n         return 0;\n      }\n   }\n\n   /**\n    * The reserve provided by the owners of collateralized positions.\n    * The minter reserve can be used to cover losses after all else failed and the equity holders have already been wiped out.\n    */\n   function minterReserve() public view returns (uint256) {\n      return minterReserveE6 / 1000000;\n   }\n\n   /**\n    * Registers a collateralized debt position, thereby giving it the ability to mint Frankencoins.\n    * It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\n    */\n   function registerPosition(address _position) override external {\n      if (!isMinter(msg.sender)) revert NotMinter();\n      positions[_position] = msg.sender;\n   }\n\n   error NotMinter();\n\n   /**\n    * The amount of equity of the Frankencoin system in ZCHF, owned by the holders of Frankencoin Pool Shares.\n    * Note that the equity contract technically holds both the minter reserve as well as the equity, so the minter\n    * reserve must be subtracted. All fees and other kind of income is added to the Equity contract and essentially\n    * constitutes profits attributable to the pool share holders.\n    */\n   function equity() public view returns (uint256) {\n      uint256 balance = balanceOf(address(reserve));\n      uint256 minReserve = minterReserve();\n      if (balance <= minReserve){\n        return 0;\n      } else {\n        return balance - minReserve;\n      }\n    }\n\n   /**\n    * Qualified pool share holders can deny minters during the application period.\n    * Calling this function is relatively cheap thanks to the deletion of a storage slot.\n    */\n   function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) override external {\n      if (block.timestamp > minters[_minter]) revert TooLate();\n      reserve.checkQualified(msg.sender, _helpers);\n      delete minters[_minter];\n      emit MinterDenied(_minter, _message);\n   }\n\n   error TooLate();\n\n   /**\n    * Mints the provided amount of ZCHF to the target address, automatically forwarding\n    * the minting fee and the reserve to the right place.\n    */\n   function mint(address _target, uint256 _amount, uint32 _reservePPM, uint32 _feesPPM) override external minterOnly {\n      uint256 usableMint = (_amount * (1000_000 - _feesPPM - _reservePPM)) / 1000_000; // rounding down is fine\n      _mint(_target, usableMint);\n      _mint(address(reserve), _amount - usableMint); // rest goes to equity as reserves or as fees\n      minterReserveE6 += _amount * _reservePPM; // minter reserve must be kept accurately in order to ensure we can get back to exactly 0\n   }\n\n   function mint(address _target, uint256 _amount) override external minterOnly {\n      _mint(_target, _amount);\n   }\n\n   /**\n    * Anyone is allowed to burn their ZCHF.\n    */\n   function burn(uint256 _amount) external {\n      _burn(msg.sender, _amount);\n   }\n\n   /**\n    * Burn that amount without reclaiming the reserve, but freeing it up and thereby essentially donating it to the pool\n    * share holders. This can make sense in combination with 'notifyLoss', i.e. when it is the pool share holders that bear the risk\n    * and depending on the outcome they make a profit or a loss.\n    *\n    * Design rule: Minters calling this method are only allowed to so for tokens amounts they previously minted with the same _reservePPM amount.\n    *\n    * For example, if someone minted 50 ZCHF earlier with a 20% reserve requirement (200000 ppm), they got 40 ZCHF and paid\n    * 10 ZCHF into the reserve. Now they want to repay the debt by burning 50 ZCHF. When doing so using this method, 50 ZCHF get\n    * burned and on top of that, 10 ZCHF previously assigned to the minter's reserved are reassigned to the pool share holders.\n    */\n   function burn(uint256 amount, uint32 reservePPM) external override minterOnly {\n      _burn(msg.sender, amount);\n      minterReserveE6 -= amount * reservePPM;\n   }\n\n   /**\n    * Calculates the reserve attributable to someone who minted the given amount with the given reserve requirement.\n    * Under normal circumstances, this is just the reserver requirement multiplied by the amount. However, after a severe loss\n    * of capital that burned into the minter's reserve, this can also be less than that.\n    */\n   function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\n      uint256 theoreticalReserve = _reservePPM * mintedAmount / 1000000;\n      uint256 currentReserve = balanceOf(address(reserve));\n      if (currentReserve < minterReserve()){\n         // not enough reserves, owner has to take a loss\n         return theoreticalReserve * currentReserve / minterReserve();\n      } else {\n         return theoreticalReserve;\n      }\n   }\n\n   /**\n    * Burns the target amount taking the tokens to be burned from the payer and the payer's reserve.\n    * The caller is only allowed to use this method for tokens also minted through the caller with the same _reservePPM amount.\n    *\n    * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm). To burn half\n    * of that again, the minter calls burnFrom with a target amount of 50 ZCHF. Assuming that reserves are only 90% covered,\n    * this call will deduct 41 ZCHF from the payer's balance and 9 from the reserve, while reducing the minter reserve by 10.\n    */\n   function burnFrom(address payer, uint256 targetTotalBurnAmount, uint32 _reservePPM) external override minterOnly returns (uint256) {\n      uint256 assigned = calculateAssignedReserve(targetTotalBurnAmount, _reservePPM);\n      _transfer(address(reserve), payer, assigned); // send reserve to owner\n      _burn(payer, targetTotalBurnAmount); // and burn the full amount from the owner's address\n      minterReserveE6 -= targetTotalBurnAmount * _reservePPM; // reduce reserve requirements by original ratio\n      return assigned;\n   }\n\n   /**\n    * Calculate the amount that is freed when returning amountExcludingReserve given a reserve ratio of reservePPM, taking\n    * into account potential losses. Example values in the comments.\n    */\n   function calculateFreedAmount(uint256 amountExcludingReserve /* 41 */, uint32 reservePPM /* 20% */) public view returns (uint256){\n      uint256 currentReserve = balanceOf(address(reserve)); // 18, 10% below what we should have\n      uint256 minterReserve_ = minterReserve(); // 20\n      uint256 adjustedReservePPM = currentReserve < minterReserve_ ? reservePPM * currentReserve / minterReserve_ : reservePPM; // 18%\n      return 1000000 * amountExcludingReserve / (1000000 - adjustedReservePPM); // 41 / (1-18%) = 50\n   }\n\n   /**\n    * Burns the provided number of tokens plus whatever reserves are associated with that amount given the reserve requirement.\n    * The caller is only allowed to use this method for tokens also minted through the caller with the same _reservePPM amount.\n    *\n    * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm). Now they have\n    * 41 ZCHF that they do not need so they decide to repay that amount. Assuming the reserves are only 90% covered,\n    * the call to burnWithReserve will burn the 41 plus 9 from the reserve, reducing the outstanding 'debt' of the caller by\n    * 50 ZCHF in total. This total is returned by the method so the caller knows how much less they owe.\n    */\n   function burnWithReserve(uint256 _amountExcludingReserve, uint32 _reservePPM) external override minterOnly returns (uint256) {\n      uint256 freedAmount = calculateFreedAmount(_amountExcludingReserve, _reservePPM);\n      minterReserveE6 -= freedAmount * _reservePPM; // reduce reserve requirements by original ratio\n      _transfer(address(reserve), msg.sender, freedAmount - _amountExcludingReserve); // collect assigned reserve, maybe less than original reserve\n      _burn(msg.sender, freedAmount); // burn the rest of the freed amount\n      return freedAmount;\n   }\n\n   /**\n    * Burn someone elses ZCHF.\n    */\n   function burn(address _owner, uint256 _amount) override external minterOnly {\n      _burn(_owner, _amount);\n   }\n\n   modifier minterOnly() {\n      if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\n      _;\n   }\n\n   /**\n    * Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins\n    * are literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\n    * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\n    *\n    * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with the\n    * house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered by the \n    * reserve.\n    */\n   function notifyLoss(uint256 _amount) override external minterOnly {\n      uint256 reserveLeft = balanceOf(address(reserve));\n      if (reserveLeft >= _amount){\n         _transfer(address(reserve), msg.sender, _amount);\n      } else {\n         _transfer(address(reserve), msg.sender, reserveLeft);\n         _mint(msg.sender, _amount - reserveLeft);\n      }\n   }\n\n   /**\n    * Returns true if the address is an approved minter.\n    */\n   function isMinter(address _minter) override public view returns (bool){\n      return minters[_minter] != 0 && block.timestamp >= minters[_minter];\n   }\n\n   /**\n    * Returns the address of the minter that created this position or null if the provided address is unknown.\n    */\n   function isPosition(address _position) override public view returns (address){\n      return positions[_position];\n   }\n\n}"
    }
  ]
}