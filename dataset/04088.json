{
  "Title": "Gas overflow during iteration (DoS)",
  "Content": "##### Description\nEach iteration of the cycle requires a gas flow.\nA moment may come when more gas is required than it is allocated to record one block. In this case, all iterations of the loop will fail.\nAffected lines:\n* https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/factories/PieFactoryContract.sol#L72\n* https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/Call/CallFacet.sol#L43\n* https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/Call/CallFacet.sol#L67\n* https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/Call/CallFacet.sol#L81\n* https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/Basket/BasketFacet.sol on lines 45, 126, 158, 274, 296\n\n##### Recommendation\nWe recommend adding a check for the maximum possible number of elements of the arrays.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/factories/PieFactoryContract.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"diamond-2/contracts/Diamond.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/IExperiPie.sol\";\n\ncontract PieFactoryContract is Ownable {\n    using SafeERC20 for IERC20;\n\n    address[] public pies;\n    mapping(address => bool) public isPie;\n    address public defaultController;\n\n    IDiamondCut.FacetCut[] public defaultCut;\n\n    event PieCreated(\n        address indexed pieAddress,\n        address indexed deployer,\n        uint256 indexed index\n    );\n\n    event DefaultControllerSet(address indexed controller);\n    event FacetAdded(IDiamondCut.FacetCut);\n    event FacetRemoved(IDiamondCut.FacetCut);\n\n    constructor() {\n        defaultController = msg.sender;\n    }\n\n    function setDefaultController(address _controller) external onlyOwner {\n        defaultController = _controller;\n        emit DefaultControllerSet(_controller);\n    }\n\n    function removeFacet(uint256 _index) external onlyOwner {\n        emit FacetRemoved(defaultCut[_index]);\n        defaultCut[_index] = defaultCut[defaultCut.length - 1];\n        defaultCut.pop();\n    }\n\n    function addFacet(IDiamondCut.FacetCut memory _facet) external onlyOwner {\n        defaultCut.push(_facet);\n        emit FacetAdded(_facet);\n    }\n\n    function bakePie(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _initialSupply,\n        string memory _symbol,\n        string memory _name\n    ) external {\n        Diamond d = new Diamond(defaultCut, address(this));\n\n        pies.push(address(d));\n        isPie[address(d)] = true;\n\n        // emit DiamondCreated(address(d));\n        require(_tokens.length != 0, \"CANNOT_CREATE_ZERO_TOKEN_LENGTH_PIE\");\n        require(_tokens.length == _amounts.length, \"ARRAY_LENGTH_MISMATCH\");\n\n        IExperiPie pie = IExperiPie(address(d));\n\n        // Init erc20 facet\n        pie.initialize(_initialSupply, _name, _symbol);\n\n        // Transfer and add tokens\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20 token = IERC20(_tokens[i]);\n            token.safeTransferFrom(msg.sender, address(pie), _amounts[i]);\n            pie.addToken(_tokens[i]);\n        }\n\n        // Unlock pool\n        pie.setLock(1);\n\n        // Uncap pool\n        pie.setCap(uint256(-1));\n\n        // Send minted pie to msg.sender\n        pie.transfer(msg.sender, _initialSupply);\n        pie.transferOwnership(defaultController);\n\n        emit PieCreated(address(d), msg.sender, pies.length - 1);\n    }\n\n    function getDefaultCut()\n        external\n        view\n        returns (IDiamondCut.FacetCut[] memory)\n    {\n        return defaultCut;\n    }\n\n    function getDefaultCutCount() external view returns (uint256) {\n        return defaultCut.length;\n    }\n}"
    },
    {
      "filename": "contracts/facets/Call/CallFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"diamond-2/contracts/libraries/LibDiamond.sol\";\nimport \"../../interfaces/ICallFacet.sol\";\nimport \"../shared/Reentry/ReentryProtection.sol\";\nimport \"../shared/Access/CallProtection.sol\";\nimport \"./LibCallStorage.sol\";\n\ncontract CallFacet is ReentryProtection, ICallFacet {\n\n  // uses modified call protection modifier to also allow whitelisted addresses to call\n  modifier protectedCall() {\n    require(\n        msg.sender == LibDiamond.diamondStorage().contractOwner ||\n        LibCallStorage.callStorage().canCall[msg.sender] ||\n        msg.sender == address(this), \"NOT_ALLOWED\"\n    );\n    _;\n  }\n\n  function addCaller(address _caller) external override {\n    require(msg.sender == LibDiamond.diamondStorage().contractOwner, \"NOT_ALLOWED\");\n    LibCallStorage.CallStorage storage callStorage = LibCallStorage.callStorage();\n\n    require(!callStorage.canCall[_caller], \"IS_ALREADY_CALLER\");\n\n    callStorage.callers.push(_caller);\n    callStorage.canCall[_caller] = true;\n\n    emit CallerAdded(_caller);\n  }\n\n  function removeCaller(address _caller) external override {\n    require(msg.sender == LibDiamond.diamondStorage().contractOwner, \"NOT_ALLOWED\");\n    LibCallStorage.CallStorage storage callStorage = LibCallStorage.callStorage();\n\n    require(callStorage.canCall[_caller], \"IS_NOT_CALLER\");\n\n    callStorage.canCall[_caller] = false;\n\n    for(uint256 i = 0; i < callStorage.callers.length; i ++) {\n      address currentCaller = callStorage.callers[i];\n\n      // if found remove it\n      if(currentCaller == _caller) {\n        callStorage.callers[i] = callStorage.callers[callStorage.callers.length - 1];\n        callStorage.callers.pop();\n        break;\n      }\n    }\n\n    emit CallerRemoved(_caller);\n  }\n\n  function call(\n    address[] memory _targets,\n    bytes[] memory _calldata,\n    uint256[] memory _values\n  ) public override noReentry protectedCall {\n    require(\n      _targets.length == _calldata.length && _values.length == _calldata.length,\n      \"ARRAY_LENGTH_MISMATCH\"\n    );\n\n    for (uint256 i = 0; i < _targets.length; i++) {\n      _call(_targets[i], _calldata[i], _values[i]);\n    }\n  }\n\n  function callNoValue(\n    address[] memory _targets,\n    bytes[] memory _calldata\n  ) public override noReentry protectedCall {\n    require(\n      _targets.length == _calldata.length,\n      \"ARRAY_LENGTH_MISMATCH\"\n    );\n\n    for (uint256 i = 0; i < _targets.length; i++) {\n      _call(_targets[i], _calldata[i], 0);\n    }\n  }\n\n  function singleCall(\n    address _target,\n    bytes calldata _calldata,\n    uint256 _value\n  ) external override noReentry protectedCall {\n    _call(_target, _calldata, _value);\n  }\n\n  function _call(\n    address _target,\n    bytes memory _calldata,\n    uint256 _value\n  ) internal {\n    (bool success, ) = _target.call{ value: _value }(_calldata);\n    require(success, \"CALL_FAILED\");\n    emit Call(_target, _calldata, _value);\n  }\n\n  function canCall(address _caller) external view override returns (bool) {\n    return LibCallStorage.callStorage().canCall[_caller];\n  }\n\n  function getCallers() external view override returns (address[] memory) {\n    return LibCallStorage.callStorage().callers;\n  }\n}"
    },
    {
      "filename": "contracts/facets/Call/CallFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"diamond-2/contracts/libraries/LibDiamond.sol\";\nimport \"../../interfaces/ICallFacet.sol\";\nimport \"../shared/Reentry/ReentryProtection.sol\";\nimport \"../shared/Access/CallProtection.sol\";\nimport \"./LibCallStorage.sol\";\n\ncontract CallFacet is ReentryProtection, ICallFacet {\n\n  // uses modified call protection modifier to also allow whitelisted addresses to call\n  modifier protectedCall() {\n    require(\n        msg.sender == LibDiamond.diamondStorage().contractOwner ||\n        LibCallStorage.callStorage().canCall[msg.sender] ||\n        msg.sender == address(this), \"NOT_ALLOWED\"\n    );\n    _;\n  }\n\n  function addCaller(address _caller) external override {\n    require(msg.sender == LibDiamond.diamondStorage().contractOwner, \"NOT_ALLOWED\");\n    LibCallStorage.CallStorage storage callStorage = LibCallStorage.callStorage();\n\n    require(!callStorage.canCall[_caller], \"IS_ALREADY_CALLER\");\n\n    callStorage.callers.push(_caller);\n    callStorage.canCall[_caller] = true;\n\n    emit CallerAdded(_caller);\n  }\n\n  function removeCaller(address _caller) external override {\n    require(msg.sender == LibDiamond.diamondStorage().contractOwner, \"NOT_ALLOWED\");\n    LibCallStorage.CallStorage storage callStorage = LibCallStorage.callStorage();\n\n    require(callStorage.canCall[_caller], \"IS_NOT_CALLER\");\n\n    callStorage.canCall[_caller] = false;\n\n    for(uint256 i = 0; i < callStorage.callers.length; i ++) {\n      address currentCaller = callStorage.callers[i];\n\n      // if found remove it\n      if(currentCaller == _caller) {\n        callStorage.callers[i] = callStorage.callers[callStorage.callers.length - 1];\n        callStorage.callers.pop();\n        break;\n      }\n    }\n\n    emit CallerRemoved(_caller);\n  }\n\n  function call(\n    address[] memory _targets,\n    bytes[] memory _calldata,\n    uint256[] memory _values\n  ) public override noReentry protectedCall {\n    require(\n      _targets.length == _calldata.length && _values.length == _calldata.length,\n      \"ARRAY_LENGTH_MISMATCH\"\n    );\n\n    for (uint256 i = 0; i < _targets.length; i++) {\n      _call(_targets[i], _calldata[i], _values[i]);\n    }\n  }\n\n  function callNoValue(\n    address[] memory _targets,\n    bytes[] memory _calldata\n  ) public override noReentry protectedCall {\n    require(\n      _targets.length == _calldata.length,\n      \"ARRAY_LENGTH_MISMATCH\"\n    );\n\n    for (uint256 i = 0; i < _targets.length; i++) {\n      _call(_targets[i], _calldata[i], 0);\n    }\n  }\n\n  function singleCall(\n    address _target,\n    bytes calldata _calldata,\n    uint256 _value\n  ) external override noReentry protectedCall {\n    _call(_target, _calldata, _value);\n  }\n\n  function _call(\n    address _target,\n    bytes memory _calldata,\n    uint256 _value\n  ) internal {\n    (bool success, ) = _target.call{ value: _value }(_calldata);\n    require(success, \"CALL_FAILED\");\n    emit Call(_target, _calldata, _value);\n  }\n\n  function canCall(address _caller) external view override returns (bool) {\n    return LibCallStorage.callStorage().canCall[_caller];\n  }\n\n  function getCallers() external view override returns (address[] memory) {\n    return LibCallStorage.callStorage().callers;\n  }\n}"
    },
    {
      "filename": "contracts/facets/Call/CallFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"diamond-2/contracts/libraries/LibDiamond.sol\";\nimport \"../../interfaces/ICallFacet.sol\";\nimport \"../shared/Reentry/ReentryProtection.sol\";\nimport \"../shared/Access/CallProtection.sol\";\nimport \"./LibCallStorage.sol\";\n\ncontract CallFacet is ReentryProtection, ICallFacet {\n\n  // uses modified call protection modifier to also allow whitelisted addresses to call\n  modifier protectedCall() {\n    require(\n        msg.sender == LibDiamond.diamondStorage().contractOwner ||\n        LibCallStorage.callStorage().canCall[msg.sender] ||\n        msg.sender == address(this), \"NOT_ALLOWED\"\n    );\n    _;\n  }\n\n  function addCaller(address _caller) external override {\n    require(msg.sender == LibDiamond.diamondStorage().contractOwner, \"NOT_ALLOWED\");\n    LibCallStorage.CallStorage storage callStorage = LibCallStorage.callStorage();\n\n    require(!callStorage.canCall[_caller], \"IS_ALREADY_CALLER\");\n\n    callStorage.callers.push(_caller);\n    callStorage.canCall[_caller] = true;\n\n    emit CallerAdded(_caller);\n  }\n\n  function removeCaller(address _caller) external override {\n    require(msg.sender == LibDiamond.diamondStorage().contractOwner, \"NOT_ALLOWED\");\n    LibCallStorage.CallStorage storage callStorage = LibCallStorage.callStorage();\n\n    require(callStorage.canCall[_caller], \"IS_NOT_CALLER\");\n\n    callStorage.canCall[_caller] = false;\n\n    for(uint256 i = 0; i < callStorage.callers.length; i ++) {\n      address currentCaller = callStorage.callers[i];\n\n      // if found remove it\n      if(currentCaller == _caller) {\n        callStorage.callers[i] = callStorage.callers[callStorage.callers.length - 1];\n        callStorage.callers.pop();\n        break;\n      }\n    }\n\n    emit CallerRemoved(_caller);\n  }\n\n  function call(\n    address[] memory _targets,\n    bytes[] memory _calldata,\n    uint256[] memory _values\n  ) public override noReentry protectedCall {\n    require(\n      _targets.length == _calldata.length && _values.length == _calldata.length,\n      \"ARRAY_LENGTH_MISMATCH\"\n    );\n\n    for (uint256 i = 0; i < _targets.length; i++) {\n      _call(_targets[i], _calldata[i], _values[i]);\n    }\n  }\n\n  function callNoValue(\n    address[] memory _targets,\n    bytes[] memory _calldata\n  ) public override noReentry protectedCall {\n    require(\n      _targets.length == _calldata.length,\n      \"ARRAY_LENGTH_MISMATCH\"\n    );\n\n    for (uint256 i = 0; i < _targets.length; i++) {\n      _call(_targets[i], _calldata[i], 0);\n    }\n  }\n\n  function singleCall(\n    address _target,\n    bytes calldata _calldata,\n    uint256 _value\n  ) external override noReentry protectedCall {\n    _call(_target, _calldata, _value);\n  }\n\n  function _call(\n    address _target,\n    bytes memory _calldata,\n    uint256 _value\n  ) internal {\n    (bool success, ) = _target.call{ value: _value }(_calldata);\n    require(success, \"CALL_FAILED\");\n    emit Call(_target, _calldata, _value);\n  }\n\n  function canCall(address _caller) external view override returns (bool) {\n    return LibCallStorage.callStorage().canCall[_caller];\n  }\n\n  function getCallers() external view override returns (address[] memory) {\n    return LibCallStorage.callStorage().callers;\n  }\n}"
    }
  ]
}