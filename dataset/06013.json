{
  "Title": "[G-01] State variables which are not modified within functions should be set as constant or immutable for values set at deployment",
  "Content": "\nCache such variables and perform operations on them, if operations include modifications to the state variable(s) then remember to equate the state variable to it's cached counterpart at the end\n\n\n```solidity\nfile:  contracts/helper/FixedOracle.sol\n\n7    address private owner;\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/helper/FixedOracle.sol#L7\n\n```solidity\nfile:  contracts/GeVault.sol\n\n41     RangeManager rangeManager; \n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/GeVault.sol#L41\n\n```solidity\nfile: contracts/TokenisableRange.sol\n\n54   address public TREASURY_DEPRECATED = 0x22Cc3f665ba4C898226353B672c5123c58751692;\n\n55   uint public treasuryFee_deprecated = 20;\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/TokenisableRange.sol#L54\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-08-goodentry",
  "Code": [
    {
      "filename": "contracts/helper/FixedOracle.sol",
      "content": "pragma solidity ^0.8.0;\n\ncontract HardcodedPriceOracle {\n    event SetHardcodedPrice(int256 price);\n\n    int256 private hardcodedPrice;\n    address private owner;\n    \n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this function.\");\n        _;\n    }\n\n    constructor(int256 _hardcodedPrice) {\n        owner = msg.sender;\n        hardcodedPrice = _hardcodedPrice;\n    }\n\n    function latestAnswer() external view returns (int256) {\n        return hardcodedPrice;\n    }\n\n    function setHardcodedPrice(int256 _hardcodedPrice) external onlyOwner {\n        hardcodedPrice = _hardcodedPrice;\n        emit SetHardcodedPrice(_hardcodedPrice);\n    }\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = uint80(block.number);\n        answer = hardcodedPrice;\n        startedAt = block.timestamp;\n        updatedAt = block.timestamp;\n        answeredInRound = roundId;\n    }\n}"
    },
    {
      "filename": "contracts/GeVault.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport \"./openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport \"./openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/IAaveLendingPoolV2.sol\";\nimport \"../interfaces/IUniswapV3Pool.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"./RangeManager.sol\";\nimport \"./RoeRouter.sol\";\n\n\n/**\nGeVault is a reblancing vault that holds TokenisableRanges tickers\nFunctionalities:\n- Hold a list of tickers for a single pair, evenly spaced\n- Hold balances of those tickers, deposited in the ROE LP\n- Deposit one underlying asset split evenly into 2 or more consecutive ticks above/below the current price\n- Withdraw one underlying asset, taken out evenly from 2 or more consecutive ticks\n- Calculate the current balance of assets\n\nDesign:\n \n */\ncontract GeVault is ERC20, Ownable, ReentrancyGuard {\n  using SafeERC20 for ERC20;\n  \n  event Deposit(address indexed sender, address indexed token, uint amount, uint liquidity);\n  event Withdraw(address indexed sender, address indexed token, uint amount, uint liquidity);\n  event PushTick(address indexed ticker);\n  event ShiftTick(address indexed ticker);\n  event ModifyTick(address indexed ticker, uint index);\n  event Rebalance(uint tickIndex);\n  event SetEnabled(bool isEnabled);\n  event SetTreasury(address treasury);\n  event SetFee(uint baseFeeX4);\n  event SetTvlCap(uint tvlCap);\n\n  RangeManager rangeManager; \n  /// @notice Ticks properly ordered in ascending price order\n  TokenisableRange[] public ticks;\n  \n  /// @notice Tracks the beginning of active ticks: the next 4 ticks are the active\n  uint public tickIndex; \n  /// @notice Pair tokens\n  ERC20 public token0;\n  ERC20 public token1;\n  bool public isEnabled = true;\n  /// @notice Pool base fee \n  uint public baseFeeX4 = 20;\n  /// @notice Max vault TVL with 8 decimals\n  uint public tvlCap = 1e12;\n  \n  /// CONSTANTS \n  /// immutable keyword removed for coverage testing bug in brownie\n  address public treasury;\n  IUniswapV3Pool public uniswapPool;\n  ILendingPool public lendingPool;\n  IPriceOracle public oracle;\n  uint public constant nearbyRanges = 2;\n  IWETH public WETH;\n  bool public baseTokenIsToken0;\n  \n\n  constructor(\n    address _treasury, \n    address roeRouter, \n    address _uniswapPool, \n    uint poolId, \n    string memory name, \n    string memory symbol,\n    address weth,\n    bool _baseTokenIsToken0\n  ) \n    ERC20(name, symbol)\n  {\n    require(_treasury != address(0x0), \"GEV: Invalid Treasury\");\n    require(_uniswapPool != address(0x0), \"GEV: Invalid Pool\");\n    require(weth != address(0x0), \"GEV: Invalid WETH\");\n\n    (address lpap, address _token0, address _token1,, ) = RoeRouter(roeRouter).pools(poolId);\n    token0 = ERC20(_token0);\n    token1 = ERC20(_token1);\n    \n    lendingPool = ILendingPool(ILendingPoolAddressesProvider(lpap).getLendingPool());\n    oracle = IPriceOracle(ILendingPoolAddressesProvider(lpap).getPriceOracle());\n    treasury = _treasury;\n    uniswapPool = IUniswapV3Pool(_uniswapPool);\n    WETH = IWETH(weth);\n    baseTokenIsToken0 = _baseTokenIsToken0;\n  }\n  \n  \n  //////// ADMIN\n  \n  \n  /// @notice Set pool status\n  /// @param _isEnabled Pool status\n  function setEnabled(bool _isEnabled) public onlyOwner { \n    isEnabled = _isEnabled; \n    emit SetEnabled(_isEnabled);\n  }\n  \n  /// @notice Set treasury address\n  /// @param newTreasury New address\n  function setTreasury(address newTreasury) public onlyOwner { \n    treasury = newTreasury; \n    emit SetTreasury(newTreasury);\n  }\n\n\n  /// @notice Add a new ticker to the list\n  /// @param tr Tick address\n  function pushTick(address tr) public onlyOwner {\n    TokenisableRange t = TokenisableRange(tr);\n    (ERC20 t0,) = t.TOKEN0();\n    (ERC20 t1,) = t.TOKEN1();\n    require(t0 == token0 && t1 == token1, \"GEV: Invalid TR\");\n    if (ticks.length == 0) ticks.push(t);\n    else {\n      // Check that tick is properly ordered\n      if (baseTokenIsToken0) \n        require( t.lowerTick() > ticks[ticks.length-1].upperTick(), \"GEV: Push Tick Overlap\");\n      else \n        require( t.upperTick() < ticks[ticks.length-1].lowerTick(), \"GEV: Push Tick Overlap\");\n      \n      ticks.push(TokenisableRange(tr));\n    }\n    emit PushTick(tr);\n  }  \n\n\n  /// @notice Add a new ticker to the list\n  /// @param tr Tick address\n  function shiftTick(address tr) public onlyOwner {\n    TokenisableRange t = TokenisableRange(tr);\n    (ERC20 t0,) = t.TOKEN0();\n    (ERC20 t1,) = t.TOKEN1();\n    require(t0 == token0 && t1 == token1, \"GEV: Invalid TR\");\n    if (ticks.length == 0) ticks.push(t);\n    else {\n      // Check that tick is properly ordered\n      if (!baseTokenIsToken0) \n        require( t.lowerTick() > ticks[0].upperTick(), \"GEV: Shift Tick Overlap\");\n      else \n        require( t.upperTick() < ticks[0].lowerTick(), \"GEV: Shift Tick Overlap\");\n      \n      // extend array by pushing last elt\n      ticks.push(ticks[ticks.length-1]);\n      // shift each element\n      if (ticks.length > 2){\n        for (uint k = 0; k < ticks.length - 2; k++) \n          ticks[ticks.length - 2 - k] = ticks[ticks.length - 3 - k];\n        }\n      // add new tick in first place\n      ticks[0] = t;\n    }\n    emit ShiftTick(tr);\n  }\n\n\n  /// @notice Modify ticker\n  /// @param tr New tick address\n  /// @param index Tick to modify\n  function modifyTick(address tr, uint index) public onlyOwner {\n    (ERC20 t0,) = TokenisableRange(tr).TOKEN0();\n    (ERC20 t1,) = TokenisableRange(tr).TOKEN1();\n    require(t0 == token0 && t1 == token1, \"GEV: Invalid TR\");\n    ticks[index] = TokenisableRange(tr);\n    emit ModifyTick(tr, index);\n  }\n  \n  /// @notice Ticks length getter\n  /// @return len Ticks length\n  function getTickLength() public view returns(uint len){\n    len = ticks.length;\n  }\n  \n  /// @notice Set the base fee\n  /// @param newBaseFeeX4 New base fee in E4\n  function setBaseFee(uint newBaseFeeX4) public onlyOwner {\n  require(newBaseFeeX4 < 1e4, \"GEV: Invalid Base Fee\");\n    baseFeeX4 = newBaseFeeX4;\n    emit SetFee(newBaseFeeX4);\n  }\n  \n  /// @notice Set the TVL cap\n  /// @param newTvlCap New TVL cap\n  function setTvlCap(uint newTvlCap) public onlyOwner {\n    tvlCap = newTvlCap;\n    emit SetTvlCap(newTvlCap);\n  }\n  \n  \n  //////// PUBLIC FUNCTIONS\n  \n    \n  /// @notice Rebalance tickers\n  /// @dev Provide the list of tickers from \n  function rebalance() public {\n    require(poolMatchesOracle(), \"GEV: Oracle Error\");\n    removeFromAllTicks();\n    if (isEnabled) deployAssets();\n  }\n  \n\n  /// @notice Withdraw assets from the ticker\n  /// @param liquidity Amount of GEV tokens to redeem; if 0, redeem all\n  /// @param token Address of the token redeemed for\n  /// @return amount Total token returned\n  /// @dev For simplicity+efficieny, withdrawal is like a rebalancing, but a subset of the tokens are sent back to the user before redeploying\n  function withdraw(uint liquidity, address token) public nonReentrant returns (uint amount) {\n    require(poolMatchesOracle(), \"GEV: Oracle Error\");\n    if (liquidity == 0) liquidity = balanceOf(msg.sender);\n    require(liquidity <= balanceOf(msg.sender), \"GEV: Insufficient Balance\");\n    require(liquidity > 0, \"GEV: Withdraw Zero\");\n    \n    uint vaultValueX8 = getTVL();\n    uint valueX8 = vaultValueX8 * liquidity / totalSupply();\n    amount = valueX8 * 10**ERC20(token).decimals() / oracle.getAssetPrice(token);\n    uint fee = amount * getAdjustedBaseFee(token == address(token1)) / 1e4;\n    \n    _burn(msg.sender, liquidity);\n    removeFromAllTicks();\n    ERC20(token).safeTransfer(treasury, fee);\n    uint bal = amount - fee;\n\n    if (token == address(WETH)){\n      WETH.withdraw(bal);\n      payable(msg.sender).transfer(bal);\n    }\n    else {\n      ERC20(token).safeTransfer(msg.sender, bal);\n    }\n    \n    // if pool enabled, deploy assets in ticks, otherwise just let assets sit here until totally withdrawn\n    if (isEnabled) deployAssets();\n    emit Withdraw(msg.sender, token, amount, liquidity);\n  }\n\n\n  /// @notice deposit tokens in the pool, convert to WETH if necessary\n  /// @param token Token address\n  /// @param amount Amount of token deposited\n  function deposit(address token, uint amount) public payable nonReentrant returns (uint liquidity) \n  {\n    require(isEnabled, \"GEV: Pool Disabled\");\n    require(poolMatchesOracle(), \"GEV: Oracle Error\");\n    require(token == address(token0) || token == address(token1), \"GEV: Invalid Token\");\n    require(amount > 0 || msg.value > 0, \"GEV: Deposit Zero\");\n    \n    // Wrap if necessary and deposit here\n    if (msg.value > 0){\n      require(token == address(WETH), \"GEV: Invalid Weth\");\n      // wraps ETH by sending to the wrapper that sends back WETH\n      WETH.deposit{value: msg.value}();\n      amount = msg.value;\n    }\n    else { \n      ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n    }\n    \n    // Send deposit fee to treasury\n    uint fee = amount * getAdjustedBaseFee(token == address(token0)) / 1e4;\n    ERC20(token).safeTransfer(treasury, fee);\n    uint valueX8 = oracle.getAssetPrice(token) * (amount - fee) / 10**ERC20(token).decimals();\n    require(tvlCap > valueX8 + getTVL(), \"GEV: Max Cap Reached\");\n\n    uint vaultValueX8 = getTVL();\n    uint tSupply = totalSupply();\n    // initial liquidity at 1e18 token ~ $1\n    if (tSupply == 0 || vaultValueX8 == 0)\n      liquidity = valueX8 * 1e10;\n    else {\n      liquidity = tSupply * valueX8 / vaultValueX8;\n    }\n    \n    rebalance();\n    require(liquidity > 0, \"GEV: No Liquidity Added\");\n    _mint(msg.sender, liquidity);    \n    emit Deposit(msg.sender, token, amount, liquidity);\n  }\n  \n  \n  /// @notice Get value of 1e18 GEV tokens\n  /// @return priceX8 price of 1e18 tokens with 8 decimals\n  function latestAnswer() external view returns (uint256 priceX8) {\n    uint supply = totalSupply();\n    if (supply == 0) return 0;\n    uint vaultValue = getTVL();\n    priceX8 = vaultValue * 1e18 / supply;\n  }\n  \n  \n  /// @notice Get vault underlying assets\n  function getReserves() public view returns (uint amount0, uint amount1){\n    for (uint k = 0; k < ticks.length; k++){\n      TokenisableRange t = ticks[k];\n      address aTick = lendingPool.getReserveData(address(t)).aTokenAddress;\n      uint bal = ERC20(aTick).balanceOf(address(this));\n      (uint amt0, uint amt1) = t.getTokenAmounts(bal);\n      amount0 += amt0;\n      amount1 += amt1;\n    }\n  }\n\n\n  //////// INTERNAL FUNCTIONS\n  \n  /// @notice Remove assets from all the underlying ticks\n  function removeFromAllTicks() internal {\n    for (uint k = 0; k < ticks.length; k++){\n      removeFromTick(k);\n    }    \n  }\n  \n  \n  /// @notice Remove from tick\n  function removeFromTick(uint index) internal {\n    TokenisableRange tr = ticks[index];\n    address aTokenAddress = lendingPool.getReserveData(address(tr)).aTokenAddress;\n    uint aBal = ERC20(aTokenAddress).balanceOf(address(this));\n    uint sBal = tr.balanceOf(aTokenAddress);\n\n    // if there are less tokens available than the balance (because of outstanding debt), withdraw what's available\n    if (aBal > sBal) aBal = sBal;\n    if (aBal > 0){\n      lendingPool.withdraw(address(tr), aBal, address(this));\n      tr.withdraw(aBal, 0, 0);\n    }\n  }\n  \n  \n  /// @notice \n  function deployAssets() internal { \n    uint newTickIndex = getActiveTickIndex();\n    uint availToken0 = token0.balanceOf(address(this));\n    uint availToken1 = token1.balanceOf(address(this));\n    \n    // Check which is the main token\n    (uint amount0ft, uint amount1ft) = ticks[newTickIndex].getTokenAmountsExcludingFees(1e18);\n    uint tick0Index = newTickIndex;\n    uint tick1Index = newTickIndex + 2;\n    if (amount1ft > 0){\n      tick0Index = newTickIndex + 2;\n      tick1Index = newTickIndex;\n    }\n    \n    // Deposit into the ticks + into the LP\n    if (availToken0 > 0){\n      depositAndStash(ticks[tick0Index], availToken0 / 2, 0);\n      depositAndStash(ticks[tick0Index+1], availToken0 / 2, 0);\n    }\n    if (availToken1 > 0){\n      depositAndStash(ticks[tick1Index], 0, availToken1 / 2);\n      depositAndStash(ticks[tick1Index+1], 0, availToken1 / 2);\n    }\n    \n    if (newTickIndex != tickIndex) tickIndex = newTickIndex;\n    emit Rebalance(tickIndex);\n  }\n  \n  \n  /// @notice Checks that the pool price isn't manipulated\n  function poolMatchesOracle() public view returns (bool matches){\n    (uint160 sqrtPriceX96,,,,,,) = uniswapPool.slot0();\n    \n    uint decimals0 = token0.decimals();\n    uint decimals1 = token1.decimals();\n    uint priceX8 = 10**decimals0;\n    // Overflow if dont scale down the sqrtPrice before div 2*192\n    priceX8 = priceX8 * uint(sqrtPriceX96 / 2 ** 12) ** 2 * 1e8 / 2**168;\n    priceX8 = priceX8 / 10**decimals1;\n    uint oraclePrice = 1e8 * oracle.getAssetPrice(address(token0)) / oracle.getAssetPrice(address(token1));\n    if (oraclePrice < priceX8 * 101 / 100 && oraclePrice > priceX8 * 99 / 100) matches = true;\n  }\n\n\n  /// @notice Helper that checks current allowance and approves if necessary\n  /// @param token Target token\n  /// @param spender Spender\n  /// @param amount Amount below which we need to approve the token spending\n  function checkSetApprove(address token, address spender, uint amount) private {\n    if ( ERC20(token).allowance(address(this), spender) < amount ) ERC20(token).safeIncreaseAllowance(spender, type(uint256).max);\n  }\n  \n  \n  /// @notice Calculate the vault total ticks value\n  /// @return valueX8 Total value of the vault with 8 decimals\n  function getTVL() public view returns (uint valueX8){\n    for(uint k=0; k<ticks.length; k++){\n      TokenisableRange t = ticks[k];\n      uint bal = getTickBalance(k);\n      valueX8 += bal * t.latestAnswer() / 1e18;\n    }\n  }\n  \n  \n  /// @notice Deposit assets in a ticker, and the ticker in lending pool\n  /// @param t Tik address\n  /// @return liquidity The amount of ticker liquidity added\n  function depositAndStash(TokenisableRange t, uint amount0, uint amount1) internal returns (uint liquidity){\n    checkSetApprove(address(token0), address(t), amount0);\n    checkSetApprove(address(token1), address(t), amount1);\n    liquidity = t.deposit(amount0, amount1);\n    \n    uint bal = t.balanceOf(address(this));\n    if (bal > 0){\n      checkSetApprove(address(t), address(lendingPool), bal);\n      lendingPool.deposit(address(t), bal, address(this), 0);\n    }\n  }\n  \n  \n  /// @notice Get balance of tick deposited in GE\n  /// @param index Tick index\n  /// @return liquidity Amount of Ticker\n  function getTickBalance(uint index) public view returns (uint liquidity) {\n    TokenisableRange t = ticks[index];\n    address aTokenAddress = lendingPool.getReserveData(address(t)).aTokenAddress;\n    liquidity = ERC20(aTokenAddress).balanceOf(address(this));\n  }\n  \n  \n  /// @notice Return first valid tick\n  function getActiveTickIndex() public view returns (uint activeTickIndex) {\n    if (ticks.length >= 5){\n      // looking for index at which the underlying asset differs from the next tick\n      for (activeTickIndex = 0; activeTickIndex < ticks.length - 3; activeTickIndex++){\n        (uint amt0, uint amt1) = ticks[activeTickIndex+1].getTokenAmountsExcludingFees(1e18);\n        (uint amt0n, uint amt1n) = ticks[activeTickIndex+2].getTokenAmountsExcludingFees(1e18);\n        if ( (amt0 == 0 && amt0n > 0) || (amt1 == 0 && amt1n > 0) )\n          break;\n      }\n    }\n  }\n\n\n  /// @notice Get deposit fee\n  /// @param increaseToken0 Whether (token0 added || token1 removed) or not\n  /// @dev Simple linear model: from baseFeeX4 / 2 to baseFeeX4 * 2\n  /// @dev Call before withdrawing from ticks or reserves will both be 0\n  function getAdjustedBaseFee(bool increaseToken0) public view returns (uint adjustedBaseFeeX4) {\n    (uint res0, uint res1) = getReserves();\n    uint value0 = res0 * oracle.getAssetPrice(address(token0)) / 10**token0.decimals();\n    uint value1 = res1 * oracle.getAssetPrice(address(token1)) / 10**token1.decimals();\n\n    if (increaseToken0)\n      adjustedBaseFeeX4 = baseFeeX4 * value0 / (value1 + 1);\n    else\n      adjustedBaseFeeX4 = baseFeeX4 * value1 / (value0 + 1);\n\n    // Adjust from -50% to +50%\n    if (adjustedBaseFeeX4 < baseFeeX4 / 2) adjustedBaseFeeX4 = baseFeeX4 / 2;\n    if (adjustedBaseFeeX4 > baseFeeX4 * 3 / 2) adjustedBaseFeeX4 = baseFeeX4 * 3 / 2;\n  }\n\n\n  /// @notice fallback: deposit unless it's WETH being unwrapped\n  receive() external payable {\n    if(msg.sender != address(WETH)) deposit(address(WETH), msg.value);\n  }\n  \n}"
    },
    {
      "filename": "contracts/TokenisableRange.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport \"../interfaces/INonfungiblePositionManager.sol\";\nimport \"../interfaces/IUniswapV3Factory.sol\";\nimport \"../interfaces/IUniswapV3Pool.sol\";\nimport \"./openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/utils/Strings.sol\";\nimport \"./openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\";\nimport \"./lib/LiquidityAmounts.sol\";\nimport \"./lib/TickMath.sol\";\nimport \"../interfaces/IAaveOracle.sol\";\nimport \"../interfaces/IAaveOracle.sol\";\n\n\n/// @notice Tokenize a Uniswap V3 NFT position\ncontract TokenisableRange is ERC20(\"\", \"\"), ReentrancyGuard {\n  using SafeERC20 for ERC20;\n  /// EVENTS\n  event InitTR(address asset0, address asset1, uint128 startX10, uint128 endX10);\n  event Deposit(address sender, uint trAmount);\n  event Withdraw(address sender, uint trAmount);\n  event ClaimFees(uint fee0, uint fee1);\n  \n  /// VARIABLES\n\n  int24 public lowerTick;\n  int24 public upperTick;\n  uint24 public feeTier;\n  \n  uint256 public tokenId;\n  uint256 public fee0;\n  uint256 public fee1;\n  \n  struct ASSET {\n    ERC20 token;\n    uint8 decimals;\n  }\n  \n  ASSET public TOKEN0;\n  ASSET public TOKEN1;\n  IAaveOracle public ORACLE;\n  \n  string _name;\n  string _symbol;\n  \n  enum ProxyState { INIT_PROXY, INIT_LP, READY }\n  ProxyState public status;\n  address private creator;\n  \n  uint128 public liquidity;\n  // @notice deprecated, keep to avoid beacon storage slot overwriting errors\n  address public TREASURY_DEPRECATED = 0x22Cc3f665ba4C898226353B672c5123c58751692;\n  uint public treasuryFee_deprecated = 20;\n  \n  // These are constant across chains - https://docs.uniswap.org/protocol/reference/deployments\n  INonfungiblePositionManager constant public POS_MGR = INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88); \n  IUniswapV3Factory constant public V3_FACTORY = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984); \n  address constant public treasury = 0x22Cc3f665ba4C898226353B672c5123c58751692;\n  uint constant public treasuryFee = 20;\n\n  /// @notice Babylonian method for sqrt\n  /// @param x sqrt parameter\n  /// @return y Square root\n  function sqrt(uint x) internal pure returns (uint y) {\n      uint z = (x + 1) / 2;\n      y = x;\n      while (z < y) {\n          y = z;\n          z = (x / z + z) / 2;\n      }\n  }\n\n\n  /// @notice Store range parameters\n  /// @param _oracle Address of the IAaveOracle interface of the ROE lending pool\n  /// @param asset0 Quote token address\n  /// @param asset1 Base token address \n  /// @param startX10 Range lower price scaled by 1e10\n  /// @param endX10 Range high price scaled by 1e10\n  /// @param startName Name of the range lower bound \n  /// @param endName Name of the range higher bound\n  /// @param isTicker Range is single tick liquidity around upperTick/startX10/startName\n  function initProxy(IAaveOracle _oracle, ERC20 asset0, ERC20 asset1, uint128 startX10, uint128 endX10, string memory startName, string memory endName, bool isTicker) external {\n    require(address(_oracle) != address(0x0), \"Invalid oracle\");\n    require(status == ProxyState.INIT_PROXY, \"!InitProxy\");\n    creator = msg.sender;\n    status = ProxyState.INIT_LP;\n    ORACLE = _oracle;\n    \n    TOKEN0.token    = asset0;\n    TOKEN0.decimals = asset0.decimals();\n    TOKEN1.token     = asset1;\n    TOKEN1.decimals  = asset1.decimals();\n    string memory quoteSymbol = asset0.symbol();\n    string memory baseSymbol  = asset1.symbol();\n        \n    int24 _upperTick = TickMath.getTickAtSqrtRatio( uint160( 2**48 * sqrt( (2 ** 96 * (10 ** TOKEN1.decimals)) * 1e10 / (uint256(startX10) * 10 ** TOKEN0.decimals) ) ) );\n    int24 _lowerTick = TickMath.getTickAtSqrtRatio( uint160( 2**48 * sqrt( (2 ** 96 * (10 ** TOKEN1.decimals)) * 1e10 / (uint256(endX10  ) * 10 ** TOKEN0.decimals) ) ) );\n    \n    if (isTicker) { \n      feeTier   = 5;\n      int24 midleTick;\n      midleTick = (_upperTick + _lowerTick) / 2;\n      _upperTick = (midleTick + int24(feeTier)) - (midleTick + int24(feeTier)) % int24(feeTier * 2);\n      _lowerTick = _upperTick - int24(feeTier) - int24(feeTier);\n      _name     = string(abi.encodePacked(\"Ticker \", baseSymbol, \" \", quoteSymbol, \" \", startName, \"-\", endName));\n     _symbol    = string(abi.encodePacked(\"T-\",startName,\"_\",endName,\"-\",baseSymbol,\"-\",quoteSymbol));\n    } else {\n      feeTier   = 5;\n      _lowerTick = (_lowerTick + int24(feeTier)) - (_lowerTick + int24(feeTier)) % int24(feeTier * 2);\n      _upperTick = (_upperTick + int24(feeTier)) - (_upperTick + int24(feeTier)) % int24(feeTier * 2);\n      _name     = string(abi.encodePacked(\"Ranger \", baseSymbol, \" \", quoteSymbol, \" \", startName, \"-\", endName));\n      _symbol   = string(abi.encodePacked(\"R-\",startName,\"_\",endName,\"-\",baseSymbol,\"-\",quoteSymbol));\n    }\n    lowerTick = _lowerTick;\n    upperTick = _upperTick;\n    emit InitTR(address(asset0), address(asset1), startX10, endX10);\n  }\n  \n\n  /// @notice Get the name of this contract token\n  /// @dev Override name, symbol and decimals from ERC20 inheritance\n  function name()     public view virtual override returns (string memory) { return _name; }\n  /// @notice Get the symbol of this contract token\n  function symbol()   public view virtual override returns (string memory) { return _symbol; }\n\n\n  /// @notice Initialize a TokenizableRange by adding assets in the underlying Uniswap V3 position\n  /// @param n0 Amount of quote token added\n  /// @param n1 Amount of base token added\n  /// @notice The token amounts must be 95% correct or this will fail the Uniswap slippage check\n  function init(uint n0, uint n1) external {\n    require(status == ProxyState.INIT_LP, \"!InitLP\");\n    require(msg.sender == creator, \"Unallowed call\");\n    status = ProxyState.READY;\n    TOKEN0.token.safeTransferFrom(msg.sender, address(this), n0);\n    TOKEN1.token.safeTransferFrom(msg.sender, address(this), n1);\n    TOKEN0.token.safeIncreaseAllowance(address(POS_MGR), n0);\n    TOKEN1.token.safeIncreaseAllowance(address(POS_MGR), n1);\n    (tokenId, liquidity, , ) = POS_MGR.mint( \n      INonfungiblePositionManager.MintParams({\n         token0: address(TOKEN0.token),\n         token1: address(TOKEN1.token),\n         fee: feeTier * 100,\n         tickLower: lowerTick,\n         tickUpper: upperTick,\n         amount0Desired: n0,\n         amount1Desired: n1,\n         amount0Min: n0 * 95 / 100,\n         amount1Min: n1 * 95 / 100,\n         recipient: address(this),\n         deadline: block.timestamp\n      })\n    );\n    \n    // Transfer remaining assets back to user\n    TOKEN0.token.safeTransfer( msg.sender,  TOKEN0.token.balanceOf(address(this)));\n    TOKEN1.token.safeTransfer(msg.sender, TOKEN1.token.balanceOf(address(this)));\n    _mint(msg.sender, 1e18);\n    emit Deposit(msg.sender, 1e18);\n  }\n  \n  \n  /// @notice Claim the accumulated Uniswap V3 trading fees\n  function claimFee() public {\n    (uint256 newFee0, uint256 newFee1) = POS_MGR.collect( \n      INonfungiblePositionManager.CollectParams({\n        tokenId: tokenId,\n        recipient: address(this),\n        amount0Max: type(uint128).max,\n        amount1Max: type(uint128).max\n      })\n    );\n    // If there's no new fees generated, skip compounding logic;\n    if ((newFee0 == 0) && (newFee1 == 0)) return;  \n    uint tf0 = newFee0 * treasuryFee / 100;\n    uint tf1 = newFee1 * treasuryFee / 100;\n    if (tf0 > 0) TOKEN0.token.safeTransfer(treasury, tf0);\n    if (tf1 > 0) TOKEN1.token.safeTransfer(treasury, tf1);\n    \n    fee0 = fee0 + newFee0 - tf0;\n    fee1 = fee1 + newFee1 - tf1;\n    \n    // Calculate expected balance,  \n    (uint256 bal0, uint256 bal1) = returnExpectedBalanceWithoutFees(0, 0);\n    \n    // If accumulated more than 1% worth of fees, compound by adding fees to Uniswap position\n    if ((fee0 * 100 > bal0 ) && (fee1 * 100 > bal1)) { \n      TOKEN0.token.safeIncreaseAllowance(address(POS_MGR), fee0);\n      TOKEN1.token.safeIncreaseAllowance(address(POS_MGR), fee1);\n      (uint128 newLiquidity, uint256 added0, uint256 added1) = POS_MGR.increaseLiquidity(\n        INonfungiblePositionManager.IncreaseLiquidityParams({\n          tokenId: tokenId,\n          amount0Desired: fee0,\n          amount1Desired: fee1,\n          amount0Min: 0,\n          amount1Min: 0,\n          deadline: block.timestamp\n        })\n      );\n      // check slippage: validate against value since token amounts can move widely\n      uint token0Price = ORACLE.getAssetPrice(address(TOKEN0.token));\n      uint token1Price = ORACLE.getAssetPrice(address(TOKEN1.token));\n      uint addedValue = added0 * token0Price / 10**TOKEN0.decimals + added1 * token1Price / 10**TOKEN1.decimals;\n      uint totalValue =   bal0 * token0Price / 10**TOKEN0.decimals +   bal1 * token1Price / 10**TOKEN1.decimals;\n      uint liquidityValue = totalValue * newLiquidity / liquidity;\n      require(addedValue > liquidityValue * 95 / 100 && liquidityValue > addedValue * 95 / 100, \"TR: Claim Fee Slippage\");\n      fee0 -= added0;\n      fee1 -= added1;\n      liquidity = liquidity + newLiquidity;\n    }\n    emit ClaimFees(newFee0, newFee1);\n  }\n  \n  \n  /// @notice Deposit assets into the range\n  /// @param n0 Amount of quote asset\n  /// @param n1 Amount of base asset\n  /// @return lpAmt Amount of LP tokens created\n  function deposit(uint256 n0, uint256 n1) external nonReentrant returns (uint256 lpAmt) {\n    // Once all assets were withdrawn after initialisation, this is considered closed\n    // Prevents TR oracle values from being too manipulatable by emptying the range and redepositing \n    require(totalSupply() > 0, \"TR Closed\"); \n    \n    claimFee();\n    TOKEN0.token.transferFrom(msg.sender, address(this), n0);\n    TOKEN1.token.transferFrom(msg.sender, address(this), n1);\n    \n    uint newFee0; \n    uint newFee1;\n    // Calculate proportion of deposit that goes to pending fee pool, useful to deposit exact amount of liquidity and fully repay a position\n    // Cannot repay only one side, if fees are both 0, or if one side is missing, skip adding fees here\n      // if ( fee0+fee1 == 0 || (n0 == 0 && fee0 > 0) || (n1 == 0 && fee1 > 0) ) skip  \n      // DeMorgan: !( (n0 == 0 && fee0 > 0) || (n1 == 0 && fee1 > 0) ) = !(n0 == 0 && fee0 > 0) && !(n0 == 0 && fee1 > 0)\n    if ( fee0+fee1 > 0 && ( n0 > 0 || fee0 == 0) && ( n1 > 0 || fee1 == 0 ) ){\n      address pool = V3_FACTORY.getPool(address(TOKEN0.token), address(TOKEN1.token), feeTier * 100);\n      (uint160 sqrtPriceX96,,,,,,)  = IUniswapV3Pool(pool).slot0();\n      (uint256 token0Amount, uint256 token1Amount) = LiquidityAmounts.getAmountsForLiquidity( sqrtPriceX96, TickMath.getSqrtRatioAtTick(lowerTick), TickMath.getSqrtRatioAtTick(upperTick), liquidity);\n      if (token0Amount + fee0 > 0) newFee0 = n0 * fee0 / (token0Amount + fee0);\n      if (token1Amount + fee1 > 0) newFee1 = n1 * fee1 / (token1Amount + fee1);\n      fee0 += newFee0;\n      fee1 += newFee1; \n      n0   -= newFee0;\n      n1   -= newFee1;\n    }\n\n    TOKEN0.token.safeIncreaseAllowance(address(POS_MGR), n0);\n    TOKEN1.token.safeIncreaseAllowance(address(POS_MGR), n1);\n\n    // New liquidity is indeed the amount of liquidity added, not the total, despite being unclear in Uniswap doc\n    (uint128 newLiquidity, uint256 added0, uint256 added1) = POS_MGR.increaseLiquidity(\n      INonfungiblePositionManager.IncreaseLiquidityParams({\n        tokenId: tokenId,\n        amount0Desired: n0,\n        amount1Desired: n1,\n        amount0Min: n0 * 95 / 100,\n        amount1Min: n1 * 95 / 100,\n        deadline: block.timestamp\n      })\n    );\n    \n    uint256 feeLiquidity;\n\n    // Stack too deep, so localising some variables for feeLiquidity calculations \n    // If we already clawed back fees earlier, do nothing, else we need to adjust returned liquidity\n    if ( newFee0 == 0 && newFee1 == 0 ){\n      uint256 TOKEN0_PRICE = ORACLE.getAssetPrice(address(TOKEN0.token));\n      uint256 TOKEN1_PRICE = ORACLE.getAssetPrice(address(TOKEN1.token));\n      require (TOKEN0_PRICE > 0 && TOKEN1_PRICE > 0, \"Invalid Oracle Price\");\n      // Calculate the equivalent liquidity amount of the non-yet compounded fees\n      // Assume linearity for liquidity in same tick range; calculate feeLiquidity equivalent and consider it part of base liquidity \n      feeLiquidity = newLiquidity * ( (fee0 * TOKEN0_PRICE / 10 ** TOKEN0.decimals) + (fee1 * TOKEN1_PRICE / 10 ** TOKEN1.decimals) )   \n                                    / ( (added0   * TOKEN0_PRICE / 10 ** TOKEN0.decimals) + (added1   * TOKEN1_PRICE / 10 ** TOKEN1.decimals) ); \n    }\n                                     \n    lpAmt = totalSupply() * newLiquidity / (liquidity + feeLiquidity); \n    liquidity = liquidity + newLiquidity;\n    \n    _mint(msg.sender, lpAmt);\n    TOKEN0.token.safeTransfer( msg.sender, n0 - added0);\n    TOKEN1.token.safeTransfer( msg.sender, n1 - added1);\n    emit Deposit(msg.sender, lpAmt);\n  }\n  \n  \n  /// @notice Withdraw assets from a range\n  /// @param lp Amount of tokens withdrawn\n  /// @param amount0Min Minimum amount of quote token withdrawn\n  /// @param amount1Min Minimum amount of base token withdrawn\n  function withdraw(uint256 lp, uint256 amount0Min, uint256 amount1Min) external nonReentrant returns (uint256 removed0, uint256 removed1) {\n    claimFee();\n    uint removedLiquidity = uint(liquidity) * lp / totalSupply();\n    (removed0, removed1) = POS_MGR.decreaseLiquidity(\n      INonfungiblePositionManager.DecreaseLiquidityParams({\n        tokenId: tokenId,\n        liquidity: uint128(removedLiquidity),\n        amount0Min: amount0Min,\n        amount1Min: amount1Min,\n        deadline: block.timestamp\n      })\n    );\n    liquidity = uint128(uint256(liquidity) - removedLiquidity); \n    \n    POS_MGR.collect( \n      INonfungiblePositionManager.CollectParams({\n        tokenId: tokenId,\n        recipient: msg.sender,\n        amount0Max: uint128(removed0),\n        amount1Max: uint128(removed1)\n      })\n    );\n    // Handle uncompounded fees\n    if (fee0 > 0) {\n      TOKEN0.token.safeTransfer( msg.sender, fee0 * lp / totalSupply());\n      removed0 += fee0 * lp / totalSupply();\n      fee0 -= fee0 * lp / totalSupply();\n    } \n    if (fee1 > 0) {\n      TOKEN1.token.safeTransfer(  msg.sender, fee1 * lp / totalSupply());\n      removed1 += fee1 * lp / totalSupply();\n      fee1 -= fee1 * lp / totalSupply();\n    }\n    _burn(msg.sender, lp);\n    emit Withdraw(msg.sender, lp);\n  }\n  \n\n  /// @notice Calculate the balance of underlying assets based on the assets price\n  /// @param TOKEN0_PRICE Base token price\n  /// @param TOKEN1_PRICE Quote token price\n  function returnExpectedBalanceWithoutFees(uint TOKEN0_PRICE, uint TOKEN1_PRICE) internal view returns (uint256 amt0, uint256 amt1) {\n    // if 0 get price from oracle\n    if (TOKEN0_PRICE == 0) TOKEN0_PRICE = ORACLE.getAssetPrice(address(TOKEN0.token));\n    if (TOKEN1_PRICE == 0) TOKEN1_PRICE = ORACLE.getAssetPrice(address(TOKEN1.token));\n\n    (amt0, amt1) = LiquidityAmounts.getAmountsForLiquidity( uint1"
    }
  ]
}