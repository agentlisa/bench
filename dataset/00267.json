{
  "Title": "Incomplete Docstrings",
  "Content": "Throughout the codebase, there are several instances of incomplete docstrings.\n\n\n* The [`lastFinalizedBatchIndex`](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/IScrollChain.sol#L47), [`committedBatches`](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/IScrollChain.sol#L51), [`finalizedStateRoots`](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/IScrollChain.sol#L55), [`withdrawRoots`](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/IScrollChain.sol#L59), and [`isBatchFinalized`](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/IScrollChain.sol#L63) functions in `IScrollChain.sol` explain what they return in the `@notice` tag. However, this should be specified under the `@return` tag.\n* In the [`legacyVerifiersLength`](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/MultipleVersionRollupVerifier.sol#L89-L91) function in `MultipleVersionRollupVerifier.sol`, the `_version` parameter and the return value are not documented.\n* In the [`getVerifier`](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/MultipleVersionRollupVerifier.sol#L96-L113) function in `MultipleVersionRollupVerifier.sol`, the return value is not documented.\n* In the [`updateVerifier`](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/MultipleVersionRollupVerifier.sol#L149-L173) function in `MultipleVersionRollupVerifier.sol`, the `_version` parameter is not documented.\n* In the [`importGenesisBatch`](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/ScrollChain.sol#L239-L264) function in `ScrollChain.sol`, the `_batchHeader` and `_stateRoot` parameters are not documented.\n\n\nConsider thoroughly documenting all functions/events (and their parameters or return values) that are part of a contract's public API. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/latest/natspec-format.html) (NatSpec).\n\n\n***Update:** Resolved in [pull request #1256](https://github.com/scroll-tech/scroll/pull/1256) at commit [5425ce7](https://github.com/scroll-tech/scroll/pull/1256/commits/5425ce725cc60d154e112610ee380d05e23689e5).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/rollup/IScrollChain.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ninterface IScrollChain {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a new batch is committed.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch.\n    event CommitBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice revert a pending batch.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    event RevertBatch(uint256 indexed batchIndex, bytes32 indexed batchHash);\n\n    /// @notice Emitted when a batch is finalized.\n    /// @param batchIndex The index of the batch.\n    /// @param batchHash The hash of the batch\n    /// @param stateRoot The state root on layer 2 after this batch.\n    /// @param withdrawRoot The merkle root on layer2 after this batch.\n    event FinalizeBatch(uint256 indexed batchIndex, bytes32 indexed batchHash, bytes32 stateRoot, bytes32 withdrawRoot);\n\n    /// @notice Emitted when owner updates the status of sequencer.\n    /// @param account The address of account updated.\n    /// @param status The status of the account updated.\n    event UpdateSequencer(address indexed account, bool status);\n\n    /// @notice Emitted when owner updates the status of prover.\n    /// @param account The address of account updated.\n    /// @param status The status of the account updated.\n    event UpdateProver(address indexed account, bool status);\n\n    /// @notice Emitted when the value of `maxNumTxInChunk` is updated.\n    /// @param oldMaxNumTxInChunk The old value of `maxNumTxInChunk`.\n    /// @param newMaxNumTxInChunk The new value of `maxNumTxInChunk`.\n    event UpdateMaxNumTxInChunk(uint256 oldMaxNumTxInChunk, uint256 newMaxNumTxInChunk);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice The latest finalized batch index.\n    function lastFinalizedBatchIndex() external view returns (uint256);\n\n    /// @notice Return the batch hash of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function committedBatches(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the state root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function finalizedStateRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return the message root of a committed batch.\n    /// @param batchIndex The index of the batch.\n    function withdrawRoots(uint256 batchIndex) external view returns (bytes32);\n\n    /// @notice Return whether the batch is finalized by batch index.\n    /// @param batchIndex The index of the batch.\n    function isBatchFinalized(uint256 batchIndex) external view returns (bool);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Commit a batch of transactions on layer 1.\n    ///\n    /// @param version The version of current batch.\n    /// @param parentBatchHeader The header of parent batch, see the comments of `BatchHeaderV0Codec`.\n    /// @param chunks The list of encoded chunks, see the comments of `ChunkCodec`.\n    /// @param skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    function commitBatch(\n        uint8 version,\n        bytes calldata parentBatchHeader,\n        bytes[] memory chunks,\n        bytes calldata skippedL1MessageBitmap\n    ) external;\n\n    /// @notice Revert a pending batch.\n    /// @dev one can only revert unfinalized batches.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch`.\n    /// @param count The number of subsequent batches to revert, including current batch.\n    function revertBatch(bytes calldata batchHeader, uint256 count) external;\n\n    /// @notice Finalize a committed batch on layer 1.\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch.\n    /// @param prevStateRoot The state root of parent batch.\n    /// @param postStateRoot The state root of current batch.\n    /// @param withdrawRoot The withdraw trie root of current batch.\n    /// @param aggrProof The aggregation proof for current batch.\n    function finalizeBatchWithProof(\n        bytes calldata batchHeader,\n        bytes32 prevStateRoot,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata aggrProof\n    ) external;\n\n    /// @notice Finalize a committed batch (with blob) on layer 1.\n    ///\n    /// @dev Memory layout of `blobDataProof`:\n    /// |    z    |    y    | kzg_commitment | kzg_proof |\n    /// |---------|---------|----------------|-----------|\n    /// | bytes32 | bytes32 |    bytes48     |  bytes48  |\n    ///\n    /// @param batchHeader The header of current batch, see the encoding in comments of `commitBatch.\n    /// @param prevStateRoot The state root of parent batch.\n    /// @param postStateRoot The state root of current batch.\n    /// @param withdrawRoot The withdraw trie root of current batch.\n    /// @param blobDataProof The proof for blob data.\n    /// @param aggrProof The aggregation proof for current batch.\n    function finalizeBatchWithProof4844(\n        bytes calldata batchHeader,\n        bytes32 prevStateRoot,\n        bytes32 postStateRoot,\n        bytes32 withdrawRoot,\n        bytes calldata blobDataProof,\n        bytes calldata aggrProof\n    ) external;\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/MultipleVersionRollupVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IScrollChain} from \"./IScrollChain.sol\";\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\nimport {IZkEvmVerifier} from \"../../libraries/verifier/IZkEvmVerifier.sol\";\n\ncontract MultipleVersionRollupVerifier is IRollupVerifier, Ownable {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of verifier is updated.\n    /// @param version The version of the verifier.\n    /// @param startBatchIndex The start batch index when the verifier will be used.\n    /// @param verifier The address of new verifier.\n    event UpdateVerifier(uint256 version, uint256 startBatchIndex, address verifier);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /// @dev Thrown when the given start batch index is finalized.\n    error ErrorStartBatchIndexFinalized();\n\n    /// @dev Thrown when the given start batch index is smaller than `latestVerifier.startBatchIndex`.\n    error ErrorStartBatchIndexTooSmall();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of ScrollChain contract.\n    address immutable scrollChain;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct Verifier {\n        // The start batch index for the verifier.\n        uint64 startBatchIndex;\n        // The address of zkevm verifier.\n        address verifier;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from verifier version to the list of legacy zkevm verifiers.\n    /// The verifiers are sorted by batchIndex in increasing order.\n    mapping(uint256 => Verifier[]) public legacyVerifiers;\n\n    /// @notice Mapping from verifier version to the lastest used zkevm verifier.\n    mapping(uint256 => Verifier) public latestVerifier;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _scrollChain,\n        uint256[] memory _versions,\n        address[] memory _verifiers\n    ) {\n        if (_scrollChain == address(0)) revert ErrorZeroAddress();\n        scrollChain = _scrollChain;\n\n        for (uint256 i = 0; i < _versions.length; i++) {\n            if (_verifiers[i] == address(0)) revert ErrorZeroAddress();\n            latestVerifier[_versions[i]].verifier = _verifiers[i];\n\n            emit UpdateVerifier(_versions[i], 0, _verifiers[i]);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the number of legacy verifiers.\n    function legacyVerifiersLength(uint256 _version) external view returns (uint256) {\n        return legacyVerifiers[_version].length;\n    }\n\n    /// @notice Compute the verifier should be used for specific batch.\n    /// @param _version The version of verifier to query.\n    /// @param _batchIndex The batch index to query.\n    function getVerifier(uint256 _version, uint256 _batchIndex) public view returns (address) {\n        // Normally, we will use the latest verifier.\n        Verifier memory _verifier = latestVerifier[_version];\n\n        if (_verifier.startBatchIndex > _batchIndex) {\n            uint256 _length = legacyVerifiers[_version].length;\n            // In most case, only last few verifier will be used by `ScrollChain`.\n            // So, we use linear search instead of binary search.\n            unchecked {\n                for (uint256 i = _length; i > 0; --i) {\n                    _verifier = legacyVerifiers[_version][i - 1];\n                    if (_verifier.startBatchIndex <= _batchIndex) break;\n                }\n            }\n        }\n\n        return _verifier.verifier;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IRollupVerifier\n    function verifyAggregateProof(\n        uint256 _batchIndex,\n        bytes calldata _aggrProof,\n        bytes32 _publicInputHash\n    ) external view override {\n        address _verifier = getVerifier(0, _batchIndex);\n\n        IZkEvmVerifier(_verifier).verify(_aggrProof, _publicInputHash);\n    }\n\n    /// @inheritdoc IRollupVerifier\n    function verifyAggregateProof(\n        uint256 _version,\n        uint256 _batchIndex,\n        bytes calldata _aggrProof,\n        bytes32 _publicInputHash\n    ) external view override {\n        address _verifier = getVerifier(_version, _batchIndex);\n\n        IZkEvmVerifier(_verifier).verify(_aggrProof, _publicInputHash);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of zkevm verifier.\n    /// @param _startBatchIndex The start batch index when the verifier will be used.\n    /// @param _verifier The address of new verifier.\n    function updateVerifier(\n        uint256 _version,\n        uint64 _startBatchIndex,\n        address _verifier\n    ) external onlyOwner {\n        if (_startBatchIndex <= IScrollChain(scrollChain).lastFinalizedBatchIndex())\n            revert ErrorStartBatchIndexFinalized();\n\n        Verifier memory _latestVerifier = latestVerifier[_version];\n        if (_startBatchIndex < _latestVerifier.startBatchIndex) revert ErrorStartBatchIndexTooSmall();\n        if (_verifier == address(0)) revert ErrorZeroAddress();\n\n        if (_latestVerifier.startBatchIndex < _startBatchIndex) {\n            // don't push when it is the first update of the version.\n            if (_latestVerifier.verifier != address(0)) {\n                legacyVerifiers[_version].push(_latestVerifier);\n            }\n            _latestVerifier.startBatchIndex = _startBatchIndex;\n        }\n        _latestVerifier.verifier = _verifier;\n\n        latestVerifier[_version] = _latestVerifier;\n\n        emit UpdateVerifier(_version, _startBatchIndex, _verifier);\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/MultipleVersionRollupVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IScrollChain} from \"./IScrollChain.sol\";\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\nimport {IZkEvmVerifier} from \"../../libraries/verifier/IZkEvmVerifier.sol\";\n\ncontract MultipleVersionRollupVerifier is IRollupVerifier, Ownable {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of verifier is updated.\n    /// @param version The version of the verifier.\n    /// @param startBatchIndex The start batch index when the verifier will be used.\n    /// @param verifier The address of new verifier.\n    event UpdateVerifier(uint256 version, uint256 startBatchIndex, address verifier);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /// @dev Thrown when the given start batch index is finalized.\n    error ErrorStartBatchIndexFinalized();\n\n    /// @dev Thrown when the given start batch index is smaller than `latestVerifier.startBatchIndex`.\n    error ErrorStartBatchIndexTooSmall();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of ScrollChain contract.\n    address immutable scrollChain;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct Verifier {\n        // The start batch index for the verifier.\n        uint64 startBatchIndex;\n        // The address of zkevm verifier.\n        address verifier;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from verifier version to the list of legacy zkevm verifiers.\n    /// The verifiers are sorted by batchIndex in increasing order.\n    mapping(uint256 => Verifier[]) public legacyVerifiers;\n\n    /// @notice Mapping from verifier version to the lastest used zkevm verifier.\n    mapping(uint256 => Verifier) public latestVerifier;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _scrollChain,\n        uint256[] memory _versions,\n        address[] memory _verifiers\n    ) {\n        if (_scrollChain == address(0)) revert ErrorZeroAddress();\n        scrollChain = _scrollChain;\n\n        for (uint256 i = 0; i < _versions.length; i++) {\n            if (_verifiers[i] == address(0)) revert ErrorZeroAddress();\n            latestVerifier[_versions[i]].verifier = _verifiers[i];\n\n            emit UpdateVerifier(_versions[i], 0, _verifiers[i]);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the number of legacy verifiers.\n    function legacyVerifiersLength(uint256 _version) external view returns (uint256) {\n        return legacyVerifiers[_version].length;\n    }\n\n    /// @notice Compute the verifier should be used for specific batch.\n    /// @param _version The version of verifier to query.\n    /// @param _batchIndex The batch index to query.\n    function getVerifier(uint256 _version, uint256 _batchIndex) public view returns (address) {\n        // Normally, we will use the latest verifier.\n        Verifier memory _verifier = latestVerifier[_version];\n\n        if (_verifier.startBatchIndex > _batchIndex) {\n            uint256 _length = legacyVerifiers[_version].length;\n            // In most case, only last few verifier will be used by `ScrollChain`.\n            // So, we use linear search instead of binary search.\n            unchecked {\n                for (uint256 i = _length; i > 0; --i) {\n                    _verifier = legacyVerifiers[_version][i - 1];\n                    if (_verifier.startBatchIndex <= _batchIndex) break;\n                }\n            }\n        }\n\n        return _verifier.verifier;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IRollupVerifier\n    function verifyAggregateProof(\n        uint256 _batchIndex,\n        bytes calldata _aggrProof,\n        bytes32 _publicInputHash\n    ) external view override {\n        address _verifier = getVerifier(0, _batchIndex);\n\n        IZkEvmVerifier(_verifier).verify(_aggrProof, _publicInputHash);\n    }\n\n    /// @inheritdoc IRollupVerifier\n    function verifyAggregateProof(\n        uint256 _version,\n        uint256 _batchIndex,\n        bytes calldata _aggrProof,\n        bytes32 _publicInputHash\n    ) external view override {\n        address _verifier = getVerifier(_version, _batchIndex);\n\n        IZkEvmVerifier(_verifier).verify(_aggrProof, _publicInputHash);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of zkevm verifier.\n    /// @param _startBatchIndex The start batch index when the verifier will be used.\n    /// @param _verifier The address of new verifier.\n    function updateVerifier(\n        uint256 _version,\n        uint64 _startBatchIndex,\n        address _verifier\n    ) external onlyOwner {\n        if (_startBatchIndex <= IScrollChain(scrollChain).lastFinalizedBatchIndex())\n            revert ErrorStartBatchIndexFinalized();\n\n        Verifier memory _latestVerifier = latestVerifier[_version];\n        if (_startBatchIndex < _latestVerifier.startBatchIndex) revert ErrorStartBatchIndexTooSmall();\n        if (_verifier == address(0)) revert ErrorZeroAddress();\n\n        if (_latestVerifier.startBatchIndex < _startBatchIndex) {\n            // don't push when it is the first update of the version.\n            if (_latestVerifier.verifier != address(0)) {\n                legacyVerifiers[_version].push(_latestVerifier);\n            }\n            _latestVerifier.startBatchIndex = _startBatchIndex;\n        }\n        _latestVerifier.verifier = _verifier;\n\n        latestVerifier[_version] = _latestVerifier;\n\n        emit UpdateVerifier(_version, _startBatchIndex, _verifier);\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/MultipleVersionRollupVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IScrollChain} from \"./IScrollChain.sol\";\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\nimport {IZkEvmVerifier} from \"../../libraries/verifier/IZkEvmVerifier.sol\";\n\ncontract MultipleVersionRollupVerifier is IRollupVerifier, Ownable {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of verifier is updated.\n    /// @param version The version of the verifier.\n    /// @param startBatchIndex The start batch index when the verifier will be used.\n    /// @param verifier The address of new verifier.\n    event UpdateVerifier(uint256 version, uint256 startBatchIndex, address verifier);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /// @dev Thrown when the given start batch index is finalized.\n    error ErrorStartBatchIndexFinalized();\n\n    /// @dev Thrown when the given start batch index is smaller than `latestVerifier.startBatchIndex`.\n    error ErrorStartBatchIndexTooSmall();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of ScrollChain contract.\n    address immutable scrollChain;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct Verifier {\n        // The start batch index for the verifier.\n        uint64 startBatchIndex;\n        // The address of zkevm verifier.\n        address verifier;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from verifier version to the list of legacy zkevm verifiers.\n    /// The verifiers are sorted by batchIndex in increasing order.\n    mapping(uint256 => Verifier[]) public legacyVerifiers;\n\n    /// @notice Mapping from verifier version to the lastest used zkevm verifier.\n    mapping(uint256 => Verifier) public latestVerifier;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _scrollChain,\n        uint256[] memory _versions,\n        address[] memory _verifiers\n    ) {\n        if (_scrollChain == address(0)) revert ErrorZeroAddress();\n        scrollChain = _scrollChain;\n\n        for (uint256 i = 0; i < _versions.length; i++) {\n            if (_verifiers[i] == address(0)) revert ErrorZeroAddress();\n            latestVerifier[_versions[i]].verifier = _verifiers[i];\n\n            emit UpdateVerifier(_versions[i], 0, _verifiers[i]);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the number of legacy verifiers.\n    function legacyVerifiersLength(uint256 _version) external view returns (uint256) {\n        return legacyVerifiers[_version].length;\n    }\n\n    /// @notice Compute the verifier should be used for specific batch.\n    /// @param _version The version of verifier to query.\n    /// @param _batchIndex The batch index to query.\n    function getVerifier(uint256 _version, uint256 _batchIndex) public view returns (address) {\n        // Normally, we will use the latest verifier.\n        Verifier memory _verifier = latestVerifier[_version];\n\n        if (_verifier.startBatchIndex > _batchIndex) {\n            uint256 _length = legacyVerifiers[_version].length;\n            // In most case, only last few verifier will be used by `ScrollChain`.\n            // So, we use linear search instead of binary search.\n            unchecked {\n                for (uint256 i = _length; i > 0; --i) {\n                    _verifier = legacyVerifiers[_version][i - 1];\n                    if (_verifier.startBatchIndex <= _batchIndex) break;\n                }\n            }\n        }\n\n        return _verifier.verifier;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IRollupVerifier\n    function verifyAggregateProof(\n        uint256 _batchIndex,\n        bytes calldata _aggrProof,\n        bytes32 _publicInputHash\n    ) external view override {\n        address _verifier = getVerifier(0, _batchIndex);\n\n        IZkEvmVerifier(_verifier).verify(_aggrProof, _publicInputHash);\n    }\n\n    /// @inheritdoc IRollupVerifier\n    function verifyAggregateProof(\n        uint256 _version,\n        uint256 _batchIndex,\n        bytes calldata _aggrProof,\n        bytes32 _publicInputHash\n    ) external view override {\n        address _verifier = getVerifier(_version, _batchIndex);\n\n        IZkEvmVerifier(_verifier).verify(_aggrProof, _publicInputHash);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of zkevm verifier.\n    /// @param _startBatchIndex The start batch index when the verifier will be used.\n    /// @param _verifier The address of new verifier.\n    function updateVerifier(\n        uint256 _version,\n        uint64 _startBatchIndex,\n        address _verifier\n    ) external onlyOwner {\n        if (_startBatchIndex <= IScrollChain(scrollChain).lastFinalizedBatchIndex())\n            revert ErrorStartBatchIndexFinalized();\n\n        Verifier memory _latestVerifier = latestVerifier[_version];\n        if (_startBatchIndex < _latestVerifier.startBatchIndex) revert ErrorStartBatchIndexTooSmall();\n        if (_verifier == address(0)) revert ErrorZeroAddress();\n\n        if (_latestVerifier.startBatchIndex < _startBatchIndex) {\n            // don't push when it is the first update of the version.\n            if (_latestVerifier.verifier != address(0)) {\n                legacyVerifiers[_version].push(_latestVerifier);\n            }\n            _latestVerifier.startBatchIndex = _startBatchIndex;\n        }\n        _latestVerifier.verifier = _verifier;\n\n        latestVerifier[_version] = _latestVerifier;\n\n        emit UpdateVerifier(_version, _startBatchIndex, _verifier);\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/ScrollChain.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IL1MessageQueue} from \"./IL1MessageQueue.sol\";\nimport {IScrollChain} from \"./IScrollChain.sol\";\nimport {BatchHeaderV0Codec} from \"../../libraries/codec/BatchHeaderV0Codec.sol\";\nimport {BatchHeaderV1Codec} from \"../../libraries/codec/BatchHeaderV1Codec.sol\";\nimport {ChunkCodecV0} from \"../../libraries/codec/ChunkCodecV0.sol\";\nimport {ChunkCodecV1} from \"../../libraries/codec/ChunkCodecV1.sol\";\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\n\n// solhint-disable no-inline-assembly\n// solhint-disable reason-string\n\n/// @title ScrollChain\n/// @notice This contract maintains data for the Scroll rollup.\ncontract ScrollChain is OwnableUpgradeable, PausableUpgradeable, IScrollChain {\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given account is not EOA account.\n    error ErrorAccountIsNotEOA();\n\n    /// @dev Thrown when committing a committed batch.\n    error ErrorBatchIsAlreadyCommitted();\n\n    /// @dev Thrown when finalizing a verified batch.\n    error ErrorBatchIsAlreadyVerified();\n\n    /// @dev Thrown when committing empty batch (batch without chunks)\n    error ErrorBatchIsEmpty();\n\n    /// @dev Thrown when call precompile failed.\n    error ErrorCallPointEvaluationPrecompileFailed();\n\n    /// @dev Thrown when the caller is not prover.\n    error ErrorCallerIsNotProver();\n\n    /// @dev Thrown when the caller is not sequencer.\n    error ErrorCallerIsNotSequencer();\n\n    /// @dev Thrown when the transaction has multiple blobs.\n    error ErrorFoundMultipleBlob();\n\n    /// @dev Thrown when some fields are not zero in genesis batch.\n    error ErrorGenesisBatchHasNonZeroField();\n\n    /// @dev Thrown when importing genesis batch twice.\n    error ErrorGenesisBatchImported();\n\n    /// @dev Thrown when data hash in genesis batch is zero.\n    error ErrorGenesisDataHashIsZero();\n\n    /// @dev Thrown when the parent batch hash in genesis batch is zero.\n    error ErrorGenesisParentBatchHashIsNonZero();\n\n    /// @dev Thrown when the l2 transaction is incomplete.\n    error ErrorIncompleteL2TransactionData();\n\n    /// @dev Thrown when the batch hash is incorrect.\n    error ErrorIncorrectBatchHash();\n\n    /// @dev Thrown when the batch index is incorrect.\n    error ErrorIncorrectBatchIndex();\n\n    /// @dev Thrown when the bitmap length is incorrect.\n    error ErrorIncorrectBitmapLength();\n\n    /// @dev Thrown when the previous state root doesn't match stored one.\n    error ErrorIncorrectPreviousStateRoot();\n\n    /// @dev Thrown when the batch header version is invalid.\n    error ErrorInvalidBatchHeaderVersion();\n\n    /// @dev Thrown when the last message is skipped.\n    error ErrorLastL1MessageSkipped();\n\n    /// @dev Thrown when no blob found in the transaction.\n    error ErrorNoBlobFound();\n\n    /// @dev Thrown when the number of transactions is less than number of L1 message in one block.\n    error ErrorNumTxsLessThanNumL1Msgs();\n\n    /// @dev Thrown when the given previous state is zero.\n    error ErrorPreviousStateRootIsZero();\n\n    /// @dev Thrown when the number of batches to revert is zero.\n    error ErrorRevertZeroBatches();\n\n    /// @dev Thrown when the reverted batches are not in the ending of commited batch chain.\n    error ErrorRevertNotStartFromEnd();\n\n    /// @dev Thrown when reverting a finialized batch.\n    error ErrorRevertFinalizedBatch();\n\n    /// @dev Thrown when the given state root is zero.\n    error ErrorStateRootIsZero();\n\n    /// @dev Thrown when a chunk contains too many transactions.\n    error ErrorTooManyTxsInOneChunk();\n\n    /// @dev Thrown when the precompile output is incorrect.\n    error ErrorUnexpectedPointEvaluationPrecompileOutput();\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @dev Address of the point evaluation precompile used for EIP-4844 blob verification.\n    address constant POINT_EVALUATION_PRECOMPILE_ADDR = address(0x0A);\n\n    /// @dev BLS Modulus value defined in EIP-4844 and the magic value returned from a successful call to the\n    /// point evaluation precompile\n    uint256 constant BLS_MODULUS = 52435875175126190479447740508185965837690552500527637822603658699938581184513;\n\n    /// @notice The chain id of the corresponding layer 2 chain.\n    uint64 public immutable layer2ChainId;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public immutable messageQueue;\n\n    /// @notice The address of RollupVerifier.\n    address public immutable verifier;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The maximum number of transactions allowed in each chunk.\n    uint256 public maxNumTxInChunk;\n\n    /// @dev The storage slot used as L1MessageQueue contract, which is deprecated now.\n    address private __messageQueue;\n\n    /// @dev The storage slot used as RollupVerifier contract, which is deprecated now.\n    address private __verifier;\n\n    /// @notice Whether an account is a sequencer.\n    mapping(address => bool) public isSequencer;\n\n    /// @notice Whether an account is a prover.\n    mapping(address => bool) public isProver;\n\n    /// @inheritdoc IScrollChain\n    uint256 public override lastFinalizedBatchIndex;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override committedBatches;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override finalizedStateRoots;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override withdrawRoots;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier OnlySequencer() {\n        // @note In the decentralized mode, it should be only called by a list of validator.\n        if (!isSequencer[_msgSender()]) revert ErrorCallerIsNotSequencer();\n        _;\n    }\n\n    modifier OnlyProver() {\n        if (!isProver[_msgSender()]) revert ErrorCallerIsNotProver();\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Constructor for `ScrollChain` implementation contract.\n    ///\n    /// @param _chainId The chain id of L2.\n    /// @param _messageQueue The address of `L1MessageQueue` contract.\n    /// @param _verifier The address of zkevm verifier contract.\n    constructor(\n        uint64 _chainId,\n        address _messageQueue,\n        address _verifier\n    ) {\n        if (_messageQueue == address(0) || _verifier == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        layer2ChainId = _chainId;\n        messageQueue = _messageQueue;\n        verifier = _verifier;\n    }\n\n    /// @notice Initialize the storage of ScrollChain.\n    ///\n    /// @dev The parameters `_messageQueue` are no longer used.\n    ///\n    /// @param _messageQueue The address of `L1MessageQueue` contract.\n    /// @param _verifier The address of zkevm verifier contract.\n    /// @param _maxNumTxInChunk The maximum number of transactions allowed in each chunk.\n    function initialize(\n        address _messageQueue,\n        address _verifier,\n        uint256 _maxNumTxInChunk\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        maxNumTxInChunk = _maxNumTxInChunk;\n        __verifier = _verifier;\n        __messageQueue = _messageQueue;\n\n        emit UpdateMaxNumTxInChunk(0, _maxNumTxInChunk);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IScrollChain\n    function isBatchFinalized(uint256 _batchIndex) external view override returns (bool) {\n        return _batchIndex <= lastFinalizedBatchIndex;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Import layer 2 genesis block\n    function importGenesisBatch(bytes calldata _batchHeader, bytes32 _stateRoot) external {\n        // check genesis batch header length\n        if (_stateRoot == bytes32(0)) revert ErrorStateRootIsZero();\n\n        // check whether the genesis batch is imported\n        if (finalizedStateRoots[0] != bytes32(0)) revert ErrorGenesisBatchImported();\n\n        (uint256 memPtr, bytes32 _batchHash, , ) = _loadBatchHeader(_batchHeader);\n\n        // check all fields except `dataHash` and `lastBlockHash` are zero\n        unchecked {\n            uint256 sum = BatchHeaderV0Codec.getVersion(memPtr) +\n                BatchHeaderV0Codec.getBatchIndex(memPtr) +\n                BatchHeaderV0Codec.getL1MessagePopped(memPtr) +\n                BatchHeaderV0Codec.getTotalL1MessagePopped(memPtr);\n            if (sum != 0) revert ErrorGenesisBatchHasNonZeroField();\n        }\n        if (BatchHeaderV0Codec.getDataHash(memPtr) == bytes32(0)) revert ErrorGenesisDataHashIsZero();\n        if (BatchHeaderV0Codec.getParentBatchHash(memPtr) != bytes32(0)) reve"
    }
  ]
}