{
  "Title": "Checking for the existence of the recipient's address",
  "Content": "\nOne cannot be sure that a third-party smart contract whose functions are accessed using the `IController(controller).treasury()` interface returns the correct address value.\nIn the following places, tokens are transferred using the safeTransfer function, but the existence of an address before the call is not checked:\n- [strategy-base.sol#L151](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/strategy-base.sol#L151)\n- [strategy-uni-farm-base.sol#L62](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/strategy-uni-farm-base.sol#L62)\n- [strategy-uni-farm-base.sol#L97](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/strategy-uni-farm-base.sol#L97) \n- [strategy-uni-farm-base.sol#L101](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/strategy-uni-farm-base.sol#L101)\n- [strategy-uni-farm-base.sol#L111](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/strategy-uni-farm-base.sol#L111)\n- [strategy-curve-3crv-v1.sol#L105](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/strategy-curve-3crv-v1.sol#L105)\n- [strategy-curve-3crv-v1.sol#L129](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/strategy-curve-3crv-v1.sol#L129)\n- [strategy-curve-rencrv-v1.sol#L87](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/strategy-curve-rencrv-v1.sol#L87)\n- [strategy-curve-rencrv-v1.sol#L111](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/strategy-curve-rencrv-v1.sol#L111)\n- [strategy-curve-scrv-v3_1.sol#L124](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/strategy-curve-scrv-v3_1.sol#L124)\n- [strategy-curve-scrv-v3_1.sol#L155](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/strategy-curve-scrv-v3_1.sol#L155)\n- [strategy-curve-scrv-v4.sol#L236](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/strategy-curve-scrv-v4.sol#L236)\n- [strategy-curve-scrv-v4.sol#L324](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/strategy-curve-scrv-v4.sol#L324)\n- [strategy-curve-scrv-v4_1.sol#L200](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/strategy-curve-scrv-v4_1.sol#L200)\n- [strategy-cmpd-dai-v1.sol#L351](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/compound/strategy-cmpd-dai-v1.sol#L351)\n\nIn the following places, tokens are transferred using the safeTransfer function, but the existence of an address after the call is not checked `IController(controller).devfund ()`:\n- [strategy-base.sol#L147](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/strategy-base.sol#L147)\n- [strategy-curve-scrv-v4.sol#L232](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/strategy-curve-scrv-v4.sol#L232)\n\nAccess to the functionality of smart contracts with tokens is carried out using interfaces.\nBut not all token smart contracts can include logic to check addresses for zero values.\nTherefore, it is best to do this before accessing the interfaces.\nBetter to do this in one place for all calls in the src/lib/erc20.sol library.\n\nStatus: *Acknowledged.*\n\nClient's comment: *Changing this in the ERC20 library would force the function's implementation to deviate from the original OpenZeppelin source code. It also removes the ability to burn tokens by sending them to a zero address. Since we have implemented constructor checks for zero addresses, the risk of mistakenly sending tokens to a zero address is largely minimized.*\n \n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/strategies/strategy-base.sol",
      "content": "pragma solidity ^0.6.7;\n\nimport \"../lib/erc20.sol\";\nimport \"../lib/safe-math.sol\";\n\nimport \"../interfaces/jar.sol\";\nimport \"../interfaces/staking-rewards.sol\";\nimport \"../interfaces/uniswapv2.sol\";\nimport \"../interfaces/controller.sol\";\n\n// Strategy Contract Basics\n\nabstract contract StrategyBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    // Perfomance fee 4.5%\n    uint256 public performanceFee = 450;\n    uint256 public constant performanceMax = 10000;\n\n    // Withdrawal fee 0.5%\n    // - 0.325% to treasury\n    // - 0.175% to dev fund\n    uint256 public treasuryFee = 325;\n    uint256 public constant treasuryMax = 100000;\n\n    uint256 public devFundFee = 175;\n    uint256 public constant devFundMax = 100000;\n\n    // Tokens\n    address public want;\n    address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // User accounts\n    address public governance;\n    address public controller;\n    address public strategist;\n    address public timelock;\n\n    // Dex\n    address public univ2Router2 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    constructor(\n        address _want,\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    ) public {\n        require(_want != address(0));\n        require(_governance != address(0));\n        require(_strategist != address(0));\n        require(_controller != address(0));\n        require(_timelock != address(0));\n\n        want = _want;\n        governance = _governance;\n        strategist = _strategist;\n        controller = _controller;\n        timelock = _timelock;\n    }\n\n    // **** Modifiers **** //\n\n    modifier onlyBenevolent {\n        require(\n            msg.sender == tx.origin ||\n                msg.sender == governance ||\n                msg.sender == strategist\n        );\n        _;\n    }\n\n    // **** Views **** //\n\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    function balanceOfPool() public virtual view returns (uint256);\n\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    function getName() external virtual pure returns (string memory);\n\n    // **** Setters **** //\n\n    function setDevFundFee(uint256 _devFundFee) external {\n        require(msg.sender == timelock, \"!timelock\");\n        devFundFee = _devFundFee;\n    }\n\n    function setTreasuryFee(uint256 _treasuryFee) external {\n        require(msg.sender == timelock, \"!timelock\");\n        treasuryFee = _treasuryFee;\n    }\n\n    function setPerformanceFee(uint256 _performanceFee) external {\n        require(msg.sender == timelock, \"!timelock\");\n        performanceFee = _performanceFee;\n    }\n\n    function setStrategist(address _strategist) external {\n        require(msg.sender == governance, \"!governance\");\n        strategist = _strategist;\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function setTimelock(address _timelock) external {\n        require(msg.sender == timelock, \"!timelock\");\n        timelock = _timelock;\n    }\n\n    function setController(address _controller) external {\n        require(msg.sender == timelock, \"!timelock\");\n        controller = _controller;\n    }\n\n    // **** State mutations **** //\n    function deposit() public virtual;\n\n    // Controller only function for creating additional rewards from dust\n    function withdraw(IERC20 _asset) external returns (uint256 balance) {\n        require(msg.sender == controller, \"!controller\");\n        require(want != address(_asset), \"want\");\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(controller, balance);\n    }\n\n    // Withdraw partial funds, normally used with a jar withdrawal\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == controller, \"!controller\");\n        uint256 _balance = IERC20(want).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n\n        uint256 _feeDev = _amount.mul(devFundFee).div(devFundMax);\n        IERC20(want).safeTransfer(IController(controller).devfund(), _feeDev);\n\n        uint256 _feeTreasury = _amount.mul(treasuryFee).div(treasuryMax);\n        IERC20(want).safeTransfer(\n            IController(controller).treasury(),\n            _feeTreasury\n        );\n\n        address _jar = IController(controller).jars(address(want));\n        require(_jar != address(0), \"!jar\"); // additional protection so we don't burn the funds\n\n        IERC20(want).safeTransfer(_jar, _amount.sub(_feeDev).sub(_feeTreasury));\n    }\n\n    // Withdraw all funds, normally used when migrating strategies\n    function withdrawAll() external returns (uint256 balance) {\n        require(msg.sender == controller, \"!controller\");\n        _withdrawAll();\n\n        balance = IERC20(want).balanceOf(address(this));\n\n        address _jar = IController(controller).jars(address(want));\n        require(_jar != address(0), \"!jar\"); // additional protection so we don't burn the funds\n        IERC20(want).safeTransfer(_jar, balance);\n    }\n\n    function _withdrawAll() internal {\n        _withdrawSome(balanceOfPool());\n    }\n\n    function _withdrawSome(uint256 _amount) internal virtual returns (uint256);\n\n    function harvest() public virtual;\n\n    // **** Emergency functions ****\n\n    function execute(address _target, bytes memory _data)\n        public\n        payable\n        returns (bytes memory response)\n    {\n        require(msg.sender == timelock, \"!timelock\");\n        require(_target != address(0), \"!target\");\n\n        // call contract in current context\n        assembly {\n            let succeeded := delegatecall(\n                sub(gas(), 5000),\n                _target,\n                add(_data, 0x20),\n                mload(_data),\n                0,\n                0\n            )\n            let size := returndatasize()\n\n            response := mload(0x40)\n            mstore(\n                0x40,\n                add(response, and(add(add(size, 0x20), 0x1f), not(0x1f)))\n            )\n            mstore(response, size)\n            returndatacopy(add(response, 0x20), 0, size)\n\n            switch iszero(succeeded)\n                case 1 {\n                    // throw if delegatecall failed\n                    revert(add(response, 0x20), size)\n                }\n        }\n    }\n\n    // **** Internal functions ****\n    function _swapUniswap(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        require(_to != address(0));\n\n        // Swap with uniswap\n        IERC20(_from).safeApprove(univ2Router2, 0);\n        IERC20(_from).safeApprove(univ2Router2, _amount);\n\n        address[] memory path;\n\n        if (_from == weth || _to == weth) {\n            path = new address[](2);\n            path[0] = _from;\n            path[1] = _to;\n        } else {\n            path = new address[](3);\n            path[0] = _from;\n            path[1] = weth;\n            path[2] = _to;\n        }\n\n        UniswapRouterV2(univ2Router2).swapExactTokensForTokens(\n            _amount,\n            0,\n            path,\n            address(this),\n            now.add(60)\n        );\n    }\n}"
    },
    {
      "filename": "src/strategies/strategy-uni-farm-base.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.7;\n\nimport \"./strategy-staking-rewards-base.sol\";\n\nabstract contract StrategyUniFarmBase is StrategyStakingRewardsBase {\n    // Token addresses\n    address public uni = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984;\n\n    // WETH/<token1> pair\n    address public token1;\n\n    // How much UNI tokens to keep?\n    uint256 public keepUNI = 0;\n    uint256 public constant keepUNIMax = 10000;\n\n    constructor(\n        address _token1,\n        address _rewards,\n        address _lp,\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    )\n        public\n        StrategyStakingRewardsBase(\n            _rewards,\n            _lp,\n            _governance,\n            _strategist,\n            _controller,\n            _timelock\n        )\n    {\n        token1 = _token1;\n    }\n\n    // **** Setters ****\n\n    function setKeepUNI(uint256 _keepUNI) external {\n        require(msg.sender == timelock, \"!timelock\");\n        keepUNI = _keepUNI;\n    }\n\n    // **** State Mutations ****\n\n    function harvest() public override onlyBenevolent {\n        // Anyone can harvest it at any given time.\n        // I understand the possibility of being frontrun\n        // But ETH is a dark forest, and I wanna see how this plays out\n        // i.e. will be be heavily frontrunned?\n        //      if so, a new strategy will be deployed.\n\n        // Collects UNI tokens\n        IStakingRewards(rewards).getReward();\n        uint256 _uni = IERC20(uni).balanceOf(address(this));\n        if (_uni > 0) {\n            // 10% is locked up for future gov\n            uint256 _keepUNI = _uni.mul(keepUNI).div(keepUNIMax);\n            IERC20(uni).safeTransfer(\n                IController(controller).treasury(),\n                _keepUNI\n            );\n            _swapUniswap(uni, weth, _uni.sub(_keepUNI));\n        }\n\n        // Swap half WETH for DAI\n        uint256 _weth = IERC20(weth).balanceOf(address(this));\n        if (_weth > 0) {\n            _swapUniswap(weth, token1, _weth.div(2));\n        }\n\n        // Adds in liquidity for ETH/DAI\n        _weth = IERC20(weth).balanceOf(address(this));\n        uint256 _token1 = IERC20(token1).balanceOf(address(this));\n        if (_weth > 0 && _token1 > 0) {\n            IERC20(weth).safeApprove(univ2Router2, 0);\n            IERC20(weth).safeApprove(univ2Router2, _weth);\n\n            IERC20(token1).safeApprove(univ2Router2, 0);\n            IERC20(token1).safeApprove(univ2Router2, _token1);\n\n            UniswapRouterV2(univ2Router2).addLiquidity(\n                weth,\n                token1,\n                _weth,\n                _token1,\n                0,\n                0,\n                address(this),\n                now + 60\n            );\n\n            // Donates DUST\n            IERC20(weth).transfer(\n                IController(controller).treasury(),\n                IERC20(weth).balanceOf(address(this))\n            );\n            IERC20(token1).safeTransfer(\n                IController(controller).treasury(),\n                IERC20(token1).balanceOf(address(this))\n            );\n        }\n\n        // We want to get back UNI LP tokens\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            // Performance fee\n            IERC20(want).safeTransfer(\n                IController(controller).treasury(),\n                _want.mul(performanceFee).div(performanceMax)\n            );\n\n            deposit();\n        }\n    }\n}"
    },
    {
      "filename": "src/strategies/strategy-uni-farm-base.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.7;\n\nimport \"./strategy-staking-rewards-base.sol\";\n\nabstract contract StrategyUniFarmBase is StrategyStakingRewardsBase {\n    // Token addresses\n    address public uni = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984;\n\n    // WETH/<token1> pair\n    address public token1;\n\n    // How much UNI tokens to keep?\n    uint256 public keepUNI = 0;\n    uint256 public constant keepUNIMax = 10000;\n\n    constructor(\n        address _token1,\n        address _rewards,\n        address _lp,\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    )\n        public\n        StrategyStakingRewardsBase(\n            _rewards,\n            _lp,\n            _governance,\n            _strategist,\n            _controller,\n            _timelock\n        )\n    {\n        token1 = _token1;\n    }\n\n    // **** Setters ****\n\n    function setKeepUNI(uint256 _keepUNI) external {\n        require(msg.sender == timelock, \"!timelock\");\n        keepUNI = _keepUNI;\n    }\n\n    // **** State Mutations ****\n\n    function harvest() public override onlyBenevolent {\n        // Anyone can harvest it at any given time.\n        // I understand the possibility of being frontrun\n        // But ETH is a dark forest, and I wanna see how this plays out\n        // i.e. will be be heavily frontrunned?\n        //      if so, a new strategy will be deployed.\n\n        // Collects UNI tokens\n        IStakingRewards(rewards).getReward();\n        uint256 _uni = IERC20(uni).balanceOf(address(this));\n        if (_uni > 0) {\n            // 10% is locked up for future gov\n            uint256 _keepUNI = _uni.mul(keepUNI).div(keepUNIMax);\n            IERC20(uni).safeTransfer(\n                IController(controller).treasury(),\n                _keepUNI\n            );\n            _swapUniswap(uni, weth, _uni.sub(_keepUNI));\n        }\n\n        // Swap half WETH for DAI\n        uint256 _weth = IERC20(weth).balanceOf(address(this));\n        if (_weth > 0) {\n            _swapUniswap(weth, token1, _weth.div(2));\n        }\n\n        // Adds in liquidity for ETH/DAI\n        _weth = IERC20(weth).balanceOf(address(this));\n        uint256 _token1 = IERC20(token1).balanceOf(address(this));\n        if (_weth > 0 && _token1 > 0) {\n            IERC20(weth).safeApprove(univ2Router2, 0);\n            IERC20(weth).safeApprove(univ2Router2, _weth);\n\n            IERC20(token1).safeApprove(univ2Router2, 0);\n            IERC20(token1).safeApprove(univ2Router2, _token1);\n\n            UniswapRouterV2(univ2Router2).addLiquidity(\n                weth,\n                token1,\n                _weth,\n                _token1,\n                0,\n                0,\n                address(this),\n                now + 60\n            );\n\n            // Donates DUST\n            IERC20(weth).transfer(\n                IController(controller).treasury(),\n                IERC20(weth).balanceOf(address(this))\n            );\n            IERC20(token1).safeTransfer(\n                IController(controller).treasury(),\n                IERC20(token1).balanceOf(address(this))\n            );\n        }\n\n        // We want to get back UNI LP tokens\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            // Performance fee\n            IERC20(want).safeTransfer(\n                IController(controller).treasury(),\n                _want.mul(performanceFee).div(performanceMax)\n            );\n\n            deposit();\n        }\n    }\n}"
    },
    {
      "filename": "src/strategies/strategy-uni-farm-base.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.7;\n\nimport \"./strategy-staking-rewards-base.sol\";\n\nabstract contract StrategyUniFarmBase is StrategyStakingRewardsBase {\n    // Token addresses\n    address public uni = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984;\n\n    // WETH/<token1> pair\n    address public token1;\n\n    // How much UNI tokens to keep?\n    uint256 public keepUNI = 0;\n    uint256 public constant keepUNIMax = 10000;\n\n    constructor(\n        address _token1,\n        address _rewards,\n        address _lp,\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    )\n        public\n        StrategyStakingRewardsBase(\n            _rewards,\n            _lp,\n            _governance,\n            _strategist,\n            _controller,\n            _timelock\n        )\n    {\n        token1 = _token1;\n    }\n\n    // **** Setters ****\n\n    function setKeepUNI(uint256 _keepUNI) external {\n        require(msg.sender == timelock, \"!timelock\");\n        keepUNI = _keepUNI;\n    }\n\n    // **** State Mutations ****\n\n    function harvest() public override onlyBenevolent {\n        // Anyone can harvest it at any given time.\n        // I understand the possibility of being frontrun\n        // But ETH is a dark forest, and I wanna see how this plays out\n        // i.e. will be be heavily frontrunned?\n        //      if so, a new strategy will be deployed.\n\n        // Collects UNI tokens\n        IStakingRewards(rewards).getReward();\n        uint256 _uni = IERC20(uni).balanceOf(address(this));\n        if (_uni > 0) {\n            // 10% is locked up for future gov\n            uint256 _keepUNI = _uni.mul(keepUNI).div(keepUNIMax);\n            IERC20(uni).safeTransfer(\n                IController(controller).treasury(),\n                _keepUNI\n            );\n            _swapUniswap(uni, weth, _uni.sub(_keepUNI));\n        }\n\n        // Swap half WETH for DAI\n        uint256 _weth = IERC20(weth).balanceOf(address(this));\n        if (_weth > 0) {\n            _swapUniswap(weth, token1, _weth.div(2));\n        }\n\n        // Adds in liquidity for ETH/DAI\n        _weth = IERC20(weth).balanceOf(address(this));\n        uint256 _token1 = IERC20(token1).balanceOf(address(this));\n        if (_weth > 0 && _token1 > 0) {\n            IERC20(weth).safeApprove(univ2Router2, 0);\n            IERC20(weth).safeApprove(univ2Router2, _weth);\n\n            IERC20(token1).safeApprove(univ2Router2, 0);\n            IERC20(token1).safeApprove(univ2Router2, _token1);\n\n            UniswapRouterV2(univ2Router2).addLiquidity(\n                weth,\n                token1,\n                _weth,\n                _token1,\n                0,\n                0,\n                address(this),\n                now + 60\n            );\n\n            // Donates DUST\n            IERC20(weth).transfer(\n                IController(controller).treasury(),\n                IERC20(weth).balanceOf(address(this))\n            );\n            IERC20(token1).safeTransfer(\n                IController(controller).treasury(),\n                IERC20(token1).balanceOf(address(this))\n            );\n        }\n\n        // We want to get back UNI LP tokens\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            // Performance fee\n            IERC20(want).safeTransfer(\n                IController(controller).treasury(),\n                _want.mul(performanceFee).div(performanceMax)\n            );\n\n            deposit();\n        }\n    }\n}"
    },
    {
      "filename": "src/strategies/strategy-uni-farm-base.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.7;\n\nimport \"./strategy-staking-rewards-base.sol\";\n\nabstract contract StrategyUniFarmBase is StrategyStakingRewardsBase {\n    // Token addresses\n    address public uni = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984;\n\n    // WETH/<token1> pair\n    address public token1;\n\n    // How much UNI tokens to keep?\n    uint256 public keepUNI = 0;\n    uint256 public constant keepUNIMax = 10000;\n\n    constructor(\n        address _token1,\n        address _rewards,\n        address _lp,\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    )\n        public\n        StrategyStakingRewardsBase(\n            _rewards,\n            _lp,\n            _governance,\n            _strategist,\n            _controller,\n            _timelock\n        )\n    {\n        token1 = _token1;\n    }\n\n    // **** Setters ****\n\n    function setKeepUNI(uint256 _keepUNI) external {\n        require(msg.sender == timelock, \"!timelock\");\n        keepUNI = _keepUNI;\n    }\n\n    // **** State Mutations ****\n\n    function harvest() public override onlyBenevolent {\n        // Anyone can harvest it at any given time.\n        // I understand the possibility of being frontrun\n        // But ETH is a dark forest, and I wanna see how this plays out\n        // i.e. will be be heavily frontrunned?\n        //      if so, a new strategy will be deployed.\n\n        // Collects UNI tokens\n        IStakingRewards(rewards).getReward();\n        uint256 _uni = IERC20(uni).balanceOf(address(this));\n        if (_uni > 0) {\n            // 10% is locked up for future gov\n            uint256 _keepUNI = _uni.mul(keepUNI).div(keepUNIMax);\n            IERC20(uni).safeTransfer(\n                IController(controller).treasury(),\n                _keepUNI\n            );\n            _swapUniswap(uni, weth, _uni.sub(_keepUNI));\n        }\n\n        // Swap half WETH for DAI\n        uint256 _weth = IERC20(weth).balanceOf(address(this));\n        if (_weth > 0) {\n            _swapUniswap(weth, token1, _weth.div(2));\n        }\n\n        // Adds in liquidity for ETH/DAI\n        _weth = IERC20(weth).balanceOf(address(this));\n        uint256 _token1 = IERC20(token1).balanceOf(address(this));\n        if (_weth > 0 && _token1 > 0) {\n            IERC20(weth).safeApprove(univ2Router2, 0);\n            IERC20(weth).safeApprove(univ2Router2, _weth);\n\n            IERC20(token1).safeApprove(univ2Router2, 0);\n            IERC20(token1).safeApprove(univ2Router2, _token1);\n\n            UniswapRouterV2(univ2Router2).addLiquidity(\n                weth,\n                token1,\n                _weth,\n                _token1,\n                0,\n                0,\n                address(this),\n                now + 60\n            );\n\n            // Donates DUST\n            IERC20(weth).transfer(\n                IController(controller).treasury(),\n                IERC20(weth).balanceOf(address(this))\n            );\n            IERC20(token1).safeTransfer(\n                IController(controller).treasury(),\n                IERC20(token1).balanceOf(address(this))\n            );\n        }\n\n        // We want to get back UNI LP tokens\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            // Performance fee\n            IERC20(want).safeTransfer(\n                IController(controller).treasury(),\n                _want.mul(performanceFee).div(performanceMax)\n            );\n\n            deposit();\n        }\n    }\n}"
    },
    {
      "filename": "src/strategies/curve/strategy-curve-3crv-v1.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\nimport \"../../lib/erc20.sol\";\nimport \"../../lib/safe-math.sol\";\n\nimport \"../../interfaces/jar.sol\";\nimport \"../../interfaces/curve.sol\";\nimport \"../../interfaces/uniswapv2.sol\";\nimport \"../../interfaces/controller.sol\";\n\nimport \"../strategy-curve-base.sol\";\n\ncontract StrategyCurve3CRVv1 is StrategyCurveBase {\n    // Curve stuff\n    address public three_pool = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\n    address public three_gauge = 0xbFcF63294aD7105dEa65aA58F8AE5BE2D9d0952A;\n    address public three_crv = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;\n\n    constructor(\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    )\n        public\n        StrategyCurveBase(\n            three_pool,\n            three_gauge,\n            three_crv,\n            _governance,\n            _strategist,\n            _controller,\n            _timelock\n        )\n    {}\n\n    // **** Views ****\n\n    function getMostPremium()\n        public\n        override\n        view\n        returns (address, uint256)\n    {\n        uint256[] memory balances = new uint256[](3);\n        balances[0] = ICurveFi_3(curve).balances(0); // DAI\n        balances[1] = ICurveFi_3(curve).balances(1).mul(10**12); // USDC\n        balances[2] = ICurveFi_3(curve).balances(2).mul(10**12); // USDT\n\n        // DAI\n        if (\n            balances[0] < balances[1] &&\n            balances[0] < balances[2]\n        ) {\n            return (dai, 0);\n        }\n\n        // USDC\n        if (\n            balances[1] < balances[0] &&\n            balances[1] < balances[2]\n        ) {\n            return (usdc, 1);\n        }\n\n        // USDT\n        if (\n            balances[2] < balances[0] &&\n            balances[2] < balances[1]\n        ) {\n            return (usdt, 2);\n        }\n\n        // If they're somehow equal, we just want DAI\n        return (dai, 0);\n    }\n\n    function getName() external override pure returns (string memory) {\n        return \"StrategyCurve3CRVv1\";\n    }\n\n    // **** State Mutations ****\n\n    function harvest() public onlyBenevolent override {\n        // Anyone can harvest it at any given time.\n        // I understand the possibility of being frontrun\n        // But ETH is a dark forest, and I wanna see how this plays out\n        // i.e. will be be heavily frontrunned?\n        //      if so, a new strategy will be deployed.\n\n        // stablecoin we want to convert to\n        (address to, uint256 toIndex) = getMostPremium();\n\n        // Collects crv tokens\n        // Don't bother voting in v1\n        ICurveMintr(mintr).mint(gauge);\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\n        if (_crv > 0) {\n            // x% is sent back to the rewards holder\n            // to be used to lock up in as veCRV in a future date\n            uint256 _keepCRV = _crv.mul(keepCRV).div(keepCRVMax);\n            if (_keepCRV > 0) {\n                IERC20(crv).safeTransfer(\n                    IController(controller).treasury(),\n                    _keepCRV\n                );\n            }\n            _crv = _crv.sub(_keepCRV);\n            _swapUniswap(crv, to, _crv);\n        }\n\n        // Adds liquidity to curve.fi's pool\n        // to get back want (scrv)\n        uint256 _to = IERC20(to).balanceOf(address(this));\n        if (_to > 0) {\n            IERC20(to).safeApprove(curve, 0);\n            IERC20(to).safeApprove(curve, _to);\n            uint256[3] memory liquidity;\n            liquidity[toIndex] = _to;\n            ICurveFi_3(curve).add_liquidity(liquidity, 0);\n        }\n\n        // We want to get back sCRV\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            // Fees 4.5% goes to treasury\n            IERC20(want).safeTransfer(\n                IController(controller).treasury(),\n                _want.mul(performanceFee).div(performanceMax)\n            );\n\n            deposit();\n        }\n    }\n}"
    },
    {
      "filename": "src/strategies/curve/strategy-curve-3crv-v1.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\nimport \"../../lib/erc20.sol\";\nimport \"../../lib/safe-math.sol\";\n\nimport \"../../interfaces/jar.sol\";\nimport \"../../interfaces/curve.sol\";\nimport \"../../interfaces/uniswapv2.sol\";\nimport \"../../interfaces/controller.sol\";\n\nimport \"../strategy-curve-base.sol\";\n\ncontract StrategyCurve3CRVv1 is StrategyCurveBase {\n    // Curve stuff\n    address public three_pool = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\n    address public three_gauge = 0xbFcF63294aD7105dEa65aA58F8AE5BE2D9d0952A;\n    address public three_crv = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;\n\n    constructor(\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    )\n        public\n        StrategyCurveBase(\n            three_pool,\n            three_gauge,\n            three_crv,\n            _governance,\n            _strategist,\n            _controller,\n            _timelock\n        )\n    {}\n\n    // **** Views ****\n\n    function getMostPremium()\n        public\n        override\n        view\n        returns (address, uint256)\n    {\n        uint256[] memory balances = new uint256[](3);\n        balances[0] = ICurveFi_3(curve).balances(0); // DAI\n        balances[1] = ICurveFi_3(curve).balances(1).mul(10**12); // USDC\n        balances[2] = ICurveFi_3(curve).balances(2).mul(10**12); // USDT\n\n        // DAI\n        if (\n            balances[0] < balances[1] &&\n            balances[0] < balances[2]\n        ) {\n            return (dai, 0);\n        }\n\n        // USDC\n        if (\n            balances[1] < balances[0] &&\n            balances[1] < balances[2]\n        ) {\n            return (usdc, 1);\n        }\n\n        // USDT\n        if (\n            balances[2] < balances[0] &&\n            balances[2] < balances[1]\n        ) {\n            return (usdt, 2);\n        }\n\n        // If they're somehow equal, we just want DAI\n        return (dai, 0);\n    }\n\n    function getName() external override pure returns (string memory) {\n        return \"StrategyCurve3CRVv1\";\n    }\n\n    // **** State Mutations ****\n\n    function harvest() public onlyBenevolent override {\n        // Anyone can harvest it at any given time.\n        // I understand the possibility of being frontrun\n        // But ETH is a dark forest, and I wanna see how this plays out\n        // i.e. will be be heavily frontrunned?\n        //      if so, a new strategy will be deployed.\n\n        // stablecoin we want to convert to\n        (address to, uint256 toIndex) = getMostPremium();\n\n        // Collects crv tokens\n        // Don't bother voting in v1\n        ICurveMintr(mintr).mint(gauge);\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\n        if (_crv > 0) {\n            // x% is sent back to the rewards holder\n            // to be used to lock up in as veCRV in a future date\n            uint256 _keepCRV = _crv.mul(keepCRV).div(keepCRVMax);\n            if (_keepCRV > 0) {\n                IERC20(crv).safeTransfer(\n                    IController(controller).treasury(),\n                    _keepCRV\n                );\n            }\n            _crv = _crv.sub(_keepCRV);\n            _swapUniswap(crv, to, _crv);\n        }\n\n        // Adds liquidity to curve.fi's pool\n        // to get back want (scrv)\n        uint256 _to = IERC20(to).balanceOf(address(this));\n        if (_to > 0) {\n            IERC20(to).safeApprove(curve, 0);\n            IERC20(to).safeApprove(curve, _to);\n            uint256[3] memory liquidity;\n            liquidity[toIndex] = _to;\n            ICurveFi_3(curve).add_liquidity(liquidity, 0);\n        }\n\n        // We want to get back sCRV\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            // Fees 4.5% goes to treasury\n            IERC20(want).safeTransfer(\n                IController(controller).treasury(),\n                _want.mul(performanceFee).div(performanceMax)\n            );\n\n            deposit();\n        }\n    }\n}"
    },
    {
      "filename": "src/strategies/curve/strategy-curve-rencrv-v1.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\nimport \"../../lib/erc20.sol\";\nimport \"../../lib/safe-math.sol\";\n\nimport \"../../interfaces/jar.sol\";\nimport \"../../interfaces/curve.sol\";\nimport \"../../interfaces/uniswapv2.sol\";\nimport \"../../interfaces/controller.sol\";\n\nimport \"../strategy-curve-base.sol\";\n\ncontract StrategyCurveRenCRVv1 is StrategyCurveBase {\n    // https://www.curve.fi/ren\n    // Curve stuff\n    address public ren_pool = 0x93054188d876f558f4a66B2EF1d97d16eDf0895B;\n    address public ren_gauge = 0xB1F2cdeC61db658F091671F5f199635aEF202CAC;\n    address public ren_crv = 0x49849C98ae39Fff122806C06791Fa73784FB3675;\n\n    constructor(\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    )\n        public\n        StrategyCurveBase(\n            ren_pool,\n            ren_gauge,\n            ren_crv,\n            _governance,\n            _strategist,\n            _controller,\n            _timelock\n        )\n    {}\n\n    // **** Views ****\n\n    function getMostPremium() public override view returns (address, uint256) {\n        // Both 8 decimals, so doesn't matter\n        uint256[] memory balances = new uint256[](3);\n        balances[0] = ICurveFi_2(curve).balances(0); // RENBTC\n        balances[1] = ICurveFi_2(curve).balances(1); // WBTC\n\n        // renbtc\n        if (balances[0] < balances[1]) {\n            return (renbtc, 0);\n        }\n\n        // WBTC\n        if (balances[1] < balances[0]) {\n            return (wbtc, 1);\n        }\n\n        // If they're somehow equal, we just want RENBTC\n        return (renbtc, 0);\n    }\n\n    function getName() external override pure returns (string memory) {\n        return \"StrategyCurveRenCRVv1\";\n    }\n\n    // **** State Mutations ****\n\n    function harvest() public override onlyBenevolent {\n        // Anyone can harvest it at any given time.\n        // I understand the possibility of being frontrun\n        // But ETH is a dark forest, and I wanna see how this plays out\n        // i.e. will be be heavily frontrunned?\n        //      if so, a new strategy will be deployed.\n\n        // stablecoin we want to convert to\n        (address to, uint256 toIndex) = getMostPremium();\n\n        // Collects crv tokens\n        // Don't bother voting in v1\n        ICurveMintr(mintr).mint(gauge);\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\n        if (_crv > 0) {\n            // x% is sent back to the rewards holder\n            // to be used to lock up in as veCRV in a future date\n            uint256 _keepCRV = _crv.mul(keepCRV).div(keepCRVMax);\n            if (_keepCRV > 0) {\n                IERC20(crv).safeTransfer(\n                    IController(controller).treasury(),\n                    _keepCRV\n                );\n            }\n            _crv = _crv.sub(_keepCRV);"
    }
  ]
}