{
  "Title": "[H04] Token transfers may fail silently [sample]",
  "Content": "The `DepositPaymaster` ignores the token transfer return value when [adding deposits](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/samples/DepositPaymaster.sol#L53), [withdrawing tokens from the contract](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/samples/DepositPaymaster.sol#L89) and [recovering gas costs](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/samples/DepositPaymaster.sol#L122). Although many tokens revert on failure, the [token standard](https://eips.ethereum.org/EIPS/eip-20) only specifies a boolean return value indicating success or failure. For tokens that return `false`, such as the [0x Protocol Token](https://etherscan.io/address/0xe41d2489571d322189246dafa5ebde1f4699f498), these transfers may fail silently, leading to incorrect internal accounting.\n\n\nConsider checking the return value of all ERC20 transfers, or using OpenZeppelin’s [safe transfer functions](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/token/ERC20/utils/SafeERC20.sol#L21-L36).\n\n\n***Update**: Fixed in pull request [#54](https://github.com/eth-infinitism/account-abstraction/pull/54/files). The `DepositPaymaster` contract now uses OpenZeppelin’s [`SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/token/ERC20/utils/SafeERC20.sol) library functions for token transfers.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/samples/DepositPaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../BasePaymaster.sol\";\nimport \"./IOracle.sol\";\n\n/**\n * A token-based paymaster that accepts token deposit\n * The deposit is only a safeguard: the user pays with his token balance.\n *  only if the user didn't approve() the paymaster, or if the token balance is not enough, the deposit will be used.\n *  thus the required deposit is to cover just one method call.\n * The deposit is locked for the current block: the user must issue unlockTokenDeposit() to be allowed to withdraw\n *  (but can't use the deposit for this or further operations)\n *\n * paymasterData should hold the token to use.\n*/\ncontract DepositPaymaster is BasePaymaster {\n\n    using UserOperationLib for UserOperation;\n\n    IOracle constant nullOracle = IOracle(address(0));\n    mapping(IERC20 => IOracle) public oracles;\n    mapping(IERC20 => mapping(address => uint)) public balances;\n    mapping(address => uint) unlockBlock;\n\n    constructor(EntryPoint _entryPoint) BasePaymaster(_entryPoint) {\n        //owner account is unblocked, to allow withdraw of paid tokens;\n        unlockTokenDeposit();\n    }\n\n    /**\n     * owner of the paymaster should add supported tokens\n     */\n    function addToken(IERC20 token, IOracle tokenPriceOracle) external onlyOwner {\n        require(oracles[token] == nullOracle);\n        oracles[token] = tokenPriceOracle;\n    }\n\n    /**\n     * deposit tokens that a specific account can use to pay for gas.\n     * The sender must first approve this paymaster to withdraw these tokens (they are only withdrawn in this method).\n     * Note depositing the tokens is equivalent to transferring them to the \"account\" - only the account can later\n     *  use them - either as gas, or using withdrawTo()\n     *\n     * @param token the token to deposit.\n     * @param account the account to deposit for.\n     * @param amount the amount of token to deposit.\n     */\n    function addDepositFor(IERC20 token, address account, uint amount) external {\n        //(sender must have approval for the paymaster)\n        token.transferFrom(msg.sender, address(this), amount);\n        require(oracles[token] != nullOracle, \"unsupported token\");\n        balances[token][account] += amount;\n        if (msg.sender == account) {\n            lockTokenDeposit();\n        }\n    }\n\n    function depositInfo(IERC20 token, address account) public view returns (uint amount, uint _unlockBlock) {\n        amount = balances[token][account];\n        _unlockBlock = unlockBlock[account];\n    }\n\n    /**\n     * unlock deposit, so that it can be withdrawn.\n     * can't be called on in the same block as withdrawTo()\n     */\n    function unlockTokenDeposit() public {\n        unlockBlock[msg.sender] = block.number;\n    }\n\n    /**\n     * lock the tokens deposited for this account so they can be used to pay for gas.\n     * after calling unlockTokenDeposit(), the account can't use this paymaster until the deposit is locked.\n     */\n    function lockTokenDeposit() public {\n        unlockBlock[msg.sender] = 0;\n    }\n\n    /**\n     * withdraw tokens.\n     * can only be called after unlock() is called in a previous block.\n     */\n    function withdrawTokensTo(IERC20 token, address target, uint amount) public {\n        require(unlockBlock[msg.sender] != 0 && block.number > unlockBlock[msg.sender], \"DepositPaymaster: must unlockTokenDeposit\");\n        balances[token][msg.sender] -= amount;\n        token.transfer(target, amount);\n    }\n\n    function getTokenToEthOutputPrice(IERC20 token, uint ethBought) internal view virtual returns (uint requiredTokens) {\n        IOracle oracle = oracles[token];\n        require(oracle != nullOracle, \"DepositPaymaster: unsupported token\");\n        return oracle.getTokenToEthOutputPrice(ethBought);\n    }\n\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 requestId, uint maxCost)\n    external view override returns (bytes memory context) {\n\n        (requestId);\n        // make sure that verificationGas is high enough to handle postOp\n        require(userOp.verificationGas > 35000, \"DepositPaymaster: gas too low for postOp\");\n\n        require(userOp.paymasterData.length == 32, \"DepositPaymaster: paymasterData must specify token\");\n        IERC20 token = abi.decode(userOp.paymasterData, (IERC20));\n        address account = userOp.getSender();\n        uint maxTokenCost = getTokenToEthOutputPrice(token, maxCost);\n        require(unlockBlock[account] == 0, \"DepositPaymaster: deposit not locked\");\n        require(balances[token][account] >= maxTokenCost, \"DepositPaymaster: deposit too low\");\n        return abi.encode(account, token, maxTokenCost, maxCost);\n    }\n\n    function _postOp(PostOpMode mode, bytes calldata context, uint actualGasCost) internal override {\n        (mode);\n\n        (address account, IERC20 token, uint maxTokenCost, uint maxCost) = abi.decode(context, (address, IERC20, uint, uint));\n        //use same conversion rate as used for validation.\n        uint actualTokenCost = actualGasCost * maxTokenCost / maxCost;\n        if (mode != PostOpMode.postOpReverted) {\n            // attempt to pay with tokens:\n            token.transferFrom(account, address(this), actualTokenCost);\n        } else {\n            //in case above transferFrom failed, pay with deposit:\n            balances[token][account] -= actualTokenCost;\n        }\n        balances[token][owner()] += actualTokenCost;\n    }\n}"
    },
    {
      "filename": "contracts/token/ERC20/utils/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
    }
  ]
}