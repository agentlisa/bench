{
  "Title": "Incorrect Function Signature in _setActionsPaused",
  "Content": "The [`ensureAllowed`](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/facets/SetterFacet.sol#L272-L273) check in the `_setActionsPaused` function verifies whether a certain user is allowed to call the function by checking the `msg.sender` and function signature in the `AccessControlManager`.\n\n\nHowever, the signature is calculated incorrectly. To calculate the 4-byte signature for `_setActionsPaused(address[] calldata markets_, Action[] calldata actions_, bool paused_)`, the canonical representation `_setActionsPaused(address[],uint8[],bool)` should be used instead of `_setActionsPaused(address[],uint256[],bool)`. [`Actions` is an enum](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/ComptrollerStorage.sol#L208-L218), and in Solidity `0.5.16` enums are mapped to [the smallest `uint` type that is large enough to hold all the values](https://docs.soliditylang.org/en/v0.5.16/abi-spec.html?highlight=selector#mapping-solidity-to-abi-types). Since [`Actions` holds 9 values](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/ComptrollerStorage.sol#L208-L218), it will be mapped to `uint8`.\n\n\nThe correct function signature for the `_setActionsPaused` function should be `0x2b5d790c`.\n\n\nIn this case, since the canonical representation is used instead of the 4-byte signature when [setting](https://github.com/VenusProtocol/governance-contracts/blob/19b431d32fab44cadd49accd429a709e552febce/contracts/Governance/AccessControlManager.sol#L38-L42) and [checking](https://github.com/VenusProtocol/governance-contracts/blob/19b431d32fab44cadd49accd429a709e552febce/contracts/Governance/AccessControlManager.sol#L70-L79) the signature, the impact is relatively limited.\n\n\n***Update:** Resolved in [pull request #312](https://github.com/VenusProtocol/venus-protocol/pull/312) at commit [cfaa69a](https://github.com/VenusProtocol/venus-protocol/pull/312/commits/cfaa69aea6ef1d55c7fc4e457780ca83cd58add1).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Comptroller/Diamond/facets/SetterFacet.sol",
      "content": "pragma solidity 0.5.16;\n\nimport \"../../../Oracle/PriceOracle.sol\";\nimport \"../../../Tokens/VTokens/VToken.sol\";\nimport \"../../../Utils/ErrorReporter.sol\";\nimport \"./FacetBase.sol\";\n\n/**\n * @dev This facet contains all the setters for the states\n */\ncontract SetterFacet is ComptrollerErrorReporter, ExponentialNoError, FacetBase {\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(VToken vToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when borrow cap for a vToken is changed\n    event NewBorrowCap(VToken indexed vToken, uint newBorrowCap);\n\n    /// @notice Emitted when VAIController is changed\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\n\n    /// @notice Emitted when VAI mint rate is changed by admin\n    event NewVAIMintRate(uint oldVAIMintRate, uint newVAIMintRate);\n\n    /// @notice Emitted when protocol state is changed by admin\n    event ActionProtocolPaused(bool state);\n\n    /// @notice Emitted when treasury guardian is changed\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\n\n    /// @notice Emitted when treasury address is changed\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\n\n    /// @notice Emitted when treasury percent is changed\n    event NewTreasuryPercent(uint oldTreasuryPercent, uint newTreasuryPercent);\n\n    /// @notice Emitted when liquidator adress is changed\n    event NewLiquidatorContract(address oldLiquidatorContract, address newLiquidatorContract);\n\n    /// @notice Emitted when ComptrollerLens address is changed\n    event NewComptrollerLens(address oldComptrollerLens, address newComptrollerLens);\n\n    /// @notice Emitted when supply cap for a vToken is changed\n    event NewSupplyCap(VToken indexed vToken, uint newSupplyCap);\n\n    /// @notice Emitted when access control address is changed by admin\n    event NewAccessControl(address oldAccessControlAddress, address newAccessControlAddress);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(VToken indexed vToken, Action indexed action, bool pauseState);\n\n    /// @notice Emitted when VAI Vault info is changed\n    event NewVAIVaultInfo(address vault_, uint releaseStartBlock_, uint releaseInterval_);\n\n    /// @notice Emitted when Venus VAI Vault rate is changed\n    event NewVenusVAIVaultRate(uint oldVenusVAIVaultRate, uint newVenusVAIVaultRate);\n\n    /**\n     * @notice Sets a new price oracle for the comptroller\n     * @dev Admin function to set a new price oracle\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPriceOracle(PriceOracle newOracle) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(newOracle));\n\n        // Track the old oracle for the comptroller\n        PriceOracle oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Admin function to set closeFactor\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint 0=success, otherwise will revert\n     */\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the address of the access control of this contract\n     * @dev Admin function to set the access control address\n     * @param newAccessControlAddress New address for the access control\n     * @return uint 0=success, otherwise will revert\n     */\n    function _setAccessControl(address newAccessControlAddress) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(newAccessControlAddress);\n\n        address oldAccessControlAddress = accessControl;\n        accessControl = newAccessControlAddress;\n        emit NewAccessControl(oldAccessControlAddress, newAccessControlAddress);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the collateralFactor for a market\n     * @dev Restricted function to set per-market collateralFactor\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCollateralFactor(VToken vToken, uint newCollateralFactorMantissa) external returns (uint) {\n        // Check caller is allowed by access control manager\n        ensureAllowed(\"_setCollateralFactor(address,uint256)\");\n        ensureNonzeroAddress(address(vToken));\n\n        // Verify market is listed\n        Market storage market = markets[address(vToken)];\n        ensureListed(market);\n\n        Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\n\n        //-- Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(vToken) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets liquidationIncentive\n     * @dev Admin function to set liquidationIncentive\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n        ensureAllowed(\"_setLiquidationIncentive(uint256)\");\n\n        require(newLiquidationIncentiveMantissa >= 1e18, \"incentive must be over 1e18\");\n\n        // Save current value for use in log\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setLiquidatorContract(address newLiquidatorContract_) external {\n        // Check caller is admin\n        ensureAdmin();\n        address oldLiquidatorContract = liquidatorContract;\n        liquidatorContract = newLiquidatorContract_;\n        emit NewLiquidatorContract(oldLiquidatorContract, newLiquidatorContract_);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(address newPauseGuardian) external returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(newPauseGuardian);\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the given borrow caps for the given vToken market Borrowing that brings total borrows to or above borrow cap will revert.\n     * @dev Access is controled by ACM. A borrow cap of 0 corresponds to unlimited borrowing.\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n     */\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint[] calldata newBorrowCaps) external {\n        ensureAllowed(\"_setMarketBorrowCaps(address[],uint256[])\");\n\n        uint numMarkets = vTokens.length;\n        uint numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for (uint i; i < numMarkets; ++i) {\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Set the given supply caps for the given vToken market Supply that brings total Supply to or above supply cap will revert.\n     * @dev Admin function to set the supply cap A supply cap of 0 corresponds to Minting NotAllowed.\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed.\n     */\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\n        ensureAllowed(\"_setMarketSupplyCaps(address[],uint256[])\");\n\n        uint numMarkets = vTokens.length;\n        uint numSupplyCaps = newSupplyCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\n\n        for (uint i; i < numMarkets; ++i) {\n            supplyCaps[address(vTokens[i])] = newSupplyCaps[i];\n            emit NewSupplyCap(vTokens[i], newSupplyCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Set whole protocol pause/unpause state\n     */\n    function _setProtocolPaused(bool state) external returns (bool) {\n        ensureAllowed(\"_setProtocolPaused(bool)\");\n\n        protocolPaused = state;\n        emit ActionProtocolPaused(state);\n        return state;\n    }\n\n    /**\n     * @notice Pause/unpause certain actions\n     * @param markets_ Markets to pause/unpause the actions on\n     * @param actions_ List of action ids to pause/unpause\n     * @param paused_ The new paused state (true=paused, false=unpaused)\n     */\n    function _setActionsPaused(address[] calldata markets_, Action[] calldata actions_, bool paused_) external {\n        ensureAllowed(\"_setActionsPaused(address[],uint256[],bool)\");\n\n        uint256 numMarkets = markets_.length;\n        uint256 numActions = actions_.length;\n        for (uint marketIdx; marketIdx < numMarkets; ++marketIdx) {\n            for (uint actionIdx; actionIdx < numActions; ++actionIdx) {\n                setActionPausedInternal(markets_[marketIdx], actions_[actionIdx], paused_);\n            }\n        }\n    }\n\n    /**\n     * @dev Pause/unpause an action on a market\n     * @param market Market to pause/unpause the action on\n     * @param action Action id to pause/unpause\n     * @param paused The new paused state (true=paused, false=unpaused)\n     */\n    function setActionPausedInternal(address market, Action action, bool paused) internal {\n        ensureListed(markets[market]);\n        _actionPaused[market][uint(action)] = paused;\n        emit ActionPausedMarket(VToken(market), action, paused);\n    }\n\n    /**\n     * @notice Sets a new VAI controller\n     * @dev Admin function to set a new VAI controller\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(vaiController_));\n\n        VAIControllerInterface oldVaiController = vaiController;\n        vaiController = vaiController_;\n        emit NewVAIController(oldVaiController, vaiController_);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setVAIMintRate(uint newVAIMintRate) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        uint oldVAIMintRate = vaiMintRate;\n        vaiMintRate = newVAIMintRate;\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the minted VAI amount of the `owner`\n     * @param owner The address of the account to set\n     * @param amount The amount of VAI to set to the account\n     * @return The number of minted VAI by `owner`\n     */\n    function setMintedVAIOf(address owner, uint amount) external returns (uint) {\n        checkProtocolPauseState();\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\n        // Check caller is vaiController\n        if (msg.sender != address(vaiController)) {\n            return fail(Error.REJECTION, FailureInfo.SET_MINTED_VAI_REJECTION);\n        }\n        mintedVAIs[owner] = amount;\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setTreasuryData(\n        address newTreasuryGuardian,\n        address newTreasuryAddress,\n        uint newTreasuryPercent\n    ) external returns (uint) {\n        // Check caller is admin\n        ensureAdminOr(treasuryGuardian);\n\n        require(newTreasuryPercent < 1e18, \"treasury percent cap overflow\");\n        ensureNonzeroAddress(newTreasuryGuardian);\n        ensureNonzeroAddress(newTreasuryAddress);\n\n        address oldTreasuryGuardian = treasuryGuardian;\n        address oldTreasuryAddress = treasuryAddress;\n        uint oldTreasuryPercent = treasuryPercent;\n\n        treasuryGuardian = newTreasuryGuardian;\n        treasuryAddress = newTreasuryAddress;\n        treasuryPercent = newTreasuryPercent;\n\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\n        emit NewTreasuryPercent(oldTreasuryPercent, newTreasuryPercent);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /*** Venus Distribution ***/\n\n    /**\n     * @dev Set ComptrollerLens contract address\n     */\n    function _setComptrollerLens(ComptrollerLensInterface comptrollerLens_) external returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(comptrollerLens_));\n        address oldComptrollerLens = address(comptrollerLens);\n        comptrollerLens = comptrollerLens_;\n        emit NewComptrollerLens(oldComptrollerLens, address(comptrollerLens));\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the amount of XVS distributed per block to VAI Vault\n     * @param venusVAIVaultRate_ The amount of XVS wei per block to distribute to VAI Vault\n     */\n    function _setVenusVAIVaultRate(uint venusVAIVaultRate_) external {\n        ensureAdmin();\n        if (vaiVaultAddress != address(0)) {\n            releaseToVault();\n        }\n        uint oldVenusVAIVaultRate = venusVAIVaultRate;\n        venusVAIVaultRate = venusVAIVaultRate_;\n        emit NewVenusVAIVaultRate(oldVenusVAIVaultRate, venusVAIVaultRate_);\n    }\n\n    /**\n     * @notice Set the VAI Vault infos\n     * @param vault_ The address of the VAI Vault\n     * @param releaseStartBlock_ The start block of release to VAI Vault\n     * @param minReleaseAmount_ The minimum release amount to VAI Vault\n     */\n    function _setVAIVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) external {\n        ensureAdmin();\n        ensureNonzeroAddress(vault_);\n        if (vaiVaultAddress != address(0)) {\n            releaseToVault();\n        }\n\n        vaiVaultAddress = vault_;\n        releaseStartBlock = releaseStartBlock_;\n        minReleaseAmount = minReleaseAmount_;\n        emit NewVAIVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\n    }\n}"
    },
    {
      "filename": "contracts/Comptroller/ComptrollerStorage.sol",
      "content": "pragma solidity ^0.5.16;\n\nimport \"../Tokens/VTokens/VToken.sol\";\nimport \"../Oracle/PriceOracle.sol\";\nimport \"../Tokens/VAI/VAIControllerInterface.sol\";\nimport \"./ComptrollerLensInterface.sol\";\n\ncontract UnitrollerAdminStorage {\n    /**\n     * @notice Administrator for this contract\n     */\n    address public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address public pendingAdmin;\n\n    /**\n     * @notice Active brains of Unitroller\n     */\n    address public comptrollerImplementation;\n\n    /**\n     * @notice Pending brains of Unitroller\n     */\n    address public pendingComptrollerImplementation;\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    PriceOracle public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint public liquidationIncentiveMantissa;\n\n    /**\n     * @notice Max number of assets a single account can participate in (borrow or use as collateral)\n     */\n    uint public maxAssets;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => VToken[]) public accountAssets;\n\n    struct Market {\n        /// @notice Whether or not this market is listed\n        bool isListed;\n        /**\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be between 0 and 1, and stored as a mantissa.\n         */\n        uint collateralFactorMantissa;\n        /// @notice Per-market mapping of \"accounts in this asset\"\n        mapping(address => bool) accountMembership;\n        /// @notice Whether or not this market receives XVS\n        bool isVenus;\n    }\n\n    /**\n     * @notice Official mapping of vTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     */\n    address public pauseGuardian;\n\n    /// @notice Whether minting is paused (deprecated, superseded by actionPaused)\n    bool private _mintGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool private _borrowGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool internal transferGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    bool internal seizeGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    mapping(address => bool) internal mintGuardianPaused;\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\n    mapping(address => bool) internal borrowGuardianPaused;\n\n    struct VenusMarketState {\n        /// @notice The market's last updated venusBorrowIndex or venusSupplyIndex\n        uint224 index;\n        /// @notice The block number the index was last updated at\n        uint32 block;\n    }\n\n    /// @notice A list of all markets\n    VToken[] public allMarkets;\n\n    /// @notice The rate at which the flywheel distributes XVS, per block\n    uint public venusRate;\n\n    /// @notice The portion of venusRate that each market currently receives\n    mapping(address => uint) public venusSpeeds;\n\n    /// @notice The Venus market supply state for each market\n    mapping(address => VenusMarketState) public venusSupplyState;\n\n    /// @notice The Venus market borrow state for each market\n    mapping(address => VenusMarketState) public venusBorrowState;\n\n    /// @notice The Venus supply index for each market for each supplier as of the last time they accrued XVS\n    mapping(address => mapping(address => uint)) public venusSupplierIndex;\n\n    /// @notice The Venus borrow index for each market for each borrower as of the last time they accrued XVS\n    mapping(address => mapping(address => uint)) public venusBorrowerIndex;\n\n    /// @notice The XVS accrued but not yet transferred to each user\n    mapping(address => uint) public venusAccrued;\n\n    /// @notice The Address of VAIController\n    VAIControllerInterface public vaiController;\n\n    /// @notice The minted VAI amount to each user\n    mapping(address => uint) public mintedVAIs;\n\n    /// @notice VAI Mint Rate as a percentage\n    uint public vaiMintRate;\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     */\n    bool public mintVAIGuardianPaused;\n    bool public repayVAIGuardianPaused;\n\n    /**\n     * @notice Pause/Unpause whole protocol actions\n     */\n    bool public protocolPaused;\n\n    /// @notice The rate at which the flywheel distributes XVS to VAI Minters, per block (deprecated)\n    uint private venusVAIRate;\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n    /// @notice The rate at which the flywheel distributes XVS to VAI Vault, per block\n    uint public venusVAIVaultRate;\n\n    // address of VAI Vault\n    address public vaiVaultAddress;\n\n    // start block of release to VAI Vault\n    uint256 public releaseStartBlock;\n\n    // minimum release amount to VAI Vault\n    uint256 public minReleaseAmount;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n    /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    /// @notice Borrow caps enforced by borrowAllowed for each vToken address. Defaults to zero which corresponds to unlimited borrowing.\n    mapping(address => uint) public borrowCaps;\n}\n\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\n    /// @notice Treasury Guardian address\n    address public treasuryGuardian;\n\n    /// @notice Treasury address\n    address public treasuryAddress;\n\n    /// @notice Fee percent of accrued interest with decimal 18\n    uint256 public treasuryPercent;\n}\n\ncontract ComptrollerV5Storage is ComptrollerV4Storage {\n    /// @notice The portion of XVS that each contributor receives per block (deprecated)\n    mapping(address => uint) private venusContributorSpeeds;\n\n    /// @notice Last block at which a contributor's XVS rewards have been allocated (deprecated)\n    mapping(address => uint) private lastContributorBlock;\n}\n\ncontract ComptrollerV6Storage is ComptrollerV5Storage {\n    address public liquidatorContract;\n}\n\ncontract ComptrollerV7Storage is ComptrollerV6Storage {\n    ComptrollerLensInterface public comptrollerLens;\n}\n\ncontract ComptrollerV8Storage is ComptrollerV7Storage {\n    /// @notice Supply caps enforced by mintAllowed for each vToken address. Defaults to zero which corresponds to minting notAllowed\n    mapping(address => uint256) public supplyCaps;\n}\n\ncontract ComptrollerV9Storage is ComptrollerV8Storage {\n    /// @notice AccessControlManager address\n    address internal accessControl;\n\n    enum Action {\n        MINT,\n        REDEEM,\n        BORROW,\n        REPAY,\n        SEIZE,\n        LIQUIDATE,\n        TRANSFER,\n        ENTER_MARKET,\n        EXIT_MARKET\n    }\n\n    /// @notice True if a certain action is paused on a certain market\n    mapping(address => mapping(uint => bool)) internal _actionPaused;\n}\n\ncontract ComptrollerV10Storage is ComptrollerV9Storage {\n    /// @notice The rate at which venus is distributed to the corresponding borrow market (per block)\n    mapping(address => uint) public venusBorrowSpeeds;\n\n    /// @notice The rate at which venus is distributed to the corresponding supply market (per block)\n    mapping(address => uint) public venusSupplySpeeds;\n}\n\ncontract ComptrollerV11Storage is ComptrollerV10Storage {\n    /// @notice Whether the delegate is allowed to borrow on behalf of the borrower\n    //mapping(address borrower => mapping (address delegate => bool approved)) public approvedDelegates;\n    mapping(address => mapping(address => bool)) public approvedDelegates;\n}\n\ncontract ComptrollerV12Storage is ComptrollerV11Storage {\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    mapping(bytes4 => FacetAddressAndPosition) internal selectorToFacetAndPosition;\n    // maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) internal facetFunctionSelectors;\n    // facet addresses\n    address[] internal facetAddresses;\n}"
    },
    {
      "filename": "contracts/Governance/AccessControlManager.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./IAccessControlManagerV8.sol\";\n\n/**\n * @title Venus Access Control Contract\n * @author venus\n * @dev This contract is a wrapper of OpenZeppelin AccessControl\n *\t\textending it in a way to standartize access control\n *\t\twithin Venus Smart Contract Ecosystem\n */\ncontract AccessControlManager is AccessControl, IAccessControlManagerV8 {\n    /// @notice Emitted when an account is given a permission to a certain contract function\n    /// @dev If contract address is 0x000..0 this means that the account is a default admin of this function and\n    /// can call any contract function with this signature\n    event PermissionGranted(address account, address contractAddress, string functionSig);\n\n    /// @notice Emitted when an account is revoked a permission to a certain contract function\n    event PermissionRevoked(address account, address contractAddress, string functionSig);\n\n    constructor() {\n        // Grant the contract deployer the default admin role: it will be able\n        // to grant and revoke any roles\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Gives a function call permission to one single account\n     * @dev this function can be called only from Role Admin or DEFAULT_ADMIN_ROLE\n     * @param contractAddress address of contract for which call permissions will be granted\n     * @dev if contractAddress is zero address, the account can access the specified function\n     *      on **any** contract managed by this ACL\n     * @param functionSig signature e.g. \"functionName(uint256,bool)\"\n     * @param accountToPermit account that will be given access to the contract function\n     * @custom:event Emits a {RoleGranted} and {PermissionGranted} events.\n     */\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) public {\n        bytes32 role = keccak256(abi.encodePacked(contractAddress, functionSig));\n        grantRole(role, accountToPermit);\n        emit PermissionGranted(accountToPermit, contractAddress, functionSig);\n    }\n\n    /**\n     * @notice Revokes an account's permission to a particular function call\n     * @dev this function can be called only from Role Admin or DEFAULT_ADMIN_ROLE\n     * \t\tMay emit a {RoleRevoked} event.\n     * @param contractAddress address of contract for which call permissions will be revoked\n     * @param functionSig signature e.g. \"functionName(uint256,bool)\"\n     * @custom:event Emits {RoleRevoked} and {PermissionRevoked} events.\n     */\n    function revokeCallPermission(\n        address contractAddress,\n        string calldata functionSig,\n        address accountToRevoke\n    ) public {\n        bytes32 role = keccak256(abi.encodePacked(contractAddress, functionSig));\n        revokeRole(role, accountToRevoke);\n        emit PermissionRevoked(accountToRevoke, contractAddress, functionSig);\n    }\n\n    /**\n     * @notice Verifies if the given account can call a contract's guarded function\n     * @dev Since restricted contracts using this function as a permission hook, we can get contracts address with msg.sender\n     * @param account for which call permissions will be checked\n     * @param functionSig restricted function signature e.g. \"functionName(uint256,bool)\"\n     * @return false if the user account cannot call the particular contract function\n     *\n     */\n    function isAllowedToCall(address account, string calldata functionSig) public view returns (bool) {\n        bytes32 role = keccak256(abi.encodePacked(msg.sender, functionSig));\n\n        if (hasRole(role, account)) {\n            return true;\n        } else {\n            role = keccak256(abi.encodePacked(address(0), functionSig));\n            return hasRole(role, account);\n        }\n    }\n\n    /**\n     * @notice Verifies if the given account can call a contract's guarded function\n     * @dev This function is used as a view function to check permissions rather than contract hook for access restriction check.\n     * @param account for which call permissions will be checked against\n     * @param contractAddress address of the restricted contract\n     * @param functionSig signature of the restricted function e.g. \"functionName(uint256,bool)\"\n     * @return false if the user account cannot call the particular contract function\n     */\n    function hasPermission(\n        address account,\n        address contractAddress,\n        string calldata functionSig\n    ) public view returns (bool) {\n        bytes32 role = keccak256(abi.encodePacked(contractAddress, functionSig));\n        return hasRole(role, account);\n    }\n}"
    }
  ]
}