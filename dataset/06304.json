{
  "Title": "[G-16]  Not using the named return variables when a function returns, wastes deployment gas",
  "Content": "\n```solidity\nfile: /src/pumps/MultiFlowPump.sol\n\n350        return uint256(uint40(block.timestamp) - lastTimestamp);\n\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/pumps/MultiFlowPump.sol#L350\n\n\n```solidity\nfile: /src/Well.sol\n\n649            return reserves;\n\n762            return j;\n\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/Well.sol#L649\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/Well.sol#L762\n\n```solidity\nfile: /src/libraries/LibBytes.sol\n\n88            return reserves;\n\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/libraries/LibBytes.sol#L88\n\n\n### Recommended Code\n```solidity\n\n    return (uint40(block.timestamp) - lastTimestamp);\n\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/pumps/MultiFlowPump.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IMultiFlowPumpErrors} from \"src/interfaces/pumps/IMultiFlowPumpErrors.sol\";\nimport {IWell} from \"src/interfaces/IWell.sol\";\nimport {IInstantaneousPump} from \"src/interfaces/pumps/IInstantaneousPump.sol\";\nimport {ICumulativePump} from \"src/interfaces/pumps/ICumulativePump.sol\";\nimport {ABDKMathQuad} from \"src/libraries/ABDKMathQuad.sol\";\nimport {LibBytes16} from \"src/libraries/LibBytes16.sol\";\nimport {LibLastReserveBytes} from \"src/libraries/LibLastReserveBytes.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\n\n/**\n * @title MultiFlowPump\n * @author Publius\n * @notice Stores a geometric EMA and cumulative geometric SMA for each reserve.\n * @dev A Pump designed for use in Beanstalk with 2 tokens.\n *\n * This Pump has 3 main features:\n *  1. Multi-block MEV resistence reserves\n *  2. MEV-resistant Geometric EMA intended for instantaneous reserve queries\n *  3. MEV-resistant Cumulative Geometric intended for SMA reserve queries\n *\n * Note: If an `update` call is made with a reserve of 0, the Geometric mean oracles will be set to 0.\n * Each Well is responsible for ensuring that an `update` call cannot be made with a reserve of 0.\n */\ncontract MultiFlowPump is IPump, IMultiFlowPumpErrors, IInstantaneousPump, ICumulativePump {\n    using SafeCast for uint256;\n    using LibLastReserveBytes for bytes32;\n    using LibBytes16 for bytes32;\n    using ABDKMathQuad for bytes16;\n    using ABDKMathQuad for uint256;\n\n    bytes16 immutable LOG_MAX_INCREASE;\n    bytes16 immutable LOG_MAX_DECREASE;\n    bytes16 immutable ALPHA;\n    uint256 immutable BLOCK_TIME;\n\n    struct PumpState {\n        uint40 lastTimestamp;\n        bytes16[] lastReserves;\n        bytes16[] emaReserves;\n        bytes16[] cumulativeReserves;\n    }\n\n    /**\n     * @param _maxPercentIncrease The maximum percent increase allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _maxPercentDecrease The maximum percent decrease allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _blockTime The block time in the current EVM in seconds.\n     * @param _alpha The geometric EMA constant. Must be in quadruple precision format (See {ABDKMathQuad}).\n     */\n    constructor(bytes16 _maxPercentIncrease, bytes16 _maxPercentDecrease, uint256 _blockTime, bytes16 _alpha) {\n        LOG_MAX_INCREASE = ABDKMathQuad.ONE.add(_maxPercentIncrease).log_2();\n        // _maxPercentDecrease <= 100%\n        if (_maxPercentDecrease > ABDKMathQuad.ONE) {\n            revert InvalidMaxPercentDecreaseArgument(_maxPercentDecrease);\n        }\n        LOG_MAX_DECREASE = ABDKMathQuad.ONE.sub(_maxPercentDecrease).log_2();\n        BLOCK_TIME = _blockTime;\n\n        // ALPHA <= 1\n        if (_alpha > ABDKMathQuad.ONE) {\n            revert InvalidAArgument(_alpha);\n        }\n        ALPHA = _alpha;\n    }\n\n    //////////////////// PUMP ////////////////////\n\n    function update(uint256[] calldata reserves, bytes calldata) external {\n        uint256 numberOfReserves = reserves.length;\n        PumpState memory pumpState;\n\n        // All reserves are stored starting at the msg.sender address slot in storage.\n        bytes32 slot = _getSlotForAddress(msg.sender);\n\n        // Read: Last Timestamp & Last Reserves\n        (, pumpState.lastTimestamp, pumpState.lastReserves) = slot.readLastReserves();\n\n        // If the last timestamp is 0, then the pump has never been used before.\n        if (pumpState.lastTimestamp == 0) {\n            for (uint256 i; i < numberOfReserves; ++i) {\n                // If a reserve is 0, then the pump cannot be initialized.\n                if (reserves[i] == 0) return;\n            }\n            _init(slot, uint40(block.timestamp), reserves);\n            return;\n        }\n\n        // Read: Cumulative & EMA Reserves\n        // Start at the slot after `pumpState.lastReserves`\n        uint256 numSlots = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.emaReserves = slot.readBytes16(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.cumulativeReserves = slot.readBytes16(numberOfReserves);\n\n        bytes16 alphaN;\n        bytes16 deltaTimestampBytes;\n        bytes16 blocksPassed;\n        // Isolate in brackets to prevent stack too deep errors\n        {\n            uint256 deltaTimestamp = _getDeltaTimestamp(pumpState.lastTimestamp);\n            alphaN = ALPHA.powu(deltaTimestamp);\n            deltaTimestampBytes = deltaTimestamp.fromUInt();\n            // Relies on the assumption that a block can only occur every `BLOCK_TIME` seconds.\n            blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        }\n\n        for (uint256 i; i < numberOfReserves; ++i) {\n            // Use a minimum of 1 for reserve. Geometric means will be set to 0 if a reserve is 0.\n            pumpState.lastReserves[i] = _capReserve(\n                pumpState.lastReserves[i], (reserves[i] > 0 ? reserves[i] : 1).fromUIntToLog2(), blocksPassed\n            );\n            pumpState.emaReserves[i] =\n                pumpState.lastReserves[i].mul((ABDKMathQuad.ONE.sub(alphaN))).add(pumpState.emaReserves[i].mul(alphaN));\n            pumpState.cumulativeReserves[i] =\n                pumpState.cumulativeReserves[i].add(pumpState.lastReserves[i].mul(deltaTimestampBytes));\n        }\n\n        // Write: Cumulative & EMA Reserves\n        // Order matters: work backwards to avoid using a new memory var to count up\n        slot.storeBytes16(pumpState.cumulativeReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n        slot.storeBytes16(pumpState.emaReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(uint40(block.timestamp), pumpState.lastReserves);\n    }\n\n    /**\n     * @dev On first update for a particular Well, initialize oracle with\n     * reserves data.\n     */\n    function _init(bytes32 slot, uint40 lastTimestamp, uint256[] memory reserves) internal {\n        uint256 numberOfReserves = reserves.length;\n        bytes16[] memory byteReserves = new bytes16[](numberOfReserves);\n\n        // Skip {_capReserve} since we have no prior reference\n\n        for (uint256 i; i < numberOfReserves; ++i) {\n            if (reserves[i] == 0) return;\n            byteReserves[i] = reserves[i].fromUIntToLog2();\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(lastTimestamp, byteReserves);\n\n        // Write: EMA Reserves\n        // Start at the slot after `byteReserves`\n        uint256 numSlots = _getSlotsOffset(byteReserves.length);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        slot.storeBytes16(byteReserves); // EMA Reserves\n    }\n\n    //////////////////// LAST RESERVES ////////////////////\n\n    function readLastReserves(address well) public view returns (uint256[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        (uint8 numberOfReserves,, bytes16[] memory bytesReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        reserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            reserves[i] = bytesReserves[i].pow_2ToUInt();\n        }\n    }\n\n    /**\n     * @dev Adds a cap to the reserve value to prevent extreme changes.\n     *\n     *  Linear space:\n     *     max reserve = (last reserve) * ((1 + MAX_PERCENT_CHANGE_PER_BLOCK) ^ blocks)\n     *\n     *  Log space:\n     *     log2(max reserve) = log2(last reserve) + blocks*log2(1 + MAX_PERCENT_CHANGE_PER_BLOCK)\n     *\n     *     `bytes16 lastReserve`      <- log2(last reserve)\n     *     `bytes16 blocksPassed`     <- log2(blocks)\n     *     `bytes16 LOG_MAX_INCREASE` <- log2(1 + MAX_PERCENT_CHANGE_PER_BLOCK)\n     *\n     *     âˆ´ `maxReserve = lastReserve + blocks*LOG_MAX_INCREASE`\n     *\n     */\n    function _capReserve(\n        bytes16 lastReserve,\n        bytes16 reserve,\n        bytes16 blocksPassed\n    ) internal view returns (bytes16 cappedReserve) {\n        // Reserve decreasing (lastReserve > reserve)\n        if (lastReserve.cmp(reserve) == 1) {\n            bytes16 minReserve = lastReserve.add(blocksPassed.mul(LOG_MAX_DECREASE));\n            // if reserve < minimum reserve, set reserve to minimum reserve\n            if (minReserve.cmp(reserve) == 1) reserve = minReserve;\n        }\n        // Rerserve Increasing or staying the same.\n        else {\n            bytes16 maxReserve = blocksPassed.mul(LOG_MAX_INCREASE);\n            maxReserve = lastReserve.add(maxReserve);\n            // If reserve > maximum reserve, set reserve to maximum reserve\n            if (reserve.cmp(maxReserve) == 1) reserve = maxReserve;\n        }\n        cappedReserve = reserve;\n    }\n\n    //////////////////// EMA RESERVES ////////////////////\n\n    function readLastInstantaneousReserves(address well) public view returns (uint256[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory byteReserves = slot.readBytes16(numberOfReserves);\n        reserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            reserves[i] = byteReserves[i].pow_2ToUInt();\n        }\n    }\n\n    function readInstantaneousReserves(address well, bytes memory) public view returns (uint256[] memory emaReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, bytes16[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory lastEmaReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        bytes16 blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        bytes16 alphaN = ALPHA.powu(deltaTimestamp);\n        emaReserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            lastReserves[i] = _capReserve(lastReserves[i], reserves[i].fromUIntToLog2(), blocksPassed);\n            emaReserves[i] =\n                lastReserves[i].mul((ABDKMathQuad.ONE.sub(alphaN))).add(lastEmaReserves[i].mul(alphaN)).pow_2ToUInt();\n        }\n    }\n\n    //////////////////// CUMULATIVE RESERVES ////////////////////\n\n    /**\n     * @notice Read the latest cumulative reserves of `well`.\n     */\n    function readLastCumulativeReserves(address well) public view returns (bytes16[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        reserves = slot.readBytes16(numberOfReserves);\n    }\n\n    function readCumulativeReserves(address well, bytes memory) public view returns (bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well);\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    function _readCumulativeReserves(address well) internal view returns (bytes16[] memory cumulativeReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, bytes16[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        cumulativeReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        bytes16 deltaTimestampBytes = deltaTimestamp.fromUInt();\n        bytes16 blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        // Currently, there is so support for overflow.\n        for (uint256 i; i < cumulativeReserves.length; ++i) {\n            lastReserves[i] = _capReserve(lastReserves[i], reserves[i].fromUIntToLog2(), blocksPassed);\n            cumulativeReserves[i] = cumulativeReserves[i].add(lastReserves[i].mul(deltaTimestampBytes));\n        }\n    }\n\n    function readTwaReserves(\n        address well,\n        bytes calldata startCumulativeReserves,\n        uint256 startTimestamp,\n        bytes memory\n    ) public view returns (uint256[] memory twaReserves, bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well);\n        bytes16[] memory byteStartCumulativeReserves = abi.decode(startCumulativeReserves, (bytes16[]));\n        twaReserves = new uint256[](byteCumulativeReserves.length);\n\n        // Overflow is desired on `startTimestamp`, so SafeCast is not used.\n        bytes16 deltaTimestamp = _getDeltaTimestamp(uint40(startTimestamp)).fromUInt();\n        if (deltaTimestamp == bytes16(0)) {\n            revert NoTimePassed();\n        }\n        for (uint256 i; i < byteCumulativeReserves.length; ++i) {\n            // Currently, there is no support for overflow.\n            twaReserves[i] =\n                (byteCumulativeReserves[i].sub(byteStartCumulativeReserves[i])).div(deltaTimestamp).pow_2ToUInt();\n        }\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    //////////////////// HELPERS ////////////////////\n\n    /**\n     * @dev Convert an `address` into a `bytes32` by zero padding the right 12 bytes.\n     */\n    function _getSlotForAddress(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue)); // Because right padded, no collision on adjacent\n    }\n\n    /**\n     * @dev Get the starting byte of the slot that contains the `n`th element of an array.\n     */\n    function _getSlotsOffset(uint256 numberOfReserves) internal pure returns (uint256) {\n        return ((numberOfReserves - 1) / 2 + 1) << 5;\n    }\n\n    /**\n     * @dev Get the delta between the current and provided timestamp as a `uint256`.\n     */\n    function _getDeltaTimestamp(uint40 lastTimestamp) internal view returns (uint256) {\n        return uint256(uint40(block.timestamp) - lastTimestamp);\n    }\n}"
    },
    {
      "filename": "src/Well.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {ReentrancyGuardUpgradeable} from \"ozu/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC20Upgradeable, ERC20PermitUpgradeable} from \"ozu/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {IERC20, SafeERC20} from \"oz/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\nimport {IWell, Call} from \"src/interfaces/IWell.sol\";\nimport {IWellErrors} from \"src/interfaces/IWellErrors.sol\";\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IWellFunction} from \"src/interfaces/IWellFunction.sol\";\nimport {LibBytes} from \"src/libraries/LibBytes.sol\";\nimport {ClonePlus} from \"src/utils/ClonePlus.sol\";\n\n/**\n * @title Well\n * @author Publius, Silo Chad, Brean\n * @dev A Well is a constant function AMM allowing the provisioning of liquidity\n * into a single pooled on-chain liquidity position.\n */\ncontract Well is ERC20PermitUpgradeable, IWell, IWellErrors, ReentrancyGuardUpgradeable, ClonePlus {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    uint256 constant ONE_WORD = 32;\n    uint256 constant PACKED_ADDRESS = 20;\n    uint256 constant ONE_WORD_PLUS_PACKED_ADDRESS = 52; // For gas efficiency purposes\n    bytes32 constant RESERVES_STORAGE_SLOT = bytes32(uint256(keccak256(\"reserves.storage.slot\")) - 1);\n\n    function init(string memory name, string memory symbol) public initializer {\n        __ERC20Permit_init(name);\n        __ERC20_init(name, symbol);\n\n        IERC20[] memory _tokens = tokens();\n        for (uint256 i; i < _tokens.length - 1; ++i) {\n            for (uint256 j = i + 1; j < _tokens.length; ++j) {\n                if (_tokens[i] == _tokens[j]) {\n                    revert DuplicateTokens(_tokens[i]);\n                }\n            }\n        }\n    }\n\n    //////////////////// WELL DEFINITION ////////////////////\n\n    /// This Well uses a dynamic immutable storage layout. Immutable storage is\n    /// used for gas-efficient reads during Well operation. The Well must be\n    /// created by cloning with a pre-encoded byte string containing immutable\n    /// data.\n    ///\n    /// Let n = number of tokens\n    ///     m = length of well function data (bytes)\n    ///\n    /// TYPE        NAME                       LOCATION (CONSTANT)\n    /// ==============================================================\n    /// address     aquifer()                  0        (LOC_AQUIFER_ADDR)\n    /// uint256     numberOfTokens()           20       (LOC_TOKENS_COUNT)\n    /// address     wellFunctionAddress()      52       (LOC_WELL_FUNCTION_ADDR)\n    /// uint256     wellFunctionDataLength()   72       (LOC_WELL_FUNCTION_DATA_LENGTH)\n    /// uint256     numberOfPumps()            104      (LOC_PUMPS_COUNT)\n    /// --------------------------------------------------------------\n    /// address     token0                     136      (LOC_VARIABLE)\n    /// ...\n    /// address     tokenN                     136 + (n-1) * 32\n    /// --------------------------------------------------------------\n    /// byte        wellFunctionData0          136 + n * 32\n    /// ...\n    /// byte        wellFunctionDataM          136 + n * 32 + m\n    /// --------------------------------------------------------------\n    /// address     pump1Address               136 + n * 32 + m\n    /// uint256     pump1DataLength            136 + n * 32 + m + 20\n    /// byte        pump1Data                  136 + n * 32 + m + 52\n    /// ...\n    /// ==============================================================\n\n    uint256 constant LOC_AQUIFER_ADDR = 0;\n    uint256 constant LOC_TOKENS_COUNT = LOC_AQUIFER_ADDR + PACKED_ADDRESS;\n    uint256 constant LOC_WELL_FUNCTION_ADDR = LOC_TOKENS_COUNT + ONE_WORD;\n    uint256 constant LOC_WELL_FUNCTION_DATA_LENGTH = LOC_WELL_FUNCTION_ADDR + PACKED_ADDRESS;\n    uint256 constant LOC_PUMPS_COUNT = LOC_WELL_FUNCTION_DATA_LENGTH + ONE_WORD;\n    uint256 constant LOC_VARIABLE = LOC_PUMPS_COUNT + ONE_WORD;\n\n    function tokens() public pure returns (IERC20[] memory ts) {\n        ts = _getArgIERC20Array(LOC_VARIABLE, numberOfTokens());\n    }\n\n    function wellFunction() public pure returns (Call memory _wellFunction) {\n        _wellFunction.target = wellFunctionAddress();\n        uint256 dataLoc = LOC_VARIABLE + numberOfTokens() * ONE_WORD;\n        _wellFunction.data = _getArgBytes(dataLoc, wellFunctionDataLength());\n    }\n\n    function pumps() public pure returns (Call[] memory _pumps) {\n        if (numberOfPumps() == 0) return _pumps;\n\n        _pumps = new Call[](numberOfPumps());\n        uint256 dataLoc = LOC_VARIABLE + numberOfTokens() * ONE_WORD + wellFunctionDataLength();\n\n        uint256 pumpDataLength;\n        for (uint256 i; i < _pumps.length; i++) {\n            _pumps[i].target = _getArgAddress(dataLoc);\n            dataLoc += PACKED_ADDRESS;\n            pumpDataLength = _getArgUint256(dataLoc);\n            dataLoc += ONE_WORD;\n            _pumps[i].data = _getArgBytes(dataLoc, pumpDataLength);\n            dataLoc += pumpDataLength;\n        }\n    }\n\n    /**\n     * @dev {wellData} is unused in this implementation.\n     */\n    function wellData() public pure returns (bytes memory) {}\n\n    function aquifer() public pure override returns (address) {\n        return _getArgAddress(LOC_AQUIFER_ADDR);\n    }\n\n    function well()\n        external\n        pure\n        returns (\n            IERC20[] memory _tokens,\n            Call memory _wellFunction,\n            Call[] memory _pumps,\n            bytes memory _wellData,\n            address _aquifer\n        )\n    {\n        _tokens = tokens();\n        _wellFunction = wellFunction();\n        _pumps = pumps();\n        _wellData = wellData();\n        _aquifer = aquifer();\n    }\n\n    //////////////////// WELL DEFINITION: HELPERS ////////////////////\n\n    /**\n     * @notice Returns the number of tokens that are tradable in this Well.\n     * @dev Length of the `tokens()` array.\n     */\n    function numberOfTokens() public pure returns (uint256) {\n        return _getArgUint256(LOC_TOKENS_COUNT);\n    }\n\n    /**\n     * @notice Returns the address of the Well Function.\n     */\n    function wellFunctionAddress() public pure returns (address) {\n        return _getArgAddress(LOC_WELL_FUNCTION_ADDR);\n    }\n\n    /**\n     * @notice Returns the length of the configurable `data` parameter passed during calls to the Well Function.\n     */\n    function wellFunctionDataLength() public pure returns (uint256) {\n        return _getArgUint256(LOC_WELL_FUNCTION_DATA_LENGTH);\n    }\n\n    /**\n     * @notice Returns the number of Pumps which this Well was initialized with.\n     */\n    function numberOfPumps() public pure returns (uint256) {\n        return _getArgUint256(LOC_PUMPS_COUNT);\n    }\n\n    /**\n     * @notice Returns address & data used to call the first Pump.\n     * @dev Provided as an optimization in the case where {numberOfPumps} returns 1.\n     */\n    function firstPump() public pure returns (Call memory _pump) {\n        uint256 dataLoc = LOC_VARIABLE + numberOfTokens() * ONE_WORD + wellFunctionDataLength();\n        _pump.target = _getArgAddress(dataLoc);\n        uint256 pumpDataLength = _getArgUint256(dataLoc + PACKED_ADDRESS);\n        _pump.data = _getArgBytes(dataLoc + ONE_WORD_PLUS_PACKED_ADDRESS, pumpDataLength);\n    }\n\n    //////////////////// SWAP: FROM ////////////////////\n\n    /**\n     * @dev MUST revert if a fee on transfer token is used. The requisite check\n     * is performed in {_setReserves}.\n     */\n    function swapFrom(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256 amountOut) {\n        fromToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        amountOut = _swapFrom(fromToken, toToken, amountIn, minAmountOut, recipient);\n    }\n\n    /**\n     * @dev Note that `amountOut` is the amount *transferred* by the Well; if a fee\n     * is charged on transfers of `toToken`, the amount received by `recipient`\n     * will be less than `amountOut`.\n     */\n    function swapFromFeeOnTransfer(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256 amountOut) {\n        amountIn = _safeTransferFromFeeOnTransfer(fromToken, msg.sender, amountIn);\n        amountOut = _swapFrom(fromToken, toToken, amountIn, minAmountOut, recipient);\n    }\n\n    function _swapFrom(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient\n    ) internal returns (uint256 amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _updatePumps(_tokens.length);\n        (uint256 i, uint256 j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[i] += amountIn;\n        uint256 reserveJBefore = reserves[j];\n        reserves[j] = _calcReserve(wellFunction(), reserves, j, totalSupply());\n\n        // Note: The rounding approach of the Well function determines whether\n        // slippage from imprecision goes to the Well or to the User.\n        amountOut = reserveJBefore - reserves[j];\n        if (amountOut < minAmountOut) {\n            revert SlippageOut(amountOut, minAmountOut);\n        }\n\n        toToken.safeTransfer(recipient, amountOut);\n        emit Swap(fromToken, toToken, amountIn, amountOut, recipient);\n        _setReserves(_tokens, reserves);\n    }\n\n    /**\n     * @dev Assumes both tokens incur no fee on transfer.\n     */\n    function getSwapOut(IERC20 fromToken, IERC20 toToken, uint256 amountIn) external view returns (uint256 amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _getReserves(_tokens.length);\n        (uint256 i, uint256 j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[i] += amountIn;\n\n        // underflow is desired; Well Function SHOULD NOT increase reserves of both `i` and `j`\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n    }\n\n    //////////////////// SWAP: TO ////////////////////\n\n    /**\n     * @dev {swapTo} does not support fee on transfer tokens, and no corresponding\n     * \"swapToFeeOnTransfer\" function is provided as this would require either:\n     * (a) inclusion of the fee as a parameter with verification; or\n     * (b) iterative transfers which attempts to back-calculate the fee.\n     */\n    function swapTo(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 maxAmountIn,\n        uint256 amountOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256 amountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _updatePumps(_tokens.length);\n        (uint256 i, uint256 j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[j] -= amountOut;\n        uint256 reserveIBefore = reserves[i];\n        reserves[i] = _calcReserve(wellFunction(), reserves, i, totalSupply());\n\n        // Note: The rounding approach of the Well function determines whether\n        // slippage from imprecision goes to the Well or to the User.\n        amountIn = reserves[i] - reserveIBefore;\n\n        if (amountIn > maxAmountIn) {\n            revert SlippageIn(amountIn, maxAmountIn);\n        }\n\n        _swapTo(fromToken, toToken, amountIn, amountOut, recipient);\n        _setReserves(_tokens, reserves);\n    }\n\n    /**\n     * @dev Executes token transfers and emits Swap event. Used by {swapTo} to\n     * avoid stack too deep errors.\n     */\n    function _swapTo(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 amountIn,\n        uint256 amountOut,\n        address recipient\n    ) internal {\n        fromToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        toToken.safeTransfer(recipient, amountOut);\n        emit Swap(fromToken, toToken, amountIn, amountOut, recipient);\n    }\n\n    /**\n     * @dev Assumes both tokens incur no fee on transfer.\n     */\n    function getSwapIn(IERC20 fromToken, IERC20 toToken, uint256 amountOut) external view returns (uint256 amountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _getReserves(_tokens.length);\n        (uint256 i, uint256 j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[j] -= amountOut;\n\n        amountIn = _calcReserve(wellFunction(), reserves, i, totalSupply()) - reserves[i];\n    }\n\n    //////////////////// SHIFT ////////////////////\n\n    /**\n     * @dev When using Wells for a multi-step swap, gas costs can be reduced by\n     * \"shifting\" tokens from one Well to another rather than returning them to\n     * a router (like Pipeline).\n     *\n     * Example multi-hop swap: WETH -> DAI -> USDC\n     *\n     * 1. Using a router without {shift}:\n     *  WETH.transfer(sender=0xUSER, recipient=0xROUTER)                     [1]\n     *  Call the router, which performs:\n     *      Well1.swapFrom(fromToken=WETH, toToken=DAI, recipient=0xROUTER)\n     *          WETH.transfer(sender=0xROUTER, recipient=Well1)              [2]\n     *          DAI.transfer(sender=Well1, recipient=0xROUTER)               [3]\n     *      Well2.swapFrom(fromToken=DAI, toToken=USDC, recipient=0xROUTER)\n     *          DAI.transfer(sender=0xROUTER, recipient=Well2)               [4]\n     *          USDC.transfer(sender=Well2, recipient=0xROUTER)              [5]\n     *  USDC.transfer(sender=0xROUTER, recipient=0xUSER)                     [6]\n     *\n     *  Note: this could be optimized by configuring the router to deliver\n     *  tokens from the last swap directly to the user.\n     *\n     * 2. Using a router with {shift}:\n     *  WETH.transfer(sender=0xUSER, recipient=Well1)                        [1]\n     *  Call the router, which performs:\n     *      Well1.shift(tokenOut=DAI, recipient=Well2)\n     *          DAI.transfer(sender=Well1, recipient=Well2)                  [2]\n     *      Well2.shift(tokenOut=USDC, recipient=0xUSER)\n     *          USDC.transfer(sender=Well2, recipient=0xUSER)                [3]\n     */\n    function shift(\n        IERC20 tokenOut,\n        uint256 minAmountOut,\n        address recipient\n    ) external nonReentrant returns (uint256 amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = new uint256[](_tokens.length);\n\n        // Use the balances of the pool instead of the stored reserves.\n        // If there is a change in token balances relative to the currently\n        // stored reserves, the extra tokens can be shifted into `tokenOut`.\n        for (uint256 i; i < _tokens.length; ++i) {\n            reserves[i] = _tokens[i].balanceOf(address(this));\n        }\n        uint256 j = _getJ(_tokens, tokenOut);\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n\n        if (amountOut >= minAmountOut) {\n            tokenOut.safeTransfer(recipient, amountOut);\n            reserves[j] -= amountOut;\n            _setReserves(_tokens, reserves);\n            emit Shift(reserves, tokenOut, amountOut, recipient);\n        } else {\n            revert SlippageOut(amountOut, minAmountOut);\n        }\n    }\n\n    function getShiftOut(IERC20 tokenOut) external view returns (uint256 amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = new uint256[](_tokens.length);\n        for (uint256 i; i < _tokens.length; ++i) {\n            reserves[i] = _tokens[i].balanceOf(address(this));\n        }\n\n        uint256 j = _getJ(_tokens, tokenOut);\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n    }\n\n    //////////////////// ADD LIQUIDITY ////////////////////\n\n    function addLiquidity(\n        uint256[] memory tokenAmountsIn,\n        uint256 minLpAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256 lpAmountOut) {\n        lpAmountOut = _addLiquidity(tokenAmountsIn, minLpAmountOut, recipient, false);\n    }\n\n    function addLiquidityFeeOnTransfer(\n        uint256[] memory tokenAmountsIn,\n        uint256 minLpAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256 lpAmountOut) {\n        lpAmountOut = _addLiquidity(tokenAmountsIn, minLpAmountOut, recipient, true);\n    }\n\n    /**\n     * @dev Gas optimization: {IWell.AddLiquidity} is emitted even if `lpAmountOut` is 0.\n     */\n    function _addLiquidity(\n        uint256[] memory tokenAmountsIn,\n        uint256 minLpAmountOut,\n        address recipient,\n        bool feeOnTransfer\n    ) internal returns (uint256 lpAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _updatePumps(_tokens.length);\n\n        if (feeOnTransfer) {\n            for (uint256 i; i < _tokens.length; ++i) {\n                if (tokenAmountsIn[i] == 0) continue;\n                tokenAmountsIn[i] = _safeTransferFromFeeOnTransfer(_tokens[i], msg.sender, tokenAmountsIn[i]);\n                reserves[i] = reserves[i] + tokenAmountsIn[i];\n            }\n        } else {\n            for (uint256 i; i < _tokens.length; ++i) {\n                if (tokenAmountsIn[i] == 0) continue;\n                _tokens[i].safeTransferFrom(msg.sender, address(this), tokenAmountsIn[i]);\n                reserves[i] = reserves[i] + tokenAmountsIn[i];\n            }\n        }\n\n        lpAmountOut = _calcLpTokenSupply(wellFunction(), reserves) - totalSupply();\n        if (lpAmountOut < m"
    }
  ]
}