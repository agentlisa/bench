{
  "Title": "[G-03] Multiple address mappings can be combined into a single mapping of an address to a struct, where appropriate",
  "Content": "We can combine multiple mappings below into structs. This will result in cheaper storage reads since multiple mappings are accessed in functions and those values are now occupying the same storage slot, meaning the slot will become warm after the first SLOAD. In addition, when writing to and reading from the struct values we will avoid a `Gsset (20000 gas)` and `Gcoldsload (2100 gas)` since multiple struct values are now occupying the same slot.\n\n**Note: This instance was missed by the automated report.**\n\nhttps://github.com/code-423n4/2023-06-llama/blob/main/src/strategies/LlamaRelativeQuorum.sol#L130-L133\n\n*Gas Savings for `LlamaCore.executeAction`, obtained via protocol's tests: Avg 21838 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  5186172 | 23819570 | 4807541 |    430   |\n| After  |  5164334 | 32081589 | 4803180 |    430   |\n\n```solidity\nFile: src/strategies/LlamaRelativeQuorum.sol\n130:  mapping(uint8 => bool) public forceApprovalRole;\n131:\n132:  /// @notice Mapping of roles that can force an action to be disapproved.\n133:  mapping(uint8 => bool) public forceDisapprovalRole;\n```\n```diff\ndiff --git a/src/strategies/LlamaRelativeQuorum.sol b/src/strategies/LlamaRelativeQuorum.sol\nindex d796ae9..2cbeb0c 100644\n--- a/src/strategies/LlamaRelativeQuorum.sol\n+++ b/src/strategies/LlamaRelativeQuorum.sol\n@@ -125,12 +125,13 @@ contract LlamaRelativeQuorum is ILlamaStrategy, Initializable {\n\n   /// @notice The role that can disapprove an action.\n   uint8 public disapprovalRole;\n+\n+  struct ForceRoles {\n+    bool forceApprovalRole;\n+    bool forceDisapprovalRole;\n+  }\n\n-  /// @notice Mapping of roles that can force an action to be approved.\n-  mapping(uint8 => bool) public forceApprovalRole;\n-\n-  /// @notice Mapping of roles that can force an action to be disapproved.\n-  mapping(uint8 => bool) public forceDisapprovalRole;\n+  mapping(uint8 => ForceRoles) forceRoles;\n\n   /// @notice Mapping of action ID to the supply of the approval role at the time the action was created.\n   mapping(uint256 => uint256) public actionApprovalSupply;\n@@ -146,6 +147,15 @@ contract LlamaRelativeQuorum is ILlamaStrategy, Initializable {\n     _disableInitializers();\n   }\n\n+  // @audit: Getters used for benchmarking purposes\n+  function forceApprovalRole(uint8 role) external view returns (bool) {\n+    return forceRoles[role].forceApprovalRole;\n+  }\n+\n+  function forceDisapprovalRole(uint8 role) external view returns (bool) {\n+    return forceRoles[role].forceDisapprovalRole;\n+  }\n+\n   // ==========================================\n   // ======== Interface Implementation ========\n   // ==========================================\n@@ -178,7 +188,7 @@ contract LlamaRelativeQuorum is ILlamaStrategy, Initializable {\n       uint8 role = strategyConfig.forceApprovalRoles[i];\n       if (role == 0) revert InvalidRole(0);\n       _assertValidRole(role, numRoles);\n-      forceApprovalRole[role] = true;\n+      forceRoles[role].forceApprovalRole = true;\n       emit ForceApprovalRoleAdded(role);\n     }\n\n@@ -186,7 +196,7 @@ contract LlamaRelativeQuorum is ILlamaStrategy, Initializable {\n       uint8 role = strategyConfig.forceDisapprovalRoles[i];\n       if (role == 0) revert InvalidRole(0);\n       _assertValidRole(role, numRoles);\n-      forceDisapprovalRole[role] = true;\n+      forceRoles[role].forceDisapprovalRole = true;\n       emit ForceDisapprovalRoleAdded(role);\n     }\n\n@@ -213,14 +223,14 @@ contract LlamaRelativeQuorum is ILlamaStrategy, Initializable {\n\n   /// @inheritdoc ILlamaStrategy\n   function isApprovalEnabled(ActionInfo calldata, address, uint8 role) external view {\n-    if (role != approvalRole && !forceApprovalRole[role]) revert InvalidRole(approvalRole);\n+    if (role != approvalRole && !forceRoles[role].forceApprovalRole) revert InvalidRole(approvalRole);\n   }\n\n   /// @inheritdoc ILlamaStrategy\n   function getApprovalQuantityAt(address policyholder, uint8 role, uint256 timestamp) external view returns (uint128) {\n-    if (role != approvalRole && !forceApprovalRole[role]) return 0;\n+    if (role != approvalRole && !forceRoles[role].forceApprovalRole) return 0;\n     uint128 quantity = policy.getPastQuantity(policyholder, role, timestamp);\n-    return quantity > 0 && forceApprovalRole[role] ? type(uint128).max : quantity;\n+    return quantity > 0 && forceRoles[role].forceApprovalRole ? type(uint128).max : quantity;\n   }\n\n   // -------- When Casting Disapproval --------\n@@ -228,7 +238,7 @@ contract LlamaRelativeQuorum is ILlamaStrategy, Initializable {\n   /// @inheritdoc ILlamaStrategy\n   function isDisapprovalEnabled(ActionInfo calldata, address, uint8 role) external view {\n     if (minDisapprovalPct > ONE_HUNDRED_IN_BPS) revert DisapprovalDisabled();\n-    if (role != disapprovalRole && !forceDisapprovalRole[role]) revert InvalidRole(disapprovalRole);\n+    if (role != disapprovalRole && !forceRoles[role].forceDisapprovalRole) revert InvalidRole(disapprovalRole);\n   }\n\n   /// @inheritdoc ILlamaStrategy\n@@ -237,9 +247,9 @@ contract LlamaRelativeQuorum is ILlamaStrategy, Initializable {\n     view\n     returns (uint128)\n   {\n-    if (role != disapprovalRole && !forceDisapprovalRole[role]) return 0;\n+    if (role != disapprovalRole && !forceRoles[role].forceDisapprovalRole) return 0;\n     uint128 quantity = policy.getPastQuantity(policyholder, role, timestamp);\n-    return quantity > 0 && forceDisapprovalRole[role] ? type(uint128).max : quantity;\n+    return quantity > 0 && forceRoles[role].forceDisapprovalRole ? type(uint128).max : quantity;\n   }\n\n   // -------- When Queueing --------\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-llama",
  "Code": [
    {
      "filename": "src/strategies/LlamaRelativeQuorum.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Initializable} from \"@openzeppelin/proxy/utils/Initializable.sol\";\n\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\nimport {ILlamaStrategy} from \"src/interfaces/ILlamaStrategy.sol\";\nimport {ActionState} from \"src/lib/Enums.sol\";\nimport {LlamaUtils} from \"src/lib/LlamaUtils.sol\";\nimport {Action, ActionInfo} from \"src/lib/Structs.sol\";\nimport {LlamaCore} from \"src/LlamaCore.sol\";\nimport {LlamaPolicy} from \"src/LlamaPolicy.sol\";\n\n/// @title Llama Relative Quorum Strategy\n/// @author Llama (devsdosomething@llama.xyz)\n/// @notice This is a Llama strategy which has the following properties:\n///   - Approval/disapproval thresholds are specified as percentages of total supply.\n///   - Action creators are allowed to cast approvals or disapprovals on their own actions within this strategy.\ncontract LlamaRelativeQuorum is ILlamaStrategy, Initializable {\n  // =========================\n  // ======== Structs ========\n  // =========================\n\n  struct Config {\n    uint64 approvalPeriod; // The length of time of the approval period.\n    uint64 queuingPeriod; // The length of time of the queuing period. The disapproval period is the queuing period when\n      // enabled.\n    uint64 expirationPeriod; // The length of time an action can be executed before it expires.\n    uint16 minApprovalPct; // Minimum percentage of total approval quantity / total approval supply.\n    uint16 minDisapprovalPct; // Minimum percentage of total disapproval quantity / total disapproval supply.\n    bool isFixedLengthApprovalPeriod; // Determines if an action be queued before approvalEndTime.\n    uint8 approvalRole; // Anyone with this role can cast approval of an action.\n    uint8 disapprovalRole; // Anyone with this role can cast disapproval of an action.\n    uint8[] forceApprovalRoles; // Anyone with this role can single-handedly approve an action.\n    uint8[] forceDisapprovalRoles; // Anyone with this role can single-handedly disapprove an action.\n  }\n\n  // ========================\n  // ======== Errors ========\n  // ========================\n\n  /// @dev The action cannot be canceled if it's already in a terminal state.\n  /// @param currentState The current state of the action.\n  error CannotCancelInState(ActionState currentState);\n\n  /// @dev The strategy has disabled disapprovals.\n  error DisapprovalDisabled();\n\n  /// @dev The action cannot be created because the minimum approval percentage cannot be greater than 100%.\n  /// @param minApprovalPct The provided minApprovalPct.\n  error InvalidMinApprovalPct(uint256 minApprovalPct);\n\n  /// @dev The role is not eligible to participate in this strategy in the specified way.\n  /// @param role The role being used.\n  error InvalidRole(uint8 role);\n\n  /// @dev Only the action creator can cancel an action.\n  error OnlyActionCreator();\n\n  /// @dev The action cannot be created if the approval or disapproval supply is 0.\n  /// @param role The role being used.\n  error RoleHasZeroSupply(uint8 role);\n\n  /// @dev The provided role is not initialized by the `LlamaPolicy`.\n  /// @param role The role being used.\n  error RoleNotInitialized(uint8 role);\n\n  // ========================\n  // ======== Events ========\n  // ========================\n\n  /// @dev Emitted when a force approval role is added to the strategy. This can only happen at strategy deployment\n  /// time during initialization.\n  event ForceApprovalRoleAdded(uint8 role);\n\n  /// @dev Emitted when a force disapproval role is added to the strategy. This can only happen at strategy deployment\n  /// time during initialization.\n  event ForceDisapprovalRoleAdded(uint8 role);\n\n  /// @dev Emitted when a strategy is created referencing the core and policy.\n  event StrategyCreated(LlamaCore llamaCore, LlamaPolicy policy);\n\n  // =================================================\n  // ======== Constants and Storage Variables ========\n  // =================================================\n\n  // -------- Interface Requirements --------\n\n  /// @inheritdoc ILlamaStrategy\n  LlamaCore public llamaCore;\n\n  /// @inheritdoc ILlamaStrategy\n  LlamaPolicy public policy;\n\n  // -------- Strategy Configuration --------\n\n  /// @dev Equivalent to 100%, but in basis points.\n  uint256 internal constant ONE_HUNDRED_IN_BPS = 10_000;\n\n  /// @notice If `false`, action be queued before approvalEndTime.\n  bool public isFixedLengthApprovalPeriod;\n\n  /// @notice Length of approval period in seconds.\n  uint64 public approvalPeriod;\n\n  /// @notice Minimum time, in seconds, between queueing and execution of action.\n  uint64 public queuingPeriod;\n\n  /// @notice Time, in seconds, after `minExecutionTime` that action can be executed before permanently expiring.\n  uint64 public expirationPeriod;\n\n  /// @notice Minimum percentage of `totalApprovalQuantity / totalApprovalSupplyAtCreationTime` required for the\n  /// action to be queued. In bps, where 10,000 == 100%.\n  /// @dev We use `uint16` because it's the smallest integer type that can hold 10,000.\n  uint16 public minApprovalPct;\n\n  /// @notice Minimum percentage of `totalDisapprovalQuantity / totalDisapprovalSupplyAtCreationTime` required of the\n  /// action for it to be canceled. In bps, 10,000 == 100%.\n  /// @dev We use `uint16` because it's the smallest integer type that can hold 10,000.\n  uint16 public minDisapprovalPct;\n\n  /// @notice The role that can approve an action.\n  uint8 public approvalRole;\n\n  /// @notice The role that can disapprove an action.\n  uint8 public disapprovalRole;\n\n  /// @notice Mapping of roles that can force an action to be approved.\n  mapping(uint8 => bool) public forceApprovalRole;\n\n  /// @notice Mapping of roles that can force an action to be disapproved.\n  mapping(uint8 => bool) public forceDisapprovalRole;\n\n  /// @notice Mapping of action ID to the supply of the approval role at the time the action was created.\n  mapping(uint256 => uint256) public actionApprovalSupply;\n\n  /// @notice Mapping of action ID to the supply of the disapproval role at the time the action was created.\n  mapping(uint256 => uint256) public actionDisapprovalSupply;\n\n  // =============================\n  // ======== Constructor ========\n  // =============================\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  // ==========================================\n  // ======== Interface Implementation ========\n  // ==========================================\n\n  // -------- At Strategy Creation --------\n\n  /// @inheritdoc ILlamaStrategy\n  function initialize(bytes memory config) external initializer {\n    Config memory strategyConfig = abi.decode(config, (Config));\n    llamaCore = LlamaCore(msg.sender);\n    policy = llamaCore.policy();\n    queuingPeriod = strategyConfig.queuingPeriod;\n    expirationPeriod = strategyConfig.expirationPeriod;\n    isFixedLengthApprovalPeriod = strategyConfig.isFixedLengthApprovalPeriod;\n    approvalPeriod = strategyConfig.approvalPeriod;\n\n    if (strategyConfig.minApprovalPct > ONE_HUNDRED_IN_BPS) revert InvalidMinApprovalPct(minApprovalPct);\n    minApprovalPct = strategyConfig.minApprovalPct;\n    minDisapprovalPct = strategyConfig.minDisapprovalPct;\n\n    uint8 numRoles = policy.numRoles();\n\n    approvalRole = strategyConfig.approvalRole;\n    _assertValidRole(strategyConfig.approvalRole, numRoles);\n\n    disapprovalRole = strategyConfig.disapprovalRole;\n    _assertValidRole(strategyConfig.disapprovalRole, numRoles);\n\n    for (uint256 i = 0; i < strategyConfig.forceApprovalRoles.length; i = LlamaUtils.uncheckedIncrement(i)) {\n      uint8 role = strategyConfig.forceApprovalRoles[i];\n      if (role == 0) revert InvalidRole(0);\n      _assertValidRole(role, numRoles);\n      forceApprovalRole[role] = true;\n      emit ForceApprovalRoleAdded(role);\n    }\n\n    for (uint256 i = 0; i < strategyConfig.forceDisapprovalRoles.length; i = LlamaUtils.uncheckedIncrement(i)) {\n      uint8 role = strategyConfig.forceDisapprovalRoles[i];\n      if (role == 0) revert InvalidRole(0);\n      _assertValidRole(role, numRoles);\n      forceDisapprovalRole[role] = true;\n      emit ForceDisapprovalRoleAdded(role);\n    }\n\n    emit StrategyCreated(llamaCore, policy);\n  }\n\n  // -------- At Action Creation --------\n\n  /// @inheritdoc ILlamaStrategy\n  function validateActionCreation(ActionInfo calldata actionInfo) external {\n    LlamaPolicy llamaPolicy = policy; // Reduce SLOADs.\n    uint256 approvalPolicySupply = llamaPolicy.getRoleSupplyAsNumberOfHolders(approvalRole);\n    if (approvalPolicySupply == 0) revert RoleHasZeroSupply(approvalRole);\n\n    uint256 disapprovalPolicySupply = llamaPolicy.getRoleSupplyAsNumberOfHolders(disapprovalRole);\n    if (disapprovalPolicySupply == 0) revert RoleHasZeroSupply(disapprovalRole);\n\n    // Save off the supplies to use for checking quorum.\n    actionApprovalSupply[actionInfo.id] = approvalPolicySupply;\n    actionDisapprovalSupply[actionInfo.id] = disapprovalPolicySupply;\n  }\n\n  // -------- When Casting Approval --------\n\n  /// @inheritdoc ILlamaStrategy\n  function isApprovalEnabled(ActionInfo calldata, address, uint8 role) external view {\n    if (role != approvalRole && !forceApprovalRole[role]) revert InvalidRole(approvalRole);\n  }\n\n  /// @inheritdoc ILlamaStrategy\n  function getApprovalQuantityAt(address policyholder, uint8 role, uint256 timestamp) external view returns (uint128) {\n    if (role != approvalRole && !forceApprovalRole[role]) return 0;\n    uint128 quantity = policy.getPastQuantity(policyholder, role, timestamp);\n    return quantity > 0 && forceApprovalRole[role] ? type(uint128).max : quantity;\n  }\n\n  // -------- When Casting Disapproval --------\n\n  /// @inheritdoc ILlamaStrategy\n  function isDisapprovalEnabled(ActionInfo calldata, address, uint8 role) external view {\n    if (minDisapprovalPct > ONE_HUNDRED_IN_BPS) revert DisapprovalDisabled();\n    if (role != disapprovalRole && !forceDisapprovalRole[role]) revert InvalidRole(disapprovalRole);\n  }\n\n  /// @inheritdoc ILlamaStrategy\n  function getDisapprovalQuantityAt(address policyholder, uint8 role, uint256 timestamp)\n    external\n    view\n    returns (uint128)\n  {\n    if (role != disapprovalRole && !forceDisapprovalRole[role]) return 0;\n    uint128 quantity = policy.getPastQuantity(policyholder, role, timestamp);\n    return quantity > 0 && forceDisapprovalRole[role] ? type(uint128).max : quantity;\n  }\n\n  // -------- When Queueing --------\n\n  /// @inheritdoc ILlamaStrategy\n  function minExecutionTime(ActionInfo calldata) external view returns (uint64) {\n    return LlamaUtils.toUint64(block.timestamp + queuingPeriod);\n  }\n\n  // -------- When Canceling --------\n\n  /// @inheritdoc ILlamaStrategy\n  function validateActionCancelation(ActionInfo calldata actionInfo, address caller) external view {\n    // The rules for cancelation are:\n    //   1. The action cannot be canceled if it's state is any of the following: Executed, Canceled,\n    //      Expired, Failed.\n    //   2. For all other states (Active, Approved, Queued) the action can be canceled if the caller\n    //      is the action creator.\n\n    // Check 1.\n    ActionState state = llamaCore.getActionState(actionInfo);\n    if (\n      state == ActionState.Executed || state == ActionState.Canceled || state == ActionState.Expired\n        || state == ActionState.Failed\n    ) revert CannotCancelInState(state);\n\n    // Check 2.\n    if (caller != actionInfo.creator) revert OnlyActionCreator();\n  }\n\n  // -------- When Determining Action State --------\n\n  /// @inheritdoc ILlamaStrategy\n  function isActive(ActionInfo calldata actionInfo) external view returns (bool) {\n    return\n      block.timestamp <= approvalEndTime(actionInfo) && (isFixedLengthApprovalPeriod || !isActionApproved(actionInfo));\n  }\n\n  /// @inheritdoc ILlamaStrategy\n  function isActionApproved(ActionInfo calldata actionInfo) public view returns (bool) {\n    Action memory action = llamaCore.getAction(actionInfo.id);\n    return action.totalApprovals >= _getMinimumAmountNeeded(actionApprovalSupply[actionInfo.id], minApprovalPct);\n  }\n\n  /// @inheritdoc ILlamaStrategy\n  function isActionDisapproved(ActionInfo calldata actionInfo) public view returns (bool) {\n    Action memory action = llamaCore.getAction(actionInfo.id);\n    return\n      action.totalDisapprovals >= _getMinimumAmountNeeded(actionDisapprovalSupply[actionInfo.id], minDisapprovalPct);\n  }\n\n  /// @inheritdoc ILlamaStrategy\n  function isActionExpired(ActionInfo calldata actionInfo) external view returns (bool) {\n    Action memory action = llamaCore.getAction(actionInfo.id);\n    return block.timestamp > action.minExecutionTime + expirationPeriod;\n  }\n\n  // ========================================\n  // ======== Other Public Functions ========\n  // ========================================\n\n  /// @notice Returns the timestamp at which the approval period ends.\n  function approvalEndTime(ActionInfo calldata actionInfo) public view returns (uint256) {\n    Action memory action = llamaCore.getAction(actionInfo.id);\n    return action.creationTime + approvalPeriod;\n  }\n\n  // ================================\n  // ======== Internal Logic ========\n  // ================================\n\n  /// @dev Determine the minimum quantity needed for an action to reach quorum.\n  /// @param supply Total number of policyholders eligible for participation.\n  /// @param minPct Minimum percentage needed to reach quorum.\n  /// @return The total quantity needed to reach quorum.\n  function _getMinimumAmountNeeded(uint256 supply, uint256 minPct) internal pure returns (uint256) {\n    // Rounding Up\n    return FixedPointMathLib.mulDivUp(supply, minPct, ONE_HUNDRED_IN_BPS);\n  }\n\n  /// @dev Reverts if the given `role` is greater than `numRoles`.\n  function _assertValidRole(uint8 role, uint8 numRoles) internal pure {\n    if (role > numRoles) revert RoleNotInitialized(role);\n  }\n}"
    }
  ]
}