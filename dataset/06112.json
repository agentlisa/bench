{
  "Title": "[G-01] Inefficient use of `abi.encode()`",
  "Content": "- Severity: Gas Optimization\n- Confidence: High\n- Total Gas Saved: 700\n\n### Description\nThe `abi.encode()` function is less gas efficient than `abi.encodePacked()`, especially when encoding only static types. This detector identifies instances where `abi.encode()` is used and all arguments are static, suggesting that `abi.encodePacked()` could potentially be used instead for better gas efficiency. Note: `abi.encodePacked()` should not be used if any of the arguments are dynamic types, as it could lead to hash collisions.\n\n<details>\n\n<summary>\nThere are 7 instances of this issue:\n\n</summary>\n\n###\n- File: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 261          queuedTransactions[keccak256(\n          abi.encode(\n            _proposal.targets[_i], _proposal.values[_i], _proposal.signatures[_i], _proposal.calldatas[_i], _eta\n          )\n        )]\n```\n use  abi.encodepacked() instead.\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L261-L265](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L261-L265)\n\n- File: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 299          _txHash = keccak256(abi.encode(_target, _value, _signature, _data, _eta))\n```\n use  abi.encodepacked() instead.\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L299](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L299)\n\n- File: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 405          bytes32 _txHash = keccak256(abi.encode(_target, _value, _signature, _data, _eta))\n```\n use  abi.encodepacked() instead.\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L405](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L405)\n\n- File: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 508          bytes32 _domainSeparator =\n      keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), _getChainIdInternal(), address(this)))\n```\n use  abi.encodepacked() instead.\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L508-L509](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L508-L509)\n\n- File: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 510          bytes32 _structHash = keccak256(abi.encode(BALLOT_TYPEHASH, _proposalId, _support))\n```\n use  abi.encodepacked() instead.\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L510](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L510)\n\n- File: solidity/contracts/utils/UFragments.sol\n```\n \nLine: 168          return keccak256(\n      abi.encode(EIP712_DOMAIN, keccak256(bytes(name)), keccak256(bytes(EIP712_REVISION)), _chainId, address(this))\n    )\n```\n use  abi.encodepacked() instead.\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L168-L170](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L168-L170)\n\n- File: solidity/contracts/utils/UFragments.sol\n```\n \nLine: 327          bytes32 _permitDataDigest = keccak256(abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, _ownerNonce, _deadline))\n```\n use  abi.encodepacked() instead.\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L327](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L327)\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/governance/GovernorCharlie.sol",
      "content": "// solhint-disable max-states-count\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\nimport {IAMPH} from '@interfaces/governance/IAMPH.sol';\nimport {IGovernorCharlie} from '@interfaces/governance/IGovernorCharlie.sol';\n\nimport {Receipt, ProposalState, Proposal} from '@contracts/utils/GovernanceStructs.sol';\n\ncontract GovernorCharlie is IGovernorCharlie {\n  /// @notice The name of this contract\n  string public constant NAME = 'Amphora Protocol Governor';\n\n  /// @notice The maximum number of actions that can be included in a proposal\n  uint256 public constant PROPOSAL_MAX_OPERATIONS = 10;\n\n  /// @notice The EIP-712 typehash for the contract's domain\n  bytes32 public constant DOMAIN_TYPEHASH =\n    keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n  /// @notice The EIP-712 typehash for the ballot struct used by the contract\n  bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n  /// @notice The time for a proposal to be executed after passing\n  uint256 public constant GRACE_PERIOD = 14 days;\n\n  /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n  uint256 public quorumVotes;\n\n  /// @notice The number of votes in support of a proposal required in order for an emergency quorum to be reached and for a vote to succeed\n  uint256 public emergencyQuorumVotes;\n\n  /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n  uint256 public votingDelay;\n\n  /// @notice The duration of voting on a proposal, in blocks\n  uint256 public votingPeriod;\n\n  /// @notice The number of votes required in order for a voter to become a proposer\n  uint256 public proposalThreshold;\n\n  /// @notice Initial proposal id set at become\n  uint256 public initialProposalId;\n\n  /// @notice The total number of proposals\n  uint256 public proposalCount;\n\n  /// @notice The address of the Amphora Protocol governance token\n  IAMPH public amph;\n\n  /// @notice The official record of all proposals ever proposed\n  mapping(uint256 => Proposal) public proposals;\n\n  /// @notice The latest proposal for each proposer\n  mapping(address => uint256) public latestProposalIds;\n\n  /// @notice The mapping that saves queued transactions\n  mapping(bytes32 => bool) public queuedTransactions;\n\n  /// @notice The proposal holding period\n  uint256 public proposalTimelockDelay;\n\n  /// @notice Stores the expiration of account whitelist status as a timestamp\n  mapping(address => uint256) public whitelistAccountExpirations;\n\n  /// @notice Address which manages whitelisted proposals and whitelist accounts\n  address public whitelistGuardian;\n\n  /// @notice The duration of the voting on a emergency proposal, in blocks\n  uint256 public emergencyVotingPeriod;\n\n  /// @notice The emergency proposal holding period\n  uint256 public emergencyTimelockDelay;\n\n  /// @notice all receipts for proposal\n  mapping(uint256 => mapping(address => Receipt)) public proposalReceipts;\n\n  /// @notice The number of votes to reject an optimistic proposal\n  uint256 public optimisticQuorumVotes;\n\n  /// @notice The delay period before voting begins\n  uint256 public optimisticVotingDelay;\n\n  /// @notice The maximum number of seconds an address can be whitelisted for\n  uint256 public maxWhitelistPeriod;\n\n  constructor(address _amph) {\n    amph = IAMPH(_amph);\n    votingPeriod = 40_320;\n    votingDelay = 13_140;\n    proposalThreshold = 1_000_000_000_000_000_000_000_000;\n    proposalTimelockDelay = 172_800;\n    proposalCount = 0;\n    quorumVotes = 10_000_000_000_000_000_000_000_000;\n    emergencyQuorumVotes = 40_000_000_000_000_000_000_000_000;\n    emergencyVotingPeriod = 6570;\n    emergencyTimelockDelay = 43_200;\n\n    optimisticQuorumVotes = 2_000_000_000_000_000_000_000_000;\n    optimisticVotingDelay = 25_600;\n    maxWhitelistPeriod = 31_536_000;\n  }\n\n  /// @notice any function with this modifier can only be called by governance\n  modifier onlyGov() {\n    if (msg.sender != address(this)) revert GovernorCharlie_NotGovernorCharlie();\n    _;\n  }\n\n  /**\n   * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n   * @param _targets Target addresses for proposal calls\n   * @param _values Eth values for proposal calls\n   * @param _signatures Function signatures for proposal calls\n   * @param _calldatas Calldatas for proposal calls\n   * @param _description String description of the proposal\n   * @return _proposalId Proposal id of new proposal\n   */\n  function propose(\n    address[] memory _targets,\n    uint256[] memory _values,\n    string[] memory _signatures,\n    bytes[] memory _calldatas,\n    string memory _description\n  ) public override returns (uint256 _proposalId) {\n    _proposalId = _propose(_targets, _values, _signatures, _calldatas, _description, false);\n  }\n\n  /**\n   * @notice Function used to propose a new emergency proposal. Sender must have delegates above the proposal threshold\n   * @param _targets Target addresses for proposal calls\n   * @param _values Eth values for proposal calls\n   * @param _signatures Function signatures for proposal calls\n   * @param _calldatas Calldatas for proposal calls\n   * @param _description String description of the proposal\n   * @return _proposalId Proposal id of new proposal\n   */\n  function proposeEmergency(\n    address[] memory _targets,\n    uint256[] memory _values,\n    string[] memory _signatures,\n    bytes[] memory _calldatas,\n    string memory _description\n  ) public override returns (uint256 _proposalId) {\n    _proposalId = _propose(_targets, _values, _signatures, _calldatas, _description, true);\n  }\n\n  /**\n   * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n   * @param _targets Target addresses for proposal calls\n   * @param _values Eth values for proposal calls\n   * @param _signatures Function signatures for proposal calls\n   * @param _calldatas Calldatas for proposal calls\n   * @param _description String description of the proposal\n   * @param _emergency Bool to determine if proposal an emergency proposal\n   * @return _proposalId Proposal id of new proposal\n   */\n  function _propose(\n    address[] memory _targets,\n    uint256[] memory _values,\n    string[] memory _signatures,\n    bytes[] memory _calldatas,\n    string memory _description,\n    bool _emergency\n  ) internal returns (uint256 _proposalId) {\n    // Reject proposals before initiating as Governor\n    if (quorumVotes == 0) revert GovernorCharlie_NotActive();\n    // Allow addresses above proposal threshold and whitelisted addresses to propose\n    if (amph.getPriorVotes(msg.sender, (block.number - 1)) < proposalThreshold && !isWhitelisted(msg.sender)) {\n      revert GovernorCharlie_VotesBelowThreshold();\n    }\n    if (\n      _targets.length != _values.length || _targets.length != _signatures.length || _targets.length != _calldatas.length\n    ) revert GovernorCharlie_ArityMismatch();\n    if (_targets.length == 0) revert GovernorCharlie_NoActions();\n    if (_targets.length > PROPOSAL_MAX_OPERATIONS) revert GovernorCharlie_TooManyActions();\n\n    uint256 _latestProposalId = latestProposalIds[msg.sender];\n    if (_latestProposalId != 0) {\n      ProposalState _proposersLatestProposalState = state(_latestProposalId);\n      if (_proposersLatestProposalState == ProposalState.Active) revert GovernorCharlie_MultipleActiveProposals();\n      if (_proposersLatestProposalState == ProposalState.Pending) revert GovernorCharlie_MultiplePendingProposals();\n    }\n\n    proposalCount++;\n    Proposal memory _newProposal = Proposal({\n      id: proposalCount,\n      proposer: msg.sender,\n      eta: 0,\n      targets: _targets,\n      values: _values,\n      signatures: _signatures,\n      calldatas: _calldatas,\n      startBlock: block.number + votingDelay,\n      endBlock: block.number + votingDelay + votingPeriod,\n      forVotes: 0,\n      againstVotes: 0,\n      abstainVotes: 0,\n      canceled: false,\n      executed: false,\n      emergency: _emergency,\n      quorumVotes: quorumVotes,\n      delay: proposalTimelockDelay\n    });\n\n    //whitelist can't make emergency\n    if (_emergency && !isWhitelisted(msg.sender)) {\n      _newProposal.startBlock = block.number;\n      _newProposal.endBlock = block.number + emergencyVotingPeriod;\n      _newProposal.quorumVotes = emergencyQuorumVotes;\n      _newProposal.delay = emergencyTimelockDelay;\n    }\n\n    //whitelist can only make optimistic proposals\n    if (isWhitelisted(msg.sender)) {\n      _newProposal.quorumVotes = optimisticQuorumVotes;\n      _newProposal.startBlock = block.number + optimisticVotingDelay;\n      _newProposal.endBlock = block.number + optimisticVotingDelay + votingPeriod;\n    }\n\n    proposals[_newProposal.id] = _newProposal;\n    latestProposalIds[_newProposal.proposer] = _newProposal.id;\n\n    emit ProposalCreatedIndexed(\n      _newProposal.id,\n      msg.sender,\n      _targets,\n      _values,\n      _signatures,\n      _calldatas,\n      _newProposal.startBlock,\n      _newProposal.endBlock,\n      _description\n    );\n\n    emit ProposalCreated(\n      _newProposal.id,\n      msg.sender,\n      _targets,\n      _values,\n      _signatures,\n      _calldatas,\n      _newProposal.startBlock,\n      _newProposal.endBlock,\n      _description\n    );\n    _proposalId = _newProposal.id;\n  }\n\n  /**\n   * @notice Queues a proposal of state succeeded\n   * @param _proposalId The id of the proposal to queue\n   */\n  function queue(uint256 _proposalId) external override {\n    if (state(_proposalId) != ProposalState.Succeeded) revert GovernorCharlie_ProposalNotSucceeded();\n    Proposal storage _proposal = proposals[_proposalId];\n    uint256 _eta = block.timestamp + _proposal.delay;\n    for (uint256 _i = 0; _i < _proposal.targets.length; _i++) {\n      if (\n        queuedTransactions[keccak256(\n          abi.encode(\n            _proposal.targets[_i], _proposal.values[_i], _proposal.signatures[_i], _proposal.calldatas[_i], _eta\n          )\n        )]\n      ) revert GovernorCharlie_ProposalAlreadyQueued();\n      _queueTransaction(\n        _proposal.targets[_i],\n        _proposal.values[_i],\n        _proposal.signatures[_i],\n        _proposal.calldatas[_i],\n        _eta,\n        _proposal.delay\n      );\n    }\n    _proposal.eta = _eta;\n    emit ProposalQueuedIndexed(_proposalId, _eta);\n    emit ProposalQueued(_proposalId, _eta);\n  }\n\n  /// @notice Queues a transaction\n  /// @param _target Target address for transaction\n  /// @param _value Eth value for transaction\n  /// @param _signature Function signature for transaction\n  /// @param _data Calldata for transaction\n  /// @param _eta Timestamp for transaction\n  /// @param _delay Delay for transaction\n  /// @return _txHash Transaction hash\n  function _queueTransaction(\n    address _target,\n    uint256 _value,\n    string memory _signature,\n    bytes memory _data,\n    uint256 _eta,\n    uint256 _delay\n  ) internal returns (bytes32 _txHash) {\n    if (_eta < (_getBlockTimestamp() + _delay)) revert GovernorCharlie_DelayNotReached();\n\n    _txHash = keccak256(abi.encode(_target, _value, _signature, _data, _eta));\n    queuedTransactions[_txHash] = true;\n\n    emit QueueTransaction(_txHash, _target, _value, _signature, _data, _eta);\n  }\n\n  /**\n   * @notice Executes a queued proposal if eta has passed\n   * @param _proposalId The id of the proposal to execute\n   */\n  function execute(uint256 _proposalId) external payable override {\n    if (state(_proposalId) != ProposalState.Queued) revert GovernorCharlie_ProposalNotQueued();\n    Proposal storage _proposal = proposals[_proposalId];\n    _proposal.executed = true;\n    for (uint256 _i = 0; _i < _proposal.targets.length; _i++) {\n      this.executeTransaction{value: _proposal.values[_i]}(\n        _proposal.targets[_i], _proposal.values[_i], _proposal.signatures[_i], _proposal.calldatas[_i], _proposal.eta\n      );\n    }\n    emit ProposalExecutedIndexed(_proposalId);\n    emit ProposalExecuted(_proposalId);\n  }\n\n  /// @notice Executes a transaction\n  /// @param _target Target address for transaction\n  /// @param _value Eth value for transaction\n  /// @param _signature Function signature for transaction\n  /// @param _data Calldata for transaction\n  /// @param _eta Timestamp for transaction\n  function executeTransaction(\n    address _target,\n    uint256 _value,\n    string memory _signature,\n    bytes memory _data,\n    uint256 _eta\n  ) external payable override {\n    if (msg.sender != address(this)) revert GovernorCharlie_NotGovernorCharlie();\n\n    bytes32 _txHash = keccak256(abi.encode(_target, _value, _signature, _data, _eta));\n    if (!queuedTransactions[_txHash]) revert GovernorCharlie_ProposalNotQueued();\n    if (_getBlockTimestamp() < _eta) revert GovernorCharlie_TimelockNotReached();\n    if (_getBlockTimestamp() > _eta + GRACE_PERIOD) revert GovernorCharlie_TransactionStale();\n\n    queuedTransactions[_txHash] = false;\n\n    bytes memory _callData;\n\n    if (bytes(_signature).length == 0) _callData = _data;\n    else _callData = abi.encodePacked(bytes4(keccak256(bytes(_signature))), _data);\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool _success, /*bytes memory returnData*/ ) = _target.call{value: _value}(_callData);\n    if (!_success) revert GovernorCharlie_TransactionReverted();\n\n    emit ExecuteTransaction(_txHash, _target, _value, _signature, _data, _eta);\n  }\n\n  /**\n   * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n   * @notice whitelistGuardian can cancel proposals from whitelisted addresses\n   * @param _proposalId The id of the proposal to cancel\n   */\n  function cancel(uint256 _proposalId) external override {\n    if (state(_proposalId) == ProposalState.Executed) revert GovernorCharlie_ProposalAlreadyExecuted();\n\n    Proposal storage _proposal = proposals[_proposalId];\n\n    // Proposer can cancel\n    if (msg.sender != _proposal.proposer) {\n      // Whitelisted proposers can't be canceled for falling below proposal threshold\n      if (isWhitelisted(_proposal.proposer)) {\n        if (\n          (amph.getPriorVotes(_proposal.proposer, (block.number - 1)) >= proposalThreshold)\n            || msg.sender != whitelistGuardian\n        ) revert GovernorCharlie_WhitelistedProposer();\n      } else {\n        if ((amph.getPriorVotes(_proposal.proposer, (block.number - 1)) >= proposalThreshold)) {\n          revert GovernorCharlie_ProposalAboveThreshold();\n        }\n      }\n    }\n\n    _proposal.canceled = true;\n    for (uint256 _i = 0; _i < _proposal.targets.length; _i++) {\n      _cancelTransaction(\n        _proposal.targets[_i], _proposal.values[_i], _proposal.signatures[_i], _proposal.calldatas[_i], _proposal.eta\n      );\n    }\n\n    emit ProposalCanceledIndexed(_proposalId);\n    emit ProposalCanceled(_proposalId);\n  }\n\n  /// @notice Cancels a transaction\n  /// @param _target Target address for transaction\n  /// @param _value Eth value for transaction\n  /// @param _signature Function signature for transaction\n  /// @param _data Calldata for transaction\n  /// @param _eta Timestamp for transaction\n  function _cancelTransaction(\n    address _target,\n    uint256 _value,\n    string memory _signature,\n    bytes memory _data,\n    uint256 _eta\n  ) internal {\n    bytes32 _txHash = keccak256(abi.encode(_target, _value, _signature, _data, _eta));\n    queuedTransactions[_txHash] = false;\n\n    emit CancelTransaction(_txHash, _target, _value, _signature, _data, _eta);\n  }\n\n  /**\n   * @notice Gets actions of a proposal\n   * @param _proposalId The id of the proposal\n   * @return _targets The proposal targets\n   * @return _values The proposal values\n   * @return _signatures The proposal signatures\n   * @return _calldatas The proposal calldata\n   */\n  function getActions(uint256 _proposalId)\n    external\n    view\n    override\n    returns (\n      address[] memory _targets,\n      uint256[] memory _values,\n      string[] memory _signatures,\n      bytes[] memory _calldatas\n    )\n  {\n    Proposal storage _proposal = proposals[_proposalId];\n    return (_proposal.targets, _proposal.values, _proposal.signatures, _proposal.calldatas);\n  }\n\n  /**\n   * @notice Returns the proposal\n   * @param _proposalId The id of proposal\n   * @return _proposal The proposal\n   */\n  function getProposal(uint256 _proposalId) external view returns (Proposal memory _proposal) {\n    _proposal = proposals[_proposalId];\n  }\n\n  /**\n   * @notice Gets the receipt for a voter on a given proposal\n   * @param _proposalId The id of proposal\n   * @param _voter The address of the voter\n   * @return _votingReceipt The voting receipt\n   */\n  function getReceipt(\n    uint256 _proposalId,\n    address _voter\n  ) external view override returns (Receipt memory _votingReceipt) {\n    _votingReceipt = proposalReceipts[_proposalId][_voter];\n  }\n\n  /**\n   * @notice Gets the state of a proposal\n   * @param _proposalId The id of the proposal\n   * @return _state Proposal state\n   */\n  // solhint-disable-next-line code-complexity\n  function state(uint256 _proposalId) public view override returns (ProposalState _state) {\n    if (proposalCount < _proposalId || _proposalId <= initialProposalId) revert GovernorCharlie_InvalidProposalId();\n    Proposal storage _proposal = proposals[_proposalId];\n    bool _whitelisted = isWhitelisted(_proposal.proposer);\n    if (_proposal.canceled) return ProposalState.Canceled;\n    else if (block.number <= _proposal.startBlock) return ProposalState.Pending;\n    else if (block.number <= _proposal.endBlock) return ProposalState.Active;\n    else if (\n      (_whitelisted && _proposal.againstVotes > _proposal.quorumVotes)\n        || (!_whitelisted && _proposal.forVotes <= _proposal.againstVotes)\n        || (!_whitelisted && _proposal.forVotes < _proposal.quorumVotes)\n    ) return ProposalState.Defeated;\n    else if (_proposal.eta == 0) return ProposalState.Succeeded;\n    else if (_proposal.executed) return ProposalState.Executed;\n    else if (block.timestamp >= (_proposal.eta + GRACE_PERIOD)) return ProposalState.Expired;\n    _state = ProposalState.Queued;\n  }\n\n  /**\n   * @notice Cast a vote for a proposal\n   * @param _proposalId The id of the proposal to vote on\n   * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n   */\n  function castVote(uint256 _proposalId, uint8 _support) external override {\n    uint96 _numberOfVotes = _castVoteInternal(msg.sender, _proposalId, _support);\n    emit VoteCastIndexed(msg.sender, _proposalId, _support, _numberOfVotes, '');\n    emit VoteCast(msg.sender, _proposalId, _support, _numberOfVotes, '');\n  }\n\n  /**\n   * @notice Cast a vote for a proposal with a reason\n   * @param _proposalId The id of the proposal to vote on\n   * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n   * @param _reason The reason given for the vote by the voter\n   */\n  function castVoteWithReason(uint256 _proposalId, uint8 _support, string calldata _reason) external override {\n    uint96 _numberOfVotes = _castVoteInternal(msg.sender, _proposalId, _support);\n    emit VoteCastIndexed(msg.sender, _proposalId, _support, _numberOfVotes, _reason);\n    emit VoteCast(msg.sender, _proposalId, _support, _numberOfVotes, _reason);\n  }\n\n  /**\n   * @notice Cast a vote for a proposal by signature\n   * @dev External override function that accepts EIP-712 signatures for voting on proposals.\n   */\n  function castVoteBySig(uint256 _proposalId, uint8 _support, uint8 _v, bytes32 _r, bytes32 _s) external override {\n    bytes32 _domainSeparator =\n      keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), _getChainIdInternal(), address(this)));\n    bytes32 _structHash = keccak256(abi.encode(BALLOT_TYPEHASH, _proposalId, _support));\n\n    bytes32 _digest = keccak256(abi.encodePacked('\\x19\\x01', _domainSeparator, _structHash));\n\n    if (uint256(_s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      revert GovernorCharlie_InvalidSignature();\n    }\n    address _signatory = ecrecover(_digest, _v, _r, _s);\n    if (_signatory == address(0)) revert GovernorCharlie_InvalidSignature();\n    uint96 _numberOfVotes = _castVoteInternal(_signatory, _proposalId, _support);\n    emit VoteCastIndexed(_signatory, _proposalId, _support, _numberOfVotes, '');\n    emit VoteCast(_signatory, _proposalId, _support, _numberOfVotes, '');\n  }\n\n  /**\n   * @notice Internal function that caries out voting logic\n   * @param _voter The voter that is casting their vote\n   * @param _proposalId The id of the proposal to vote on\n   * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n   * @return _numberOfVotes The number of votes cast\n   */\n  function _castVoteInternal(\n    address _voter,\n    uint256 _proposalId,\n    uint8 _support\n  ) internal returns (uint96 _numberOfVotes) {\n    if (state(_proposalId) != ProposalState.Active) revert GovernorCharlie_VotingClosed();\n    if (_support > 2) revert GovernorCharlie_InvalidVoteType();\n    Proposal storage _proposal = proposals[_proposalId];\n    Receipt storage _receipt = proposalReceipts[_proposalId][_voter];\n    if (_receipt.hasVoted) revert GovernorCharlie_AlreadyVoted();\n    uint96 _votes = amph.getPriorVotes(_voter, _proposal.startBlock);\n\n    if (_support == 0) _proposal.againstVotes = _proposal.againstVotes + _votes;\n    else if (_support == 1) _proposal.forVotes = _proposal.forVotes + _votes;\n    else if (_support == 2) _proposal.abstainVotes = _proposal.abstainVotes + _votes;\n\n    _receipt.hasVoted = true;\n    _receipt.support = _support;\n    _receipt.votes = _votes;\n\n    _numberOfVotes = _votes;\n  }\n\n  /**\n   * @notice View function which returns if an account is whitelisted\n   * @param _account Account to check white list status of\n   * @return _isWhitelisted If the account is whitelisted\n   */\n  function isWhitelisted(address _account) public view override returns (bool _isWhitelisted) {\n    return (whitelistAccountExpirations[_account] > block.timestamp);\n  }\n\n  /**\n   * @notice Governance function for setting the governance token\n   * @param  _token The new token address\n   */\n  function setNewToken(address _token) external onlyGov {\n    amph = IAMPH(_token);\n  }\n\n  /**\n   * @notice Governance function for setting the max whitelist period\n   * @param  _second How many seconds to whitelist for\n   */\n  function setMaxWhitelistPeriod(uint256 _second) external onlyGov {\n    maxWhitelistPeriod = _second;\n  }\n\n  /**\n   * @notice Used to update the timelock period\n   * @param _proposalTimelockDelay The proposal holding period\n   */\n  function setDelay(uint256 _proposalTimelockDelay) public override onlyGov {\n    uint256 _oldTimelockDelay = proposalTimelockDelay;\n    proposalTimelockDelay = _proposalTimelockDelay;\n\n    emit NewDelay(_oldTimelockDelay, proposalTimelockDelay);\n  }\n\n  /**\n   * @notice Used to update the emergency timelock period\n   * @param _emergencyTimelockDelay The proposal holding period\n   */\n  function setEmergencyDelay(uint256 _emergencyTimelockDelay) public override onlyGov {\n    uint256 _oldEmergencyTimelockDelay = emergencyTimelockDelay;\n    emergencyTimelockDelay = _emergencyTimelockDelay;\n\n    emit NewEmergencyDelay(_oldEmergencyTimelockDelay, emergencyTimelockDelay);\n  }\n\n  /**\n   * @notice Governance function for setting the voting delay\n   * @param _newVotingDelay The new voting delay, in blocks\n   */\n  function setVotingDelay(uint256 _newVotingDelay) external override onlyGov {\n    uint256 _oldVotingDelay = votingDelay;\n    votingDelay = _newVotingDelay;\n\n    emit VotingDelaySet(_oldVotingDelay, votingDelay);\n  }\n\n  /**\n   * @notice Governance function for setting the voting period\n   * @param _newVotingPeriod The new voting period, in blocks\n   */\n  function setVotingPeriod(uint256 _newVotingPeriod) external override onlyGov {\n    uint256 _oldVotingPeriod = votingPeriod;\n    votingPeriod = _newVotingPeriod;\n\n    emit VotingPeriodSet(_oldVotingPeriod, votingPeriod);\n  }\n\n  /**\n   * @notice Governance function for setting the emergency voting period\n   * @param _newEmergencyVotingPeriod The new voting period, in blocks\n   */\n  function setEmergencyVotingPeriod(uint256 _newEmergencyVotingPeriod) external override onlyGov {\n    uint256 _oldEmergencyVotingPeriod = emergencyVotingPeriod;\n    emergencyVotingPeriod = _newEmergencyVotingPeriod;\n\n    emit EmergencyVotingPeriodSet(_oldEmergencyVotingPeriod, emergencyVotingPeriod);\n  }\n\n  /**\n   * @notice Governance function for setting the proposal threshold\n   * @param _newProposalThreshold The new proposal threshold\n   */\n  function setProposalThreshold(uint256 _newProposalThreshold) external override onlyGov {\n    uint256 _oldProposalThreshold = proposalThreshold;\n    proposalThreshold = _newProposalThreshold;\n\n    emit ProposalThresholdSet(_oldProposalThreshold, proposalThreshold);\n  }\n\n  /**\n   * @notice Governance function for setting the quorum\n   * @param _newQuorumVotes The new proposal quorum\n   */\n  function setQuorumVotes(uint256 _newQuorumVotes) external override onlyGov {\n    uint256 _oldQuorumVotes = quorumVotes;\n    quorumVotes = _newQuorumVotes;\n\n    emit NewQuorum(_oldQuorumVotes, quorumVotes);\n  }\n\n  /**\n   * @notice Governance function for setting the emergency quorum\n   * @param _newEmergencyQuorumVotes The new proposal quorum\n   */\n  function setEmergencyQuorumVotes(uint256 _newEmergencyQuorumVotes) external override onlyGov {\n    uint256 _oldEmergencyQuorumVotes = emergencyQuorumVotes;\n    emergencyQuorumVotes = _newEmergencyQuorumVotes;\n\n    emit NewEmergencyQuorum(_oldEmergencyQuorumVotes, emergencyQuorumVotes);\n  }\n\n  /**\n   * @notice Governance function for setting the whitelist expiration as a timestamp\n   * for an account. Whitelist status allows accounts to propose without meeting threshold\n   * @param _account Account address to set whitelist expiration for\n   * @param _expiration Expiration for account whitelist status as timestamp (if now < expiration, whitelisted)\n   */\n  function setWhitelistAccountExpiration(address _account, uint256 _expiration) external override onlyGov {\n    if (_expiration >= (maxWhitelistPeriod + block.timestamp)) revert GovernorCharlie_ExpirationExceedsMax();\n    whitelistAccountExpirations[_account] = _expiration;\n\n    emit WhitelistAccountExpirationSet(_account, _expiration);\n  }\n\n  /**\n   * @notice Governance function for setting the whitelistGuardian. WhitelistGuardian can cancel proposals from whitelisted addresses\n   * @param _account Account to set whitelistGuardian to (0x0 to remove whitelistGuardian)\n   */\n  function setWhitelistGuardian(address _account) external override onlyGov {\n    address _oldGuardian = whitelistGuardian;\n    whitelistGuardian = _account;\n\n    emit WhitelistGuardianSet(_oldGuardian, whitelistGuardian);\n  }\n\n  /**\n   * @notice Governance function for setting the optimistic voting delay\n   * @param _newOptimisticVotingDelay The new optimistic voting delay, in blocks\n   */\n  function setOptimisticDelay(uint256 _newOptimisticVotingDelay) external override onlyGov {\n    uint256 _oldOptimisticVotingDelay = optimisticVotingDelay;\n    optimisticVotingDelay = _newOptimisticVotingDelay;\n\n    emit OptimisticVotingDelaySet(_oldOptimisticVotingDelay, optimisticVotingDelay);\n  }\n\n  /**\n   * @notice Governance function for setting the optimistic quorum\n   * @param _newOptimisticQuorumVotes The new optimistic quorum votes, in blocks\n   */\n  function setOptimisticQuorumVotes(uint256 _newOptimisticQuorumVotes) external override onlyGov {\n    uint256 _oldOptimisticQuorumVotes = optimisticQuorumVotes;\n    optimisticQuorumVotes = _newOptimisticQuorumVotes;\n\n    emit OptimisticQuorumVotesSet(_oldOptimisticQuorumVotes, optimisticQuorumVotes);\n  }\n\n  /// @notice Returns the timelock address\n  /// @param _timelock The timelock address\n  function timelock() external view override returns (address _timelock) {\n    _timelock = address(this);\n  }\n\n  /// @notice Returns the proposal time lock delay\n  /// @return _delay The proposal time lock delay\n  function delay() external view override returns (uint256 _delay) {\n    _delay = proposalTimelockDelay;\n  }\n\n  /// @notice Returns the chaid id of the blockchain\n  /// @return _chainId The chain id\n  function _getChainIdInternal() internal view returns (uint256 _chainId) {\n    _chainId = block.chainid;\n  }\n\n  /// @notice Returns the block timestamp\n  /// @return _timestamp The block timestamp\n  function _getBlockTimestamp() internal view returns (uint256 _timestamp) {\n    // solium-disable-next-line security/no-block-members\n    _timestamp = block.timestamp;\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/governance/GovernorCharlie.sol",
      "content": "// solhint-disable max-states-count\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\nimport {IAMPH} from '@interfaces/governance/IAMPH.sol';\nimport {IGovernorCharlie} from '@interfaces/governance/IGovernorCharlie.sol';\n\nimport {Receipt, ProposalState, Proposal} from '@contracts/utils/GovernanceStructs.sol';\n\ncontract GovernorCharlie is IGovernorCharlie {\n  /// @notice The name of this contract\n  string public constant NAME = 'Amphora Protocol Governor';\n\n  /// @notice The maximum number of actions that can be included in a proposal\n  uint256 public constant PROPOSAL_MAX_OPERATIONS = 10;\n\n  /// @notice The EIP-712 typehash for the contract's domain\n  bytes32 public constant DOMAIN_TYPEHASH =\n    keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n  /// @notice The EIP-712 typehash for the ballot struct used by the contract\n  bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n  /// @notice The time for a proposal to be executed after passing\n  uint256 public constant GRACE_PERIOD = 14 days;\n\n  /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n  uint256 public quorumVotes;\n\n  /// @notice The number of votes in support of a proposal required in order for an emergency quorum to be reached and for a vote to succeed\n  uint256 public emergencyQuorumVotes;\n\n  /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n  uint256 public votingDelay;\n\n  /// @notice The duration of voting on a proposal, in blocks\n  uint256 public votingPeriod;\n\n  /// @notice The number of votes required in order for a voter to become a proposer\n  uint256 public proposalThreshold;\n\n  /// @notice Initial proposal id set at become\n  uint256 public initialProposalId;\n\n  /// @notice The total number of proposals\n  uint256 public proposalCount;\n\n  /// @notice The address of the Amphora Protocol governance token\n  IAMPH public amph;\n\n  /// @notice The official record of all proposals ever proposed\n  mapping(uint256 => Proposal) public proposals;\n\n  /// @notice The latest proposal for each proposer\n  mapping(address => uint256) public latestProposalIds;\n\n  /// @notice The mapping that saves queued transactions\n  mapping(bytes32 => bool) public queuedTransactions;\n\n  /// @notice The proposal holding period\n  uint256 public proposalTimelockDelay;\n\n  /// @notice Stores the expiration of account whitelist status as a timestamp\n  mapping(address => uint256) public whitelistAccountExpirations;\n\n  /// @notice Address which manages whitelisted proposals and whitelist accounts\n  address public whitelistGuardian;\n\n  /// @notice The duration of the voting on a emergency proposal, in blocks\n  uint256 public emergencyVotingPeriod;\n\n  /// @notice The emergency proposal holding period\n  uint256 public emergencyTimelockDelay;\n\n  /// @notice all receipts for proposal\n  mapping(uint256 => mapping(address => Receipt)) public proposalReceipts;\n\n  /// @notice The number of votes to reject an optimistic proposal\n  uint256 public optimisticQuorumVotes;\n\n  /// @notice The delay period before voting begins\n  uint256 public optimisticVotingDelay;\n\n  /// @notice The maximum number of seconds an address can be whitelisted for\n  uint256 public maxWhitelistPeriod;\n\n  constructor(address _amph) {\n    amph = IAMPH(_amph);\n    votingPeriod = 40_320;\n    votingDelay = 13_140;\n    proposalThreshold = 1_000_000_000_000_000_000_000_000;\n    proposalTimelockDelay = 172_800;\n    proposalCount = 0;\n    quorumVotes = 10_000_000_000_000_000_000_000_000;\n    emergencyQuorumVotes = 40_000_000_000_000_000_000_000_000;\n    emergencyVotingPeriod = 6570;\n    emergencyTimelockDelay = 43_200;\n\n    optimisticQuorumVotes = 2_000_000_000_000_000_000_000_000;\n    optimisticVotingDelay = 25_600;\n    maxWhitelistPeriod = 31_536_000;\n  }\n\n  /// @notice any function with this modifier can only be called by governanc"
    }
  ]
}