{
  "Title": "[M-01] User may force fail the action from the `DAO:execute`",
  "Content": "\n[DAO.sol#L186](https://github.com/aragon/osx/blob/develop/packages/contracts/src/core/dao/DAO.sol#L186)<br>\n[MajorityVotingBase.sol#L286](https://github.com/aragon/osx/blob/develop/packages/contracts/src/plugins/governance/majority-voting/MajorityVotingBase.sol#L286)<br>\n[MajorityVotingBase.sol#L459](https://github.com/aragon/osx/blob/develop/packages/contracts/src/plugins/governance/majority-voting/MajorityVotingBase.sol#L459)\n\nThe `execute` function from the `DAO.sol` contract allow to execution of any call to any address if the caller has appropriate permission. Some calls are expected to be always successfully executed, and some may revert and `execute` will continue the execution.\n\nThe following code may call and handle call status.\n\n```solidity\naddress to = _actions[i].to;\n(bool success, bytes memory response) = to.call{value: _actions[i].value}(\n    _actions[i].data\n);\n\nif (!success) {\n    // If the call failed and wasn't allowed in allowFailureMap, revert.\n    if (!hasBit(_allowFailureMap, uint8(i))) {\n        revert ActionFailed(i);\n    }\n\n    // If the call failed, but was allowed in allowFailureMap, store that\n    // this specific action has actually failed.\n    failureMap = flipBit(failureMap, uint8(i));\n}\n```\n\nAlso, the function is expected to be used in a different scenario, where the caller may be a user, voter, etc. (See `MajorityVotingBase`). So the caller is not a trusted entity and that means any manipulation of the DAO call should be avoided.\n\nThe problem is that caller may choose the gas with which the code is executed. If the child call execution spends enough gas then the user may choose that amount of gas, that child call frame fails, but the left gas is enough to successfully finish `DAO:execute` function.\n\nPlease note, even though the `execute` pass all gas to the child call, actually only 63/64 gas is passed and 1/64 of gas is left on the parent call (EIP-150).\n\n*   <https://medium.com/iovlabs-innovation-stories/the-dark-side-of-ethereum-1-64th-call-gas-reduction-ba661778568c>\n\n**Attack scenario**\n\nThe DAO starts majority voting, and users who have DAO tokens may vote for the proposal. The proposal is to call one `target` protocol, which may fail in case of an inner reason. So the DAO set that the call may fail. The approximate gas that is needed to finish the call to the `target` contract is `700k`. A malicious voter call `execute` function with `711.1k` of gas. Since `63/64 * 711.1 < 700`, the requested call will fail. And the remaining gas is still sufficient to end the `execute` function logic.\n\n### Impact\n\nThe user may forcefully fail the inner call from the `execute` function. Also, anyone who will use the usual `eth_estimateGas` for the gas estimation for the `execute` function will accidentally calculate the amount of gas that will fail the call.\n\nSince majority voting is hard to process with many users involved, creating another proposal may create a lot of pain.\n\n### Recommended Mitigation Steps\n\nAdd the require that gas after the call is bigger than gas before / 64.\n\n```solidity\nuint256 gasBefore;\n// Do call...\nrequire(gasleft() > gasBefore/64);\n```\n\n**[novaknole20 (Aragon) confirmed](https://github.com/code-423n4/2023-03-aragon-findings/issues/191#issuecomment-1468216052)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-03-aragon",
  "Code": [
    {
      "filename": "packages/contracts/src/core/dao/DAO.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ERC165StorageUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC721ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport {IERC1155Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport {IERC1155ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\n\nimport {IProtocolVersion} from \"@aragon/osx-commons-contracts/src/utils/versioning/IProtocolVersion.sol\";\nimport {ProtocolVersion} from \"@aragon/osx-commons-contracts/src/utils/versioning/ProtocolVersion.sol\";\nimport {VersionComparisonLib} from \"@aragon/osx-commons-contracts/src/utils/versioning/VersionComparisonLib.sol\";\nimport {hasBit, flipBit} from \"@aragon/osx-commons-contracts/src/utils/math/BitMap.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\n\nimport {PermissionManager} from \"../permission/PermissionManager.sol\";\nimport {CallbackHandler} from \"../utils/CallbackHandler.sol\";\nimport {IEIP4824} from \"./IEIP4824.sol\";\n\n/// @title DAO\n/// @author Aragon X - 2021-2023\n/// @notice This contract is the entry point to the Aragon DAO framework and provides our users a simple and easy to use public interface.\n/// @dev Public API of the Aragon DAO framework.\n/// @custom:security-contact sirt@aragon.org\ncontract DAO is\n    IEIP4824,\n    Initializable,\n    IERC1271,\n    ERC165StorageUpgradeable,\n    IDAO,\n    UUPSUpgradeable,\n    ProtocolVersion,\n    PermissionManager,\n    CallbackHandler\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n    using VersionComparisonLib for uint8[3];\n\n    /// @notice The ID of the permission required to call the `execute` function.\n    bytes32 public constant EXECUTE_PERMISSION_ID = keccak256(\"EXECUTE_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.\n    bytes32 public constant UPGRADE_DAO_PERMISSION_ID = keccak256(\"UPGRADE_DAO_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `setMetadata` function.\n    bytes32 public constant SET_METADATA_PERMISSION_ID = keccak256(\"SET_METADATA_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `setTrustedForwarder` function.\n    bytes32 public constant SET_TRUSTED_FORWARDER_PERMISSION_ID =\n        keccak256(\"SET_TRUSTED_FORWARDER_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `registerStandardCallback` function.\n    bytes32 public constant REGISTER_STANDARD_CALLBACK_PERMISSION_ID =\n        keccak256(\"REGISTER_STANDARD_CALLBACK_PERMISSION\");\n\n    /// @notice The ID of the permission required to validate [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) signatures.\n    bytes32 public constant VALIDATE_SIGNATURE_PERMISSION_ID =\n        keccak256(\"VALIDATE_SIGNATURE_PERMISSION\");\n\n    /// @notice The internal constant storing the maximal action array length.\n    uint256 internal constant MAX_ACTIONS = 256;\n\n    /// @notice The first out of two values to which the `_reentrancyStatus` state variable (used by the `nonReentrant` modifier) can be set indicating that a function was not entered.\n    uint256 private constant _NOT_ENTERED = 1;\n\n    /// @notice The second out of two values to which the `_reentrancyStatus` state variable (used by the `nonReentrant` modifier) can be set indicating that a function was entered.\n    uint256 private constant _ENTERED = 2;\n\n    /// @notice Removed variable that is left here to maintain the storage layout.\n    /// @dev Introduced in v1.0.0. Removed in v1.4.0.\n    /// @custom:oz-renamed-from signatureValidator\n    address private __removed0;\n\n    /// @notice The address of the trusted forwarder verifying meta transactions.\n    /// @dev Added in v1.0.0.\n    address private trustedForwarder;\n\n    /// @notice The [EIP-4824](https://eips.ethereum.org/EIPS/eip-4824) DAO URI.\n    /// @dev Added in v1.0.0.\n    string private _daoURI;\n\n    /// @notice The state variable for the reentrancy guard of the `execute` function.\n    /// @dev Added in v1.3.0. The variable can be of value `_NOT_ENTERED = 1` or `_ENTERED = 2` in usage and is initialized with `_NOT_ENTERED`.\n    uint256 private _reentrancyStatus;\n\n    /// @notice Thrown if a call is reentrant.\n    error ReentrantCall();\n\n    /// @notice Thrown if the action array length is larger than `MAX_ACTIONS`.\n    error TooManyActions();\n\n    /// @notice Thrown if action execution has failed.\n    /// @param index The index of the action in the action array that failed.\n    error ActionFailed(uint256 index);\n\n    /// @notice Thrown if an action has insufficient gas left.\n    error InsufficientGas();\n\n    /// @notice Thrown if the deposit amount is zero.\n    error ZeroAmount();\n\n    /// @notice Thrown if there is a mismatch between the expected and actually deposited amount of native tokens.\n    /// @param expected The expected native token amount.\n    /// @param actual The actual native token amount deposited.\n    error NativeTokenDepositAmountMismatch(uint256 expected, uint256 actual);\n\n    /// @notice Thrown if an upgrade is not supported from a specific protocol version .\n    error ProtocolVersionUpgradeNotSupported(uint8[3] protocolVersion);\n\n    /// @notice Thrown when a function is removed but left to not corrupt the interface ID.\n    error FunctionRemoved();\n\n    /// @notice Emitted when a new DAO URI is set.\n    /// @param daoURI The new URI.\n    event NewURI(string daoURI);\n\n    /// @notice A modifier to protect a function from calling itself, directly or indirectly (reentrancy).\n    /// @dev Currently, this modifier is only applied to the `execute()` function. If this is used multiple times, private `_beforeNonReentrant()` and `_afterNonReentrant()` functions should be created to prevent code duplication.\n    modifier nonReentrant() {\n        if (_reentrancyStatus == _ENTERED) {\n            revert ReentrantCall();\n        }\n        _reentrancyStatus = _ENTERED;\n\n        _;\n\n        _reentrancyStatus = _NOT_ENTERED;\n    }\n\n    /// @notice Disables the initializers on the implementation contract to prevent it from being left uninitialized.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the DAO by\n    /// - setting the reentrancy status variable to `_NOT_ENTERED`\n    /// - registering the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID\n    /// - setting the trusted forwarder for meta transactions\n    /// - giving the `ROOT_PERMISSION_ID` permission to the initial owner (that should be revoked and transferred to the DAO after setup).\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _metadata IPFS hash that points to all the metadata (logo, description, tags, etc.) of a DAO.\n    /// @param _initialOwner The initial owner of the DAO having the `ROOT_PERMISSION_ID` permission.\n    /// @param _trustedForwarder The trusted forwarder responsible for verifying meta transactions.\n    /// @param daoURI_ The DAO URI required to support [ERC-4824](https://eips.ethereum.org/EIPS/eip-4824).\n    function initialize(\n        bytes calldata _metadata,\n        address _initialOwner,\n        address _trustedForwarder,\n        string calldata daoURI_\n    ) external reinitializer(3) {\n        _reentrancyStatus = _NOT_ENTERED; // added in v1.3.0\n\n        _registerInterface(type(IDAO).interfaceId);\n        _registerInterface(type(IERC1271).interfaceId);\n        _registerInterface(type(IEIP4824).interfaceId);\n        _registerInterface(type(IProtocolVersion).interfaceId); // added in v1.3.0\n        _registerTokenInterfaces();\n\n        _setMetadata(_metadata);\n        _setTrustedForwarder(_trustedForwarder);\n        _setDaoURI(daoURI_);\n        __PermissionManager_init(_initialOwner);\n    }\n\n    /// @notice Initializes the DAO after an upgrade from a previous protocol version.\n    /// @param _previousProtocolVersion The semantic protocol version number of the previous DAO implementation contract this upgrade is transitioning from.\n    /// @param _initData The initialization data to be passed to via `upgradeToAndCall` (see [ERC-1967](https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Upgrade)).\n    function initializeFrom(\n        uint8[3] calldata _previousProtocolVersion,\n        bytes calldata _initData\n    ) external reinitializer(3) {\n        _initData; // Silences the unused function parameter warning.\n\n        // Check that the contract is not upgrading from a different major release.\n        if (_previousProtocolVersion[0] != 1) {\n            revert ProtocolVersionUpgradeNotSupported(_previousProtocolVersion);\n        }\n\n        // Initialize `_reentrancyStatus` that was added in v1.3.0.\n        // Register Interface `ProtocolVersion` that was added in v1.3.0.\n        if (_previousProtocolVersion.lt([1, 3, 0])) {\n            _reentrancyStatus = _NOT_ENTERED;\n            _registerInterface(type(IProtocolVersion).interfaceId);\n        }\n\n        // Revoke the `SET_SIGNATURE_VALIDATOR_PERMISSION` that was deprecated in v1.4.0.\n        if (_previousProtocolVersion.lt([1, 4, 0])) {\n            _revoke({\n                _where: address(this),\n                _who: address(this),\n                _permissionId: keccak256(\"SET_SIGNATURE_VALIDATOR_PERMISSION\")\n            });\n        }\n    }\n\n    /// @inheritdoc PermissionManager\n    function isPermissionRestrictedForAnyAddr(\n        bytes32 _permissionId\n    ) internal pure override returns (bool) {\n        return\n            _permissionId == EXECUTE_PERMISSION_ID ||\n            _permissionId == UPGRADE_DAO_PERMISSION_ID ||\n            _permissionId == SET_METADATA_PERMISSION_ID ||\n            _permissionId == SET_TRUSTED_FORWARDER_PERMISSION_ID ||\n            _permissionId == REGISTER_STANDARD_CALLBACK_PERMISSION_ID;\n    }\n\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeability mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    /// @dev The caller must have the `UPGRADE_DAO_PERMISSION_ID` permission.\n    function _authorizeUpgrade(address) internal virtual override auth(UPGRADE_DAO_PERMISSION_ID) {}\n\n    /// @inheritdoc IDAO\n    function setTrustedForwarder(\n        address _newTrustedForwarder\n    ) external override auth(SET_TRUSTED_FORWARDER_PERMISSION_ID) {\n        _setTrustedForwarder(_newTrustedForwarder);\n    }\n\n    /// @inheritdoc IDAO\n    function getTrustedForwarder() external view virtual override returns (address) {\n        return trustedForwarder;\n    }\n\n    /// @inheritdoc IDAO\n    function hasPermission(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) external view override returns (bool) {\n        return isGranted({_where: _where, _who: _who, _permissionId: _permissionId, _data: _data});\n    }\n\n    /// @inheritdoc IDAO\n    function setMetadata(\n        bytes calldata _metadata\n    ) external override auth(SET_METADATA_PERMISSION_ID) {\n        _setMetadata(_metadata);\n    }\n\n    /// @inheritdoc IDAO\n    function execute(\n        bytes32 _callId,\n        Action[] calldata _actions,\n        uint256 _allowFailureMap\n    )\n        external\n        override\n        nonReentrant\n        auth(EXECUTE_PERMISSION_ID)\n        returns (bytes[] memory execResults, uint256 failureMap)\n    {\n        // Check that the action array length is within bounds.\n        if (_actions.length > MAX_ACTIONS) {\n            revert TooManyActions();\n        }\n\n        execResults = new bytes[](_actions.length);\n\n        uint256 gasBefore;\n        uint256 gasAfter;\n\n        for (uint256 i = 0; i < _actions.length; ) {\n            gasBefore = gasleft();\n\n            (bool success, bytes memory result) = _actions[i].to.call{value: _actions[i].value}(\n                _actions[i].data\n            );\n            gasAfter = gasleft();\n\n            // Check if failure is allowed\n            if (!hasBit(_allowFailureMap, uint8(i))) {\n                // Check if the call failed.\n                if (!success) {\n                    revert ActionFailed(i);\n                }\n            } else {\n                // Check if the call failed.\n                if (!success) {\n                    // Make sure that the action call did not fail because 63/64 of `gasleft()` was insufficient to execute the external call `.to.call` (see [ERC-150](https://eips.ethereum.org/EIPS/eip-150)).\n                    // In specific scenarios, i.e. proposal execution where the last action in the action array is allowed to fail, the account calling `execute` could force-fail this action by setting a gas limit\n                    // where 63/64 is insufficient causing the `.to.call` to fail, but where the remaining 1/64 gas are sufficient to successfully finish the `execute` call.\n                    if (gasAfter < gasBefore / 64) {\n                        revert InsufficientGas();\n                    }\n\n                    // Store that this action failed.\n                    failureMap = flipBit(failureMap, uint8(i));\n                }\n            }\n\n            execResults[i] = result;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit Executed({\n            actor: msg.sender,\n            callId: _callId,\n            actions: _actions,\n            allowFailureMap: _allowFailureMap,\n            failureMap: failureMap,\n            execResults: execResults\n        });\n    }\n\n    /// @inheritdoc IDAO\n    function deposit(\n        address _token,\n        uint256 _amount,\n        string calldata _reference\n    ) external payable override {\n        if (_amount == 0) revert ZeroAmount();\n\n        if (_token == address(0)) {\n            if (msg.value != _amount)\n                revert NativeTokenDepositAmountMismatch({expected: _amount, actual: msg.value});\n        } else {\n            if (msg.value != 0)\n                revert NativeTokenDepositAmountMismatch({expected: 0, actual: msg.value});\n\n            IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        }\n\n        emit Deposited(msg.sender, _token, _amount, _reference);\n    }\n\n    /// @inheritdoc IDAO\n    function setSignatureValidator(address) external pure override {\n        revert FunctionRemoved();\n    }\n\n    /// @inheritdoc IDAO\n    /// @dev Relays the validation logic determining who is allowed to sign on behalf of the DAO to its permission manager.\n    /// Caller specific bypassing can be set direct granting (i.e., `grant({_where: dao, _who: specificErc1271Caller, _permissionId: VALIDATE_SIGNATURE_PERMISSION_ID})`).\n    /// Caller specific signature validation logic can be set by granting with a `PermissionCondition` (i.e., `grantWithCondition({_where: dao, _who: specificErc1271Caller, _permissionId: VALIDATE_SIGNATURE_PERMISSION_ID, _condition: yourConditionImplementation})`)\n    /// Generic signature validation logic can be set for all calling contracts by granting with a `PermissionCondition` to `PermissionManager.ANY_ADDR()` (i.e., `grantWithCondition({_where: dao, _who: PermissionManager.ANY_ADDR(), _permissionId: VALIDATE_SIGNATURE_PERMISSION_ID, _condition: yourConditionImplementation})`).\n    function isValidSignature(\n        bytes32 _hash,\n        bytes memory _signature\n    ) external view override(IDAO, IERC1271) returns (bytes4) {\n        if (\n            isGranted({\n                _where: address(this),\n                _who: msg.sender,\n                _permissionId: VALIDATE_SIGNATURE_PERMISSION_ID,\n                _data: abi.encode(_hash, _signature)\n            })\n        ) {\n            return 0x1626ba7e; // `type(IERC1271).interfaceId` = bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")`\n        }\n        return 0xffffffff; // `bytes4(uint32(type(uint32).max-1))`\n    }\n\n    /// @notice Emits the `NativeTokenDeposited` event to track native token deposits that weren't made via the deposit method.\n    /// @dev This call is bound by the gas limitations for `send`/`transfer` calls introduced by [ERC-2929](https://eips.ethereum.org/EIPS/eip-2929).\n    /// Gas cost increases in future hard forks might break this function. As an alternative, [ERC-2930](https://eips.ethereum.org/EIPS/eip-2930)-type transactions using access lists can be employed.\n    receive() external payable {\n        emit NativeTokenDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Fallback to handle future versions of the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) standard.\n    /// @param _input An alias being equivalent to `msg.data`. This feature of the fallback function was introduced with the [solidity compiler version 0.7.6](https://github.com/ethereum/solidity/releases/tag/v0.7.6)\n    /// @return The magic number registered for the function selector triggering the fallback.\n    fallback(bytes calldata _input) external returns (bytes memory) {\n        bytes4 magicNumber = _handleCallback(msg.sig, _input);\n        return abi.encode(magicNumber);\n    }\n\n    /// @notice Emits the MetadataSet event if new metadata is set.\n    /// @param _metadata Hash of the IPFS metadata object.\n    function _setMetadata(bytes calldata _metadata) internal {\n        emit MetadataSet(_metadata);\n    }\n\n    /// @notice Sets the trusted forwarder on the DAO and emits the associated event.\n    /// @param _trustedForwarder The trusted forwarder address.\n    function _setTrustedForwarder(address _trustedForwarder) internal {\n        trustedForwarder = _trustedForwarder;\n\n        emit TrustedForwarderSet(_trustedForwarder);\n    }\n\n    /// @notice Registers the [ERC-721](https://eips.ethereum.org/EIPS/eip-721) and [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155) interfaces and callbacks.\n    function _registerTokenInterfaces() private {\n        _registerInterface(type(IERC721ReceiverUpgradeable).interfaceId);\n        _registerInterface(type(IERC1155ReceiverUpgradeable).interfaceId);\n\n        _registerCallback(\n            IERC721ReceiverUpgradeable.onERC721Received.selector,\n            IERC721ReceiverUpgradeable.onERC721Received.selector\n        );\n        _registerCallback(\n            IERC1155ReceiverUpgradeable.onERC1155Received.selector,\n            IERC1155ReceiverUpgradeable.onERC1155Received.selector\n        );\n        _registerCallback(\n            IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector,\n            IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector\n        );\n    }\n\n    /// @inheritdoc IDAO\n    function registerStandardCallback(\n        bytes4 _interfaceId,\n        bytes4 _callbackSelector,\n        bytes4 _magicNumber\n    ) external override auth(REGISTER_STANDARD_CALLBACK_PERMISSION_ID) {\n        _registerInterface(_interfaceId);\n        _registerCallback(_callbackSelector, _magicNumber);\n        emit StandardCallbackRegistered(_interfaceId, _callbackSelector, _magicNumber);\n    }\n\n    /// @inheritdoc IEIP4824\n    function daoURI() external view returns (string memory) {\n        return _daoURI;\n    }\n\n    /// @notice Updates the set DAO URI to a new value.\n    /// @param newDaoURI The new DAO URI to be set.\n    function setDaoURI(string calldata newDaoURI) external auth(SET_METADATA_PERMISSION_ID) {\n        _setDaoURI(newDaoURI);\n    }\n\n    /// @notice Sets the new [ERC-4824](https://eips.ethereum.org/EIPS/eip-4824) DAO URI and emits the associated event.\n    /// @param daoURI_ The new DAO URI.\n    function _setDaoURI(string calldata daoURI_) internal {\n        _daoURI = daoURI_;\n\n        emit NewURI(daoURI_);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[46] private __gap;\n}"
    }
  ]
}