{
  "Title": "[G-03] `require` in `hashL2Bytecode` in `L2ContractHelper.sol` can be moved on top",
  "Content": "\n[File: ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L23-L26)\n\n```\n        require(_bytecode.length % 32 == 0, \"pq\");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2**16, \"pp\"); // bytecode length must be less than 2^16 words\n```\n\nSince `_bytecode.length` is divisible by 32 (the first `require`), we know, that we can divide `_bytecode.length` by 32, without a remainder.\n\nLet's take a look at the 2nd `require`:\n\n`bytecodeLenInWords < 2**16  =>  _bytecode.length / 32 < 2**16  => _bytecode.length < 2**16 * 32  => _bytecode.length < 2**21`\n\nThis implies that we can rewrite above code snippet as:\n\n```\n        require(_bytecode.length % 32 == 0, \"pq\");\n        require(_bytecode.length < 2**21, \"pp\"); // bytecode length must be less than 2^16 words\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        \n```\n\nThat way, when `_bytecode.length` is too big, we will revert immediately, instead of wasting gas on executing line: `uint256 bytecodeLenInWords = _bytecode.length / 32`. That line will be executed after the 2nd `require`.\n\nMoreover, please keep in mind, to cache `_bytecode.length` into local variable - as it was suggested in `G-02`:\n\n```\n        uint256 _bytecodeLength = _bytecode.length;\n        require(_bytecodeLength % 32 == 0, \"pq\");\n        require(_bytecodeLength < 2**21, \"pp\"); // bytecode length must be less than 2^16 words\n        uint256 bytecodeLenInWords = _bytecodeLength / 32;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Helper library for working with L2 contracts on L1.\n */\nlibrary L2ContractHelper {\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 constant CREATE2_PREFIX = keccak256(\"zksyncCreate2\");\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(bytes memory _bytecode) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecode.length % 32 == 0, \"pq\");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2**16, \"pp\"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, \"ps\"); // bytecode length in words must be odd\n        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validates the format of the given bytecode hash.\n    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.\n    /// @dev The function reverts on invalid bytecode hash formam.\n    /// @param _bytecodeHash The hash of the bytecode to validate.\n    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), \"zf\"); // Incorrectly formatted bytecodeHash\n\n        require(_bytecodeLen(_bytecodeHash) % 2 == 1, \"uy\"); // Code length in words must be odd\n    }\n\n    /// @notice Returns the length of the bytecode associated with the given hash.\n    /// @param _bytecodeHash The hash of the bytecode.\n    /// @return codeLengthInWords The length of the bytecode in words.\n    function _bytecodeLen(bytes32 _bytecodeHash) private pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the sender.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n}"
    }
  ]
}