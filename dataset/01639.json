{
  "Title": "H-4: A user can get more dTokens than they should get via `D3VaultFunding.userDeposit()`, due to accounting issues in `D3VaultLiquidation.liquidate()`",
  "Content": "# Issue H-4: A user can get more dTokens than they should get via `D3VaultFunding.userDeposit()`, due to accounting issues in `D3VaultLiquidation.liquidate()` \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/211 \n\n## Found by \n0xkaden, dirk\\_y, lemonmon, seeques\n## Summary\n\nThe vault token balance (`assetInfo[debt].balance`) is not updated during liquidation (`D3VaultLiquidation.liquidate()`).\n\nThus, a user who calls `D3VaultFunding.userDeposit()` can get more dTokens than they should get.\n\n## Vulnerability Detail\n\nWhen `D3VaultLiquidation.liquidate()` is called, the debt is transferred to the vault:\n\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol#L55\n\nBut `assetInfo[debt].balance` is not updated, even though the debt tokens were received.\n\nThis leads to the issue that if a user deposits this debt token right after the liquidation, they will receive more dTokens in return than they should, because `D3VaultFunding.userDeposit()` is using the wrongly tracked value of `assetInfo[debt].balance`:\n\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol#L32-L34\n\nAs a result, the protocol will mint more dTokens for the user than they should receive:\n\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol#L39-L41\n\n## Impact\n\nA user can call `D3VaultFunding.userDeposit()` right after a token got liquidated by `D3VaultLiquidation.liquidate()`, resulting in that the user will receive more dToken than they should receive, due to accounting issues in `D3VaultLiquidation.liquidate()`.\n\nAll LP holders will suffer from inflated dTokens.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol#L55\n\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol#L32-L34\n\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol#L39-L41\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAfter `D3VaultLiquidation.liquidate()` is transferring the debt tokens to the vault, update the `assetInfo[debt].balance` of the vault.\n\nIf the repaid debt in `D3VaultLiquidation.liquidate()` was meant to be sent to the pool, like in the function `D3VaultLiquidation.liquidateByDODO()`, the `ID3MM(pool).updateReserveByVault(debt)` should be called at the end of `D3VaultLiquidation.liquidate()`. Otherwise a very similar problem can occur since the `state.balances[debtToken]` is not being updated. `state.balances[debtToken]` is used in a similar way in the D3Trading.sol contract to determine the actual balance received.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"./D3VaultFunding.sol\";\n\ncontract D3VaultLiquidation is D3VaultFunding {\n    using SafeERC20 for IERC20;\n    using DecimalMath for uint256;\n\n    function isPositiveNetWorthAsset(address pool, address token) internal view returns (bool) {\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n        return balance >= borrows;\n    }\n\n    function getPositiveNetWorthAsset(address pool, address token) internal view returns (uint256) {\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n        if (balance > borrows) {\n            return balance - borrows;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice public liquidate function, repay pool negative worth token and get collateral tokens with discount\n    /// @param pool pool address, must be in belowMM\n    /// @param collateral pool collateral, any positive worth token pool has\n    /// @param collateralAmount collateral amount liquidator claim\n    /// @param debt pool debt, any negative worth token pool has\n    /// @param debtToCover debt amount liquidator repay\n    function liquidate(\n        address pool,\n        address collateral,\n        uint256 collateralAmount,\n        address debt,\n        uint256 debtToCover\n    ) external nonReentrant {\n        accrueInterests();\n\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\n        require(!checkBadDebtAfterAccrue(pool), Errors.HAS_BAD_DEBT);\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\n        require(isPositiveNetWorthAsset(pool, collateral), Errors.INVALID_COLLATERAL_TOKEN);\n        require(!isPositiveNetWorthAsset(pool, debt), Errors.INVALID_DEBT_TOKEN);\n        require(getPositiveNetWorthAsset(pool, collateral) >= collateralAmount, Errors.COLLATERAL_AMOUNT_EXCEED);\n        \n        uint256 collateralTokenPrice = ID3Oracle(_ORACLE_).getPrice(collateral);\n        uint256 debtTokenPrice = ID3Oracle(_ORACLE_).getPrice(debt);\n        uint256 collateralAmountMax = debtToCover.mul(debtTokenPrice).div(collateralTokenPrice.mul(DISCOUNT));\n        require(collateralAmount <= collateralAmountMax, Errors.COLLATERAL_AMOUNT_EXCEED);\n\n        AssetInfo storage info = assetInfo[debt];\n        BorrowRecord storage record = info.borrowRecord[pool];\n        uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n        require(debtToCover <= borrows, Errors.DEBT_TO_COVER_EXCEED);\n        IERC20(debt).transferFrom(msg.sender, address(this), debtToCover);\n\n        record.amount = borrows - debtToCover;\n        record.interestIndex = info.borrowIndex;\n        IERC20(collateral).transferFrom(pool, msg.sender, collateralAmount);\n        ID3MM(pool).updateReserveByVault(collateral);\n    }\n\n    // ---------- Liquidate by DODO team ----------\n    /// @notice if occuring bad debt, dodo team will start liquidation to balance debt\n    function startLiquidation(address pool) external onlyLiquidator nonReentrant {\n        accrueInterests();\n\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\n        ID3MM(pool).startLiquidation();\n\n        uint256 totalAssetValue = getTotalAssetsValue(pool);\n        uint256 totalDebtValue = _getTotalDebtValue(pool);\n        require(totalAssetValue < totalDebtValue, Errors.NO_BAD_DEBT);\n\n        uint256 ratio = totalAssetValue.div(totalDebtValue);\n\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            BorrowRecord storage record = info.borrowRecord[pool];\n            uint256 debt = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex).mul(ratio);\n            liquidationTarget[pool][token] = debt;\n        }\n    }\n\n    function liquidateByDODO(\n        address pool,\n        LiquidationOrder calldata order,\n        bytes calldata routeData,\n        address router\n    ) external onlyLiquidator nonReentrant {\n        uint256 toTokenReserve = IERC20(order.toToken).balanceOf(address(this));\n        uint256 fromTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.fromToken), order.fromAmount);\n\n        // swap using Route\n        {\n            IERC20(order.fromToken).transferFrom(pool, router, order.fromAmount);\n            (bool success, bytes memory data) = router.call(routeData);\n            if (!success) {\n                assembly {\n                    revert(add(data, 32), mload(data))\n                }\n            }\n        }\n\n        // the transferred-in toToken USD value should not be less than 95% of the transferred-out fromToken\n        uint256 receivedToToken = IERC20(order.toToken).balanceOf(address(this)) - toTokenReserve;\n        uint256 toTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.toToken), receivedToToken);\n\n        require(toTokenValue.div(fromTokenValue) >= DISCOUNT, Errors.EXCEED_DISCOUNT);\n        IERC20(order.toToken).safeTransfer(pool, receivedToToken);\n        ID3MM(pool).updateReserveByVault(order.fromToken);\n        ID3MM(pool).updateReserveByVault(order.toToken);\n    }\n\n    function finishLiquidation(address pool) external onlyLiquidator nonReentrant {\n        require(ID3MM(pool).isInLiquidation(), Errors.NOT_IN_LIQUIDATION);\n        accrueInterests();\n\n        bool hasPositiveBalance;\n        bool hasNegativeBalance;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            uint256 balance = IERC20(token).balanceOf(pool);\n            uint256 debt = liquidationTarget[pool][token];\n            int256 difference = int256(balance) - int256(debt);\n            if (difference > 0) {\n                require(!hasNegativeBalance, Errors.LIQUIDATION_NOT_DONE);\n                hasPositiveBalance = true;\n            } else if (difference < 0) {\n                require(!hasPositiveBalance, Errors.LIQUIDATION_NOT_DONE);\n                hasNegativeBalance = true;\n                debt = balance; // if balance is less than target amount, just repay with balance\n            }\n\n            BorrowRecord storage record = info.borrowRecord[pool];\n            uint256 borrows = record.amount;\n            if (borrows == 0) continue;\n\n            // note: During liquidation process, the pool's debt will slightly increase due to the generated interests. \n            // The liquidation process will not repay the interests. Thus all dToken holders will share the loss equally.\n            uint256 realDebt = borrows.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n            IERC20(token).transferFrom(pool, address(this), debt);\n\n            info.totalBorrows = info.totalBorrows - realDebt;\n            record.amount = 0;\n        }\n\n        ID3MM(pool).finishLiquidation();\n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {ICloneFactory} from \"../lib/CloneFactory.sol\";\nimport \"./D3VaultStorage.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"../intf/ID3UserQuota.sol\";\nimport \"../intf/ID3PoolQuota.sol\";\nimport \"../intf/ID3MM.sol\";\nimport \"../intf/IDToken.sol\";\nimport \"../intf/ID3RateManager.sol\";\n\n/// @title D3VaultFunding\n/// @notice This contract defines the fund management of D3Vault.\n/// @notice Users (LP) deposit funds into vault to earn interests; D3Pools borrows funds from vault to make market.\n/// @notice Part of the borrow interests will become the reserve fund.\n/// @notice The borrow interest rate is dynamicly changing with fund utilization ratio, and is caculated by D3RateManager.\n/// @notice The fund utilization ratio is defined as U = borrows / (cash + borrows - reserves)\n/// @notice Users who deposit funds into vault will receive certain amounts of corresponding dToken. The amount is calculated by the exchange rate.\n/// @notice The exchange rate between dToken and underlying token is defined as exchangeRate = (cash + totalBorrows -reserves) / dTokenSupply\n/// @notice As time passes, totalBorrows will increase, so does the dToken exchangeRate. That's how users earn interests with dToken.\ncontract D3VaultFunding is D3VaultStorage {\n    using SafeERC20 for IERC20;\n    using DecimalMath for uint256;\n\n    // ---------- LP user Fund ----------\n\n    /// @notice user should transfer token to vault before call this function\n    function userDeposit(address user, address token) external nonReentrant allowedToken(token) {\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        uint256 realBalance = IERC20(token).balanceOf(address(this));\n        uint256 amount = realBalance  - info.balance;\n        require(ID3UserQuota(_USER_QUOTA_).checkQuota(user, token, amount), Errors.EXCEED_QUOTA);\n        uint256 exchangeRate = _getExchangeRate(token);\n        uint256 totalDToken = IDToken(info.dToken).totalSupply();\n        require(totalDToken.mul(exchangeRate) + amount <= info.maxDepositAmount, Errors.EXCEED_MAX_DEPOSIT_AMOUNT);\n        uint256 dTokenAmount = amount.div(exchangeRate);\n\n        IDToken(info.dToken).mint(user, dTokenAmount);\n        info.balance = realBalance;\n\n        emit UserDeposit(user, token, amount);\n    }\n\n    /// @param to who receive tokens\n    /// @param user who pay dTokens\n    /// @param token original token address\n    /// @param dTokenAmount dtoken the token record amount\n    function userWithdraw(address to, address user, address token, uint256 dTokenAmount) external nonReentrant allowedToken(token) returns(uint256 amount) {\n        accrueInterest(token);\n        AssetInfo storage info = assetInfo[token];\n        require(dTokenAmount <= IDToken(info.dToken).balanceOf(msg.sender), Errors.DTOKEN_BALANCE_NOT_ENOUGH);\n\n        amount = dTokenAmount.mul(_getExchangeRate(token));\n        IDToken(info.dToken).burn(msg.sender, dTokenAmount);\n        IERC20(token).safeTransfer(to, amount);\n        info.balance = info.balance - amount;\n\n        // used for calculate user withdraw amount\n        // this function could be called from d3Proxy, so we need \"user\" param\n        // In the meantime, some users may hope to use this function directly,\n        // to prevent these users fill \"user\" param with wrong addresses,\n        // we use \"msg.sender\" param to check.\n        emit UserWithdraw(msg.sender, user, token, amount);\n    }\n\n    // ---------- Pool Fund ----------\n    function poolBorrow(address token, uint256 amount) external nonReentrant allowedToken(token) onlyPool {\n        uint256 quota = ID3PoolQuota(_POOL_QUOTA_).getPoolQuota(msg.sender, token);\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[msg.sender];\n        uint256 oldInterestIndex = record.interestIndex;\n        uint256 currentInterestIndex = info.borrowIndex;\n        if (oldInterestIndex == 0) oldInterestIndex = 1e18;\n        uint256 usedQuota = record.amount.div(oldInterestIndex).mul(currentInterestIndex);\n        require(amount + usedQuota <= quota, Errors.EXCEED_QUOTA);\n        require(amount <= info.balance, Errors.AMOUNT_EXCEED_VAULT_BALANCE);\n\n        uint256 interests = usedQuota - record.amount;\n\n        record.amount = usedQuota + amount;\n        record.interestIndex = currentInterestIndex;\n        info.totalBorrows = info.totalBorrows + amount;\n        info.balance = info.balance - amount; \n        IERC20(token).safeTransfer(msg.sender, amount);\n\n        emit PoolBorrow(msg.sender, token, amount, interests);\n    }\n\n    function poolRepay(address token, uint256 amount) external nonReentrant allowedToken(token) onlyPool {\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[msg.sender];\n        uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n        require(amount <= borrows, Errors.AMOUNT_EXCEED);\n\n        uint256 interests = borrows - record.amount;\n\n        record.amount = borrows - amount;\n        record.interestIndex = info.borrowIndex;\n        info.totalBorrows = info.totalBorrows - amount;\n        info.balance = info.balance + amount;\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n        emit PoolRepay(msg.sender, token, amount, interests);\n    }\n\n    function poolRepayAll(address token) external nonReentrant allowedToken(token) onlyPool {\n        _poolRepayAll(msg.sender, token);\n    }\n\n    function _poolRepayAll(address pool, address token) internal {\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[pool];\n        uint256 amount = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n\n        uint256 interests = amount;\n\n        record.amount = 0;\n        record.interestIndex = info.borrowIndex;\n        info.totalBorrows = info.totalBorrows - amount;\n        info.balance = info.balance - amount;\n        IERC20(token).safeTransferFrom(pool, address(this), amount);\n\n        emit PoolRepay(pool, token, amount, interests);\n    }\n\n    // ---------- Interest ----------\n\n    /// @notice Accrue interest for a token\n    /// @notice Step1: get time past\n    /// @notice Step2: get borrow rate\n    /// @notice Step3: calculate compound interest rate during the past time\n    /// @notice Step4: calculate increased borrows, reserves\n    /// @notice Step5: update borrows, reserves, accrual time, borrowIndex\n    /// @notice borrowIndex is the accrual interest rate\n    function _accrueInterestForRead(address token) internal view returns(uint256 totalBorrowsNew, uint256 totalReservesNew, uint256 borrowIndexNew, uint256 accrualTime) {\n        AssetInfo storage info = assetInfo[token];\n\n        uint256 currentTime = block.timestamp;\n        uint256 deltaTime = currentTime - info.accrualTime;\n        if (deltaTime == 0) return(info.totalBorrows, info.totalReserves, info.borrowIndex, currentTime);\n\n        uint256 borrowsPrior = info.totalBorrows;\n        uint256 reservesPrior = info.totalReserves;\n        uint256 borrowIndexPrior = info.borrowIndex;\n\n        uint256 borrowRate = ID3RateManager(_RATE_MANAGER_).getBorrowRate(token, getUtilizationRatio(token));\n        uint256 borrowRatePerSecond = borrowRate / SECONDS_PER_YEAR;\n        uint256 compoundInterestRate = getCompoundInterestRate(borrowRatePerSecond, deltaTime);\n        totalBorrowsNew = borrowsPrior.mul(compoundInterestRate);\n        totalReservesNew = reservesPrior + (totalBorrowsNew - borrowsPrior).mul(info.reserveFactor);\n        borrowIndexNew = borrowIndexPrior.mul(compoundInterestRate);\n\n        accrualTime = currentTime;\n    }\n\n    /// @notice Accrue interest for a token, change storage\n    function accrueInterest(address token) public {\n        (assetInfo[token].totalBorrows, assetInfo[token].totalReserves, assetInfo[token].borrowIndex, assetInfo[token].accrualTime) =\n        _accrueInterestForRead(token);\n    }\n\n    function accrueInterests() public {\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            accrueInterest(token);\n        }\n    }\n\n    /// @dev r: interest rate per second (decimals 18)\n    /// @dev t: total time in seconds\n    /// @dev (1+r)^t = 1 + rt + t*(t-1)*r^2/2! + t*(t-1)*(t-2)*r^3/3! + ... + t*(t-1)...*(t-n+1)*r^n/n!\n    function getCompoundInterestRate(uint256 r, uint256 t) public pure returns (uint256) {\n        if (t < 1) {\n            return 1e18;\n        } else if (t < 2) {\n            return 1e18 + r * t;\n        } else {\n            return 1e18 + r * t + r.powFloor(2) * t * (t - 1) / 2;\n        }\n    }\n\n    // ----------- View ----------\n\n    function getPoolLeftQuota(address pool, address token) public view returns(uint256 leftQuota) {\n        uint256 quota = ID3PoolQuota(_POOL_QUOTA_).getPoolQuota(pool, token);\n        uint256 oldInterestIndex = assetInfo[token].borrowRecord[pool].interestIndex;\n        ( , ,uint256 currentInterestIndex, ) = _accrueInterestForRead(token);\n        if (oldInterestIndex == 0) oldInterestIndex = 1e18;\n        uint256 usedQuota = assetInfo[token].borrowRecord[pool].amount.div(oldInterestIndex).mul(currentInterestIndex);\n        leftQuota = quota > usedQuota ? quota - usedQuota : 0;\n    }\n\n    /// @notice U = borrows / (cash + borrows - reserves)\n    function getUtilizationRatio(address token) public view returns (uint256) {\n        uint256 borrows = getTotalBorrows(token);\n        uint256 cash = getCash(token);\n        uint256 reserves = getReservesInVault(token);\n        if (borrows == 0) return 0;\n        return borrows.div(cash + borrows - reserves);\n    }\n\n    function getBorrowRate(address token) public view returns (uint256 rate) {\n        rate = ID3RateManager(_RATE_MANAGER_).getBorrowRate(token, getUtilizationRatio(token));\n    }\n\n    function getCash(address token) public view returns (uint256) {\n        return assetInfo[token].balance;\n    }\n\n    function getTotalBorrows(address token) public view returns (uint256) {\n        return assetInfo[token].totalBorrows;\n    }\n\n    function getReservesInVault(address token) public view returns (uint256) {\n        AssetInfo storage info = assetInfo[token];\n        return info.totalReserves - info.withdrawnReserves;\n    }\n\n    /// @notice exchangeRate = (cash + totalBorrows -reserves) / dTokenSupply\n    /// @notice Make sure accrueInterests or accrueInterest(token) is called before\n    function _getExchangeRate(address token) internal view returns (uint256) {\n        AssetInfo storage info = assetInfo[token];\n        uint256 cash = getCash(token);\n        uint256 dTokenSupply = IERC20(info.dToken).totalSupply();\n        if (dTokenSupply == 0) { return 1e18; }\n        return (cash + info.totalBorrows - (info.totalReserves - info.withdrawnReserves)).div(dTokenSupply);\n    } \n\n    /// @notice Make sure accrueInterests or accrueInterest(token) is called before\n    function _getBalanceAndBorrows(address pool, address token) internal view returns (uint256, uint256) {\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[pool];\n\n        uint256 balance = ID3MM(pool).getTokenReserve(token);\n        uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n\n        return (balance, borrows);\n    }\n\n    /// @notice Make sure accrueInterests() is called before calling this function\n    function _getTotalDebtValue(address pool) internal view returns (uint256 totalDebt) {\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            BorrowRecord memory record = info.borrowRecord[pool];\n            uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            totalDebt += borrows.mul(price);\n        }\n    }\n\n    function getTotalAssetsValue(address pool) public view returns (uint256 totalValue) {\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            totalValue += DecimalMath.mul(ID3MM(pool).getTokenReserve(token), price);\n        }\n    }\n\n    /// @notice Make sure accrueInterests() is called before\n    /// @notice net = balance - borrowed\n    /// @notice collateral = sum(min(positive net, maxCollateralAmount）* weight * price)\n    /// @notice debt = sum(negative net * weight * price)\n    /// @notice collateralRatio = collateral / debt\n    function _getCollateralRatio(address pool) internal view returns (uint256) {\n        uint256 collateral = 0;\n        uint256 debt = 0;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n\n            (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            if (balance >= borrows) {\n                collateral += min(balance - borrows, info.maxCollateralAmount).mul(info.collateralWeight).mul(price);\n            } else {\n                debt += (borrows - balance).mul(info.debtWeight).mul(price);\n            }\n        }\n        return _ratioDiv(collateral, debt);\n    }\n\n    function checkSafe(address pool) public view returns (bool) {\n        return getCollateralRatio(pool) >  1e18 + IM;\n    }\n\n    function checkBorrowSafe(address pool) public view returns (bool) {\n        return getCollateralRatioBorrow(pool) > IM;\n    }\n\n    function checkCanBeLiquidated(address pool) public view returns (bool) {\n        return getCollateralRatio(pool) < 1e18 + MM;\n    }\n\n    function checkCanBeLiquidatedAfterAccrue(address pool) public view returns (bool) {\n        return _getCollateralRatio(pool) < 1e18 + MM;\n    }\n\n    function checkBadDebt(address pool) public view returns (bool) {\n        return getCollateralRatio(pool) < 1e18;\n    }\n\n    function checkBadDebtAfterAccrue(address pool) public view returns (bool) {\n        return _getCollateralRatio(pool) < 1e18;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n\n    function _ratioDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 && b == 0) {\n            return 1e18;\n        } else if (a == 0 && b != 0) {\n            return 0;\n        } else if (a != 0 && b == 0) {\n            return type(uint256).max;\n        } else {\n            return a.div(b);\n        }\n    }\n\n    // ======================= Read Only =======================\n\n    function getExchangeRate(address token) public view returns(uint256 exchangeRate) {\n        (uint256 totalBorrows, uint256 totalReserves, ,) = _accrueInterestForRead(token);\n        uint256 cash = getCash(token);\n        uint256 dTokenSupply = IERC20(assetInfo[token].dToken).totalSupply();\n        if (dTokenSupply == 0) { return 1e18; }\n        exchangeRate = (cash + totalBorrows - (totalReserves - assetInfo[token].withdrawnReserves)).div(dTokenSupply);\n    }\n\n    function getLatestBorrowIndex(address token) public view returns (uint256 borrowIndex) {\n        AssetInfo storage info = assetInfo[token];\n        uint256 deltaTime = block.timestamp - info.accrualTime;\n        uint256 borrowRate = getBorrowRate(token);\n        uint256 borrowRatePerSecond = borrowRate / SECONDS_PER_YEAR;\n        uint256 compoundInterestRate = getCompoundInterestRate(borrowRatePerSecond, deltaTime);\n        borrowIndex = info.borrowIndex.mul(compoundInterestRate);\n    }\n\n    function getPoolBorrowAmount(address pool, address token) public view returns (uint256 amount) {\n        BorrowRecord storage record = assetInfo[token].borrowRecord[pool];\n        uint256 borrowIndex = getLatestBorrowIndex(token);\n        amount = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(borrowIndex);\n    }\n\n    function getTotalDebtValue(address pool) external view returns (uint256 totalDebt) {\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            uint256 borrowAmount = getPoolBorrowAmount(pool, token);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            totalDebt += borrowAmount.mul(price);\n        }\n    }\n\n    function getBalanceAndBorrows(address pool, address token) public view returns (uint256, uint256) {\n        uint256 balance = ID3MM(pool).getTokenReserve(token);\n        uint256 borrows = getPoolBorrowAmount(pool, token);\n        return (balance, borrows);\n    }\n\n    function getCollateralRatio(address pool) public view returns (uint256) {\n        uint256 collateral = 0;\n        uint256 debt = 0;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n\n            (uint256 balance, uint256 borrows) = getBalanceAndBorrows(pool, token);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            \n            if (balance >= borrows) {\n                collateral += min(balance - borrows, info.maxCollateralAmount).mul(info.collateralWeight).mul(price);\n            } else {\n                debt += (borrows - balance).mul(info.debtWeight).mul(price);\n            }\n        }\n        return _ratioDiv(collateral, debt);\n    }\n    \n    /// @notice collateralRatioBorrow = ∑[min(maxCollateralAmount，balance - borrows）] / ∑borrows\n    function getCollateralRatioBorrow(address pool) public view returns (uint256) {\n        uint256 balanceSumPositive = 0;\n        uint256 balanceSumNegative = 0;\n        uint256 borrowedSum = 0;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n\n            (uint256 balance, uint256 borrows) = getBalanceAndBorrows(pool, token);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n\n            if (balance >= borrows) {\n                balanceSumPositive += min(balance - borrows, assetInfo[token].maxCollateralAmount).mul(price);\n            } else {\n                balanceSumNegative += (borrows - balance).mul(price);\n            }\n\n            borrowedSum += borrows.mul(price);\n        }\n        \n        uint256 balanceSum = balanceSumPositive < balanceSumNegative ? 0 : balanceSumPositive - balanceSumNegative;\n        return _ratioDiv(balanceSum, borrowedSum);\n    }\n\n    function getCumulativeBorrowRate(address pool, address token) external view returns (uint256 cumulativeRate, uint256 currentAmount) {\n        BorrowRecord storage record = assetInfo[token].borrowRecord[pool];\n        uint256 borrowIndex = getLatestBorrowIndex(token);\n        cumulativeRate = borrowIndex.div(record.interestIndex == 0 ? 1e18 : record.interestIndex);\n        currentAmount = record.amount;\n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {ICloneFactory} from \"../lib/CloneFactory.sol\";\nimport \"./D3VaultStorage.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"../intf/ID3UserQuota.sol\";\nimport \"../intf/ID3PoolQuota.sol\";\nimport \"../intf/ID3MM.sol\";\nimport \"../intf/IDToken.sol\";\nimport \"../intf/ID3RateManager.sol\";\n\n/// @title D3VaultFunding\n/// @notice This contract defines the fund management of D3Vault.\n/// @notice Users (LP) deposit funds into vault to earn interests; D3Pools borrows funds from vault to make market.\n/// @notice Part of the borrow interests will become the reserve fund.\n/// @notice The borrow interest rate is dynamicly changing with fund utilization ratio, and is caculated by D3RateManager.\n/// @notice The fund utilization ratio is defined as U = borrows / (cash + borrows - reserves)\n/// @notice Users who deposit funds into vault will receive certain amounts of corresponding dToken. The amount is calculated by the exchange rate.\n/// @notice The exchange rate between dToken and underlying token is defined as exchangeRate = (cash + totalBorrows -reserves) / dTokenSupply\n/// @notice As time passes, totalBorrows will increase, so does the dToken exchangeRate. That's how users earn interests with dToken.\ncontract D3VaultFunding is D3VaultStorage {\n    using SafeERC20 for IERC20;\n    using DecimalMath for uint256;\n\n    // ---------- LP user Fund ----------\n\n    /// @notice user should transfer token to vault before call this function\n    function userDeposit(address user, address token) external nonReentrant allowedToken(token) {\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        uint256 realBalance = IERC20(token).balanceOf(address(this));\n        uint256 amount = realBalance  - info.balance;\n        require(ID3UserQuota(_USER_QUOTA_).checkQuota(user, token, amount), Errors.EXCEED_QUOTA);\n        uint256 exchangeRate = _getExchangeRate(token);\n        uint256 totalDToken = IDToken(info.dToken).totalSupply();\n        require(totalDToken.mul(exchangeRate) + amount <= info.maxDepositAmount, Errors.EXCEED_MAX_DEPOSIT_AMOUNT);\n        uint256 dTokenAmount = amount.div(exchangeRate);\n\n        IDToken(info.dToken).mint(user, dTokenAmount);\n        info.balance = realBalance;\n\n        emit UserDeposit(user, token, amount);\n    }\n\n    /// @param to who receive tokens\n    /// @param user who pay dTokens\n    /// @param token original token address\n    /// @param dTokenAmount dtoken the token record amount\n    function userWithdraw(address to, address user, address token, uint256 dTokenAmount) external nonReentrant allowedToken(token) returns(uint256 amount) {\n        accrueInterest(token);\n        AssetInfo storage info = assetInfo[token];\n        require(dTokenAmount <= IDToken(info.dToken).balanceOf(msg.sender), Errors.DTOKEN_BALANCE_NOT_ENOUGH);\n\n        amount = dTokenAmount.mul(_getExchangeRate(token));\n        IDToken(info.dToken).burn(msg.sender, dTokenAmount);\n        IERC20(token).safeTransfer(to, amount);\n        info.balance = info.balance - amount;\n\n        // used for calculate user withdraw amount\n        // this function could be called from d3Proxy, so we need \"user\" param\n        // In the meantime, some users may hope to use this function directly,\n        // to prevent these users fill \"user\" param with wrong addresses,\n        // we use \"msg.sender\" param to check.\n        emit UserWithdraw(msg.sender, user, token, amount);\n    }\n\n    // ---------- Pool Fund ----------\n    function poolBorrow(address token, uint256 amount) external nonReentrant allowedToken(token) onlyPool {\n        uint256 quota = ID3PoolQuota(_POOL_QUOTA_).getPoolQuota(msg.sender, token);\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[msg.sender];\n        uint256 oldInterestIndex = record.interestIndex;\n        uint256 currentInterestIndex = info.borrowIndex;\n        if (oldInterestIndex == 0) oldInterestIndex = 1e18;\n        uint256 usedQuota = record.amount.div(oldInterestIndex).mul(currentInterestIndex);\n        require(amount + usedQuota <= quota, Errors.EXCEED_QUOTA);\n        require(amount <= info.balance, Errors.AMOUNT_EXCEED_VAULT_BALANCE);\n\n        uint256 interests = usedQuota - record.amount;\n\n        record.amount = usedQuota + amount;\n        record.interestIndex = currentInterestIndex;\n        info.totalBorrows = info.totalBorrows + amount;\n        info.balance = info.balance - amount; \n        IERC20(token).safeTransfer(msg.sender, amount);\n\n        emit PoolBorrow(msg.sender, token, amount, interests);\n    }\n\n    function poolRepay(address token, uint256 amount) external nonReentrant allowedToken(token) onlyPool {\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[msg.sender];\n        uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n        require(amount <= borrows, Errors.AMOUNT_EXCEED);\n\n        uint256 interests = borrows - record.amount;\n\n        record.amount = borrows - amount;\n        record.interestIndex = info.borrowIndex;\n        info.totalBorrows = info.totalBorrows - amount;\n        info.balance = info.balance + amount;\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n        emit PoolRepay(msg.sender, token, amount, interests);\n    }\n\n    function poolRepayAll(address token) external nonReentrant allowedToken(token) onlyPool {\n        _poolRepayAll(msg.sender, token);\n    }\n\n    function _poolRepayAll(address pool, address token) internal {\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[pool];\n        uint256 amount = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n\n        uint256 interests = amount;\n\n        record.amount = 0;\n        record.interestIndex = info.borrowIndex;\n        info.totalBorrows = info.totalBorrows - amount;\n        info.balance = info.balance - amount;\n        IERC20(token).safeTransferFrom(pool, address(this"
    }
  ]
}