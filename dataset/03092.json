{
  "Title": "Inconvenient use of immutable keyword",
  "Content": "For accounts that use the protocol, the protocol provides a built-in system for tracking rewards. `Comet` contracts keep account of all accrued incentives for suppliers and borrowers of the base token, and users can claim them on [`CometRewards`](https://github.com/compound-finance/comet/blob/0f1221967149115f50a09681eea9580879ee7720/contracts/CometRewards.sol) contract. It should be emphasized that all rewards from all the `Comet`s from the same chain are claimed in the same `CometRewards` contract.\n\n\nThe latter has a `governor` variable defined which is the role that can set the reward settings and withdraw rewards from the contract. Since the contract does not have an upgradeability mechanism, it is inconvenient to define this variable as [`immutable`](https://github.com/compound-finance/comet/blob/0f1221967149115f50a09681eea9580879ee7720/contracts/CometRewards.sol#L20). If the `governor` needs to be changed, a new contract must be deployed and the old contract’s state must be migrated to the new one.\n\n\nConsider adding this variable to the contract storage and specifying a setter function so that the `governor` can be changed any time it is needed.\n\n\n**Update**: *Fixed in commits [43b5502](https://github.com/compound-finance/comet/commit/43b5502ab8217f05baea538d0a055717fa056528) and [4d1c1a4](https://github.com/compound-finance/comet/commit/4d1c1a42fc31b4b26129fe79e3d97ef637da9520).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/CometRewards.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"./CometInterface.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @title Compound's CometRewards Contract\n * @notice Hold and claim token rewards\n * @author Compound\n */\ncontract CometRewards {\n    struct RewardConfig {\n        address token;\n        uint64 rescaleFactor;\n        bool shouldUpscale;\n    }\n\n    /// @notice The governor address which controls the contract\n    address public immutable governor;\n\n    /// @notice Reward token address per Comet instance\n    mapping(address => RewardConfig) public rewardConfig;\n\n    /// @notice Rewards claimed per Comet instance and user account\n    mapping(address => mapping(address => uint)) public rewardsClaimed;\n\n    /** Custom errors **/\n\n    error InvalidUInt64(uint);\n    error NotPermitted(address);\n    error NotSupported(address);\n    error TransferOutFailed(address, uint);\n\n    /**\n     * @notice Construct a new rewards pool\n     * @param governor_ The governor who will control the contract\n     */\n    constructor(address governor_) {\n        governor = governor_;\n    }\n\n    /**\n     * @notice Set the reward token for a Comet instance\n     * @param comet The protocol instance\n     * @param token The reward token address\n     */\n    function _setRewardConfig(address comet, address token) external {\n        if (msg.sender != governor) revert NotPermitted(msg.sender);\n\n        uint64 accrualScale = CometInterface(comet).baseAccrualScale();\n        uint8 tokenDecimals = ERC20(token).decimals();\n        uint64 tokenScale = safe64(10 ** tokenDecimals);\n        if (accrualScale > tokenScale) {\n            rewardConfig[comet] = RewardConfig({\n                token: token,\n                rescaleFactor: accrualScale / tokenScale,\n                shouldUpscale: false\n            });\n        } else {\n            rewardConfig[comet] = RewardConfig({\n                token: token,\n                rescaleFactor: tokenScale / accrualScale,\n                shouldUpscale: true\n            });\n        }\n    }\n\n    /**\n     * @notice Withdraw tokens from the contract\n     * @param token The reward token address\n     * @param to Where to send the tokens\n     * @param amount The number of tokens to withdraw\n     */\n    function _withdrawToken(address token, address to, uint amount) external {\n        if (msg.sender != governor) revert NotPermitted(msg.sender);\n\n        doTransferOut(token, to, amount);\n    }\n\n    /**\n     * @notice Claim rewards of token type from a comet instance to owner address\n     * @param comet The protocol instance\n     * @param src The owner to claim for\n     * @param shouldAccrue Whether or not to call accrue first\n     */\n    function claim(address comet, address src, bool shouldAccrue) external {\n        claimInternal(comet, src, src, shouldAccrue);\n    }\n\n    /**\n     * @notice Claim rewards of token type from a comet instance to a target address\n     * @param comet The protocol instance\n     * @param src The owner to claim for\n     * @param to The address to receive the rewards\n     */\n    function claimTo(address comet, address src, address to, bool shouldAccrue) external {\n        if (!CometInterface(comet).hasPermission(src, msg.sender)) revert NotPermitted(msg.sender);\n\n        claimInternal(comet, src, to, shouldAccrue);\n    }\n\n    /**\n     * @dev Claim to, assuming permitted\n     */\n    function claimInternal(address comet, address src, address to, bool shouldAccrue) internal {\n        RewardConfig memory config = rewardConfig[comet];\n        if (config.token == address(0)) revert NotSupported(comet);\n\n        if (shouldAccrue) {\n            CometInterface(comet).accrueAccount(src);\n        }\n\n        uint claimed = rewardsClaimed[comet][src];\n        uint accrued = CometInterface(comet).baseTrackingAccrued(src);\n        if (config.shouldUpscale) {\n            accrued *= config.rescaleFactor;\n        } else {\n            accrued /= config.rescaleFactor;\n        }\n        if (accrued > claimed) {\n            uint owed = accrued - claimed;\n            rewardsClaimed[comet][src] = accrued;\n            doTransferOut(config.token, to, owed);\n        }\n    }\n\n    /**\n     * @dev Safe ERC20 transfer out\n     */\n    function doTransferOut(address token, address to, uint amount) internal {\n        bool success = ERC20(token).transfer(to, amount);\n        if (!success) revert TransferOutFailed(to, amount);\n    }\n\n    /**\n     * @dev Safe cast to uint64\n     */\n    function safe64(uint n) internal pure returns (uint64) {\n        if (n > type(uint64).max) revert InvalidUInt64(n);\n        return uint64(n);\n    }\n}"
    }
  ]
}