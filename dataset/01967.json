{
  "Title": "H-8: UserData for balancer pool exits is malformed and will permanently trap users",
  "Content": "# Issue H-8: UserData for balancer pool exits is malformed and will permanently trap users \n\nSource: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/129 \n\n## Found by \n0x52, cuthalion0x\n## Summary\n\nUserData for balancer pool exits is malformed and will result in all withdrawal attempts failing, trapping the user permanently. \n\n## Vulnerability Detail\n\n[AuraSpell.sol#L184-L189](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L184-L189)\n\n    wAuraPools.getVault(lpToken).exitPool(\n        IBalancerPool(lpToken).getPoolId(),\n        address(this),\n        address(this),\n        IBalancerVault.ExitPoolRequest(tokens, minAmountsOut, \"\", false)\n    );\n\nWe see above that UserData is encoded as \"\". This is problematic as it doesn't contain the proper data for exiting the pool, causing all exit request to fail and trap the user permanently.\n\nhttps://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F9#L50\n\n    function exactBptInForTokenOut(bytes memory self) internal pure returns (uint256 bptAmountIn, uint256 tokenIndex) {\n        (, bptAmountIn, tokenIndex) = abi.decode(self, (WeightedPool.ExitKind, uint256, uint256));\n    }\n\nUserData is decoded into the data shown above when using ExitKind = 0. Since the exit uses \"\" as the user data this will be decoded as 0 a.k.a [EXACT_BPT_IN_FOR_ONE_TOKEN_OUT](https://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L50). This is problematic because the token index and bptAmountIn should also be encoded in user data for this kind of exit. Since it isn't the exit call will always revert and the user will be permanently trapped.\n\n## Impact\n\nUsers will be permanently trapped, unable to withdraw\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L149-L224\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEncode the necessary exit data in userData\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/69",
  "Code": [
    {
      "filename": "blueberry-core/contracts/spell/AuraSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Router02.sol\";\n\n/**\n * @title AuraSpell\n * @author BlueberryProtocol\n * @notice AuraSpell is the factory contract that\n * defines how Blueberry Protocol interacts with Aura pools\n */\ncontract AuraSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev Address to Wrapped Aura Pools\n    IWAuraPools public wAuraPools;\n    /// @dev address of CurveOracle\n    ICurveOracle public crvOracle;\n    /// @dev address of AURA token\n    address public AURA;\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wAuraPools_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wAuraPools_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        wAuraPools = IWAuraPools(wAuraPools_);\n        AURA = address(wAuraPools.AURA());\n        IWAuraPools(wAuraPools_).setApprovalForAll(address(bank_), true);\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param bpt Address of Balaner Pool Token\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(address bpt, uint256 maxPosSize) external onlyOwner {\n        _addStrategy(bpt, maxPosSize);\n    }\n\n    /**\n     * @notice Add liquidity to Balancer pool, with staking to Aura\n     */\n    function openPositionFarm(\n        OpenPosParam calldata param\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        (address lpToken, ) = wAuraPools.getPool(\n            strategy.vault,\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        // 3. Add liquidity on Balancer, get BPT\n        {\n            IBalancerVault vault = wAuraPools.getVault(lpToken);\n            _ensureApprove(param.borrowToken, address(vault), borrowBalance);\n\n            (address[] memory tokens, uint256[] memory balances, ) = wAuraPools\n                .getPoolTokens(lpToken);\n            uint[] memory maxAmountsIn = new uint[](2);\n            maxAmountsIn[0] = IERC20(tokens[0]).balanceOf(address(this));\n            maxAmountsIn[1] = IERC20(tokens[1]).balanceOf(address(this));\n\n            uint totalLPSupply = IBalancerPool(lpToken).totalSupply();\n            // compute in reverse order of how Balancer's `joinPool` computes tokenAmountIn\n            uint poolAmountFromA = (maxAmountsIn[0] * totalLPSupply) /\n                balances[0];\n            uint poolAmountFromB = (maxAmountsIn[1] * totalLPSupply) /\n                balances[1];\n            uint poolAmountOut = poolAmountFromA > poolAmountFromB\n                ? poolAmountFromB\n                : poolAmountFromA;\n\n            bytes32 poolId = bytes32(param.farmingPoolId);\n            if (poolAmountOut > 0) {\n                vault.joinPool(\n                    poolId,\n                    address(this),\n                    address(this),\n                    IBalancerVault.JoinPoolRequest(\n                        tokens,\n                        maxAmountsIn,\n                        \"\",\n                        false\n                    )\n                );\n            }\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 5. Validate Max Pos Size\n        _validateMaxPosSize(param.strategyId);\n\n        // 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wAuraPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(AURA);\n        }\n\n        // 7. Deposit on Aura Pool, Put wrapped collateral tokens on Blueberry Bank\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wAuraPools), lpAmount);\n        uint256 id = wAuraPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wAuraPools), id, lpAmount);\n    }\n\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        IUniswapV2Router02 swapRouter,\n        address[][] calldata swapPath\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address lpToken = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collToken != address(wAuraPools))\n            revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n        if (wAuraPools.getUnderlyingToken(pos.collId) != lpToken)\n            revert Errors.INCORRECT_UNDERLYING(lpToken);\n\n        // 1. Take out collateral - Burn wrapped tokens, receive BPT tokens and harvest AURA\n        bank.takeCollateral(param.amountPosRemove);\n        (address[] memory rewardTokens, ) = wAuraPools.burn(\n            pos.collId,\n            param.amountPosRemove\n        );\n\n        {\n            // 2. Calculate actual amount to remove\n            uint256 amountPosRemove = param.amountPosRemove;\n            if (amountPosRemove == type(uint256).max) {\n                amountPosRemove = IERC20Upgradeable(lpToken).balanceOf(\n                    address(this)\n                );\n            }\n\n            // 3. Remove liquidity\n            (address[] memory tokens, , ) = wAuraPools.getPoolTokens(lpToken);\n            uint[] memory minAmountsOut = new uint[](2);\n            wAuraPools.getVault(lpToken).exitPool(\n                IBalancerPool(lpToken).getPoolId(),\n                address(this),\n                address(this),\n                IBalancerVault.ExitPoolRequest(tokens, minAmountsOut, \"\", false)\n            );\n        }\n\n        // 4. Swap rewards tokens to debt token\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 rewards = _doCutRewardsFee(rewardTokens[i]);\n            _ensureApprove(rewardTokens[i], address(swapRouter), rewards);\n            swapRouter.swapExactTokensForTokens(\n                rewards,\n                0,\n                swapPath[i],\n                address(this),\n                type(uint256).max\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 6. Repay\n        {\n            // Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 7. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n        _doRefund(AURA);\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/AuraSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Router02.sol\";\n\n/**\n * @title AuraSpell\n * @author BlueberryProtocol\n * @notice AuraSpell is the factory contract that\n * defines how Blueberry Protocol interacts with Aura pools\n */\ncontract AuraSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev Address to Wrapped Aura Pools\n    IWAuraPools public wAuraPools;\n    /// @dev address of CurveOracle\n    ICurveOracle public crvOracle;\n    /// @dev address of AURA token\n    address public AURA;\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wAuraPools_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wAuraPools_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        wAuraPools = IWAuraPools(wAuraPools_);\n        AURA = address(wAuraPools.AURA());\n        IWAuraPools(wAuraPools_).setApprovalForAll(address(bank_), true);\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param bpt Address of Balaner Pool Token\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(address bpt, uint256 maxPosSize) external onlyOwner {\n        _addStrategy(bpt, maxPosSize);\n    }\n\n    /**\n     * @notice Add liquidity to Balancer pool, with staking to Aura\n     */\n    function openPositionFarm(\n        OpenPosParam calldata param\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        (address lpToken, ) = wAuraPools.getPool(\n            strategy.vault,\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        // 3. Add liquidity on Balancer, get BPT\n        {\n            IBalancerVault vault = wAuraPools.getVault(lpToken);\n            _ensureApprove(param.borrowToken, address(vault), borrowBalance);\n\n            (address[] memory tokens, uint256[] memory balances, ) = wAuraPools\n                .getPoolTokens(lpToken);\n            uint[] memory maxAmountsIn = new uint[](2);\n            maxAmountsIn[0] = IERC20(tokens[0]).balanceOf(address(this));\n            maxAmountsIn[1] = IERC20(tokens[1]).balanceOf(address(this));\n\n            uint totalLPSupply = IBalancerPool(lpToken).totalSupply();\n            // compute in reverse order of how Balancer's `joinPool` computes tokenAmountIn\n            uint poolAmountFromA = (maxAmountsIn[0] * totalLPSupply) /\n                balances[0];\n            uint poolAmountFromB = (maxAmountsIn[1] * totalLPSupply) /\n                balances[1];\n            uint poolAmountOut = poolAmountFromA > poolAmountFromB\n                ? poolAmountFromB\n                : poolAmountFromA;\n\n            bytes32 poolId = bytes32(param.farmingPoolId);\n            if (poolAmountOut > 0) {\n                vault.joinPool(\n                    poolId,\n                    address(this),\n                    address(this),\n                    IBalancerVault.JoinPoolRequest(\n                        tokens,\n                        maxAmountsIn,\n                        \"\",\n                        false\n                    )\n                );\n            }\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 5. Validate Max Pos Size\n        _validateMaxPosSize(param.strategyId);\n\n        // 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wAuraPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(AURA);\n        }\n\n        // 7. Deposit on Aura Pool, Put wrapped collateral tokens on Blueberry Bank\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wAuraPools), lpAmount);\n        uint256 id = wAuraPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wAuraPools), id, lpAmount);\n    }\n\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        IUniswapV2Router02 swapRouter,\n        address[][] calldata swapPath\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address lpToken = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collToken != address(wAuraPools))\n            revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n        if (wAuraPools.getUnderlyingToken(pos.collId) != lpToken)\n            revert Errors.INCORRECT_UNDERLYING(lpToken);\n\n        // 1. Take out collateral - Burn wrapped tokens, receive BPT tokens and harvest AURA\n        bank.takeCollateral(param.amountPosRemove);\n        (address[] memory rewardTokens, ) = wAuraPools.burn(\n            pos.collId,\n            param.amountPosRemove\n        );\n\n        {\n            // 2. Calculate actual amount to remove\n            uint256 amountPosRemove = param.amountPosRemove;\n            if (amountPosRemove == type(uint256).max) {\n                amountPosRemove = IERC20Upgradeable(lpToken).balanceOf(\n                    address(this)\n                );\n            }\n\n            // 3. Remove liquidity\n            (address[] memory tokens, , ) = wAuraPools.getPoolTokens(lpToken);\n            uint[] memory minAmountsOut = new uint[](2);\n            wAuraPools.getVault(lpToken).exitPool(\n                IBalancerPool(lpToken).getPoolId(),\n                address(this),\n                address(this),\n                IBalancerVault.ExitPoolRequest(tokens, minAmountsOut, \"\", false)\n            );\n        }\n\n        // 4. Swap rewards tokens to debt token\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 rewards = _doCutRewardsFee(rewardTokens[i]);\n            _ensureApprove(rewardTokens[i], address(swapRouter), rewards);\n            swapRouter.swapExactTokensForTokens(\n                rewards,\n                0,\n                swapPath[i],\n                address(this),\n                type(uint256).max\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 6. Repay\n        {\n            // Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 7. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n        _doRefund(AURA);\n    }\n}"
    }
  ]
}