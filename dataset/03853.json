{
  "Title": "Potential div by zero error",
  "Content": "##### Description\nAt the line https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/Market.sol#L189 contract can catch div by zero if `cumulativePrice` is zero.\n\n##### Recommendation\nWe recommend add non-zero check\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Market.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./utils/OwnablePausable.sol\";\nimport \"./uniswap/IUniswapV2Router02.sol\";\nimport \"./uniswap/IUniswapAnchoredView.sol\";\n\ncontract Market is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    uint256 public constant PRICE_DECIMALS = 6;\n\n    uint256 public constant REWARD_DECIMALS = 12;\n\n    /// @notice Address of cumulative token.\n    ERC20 public cumulative;\n\n    /// @notice Address of product token contract.\n    ERC20 public productToken;\n\n    /// @notice Address of reward token contract.\n    ERC20 public rewardToken;\n\n    /// @dev Address of UniswapV2Router.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @dev Address of IUniswapAnchoredView.\n    IUniswapAnchoredView public priceOracle;\n\n    /// @dev Allowed tokens symbols list.\n    mapping(address => string) internal allowedTokens;\n\n    /// @notice An event thats emitted when an price oracle contract address changed.\n    event PriceOracleChanged(address newPriceOracle);\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an cumulative token changed.\n    event CumulativeChanged(address newToken);\n\n    /// @notice An event thats emitted when an token allowed.\n    event TokenAllowed(address token, string symbol);\n\n    /// @notice An event thats emitted when an token denied.\n    event TokenDenied(address token);\n\n    /// @notice An event thats emitted when an account buyed token.\n    event Buy(address customer, address token, uint256 amount, uint256 buy, uint256 reward);\n\n    /// @notice An event thats emitted when an cumulative token withdrawal.\n    event Withdrawal(address recipient, address token, uint256 amount);\n\n    /**\n     * @param _cumulative Address of cumulative token.\n     * @param _productToken Address of product token.\n     * @param _rewardToken Address of reward token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     * @param _priceOracle Address of Price oracle contract.\n     */\n    constructor(\n        address _cumulative,\n        address _productToken,\n        address _rewardToken,\n        address _uniswapRouter,\n        address _priceOracle\n    ) public {\n        cumulative = ERC20(_cumulative);\n        productToken = ERC20(_productToken);\n        rewardToken = ERC20(_rewardToken);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        priceOracle = IUniswapAnchoredView(_priceOracle);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed price oracle contract address.\n     * @param _priceOracle Address new price oracle contract.\n     */\n    function changePriceOracle(address _priceOracle) external onlyOwner {\n        priceOracle = IUniswapAnchoredView(_priceOracle);\n        emit PriceOracleChanged(_priceOracle);\n    }\n\n    /**\n     * @notice Changed cumulative token address.\n     * @param newToken Address new cumulative token.\n     * @param recipient Address of recipient for withdraw current cumulative balance.\n     */\n    function changeCumulativeToken(address newToken, address recipient) external onlyOwner {\n        withdraw(recipient);\n        cumulative = ERC20(newToken);\n        emit CumulativeChanged(newToken);\n    }\n\n    /**\n     * @notice Add token to tokens white list.\n     * @param token Allowable token.\n     * @param symbol Symbol target token of price oracle contract.\n     */\n    function allowToken(address token, string calldata symbol) external onlyOwner {\n        allowedTokens[token] = symbol;\n        emit TokenAllowed(token, symbol);\n    }\n\n    /**\n     * @notice Remove token from tokens white list.\n     * @param token Denied token.\n     */\n    function denyToken(address token) external onlyOwner {\n        allowedTokens[token] = \"\";\n        emit TokenDenied(token);\n    }\n\n    /**\n     * @param token Target token.\n     * @return Is target token allowed.\n     */\n    function isAllowedToken(address token) public view returns (bool) {\n        return bytes(allowedTokens[token]).length != 0;\n    }\n\n    /**\n     * @dev Transfer token to recipient.\n     * @param from Address of transfered token contract.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transfer(\n        ERC20 from,\n        address recipient,\n        uint256 amount\n    ) internal {\n        require(recipient != address(0), \"Market::transfer: cannot transfer to the zero address\");\n\n        uint256 currentBalance = from.balanceOf(address(this));\n        require(amount <= currentBalance, \"Market::transfer: not enough tokens\");\n\n        from.safeTransfer(recipient, amount);\n    }\n\n    /**\n     * @notice Transfer product token to recipient.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transferProductToken(address recipient, uint256 amount) external onlyOwner {\n        transfer(productToken, recipient, amount);\n    }\n\n    /**\n     * @notice Transfer reward token to recipient.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transferRewardToken(address recipient, uint256 amount) external onlyOwner {\n        transfer(rewardToken, recipient, amount);\n    }\n\n    /**\n     * @notice Get token price.\n     * @param currency Currency token.\n     * @param payment Amount of payment.\n     * @return product Amount of product token.\n     * @return reward Amount of reward token.\n     */\n    function price(address currency, uint256 payment) public view returns (uint256 product, uint256 reward) {\n        require(isAllowedToken(currency), \"Market::price: currency not allowed\");\n\n        uint256 tokenDecimals = ERC20(currency).decimals();\n        uint256 productDecimals = productToken.decimals();\n        uint256 tokenPrice = priceOracle.price(allowedTokens[currency]);\n        uint256 cumulativePrice = priceOracle.price(cumulative.symbol());\n\n        product = payment.mul(10**productDecimals.sub(tokenDecimals));\n        if (address(productToken) != currency) {\n            product = tokenPrice.mul(10**PRICE_DECIMALS).div(cumulativePrice).mul(payment).div(10**PRICE_DECIMALS).mul(10**productDecimals.sub(tokenDecimals));\n        }\n\n        uint256 productTokenBalance = productToken.balanceOf(address(this));\n        if (productTokenBalance > 0) {\n            uint256 rewardTokenBalance = rewardToken.balanceOf(address(this));\n            reward = product.mul(10**REWARD_DECIMALS).div(productTokenBalance).mul(rewardTokenBalance).div(10**REWARD_DECIMALS);\n        }\n    }\n\n    /**\n     * @param currency Currency token.\n     * @return Pools for each consecutive pair of addresses must exist and have liquidity\n     */\n    function _path(address currency) internal view returns (address[] memory) {\n        address weth = uniswapRouter.WETH();\n        if (weth == currency) {\n            address[] memory path = new address[](2);\n            path[0] = currency;\n            path[1] = address(cumulative);\n            return path;\n        }\n\n        address[] memory path = new address[](3);\n        path[0] = currency;\n        path[1] = weth;\n        path[2] = address(cumulative);\n        return path;\n    }\n\n    /**\n     * @param currency Currency token.\n     * @param payment Amount of payment.\n     * @return Amount cumulative token after swap.\n     */\n    function _amountOut(address currency, uint256 payment) internal view returns (uint256) {\n        uint256[] memory amountsOut = uniswapRouter.getAmountsOut(payment, _path(currency));\n        require(amountsOut.length != 0, \"Market::_amountOut: invalid amounts out length\");\n\n        return amountsOut[amountsOut.length - 1];\n    }\n\n    /**\n     * @notice Buy token with ERC20.\n     * @param currency Currency token.\n     * @param payment Amount of payment.\n     * @return True if success.\n     */\n    function buy(address currency, uint256 payment) external whenNotPaused returns (bool) {\n        (uint256 product, uint256 reward) = price(currency, payment);\n        uint256 productTokenBalance = productToken.balanceOf(address(this));\n        require(productTokenBalance > 0 && product <= productTokenBalance, \"Market::buy: exceeds balance\");\n\n        ERC20(currency).safeTransferFrom(_msgSender(), address(this), payment);\n\n        if (currency != address(cumulative)) {\n            uint256 amountOut = _amountOut(currency, payment);\n            require(amountOut != 0, \"Market::buy: liquidity pool is empty\");\n\n            ERC20(currency).safeApprove(address(uniswapRouter), payment);\n            uniswapRouter.swapExactTokensForTokens(payment, amountOut, _path(currency), address(this), block.timestamp);\n        }\n\n        productToken.safeTransfer(_msgSender(), product);\n        if (reward > 0) {\n            rewardToken.safeTransfer(_msgSender(), reward);\n        }\n        emit Buy(_msgSender(), currency, payment, product, reward);\n\n        return true;\n    }\n\n    /**\n     * @notice Buy token with ETH.\n     * @return True if success.\n     */\n    function buyFromETH() external payable whenNotPaused returns (bool) {\n        address currency = uniswapRouter.WETH();\n        uint256 payment = msg.value;\n\n        (uint256 product, uint256 reward) = price(currency, payment);\n        uint256 productTokenBalance = productToken.balanceOf(address(this));\n        require(product <= productTokenBalance, \"Market::buyFromETH: balance is empty\");\n\n        if (currency != address(cumulative)) {\n            uint256 amountOut = _amountOut(currency, payment);\n            require(amountOut != 0, \"Market::buyFromETH: liquidity pool is empty\");\n\n            uniswapRouter.swapExactETHForTokens{value: payment}(amountOut, _path(currency), address(this), block.timestamp);\n        }\n\n        productToken.safeTransfer(_msgSender(), product);\n        if (reward > 0) {\n            rewardToken.safeTransfer(_msgSender(), reward);\n        }\n        emit Buy(_msgSender(), currency, payment, product, reward);\n\n        return true;\n    }\n\n    /**\n     * @notice Withdraw cumulative token to address.\n     * @param recipient Recipient of token.\n     */\n    function withdraw(address recipient) public onlyOwner {\n        require(recipient != address(0), \"Market::withdraw: cannot transfer to the zero address\");\n\n        uint256 balance = cumulative.balanceOf(address(this));\n        cumulative.safeTransfer(recipient, balance);\n\n        emit Withdrawal(recipient, address(cumulative), balance);\n    }\n}"
    }
  ]
}