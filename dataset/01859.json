{
  "Title": "Rates can be updated for a deactivated farming",
  "Content": "##### Description\nThere is no check that the incentive maker can't set non-zero rates for a deactivated pool.\nhttps://github.com/cryptoalgebra/Algebra/blob/7290fad656bfa89db3743c52af631154f6a8a2d5/src/tokenomics/contracts/farmings/AlgebraEternalFarming.sol#L198-L202\n\n##### Recommendation\nWe recommend adding a check that the farming was deactivated and this case allows setting only zero rates.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/tokenomics/contracts/farmings/AlgebraEternalFarming.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.17;\n\nimport './EternalVirtualPool.sol';\nimport '../libraries/IncentiveId.sol';\nimport '../libraries/NFTPositionInfo.sol';\nimport '../interfaces/IAlgebraEternalFarming.sol';\nimport '../interfaces/IAlgebraEternalVirtualPool.sol';\nimport '../interfaces/IFarmingCenter.sol';\n\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraPoolDeployer.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraPool.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraFactory.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/IERC20Minimal.sol';\nimport '@cryptoalgebra/core/contracts/libraries/SafeCast.sol';\nimport '@cryptoalgebra/core/contracts/libraries/FullMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/Constants.sol';\nimport '@cryptoalgebra/core/contracts/libraries/TickMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/LowGasSafeMath.sol';\n\nimport '@cryptoalgebra/periphery/contracts/libraries/TransferHelper.sol';\n\n/// @title Algebra eternal (v2-like) farming\ncontract AlgebraEternalFarming is IAlgebraEternalFarming {\n  using SafeCast for int256;\n  using LowGasSafeMath for uint256;\n  using LowGasSafeMath for uint128;\n\n  /// @notice Represents a farming incentive\n  struct Incentive {\n    uint128 totalReward;\n    uint128 bonusReward;\n    address virtualPoolAddress;\n    uint24 minimalPositionWidth;\n    uint224 totalLiquidity;\n    bool deactivated;\n  }\n\n  /// @notice Represents the farm for nft\n  struct Farm {\n    uint128 liquidity;\n    int24 tickLower;\n    int24 tickUpper;\n    uint256 innerRewardGrowth0;\n    uint256 innerRewardGrowth1;\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  INonfungiblePositionManager public immutable override nonfungiblePositionManager;\n\n  IAlgebraPoolDeployer private immutable deployer;\n  IAlgebraFactory private immutable factory;\n\n  IFarmingCenter public farmingCenter;\n\n  /// @dev bytes32 refers to the return value of IncentiveId.compute\n  /// @inheritdoc IAlgebraEternalFarming\n  mapping(bytes32 => Incentive) public override incentives;\n  /// @dev farms[tokenId][incentiveHash] => Farm\n  /// @inheritdoc IAlgebraEternalFarming\n  mapping(uint256 => mapping(bytes32 => Farm)) public override farms;\n\n  uint256 public numOfIncentives;\n\n  bytes32 public constant INCENTIVE_MAKER_ROLE = keccak256('INCENTIVE_MAKER_ROLE');\n  bytes32 public constant FARMINGS_ADMINISTRATOR_ROLE = keccak256('FARMINGS_ADMINISTRATOR_ROLE');\n\n  /// @dev rewards[owner][rewardToken] => uint256\n  /// @inheritdoc IAlgebraEternalFarming\n  mapping(address => mapping(IERC20Minimal => uint256)) public override rewards;\n\n  modifier onlyIncentiveMaker() {\n    _checkHasRole(INCENTIVE_MAKER_ROLE);\n    _;\n  }\n\n  modifier onlyAdministrator() {\n    _checkHasRole(FARMINGS_ADMINISTRATOR_ROLE);\n    _;\n  }\n\n  modifier onlyFarmingCenter() {\n    _checkIsFarmingCenter();\n    _;\n  }\n\n  /// @param _deployer pool deployer contract address\n  /// @param _nonfungiblePositionManager the NFT position manager contract address\n  constructor(IAlgebraPoolDeployer _deployer, INonfungiblePositionManager _nonfungiblePositionManager) {\n    (deployer, nonfungiblePositionManager) = (_deployer, _nonfungiblePositionManager);\n    factory = IAlgebraFactory(_nonfungiblePositionManager.factory());\n  }\n\n  function _checkIsFarmingCenter() internal view {\n    require(msg.sender == address(farmingCenter));\n  }\n\n  function _checkHasRole(bytes32 role) internal view {\n    require(IAlgebraFactory(factory).hasRoleOrOwner(role, msg.sender));\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function createEternalFarming(\n    IncentiveKey memory key,\n    IncentiveParams memory params\n  ) external override onlyIncentiveMaker returns (address virtualPool) {\n    if (_getCurrentVirtualPool(key.pool) != address(0)) revert farmingAlreadyExists();\n\n    virtualPool = address(new EternalVirtualPool(address(farmingCenter), address(this), address(key.pool)));\n    _connectPoolToVirtualPool(key.pool, virtualPool);\n\n    bytes32 incentiveId = IncentiveId.compute(key);\n    Incentive storage newIncentive = incentives[incentiveId];\n\n    (params.reward, params.bonusReward) = _receiveRewards(key, params.reward, params.bonusReward, newIncentive);\n    unchecked {\n      if (int256(uint256(params.minimalPositionWidth)) > (int256(TickMath.MAX_TICK) - int256(TickMath.MIN_TICK)))\n        revert minimalPositionWidthTooWide();\n    }\n    (newIncentive.virtualPoolAddress, newIncentive.minimalPositionWidth) = (virtualPool, params.minimalPositionWidth);\n\n    emit EternalFarmingCreated(\n      key.rewardToken,\n      key.bonusRewardToken,\n      key.pool,\n      virtualPool,\n      numOfIncentives++,\n      params.reward,\n      params.bonusReward,\n      params.minimalPositionWidth\n    );\n\n    _addRewards(IAlgebraEternalVirtualPool(virtualPool), params.reward, params.bonusReward, incentiveId);\n    _setRewardRates(IAlgebraEternalVirtualPool(virtualPool), params.rewardRate, params.bonusRewardRate, incentiveId);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function deactivateIncentive(IncentiveKey memory key) external override onlyIncentiveMaker {\n    (bytes32 incentiveId, Incentive storage incentive) = _getIncentiveByKey(key);\n    if (incentive.deactivated) revert incentiveStopped();\n\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(_getCurrentVirtualPool(key.pool));\n    if (address(virtualPool) == address(0)) revert incentiveNotExist();\n    if (incentive.virtualPoolAddress != address(virtualPool)) revert anotherFarmingIsActive();\n\n    (uint128 rewardRate0, uint128 rewardRate1) = virtualPool.rewardRates();\n    if (rewardRate0 | rewardRate1 != 0) _setRewardRates(virtualPool, 0, 0, incentiveId);\n\n    incentive.deactivated = true;\n\n    _connectPoolToVirtualPool(key.pool, address(0));\n    emit IncentiveDeactivated(incentiveId);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function decreaseRewardsAmount(IncentiveKey memory key, uint128 rewardAmount, uint128 bonusRewardAmount) external override onlyAdministrator {\n    (bytes32 incentiveId, Incentive storage incentive) = _getIncentiveByKey(key);\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(incentive.virtualPoolAddress);\n\n    unchecked {\n      (uint128 rewardReserve0, uint128 rewardReserve1) = virtualPool.rewardReserves();\n      if (rewardAmount > rewardReserve0) rewardAmount = rewardReserve0;\n      if (rewardAmount >= incentive.totalReward) rewardAmount = incentive.totalReward - 1; // to not trigger 'non-existent incentive'\n      incentive.totalReward = incentive.totalReward - rewardAmount;\n\n      if (bonusRewardAmount > rewardReserve1) bonusRewardAmount = rewardReserve1;\n      incentive.bonusReward = incentive.bonusReward - bonusRewardAmount;\n    }\n\n    virtualPool.decreaseRewards(rewardAmount, bonusRewardAmount);\n\n    if (rewardAmount > 0) TransferHelper.safeTransfer(address(key.rewardToken), msg.sender, rewardAmount);\n    if (bonusRewardAmount > 0) TransferHelper.safeTransfer(address(key.bonusRewardToken), msg.sender, bonusRewardAmount);\n\n    emit RewardAmountsDecreased(rewardAmount, bonusRewardAmount, incentiveId);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function setFarmingCenterAddress(address _farmingCenter) external override onlyAdministrator {\n    require(_farmingCenter != address(farmingCenter));\n    farmingCenter = IFarmingCenter(_farmingCenter);\n    emit FarmingCenter(_farmingCenter);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function addRewards(IncentiveKey memory key, uint128 rewardAmount, uint128 bonusRewardAmount) external override {\n    (bytes32 incentiveId, Incentive storage incentive) = _getIncentiveByKey(key);\n    if (incentive.deactivated) revert incentiveStopped();\n\n    (rewardAmount, bonusRewardAmount) = _receiveRewards(key, rewardAmount, bonusRewardAmount, incentive);\n\n    if (rewardAmount | bonusRewardAmount > 0) {\n      _addRewards(IAlgebraEternalVirtualPool(incentive.virtualPoolAddress), rewardAmount, bonusRewardAmount, incentiveId);\n    }\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function setRates(IncentiveKey memory key, uint128 rewardRate, uint128 bonusRewardRate) external override onlyIncentiveMaker {\n    bytes32 incentiveId = IncentiveId.compute(key);\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(incentives[incentiveId].virtualPoolAddress);\n    _setRewardRates(virtualPool, rewardRate, bonusRewardRate, incentiveId);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function enterFarming(IncentiveKey memory key, uint256 tokenId) external override onlyFarmingCenter {\n    (bytes32 incentiveId, int24 tickLower, int24 tickUpper, uint128 liquidity, address virtualPoolAddress) = _enterFarming(key, tokenId);\n\n    mapping(bytes32 => Farm) storage farmsForToken = farms[tokenId];\n    if (farmsForToken[incentiveId].liquidity != 0) revert tokenAlreadyFarmed();\n\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(virtualPoolAddress);\n    (uint256 innerRewardGrowth0, uint256 innerRewardGrowth1) = _getInnerRewardsGrowth(virtualPool, tickLower, tickUpper);\n\n    farmsForToken[incentiveId] = Farm(liquidity, tickLower, tickUpper, innerRewardGrowth0, innerRewardGrowth1);\n\n    emit FarmEntered(tokenId, incentiveId, liquidity);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function exitFarming(IncentiveKey memory key, uint256 tokenId, address _owner) external override onlyFarmingCenter {\n    bytes32 incentiveId = IncentiveId.compute(key);\n    Farm memory farm = farms[tokenId][incentiveId];\n    if (farm.liquidity == 0) revert farmDoesNotExist();\n\n    (uint256 reward, uint256 bonusReward) = _updatePosition(farm, key, incentiveId, _owner, -int256(uint256(farm.liquidity)).toInt128());\n\n    delete farms[tokenId][incentiveId];\n\n    emit FarmEnded(tokenId, incentiveId, address(key.rewardToken), address(key.bonusRewardToken), _owner, reward, bonusReward);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function claimReward(IERC20Minimal rewardToken, address to, uint256 amountRequested) external override returns (uint256 reward) {\n    return _claimReward(rewardToken, msg.sender, to, amountRequested);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function claimRewardFrom(\n    IERC20Minimal rewardToken,\n    address from,\n    address to,\n    uint256 amountRequested\n  ) external override onlyFarmingCenter returns (uint256 reward) {\n    return _claimReward(rewardToken, from, to, amountRequested);\n  }\n\n  function _updatePosition(\n    Farm memory farm,\n    IncentiveKey memory key,\n    bytes32 incentiveId,\n    address _owner,\n    int128 liquidityDelta\n  ) internal returns (uint256 reward, uint256 bonusReward) {\n    Incentive storage incentive = incentives[incentiveId];\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(incentive.virtualPoolAddress);\n\n    if (_getCurrentVirtualPool(key.pool) != address(virtualPool)) incentive.deactivated = true; // pool can \"detach\" by itself\n    int24 tick = incentive.deactivated ? virtualPool.globalTick() : _getTickInPool(key.pool);\n\n    // update rewards, as ticks may be cleared when liquidity decreases\n    _updatePositionInVirtualPool(address(virtualPool), uint32(block.timestamp), farm.tickLower, farm.tickUpper, 0, tick);\n\n    (reward, bonusReward, , ) = _getNewRewardsForFarm(virtualPool, farm);\n\n    if (liquidityDelta != 0) {\n      _updatePositionInVirtualPool(address(virtualPool), uint32(block.timestamp), farm.tickLower, farm.tickUpper, liquidityDelta, tick);\n    }\n\n    mapping(IERC20Minimal => uint256) storage rewardBalances = rewards[_owner];\n    unchecked {\n      if (reward != 0) rewardBalances[key.rewardToken] += reward; // user must claim before overflow\n      if (bonusReward != 0) rewardBalances[key.bonusRewardToken] += bonusReward; // user must claim before overflow\n    }\n  }\n\n  /// @notice reward amounts can be outdated, actual amounts could be obtained via static call of `collectRewards` in FarmingCenter\n  /// @inheritdoc IAlgebraEternalFarming\n  function getRewardInfo(IncentiveKey memory key, uint256 tokenId) external view override returns (uint256 reward, uint256 bonusReward) {\n    bytes32 incentiveId = IncentiveId.compute(key);\n    Farm memory farm = farms[tokenId][incentiveId];\n    if (farm.liquidity == 0) revert farmDoesNotExist();\n\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(incentives[incentiveId].virtualPoolAddress);\n    (reward, bonusReward, , ) = _getNewRewardsForFarm(virtualPool, farm);\n  }\n\n  /// @notice reward amounts should be updated before calling this method\n  /// @inheritdoc IAlgebraEternalFarming\n  function collectRewards(\n    IncentiveKey memory key,\n    uint256 tokenId,\n    address _owner\n  ) external override onlyFarmingCenter returns (uint256 reward, uint256 bonusReward) {\n    (bytes32 incentiveId, Incentive storage incentive) = _getIncentiveByKey(key);\n    Farm memory farm = farms[tokenId][incentiveId];\n    if (farm.liquidity == 0) revert farmDoesNotExist();\n\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(incentive.virtualPoolAddress);\n    virtualPool.distributeRewards(uint32(block.timestamp));\n\n    uint256 innerRewardGrowth0;\n    uint256 innerRewardGrowth1;\n    (reward, bonusReward, innerRewardGrowth0, innerRewardGrowth1) = _getNewRewardsForFarm(virtualPool, farm);\n\n    farms[tokenId][incentiveId].innerRewardGrowth0 = innerRewardGrowth0;\n    farms[tokenId][incentiveId].innerRewardGrowth1 = innerRewardGrowth1;\n\n    mapping(IERC20Minimal => uint256) storage rewardBalances = rewards[_owner];\n    unchecked {\n      if (reward != 0) rewardBalances[key.rewardToken] += reward; // user must claim before overflow\n      if (bonusReward != 0) rewardBalances[key.bonusRewardToken] += bonusReward; // user must claim before overflow\n    }\n\n    emit RewardsCollected(tokenId, incentiveId, reward, bonusReward);\n  }\n\n  function _getInnerRewardsGrowth(IAlgebraEternalVirtualPool virtualPool, int24 tickLower, int24 tickUpper) private view returns (uint256, uint256) {\n    return virtualPool.getInnerRewardsGrowth(tickLower, tickUpper);\n  }\n\n  function _getNewRewardsForFarm(\n    IAlgebraEternalVirtualPool virtualPool,\n    Farm memory farm\n  ) private view returns (uint256 reward, uint256 bonusReward, uint256 innerRewardGrowth0, uint256 innerRewardGrowth1) {\n    (innerRewardGrowth0, innerRewardGrowth1) = _getInnerRewardsGrowth(virtualPool, farm.tickLower, farm.tickUpper);\n\n    unchecked {\n      (reward, bonusReward) = (\n        FullMath.mulDiv(innerRewardGrowth0 - farm.innerRewardGrowth0, farm.liquidity, Constants.Q128),\n        FullMath.mulDiv(innerRewardGrowth1 - farm.innerRewardGrowth1, farm.liquidity, Constants.Q128)\n      );\n    }\n  }\n\n  function _addRewards(IAlgebraEternalVirtualPool virtualPool, uint128 amount0, uint128 amount1, bytes32 incentiveId) private {\n    virtualPool.addRewards(amount0, amount1);\n    emit RewardsAdded(amount0, amount1, incentiveId);\n  }\n\n  function _setRewardRates(IAlgebraEternalVirtualPool virtualPool, uint128 rate0, uint128 rate1, bytes32 incentiveId) private {\n    virtualPool.setRates(rate0, rate1);\n    emit RewardsRatesChanged(rate0, rate1, incentiveId);\n  }\n\n  function _connectPoolToVirtualPool(IAlgebraPool pool, address virtualPool) private {\n    farmingCenter.connectVirtualPool(pool, virtualPool);\n  }\n\n  function _getCurrentVirtualPool(IAlgebraPool pool) internal view returns (address virtualPool) {\n    return pool.activeIncentive();\n  }\n\n  function _receiveRewards(\n    IncentiveKey memory key,\n    uint128 reward,\n    uint128 bonusReward,\n    Incentive storage incentive\n  ) internal returns (uint128 receivedReward, uint128 receivedBonusReward) {\n    if (reward > 0) receivedReward = _receiveToken(key.rewardToken, reward);\n    if (bonusReward > 0) receivedBonusReward = _receiveToken(key.bonusRewardToken, bonusReward);\n\n    incentive.totalReward = incentive.totalReward + receivedReward;\n    incentive.bonusReward = incentive.bonusReward + receivedBonusReward;\n  }\n\n  function _receiveToken(IERC20Minimal token, uint128 amount) private returns (uint128) {\n    uint256 balanceBefore = token.balanceOf(address(this));\n    TransferHelper.safeTransferFrom(address(token), msg.sender, address(this), amount);\n    uint256 balanceAfter = token.balanceOf(address(this));\n    require(balanceAfter > balanceBefore);\n    unchecked {\n      uint256 received = uint128(balanceAfter - balanceBefore);\n      require(received <= type(uint128).max, 'invalid token amount');\n      return (uint128(received));\n    }\n  }\n\n  function _enterFarming(\n    IncentiveKey memory key,\n    uint256 tokenId\n  ) internal returns (bytes32 incentiveId, int24 tickLower, int24 tickUpper, uint128 liquidity, address virtualPool) {\n    Incentive storage incentive;\n    (incentiveId, incentive) = _getIncentiveByKey(key);\n    if (_getCurrentVirtualPool(key.pool) != address(virtualPool)) incentive.deactivated = true; // pool can \"detach\" by itself\n    if (incentive.deactivated) revert incentiveStopped();\n\n    IAlgebraPool pool;\n    (pool, tickLower, tickUpper, liquidity) = NFTPositionInfo.getPositionInfo(deployer, nonfungiblePositionManager, tokenId);\n\n    if (pool != key.pool) revert invalidPool();\n    if (liquidity == 0) revert zeroLiquidity();\n\n    uint24 minimalAllowedTickWidth = incentive.minimalPositionWidth;\n    unchecked {\n      if (int256(tickUpper) - int256(tickLower) < int256(uint256(minimalAllowedTickWidth))) revert positionIsTooNarrow();\n    }\n\n    virtualPool = incentive.virtualPoolAddress;\n    int24 tick = _getTickInPool(pool);\n    _updatePositionInVirtualPool(virtualPool, uint32(block.timestamp), tickLower, tickUpper, int256(uint256(liquidity)).toInt128(), tick);\n  }\n\n  function _claimReward(IERC20Minimal rewardToken, address from, address to, uint256 amountRequested) internal returns (uint256 reward) {\n    reward = rewards[from][rewardToken];\n\n    if (amountRequested == 0 || amountRequested > reward) amountRequested = reward;\n    unchecked {\n      rewards[from][rewardToken] = reward - amountRequested;\n    }\n    TransferHelper.safeTransfer(address(rewardToken), to, amountRequested);\n    emit RewardClaimed(to, amountRequested, address(rewardToken), from);\n  }\n\n  function _getIncentiveByKey(IncentiveKey memory key) internal view returns (bytes32 incentiveId, Incentive storage incentive) {\n    incentiveId = IncentiveId.compute(key);\n    incentive = incentives[incentiveId];\n    if (incentive.totalReward == 0) revert incentiveNotExist();\n  }\n\n  function _getTickInPool(IAlgebraPool pool) internal view returns (int24 tick) {\n    (, tick, , , , , ) = pool.globalState();\n  }\n\n  function _updatePositionInVirtualPool(\n    address virtualPool,\n    uint32 timestamp,\n    int24 tickLower,\n    int24 tickUpper,\n    int128 liquidityDelta,\n    int24 currentTick\n  ) internal {\n    IAlgebraEternalVirtualPool(virtualPool).applyLiquidityDeltaToPosition(timestamp, tickLower, tickUpper, liquidityDelta, currentTick);\n  }\n}"
    }
  ]
}