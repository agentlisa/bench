{
  "Title": "H-3: Adversary can stake LP directly for the vault then withdraw to break lp accounting in BLVaultManagerLido",
  "Content": "# Issue H-3: Adversary can stake LP directly for the vault then withdraw to break lp accounting in BLVaultManagerLido \n\nSource: https://github.com/sherlock-audit/2023-03-olympus-judging/issues/4 \n\n## Found by \n0x52, carrot, cducrest-brainbot, hickuphh3, Bahurum\n\n## Summary\n\nThe AuraRewardPool allows users to stake directly for other users. In this case the malicious user could stake LP directly for their vault then call withdraw on their vault. This would cause the LP tracking to break on BLVaultManagerLido. The result is that some users would now be permanently trapped because their vault would revert when trying to withdraw.\n\n## Vulnerability Detail\n\n[BaseRewardPool.sol#L196-L207](https://github.com/aurafinance/convex-platform/blob/1d6e9c403a4440c712396422e1bd5af7e5ea1ecf/contracts/contracts/BaseRewardPool.sol#L196-L207)\n\n    function stakeFor(address _for, uint256 _amount)\n        public\n        returns(bool)\n    {\n        _processStake(_amount, _for);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n        \n        return true;\n    }\n\nAuraRewardPool allows users to stake directly for another address with them receiving the staked tokens.\n\n[BLVaultLido.sol#L218-L224](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L218-L224)\n\n        manager.decreaseTotalLp(lpAmount_);\n\n        // Unstake from Aura\n        auraRewardPool().withdrawAndUnwrap(lpAmount_, claim_);\n\n        // Exit Balancer pool\n        _exitBalancerPool(lpAmount_, minTokenAmounts_);\n\nOnce the LP has been stake the adversary can immediately withdraw it from their vault. This calls decreaseTotalLP on BLVaultManagerLido which now permanently break the LP account.\n\n[BLVaultManagerLido.sol#L277-L280](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultManagerLido.sol#L277-L280)\n\n    function decreaseTotalLp(uint256 amount_) external override onlyWhileActive onlyVault {\n        if (amount_ > totalLp) revert BLManagerLido_InvalidLpAmount();\n        totalLp -= amount_;\n    }\n    \nIf the amount_ is ever greater than totalLP it will cause decreaseTotalLP to revert. By withdrawing LP that was never deposited to a vault, it permanently breaks other users from being able to withdraw.\n\nExample:\nUser A deposits wstETH to their vault which yields 50 LP. User B creates a vault then stake 50 LP and withdraws it from his vault. The manager now thinks there is 0 LP in vaults. When User A tries to withdraw their LP it will revert when it calls manger.decreaseTotalLp. User A is now permanently trapped in the vault.\n\n## Impact\n\nLP accounting is broken and users are permanently trapped.\n\n## Code Snippet\n\n[BLVaultLido.sol#L203-L256](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L203-L256)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIndividual vaults should track how much they have deposited and shouldn't be allowed to withdraw more than deposited.\n\n## Discussion\n\n**0xLienid**\n\nFix Implementation: https://github.com/0xLienid/sherlock-olympus/pull/5/files\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/60",
  "Code": [
    {
      "filename": "contracts/contracts/BaseRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: BaseRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"./Interfaces.sol\";\nimport \"./interfaces/MathUtil.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n\n/**\n * @title   BaseRewardPool\n * @author  Synthetix -> ConvexFinance\n * @notice  Unipool rewards contract that is re-deployed from rFactory for each staking pool.\n * @dev     Changes made here by ConvexFinance are to do with the delayed reward allocation. Curve is queued for\n *          rewards and the distribution only begins once the new rewards are sufficiently large, or the epoch\n *          has ended. Additionally, enables hooks for `extraRewards` that can be enabled at any point to\n *          distribute a child reward token (i.e. a secondary one from Curve, or a seperate one).\n */\ncontract BaseRewardPool {\n     using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 7 days;\n\n    address public immutable operator;\n    address public immutable rewardManager;\n\n    uint256 public immutable pid;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    address[] public extraRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev This is called directly from RewardFactory\n     * @param pid_           Effectively the pool identifier - used in the Booster\n     * @param stakingToken_  Pool LP token\n     * @param rewardToken_   Crv\n     * @param operator_      Booster\n     * @param rewardManager_ RewardFactory\n     */\n    constructor(\n        uint256 pid_,\n        address stakingToken_,\n        address rewardToken_,\n        address operator_,\n        address rewardManager_\n    ) public {\n        pid = pid_;\n        stakingToken = IERC20(stakingToken_);\n        rewardToken = IERC20(rewardToken_);\n        operator = operator_;\n        rewardManager = rewardManager_;\n    }\n\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external returns(bool){\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0),\"!reward setting\");\n        \n        if(extraRewards.length >= 12){\n            return false;\n        }\n        \n        extraRewards.push(_reward);\n        return true;\n    }\n    function clearExtraRewards() external{\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return MathUtil.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 _amount)\n        public \n        returns(bool)\n    {\n        _processStake(_amount, msg.sender);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        return true;\n    }\n\n    function stakeAll() external returns(bool){\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount)\n        public\n        returns(bool)\n    {\n        _processStake(_amount, _for);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n        \n        return true;\n    }\n\n    /**\n     * @dev Generic internal staking function that basically does 3 things: update rewards based\n     *      on previous balance, trigger also on any child contracts, then update balances.\n     * @param _amount    Units to add to the users balance\n     * @param _receiver  Address of user who will receive the stake\n     */\n    function _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {\n        require(_amount > 0, 'RewardPool : Cannot stake 0');\n        \n        //also stake to linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).stake(_receiver, _amount);\n        }\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_receiver] = _balances[_receiver].add(_amount);\n\n        emit Transfer(address(0), _receiver, _amount);\n    }\n\n    function withdraw(uint256 amount, bool claim)\n        public\n        updateReward(msg.sender)\n        returns(bool)\n    {\n        require(amount > 0, 'RewardPool : Cannot withdraw 0');\n\n        //also withdraw from linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n     \n        if(claim){\n            getReward(msg.sender,true);\n        }\n\n        emit Transfer(msg.sender, address(0), amount);\n\n        return true;\n    }\n\n    function withdrawAll(bool claim) external{\n        withdraw(_balances[msg.sender],claim);\n    }\n\n    function withdrawAndUnwrap(uint256 amount, bool claim) public returns(bool){\n        _withdrawAndUnwrapTo(amount, msg.sender, msg.sender);\n        //get rewards too\n        if(claim){\n            getReward(msg.sender,true);\n        }\n        return true;\n    }\n\n    function _withdrawAndUnwrapTo(uint256 amount, address from, address receiver) internal updateReward(from) returns(bool){\n        //also withdraw from linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).withdraw(from, amount);\n        }\n        \n        _totalSupply = _totalSupply.sub(amount);\n        _balances[from] = _balances[from].sub(amount);\n\n        //tell operator to withdraw from here directly to user\n        IDeposit(operator).withdrawTo(pid,amount,receiver);\n        emit Withdrawn(from, amount);\n\n        emit Transfer(from, address(0), amount);\n\n        return true;\n    }\n\n    function withdrawAllAndUnwrap(bool claim) external{\n        withdrawAndUnwrap(_balances[msg.sender],claim);\n    }\n\n    /**\n     * @dev Gives a staker their rewards, with the option of claiming extra rewards\n     * @param _account     Account for which to claim\n     * @param _claimExtras Get the child rewards too?\n     */\n    function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if(_claimExtras){\n            for(uint i=0; i < extraRewards.length; i++){\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Called by a staker to get their allocated rewards\n     */\n    function getReward() external returns(bool){\n        getReward(msg.sender,true);\n        return true;\n    }\n\n    /**\n     * @dev Processes queued rewards in isolation, providing the period has finished.\n     *      This allows a cheaper way to trigger rewards on low value pools.\n     */\n    function processIdleRewards() external {\n        if (block.timestamp >= periodFinish && queuedRewards > 0) {\n            notifyRewardAmount(queuedRewards);\n            queuedRewards = 0;\n        }\n    }\n\n    /**\n     * @dev Called by the booster to allocate new Crv rewards to this pool\n     *      Curve is queued for rewards and the distribution only begins once the new rewards are sufficiently\n     *      large, or the epoch has ended.\n     */\n    function queueNewRewards(uint256 _rewards) external returns(bool){\n        require(msg.sender == operator, \"!authorized\");\n\n        _rewards = _rewards.add(queuedRewards);\n\n        if (block.timestamp >= periodFinish) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n            return true;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n\n        //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);\n        if(queuedRatio < newRewardRatio){\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n        }else{\n            queuedRewards = _rewards;\n        }\n        return true;\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        historicalRewards = historicalRewards.add(reward);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            reward = reward.add(leftover);\n            rewardRate = reward.div(duration);\n        }\n        currentRewards = reward;\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}"
    },
    {
      "filename": "sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport {IBLVaultLido, RewardsData} from \"policies/BoostedLiquidity/interfaces/IBLVaultLido.sol\";\nimport {IBLVaultManagerLido} from \"policies/BoostedLiquidity/interfaces/IBLVaultManagerLido.sol\";\nimport {BLVaultManagerLido} from \"policies/BoostedLiquidity/BLVaultManagerLido.sol\";\n\n// Import external dependencies\nimport {JoinPoolRequest, ExitPoolRequest, IVault, IBasePool} from \"policies/BoostedLiquidity/interfaces/IBalancer.sol\";\nimport {IAuraBooster, IAuraRewardPool, IAuraMiningLib} from \"policies/BoostedLiquidity/interfaces/IAura.sol\";\n\n// Import types\nimport {OlympusERC20Token} from \"src/external/OlympusERC20.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n// Import libraries\nimport {Clone} from \"clones/Clone.sol\";\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\ncontract BLVaultLido is IBLVaultLido, Clone {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    // ========= ERRORS ========= //\n\n    error BLVaultLido_AlreadyInitialized();\n    error BLVaultLido_OnlyOwner();\n    error BLVaultLido_Inactive();\n    error BLVaultLido_Reentrancy();\n    error BLVaultLido_AuraDepositFailed();\n\n    // ========= EVENTS ========= //\n\n    event Deposit(uint256 ohmAmount, uint256 wstethAmount);\n    event Withdraw(uint256 ohmAmount, uint256 wstethAmount);\n    event RewardsClaimed(address indexed rewardsToken, uint256 amount);\n\n    // ========= STATE VARIABLES ========= //\n\n    uint256 private constant _OHM_DECIMALS = 1e9;\n    uint256 private constant _WSTETH_DECIMALS = 1e18;\n\n    uint256 private _reentrancyStatus;\n\n    // ========= CONSTRUCTOR ========= //\n\n    constructor() {}\n\n    // ========= INITIALIZER ========= //\n\n    function initializeClone() external {\n        if (_reentrancyStatus != 0) revert BLVaultLido_AlreadyInitialized();\n        _reentrancyStatus = 1;\n    }\n\n    // ========= IMMUTABLE CLONE ARGS ========= //\n\n    function owner() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    function manager() public pure returns (BLVaultManagerLido) {\n        return BLVaultManagerLido(_getArgAddress(20));\n    }\n\n    function TRSRY() public pure returns (address) {\n        return _getArgAddress(40);\n    }\n\n    function MINTR() public pure returns (address) {\n        return _getArgAddress(60);\n    }\n\n    function ohm() public pure returns (OlympusERC20Token) {\n        return OlympusERC20Token(_getArgAddress(80));\n    }\n\n    function wsteth() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(100));\n    }\n\n    function aura() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(120));\n    }\n\n    function bal() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(140));\n    }\n\n    function vault() public pure returns (IVault) {\n        return IVault(_getArgAddress(160));\n    }\n\n    function liquidityPool() public pure returns (IBasePool) {\n        return IBasePool(_getArgAddress(180));\n    }\n\n    function pid() public pure returns (uint256) {\n        return _getArgUint256(200);\n    }\n\n    function auraBooster() public pure returns (IAuraBooster) {\n        return IAuraBooster(_getArgAddress(232));\n    }\n\n    function auraRewardPool() public pure returns (IAuraRewardPool) {\n        return IAuraRewardPool(_getArgAddress(252));\n    }\n\n    function fee() public pure returns (uint64) {\n        return _getArgUint64(272);\n    }\n\n    // ========= MODIFIERS ========= //\n\n    modifier onlyOwner() {\n        if (msg.sender != owner()) revert BLVaultLido_OnlyOwner();\n        _;\n    }\n\n    modifier onlyWhileActive() {\n        if (!manager().isLidoBLVaultActive()) revert BLVaultLido_Inactive();\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_reentrancyStatus != 1) revert BLVaultLido_Reentrancy();\n\n        _reentrancyStatus = 2;\n\n        _;\n\n        _reentrancyStatus = 1;\n    }\n\n    //============================================================================================//\n    //                                      LIQUIDITY FUNCTIONS                                   //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function deposit(\n        uint256 amount_,\n        uint256 minLpAmount_\n    ) external override onlyWhileActive onlyOwner nonReentrant returns (uint256 lpAmountOut) {\n        // Cache variables into memory\n        IBLVaultManagerLido manager = manager();\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBasePool liquidityPool = liquidityPool();\n        IAuraBooster auraBooster = auraBooster();\n\n        // Calculate OHM amount to mint\n        // getOhmTknPrice returns the amount of OHM per 1 wstETH\n        uint256 ohmWstethPrice = manager.getOhmTknPrice();\n        uint256 ohmMintAmount = (amount_ * ohmWstethPrice) / _WSTETH_DECIMALS;\n\n        // Block scope to avoid stack too deep\n        {\n            // Cache OHM-wstETH BPT before\n            uint256 bptBefore = liquidityPool.balanceOf(address(this));\n\n            // Transfer in wstETH\n            wsteth.safeTransferFrom(msg.sender, address(this), amount_);\n\n            // Mint OHM\n            manager.mintOhmToVault(ohmMintAmount);\n\n            // Join Balancer pool\n            _joinBalancerPool(ohmMintAmount, amount_, minLpAmount_);\n\n            // OHM-PAIR BPT after\n            lpAmountOut = liquidityPool.balanceOf(address(this)) - bptBefore;\n            manager.increaseTotalLp(lpAmountOut);\n\n            // Stake into Aura\n            liquidityPool.approve(address(auraBooster), lpAmountOut);\n            bool depositSuccess = auraBooster.deposit(pid(), lpAmountOut, true);\n            if (!depositSuccess) revert BLVaultLido_AuraDepositFailed();\n        }\n\n        // Return unused tokens\n        uint256 unusedOhm = ohm.balanceOf(address(this));\n        uint256 unusedWsteth = wsteth.balanceOf(address(this));\n\n        if (unusedOhm > 0) {\n            ohm.increaseAllowance(MINTR(), unusedOhm);\n            manager.burnOhmFromVault(unusedOhm);\n        }\n\n        if (unusedWsteth > 0) {\n            wsteth.safeTransfer(msg.sender, unusedWsteth);\n        }\n\n        // Emit event\n        emit Deposit(ohmMintAmount - unusedOhm, amount_ - unusedWsteth);\n\n        return lpAmountOut;\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function withdraw(\n        uint256 lpAmount_,\n        uint256[] calldata minTokenAmounts_,\n        bool claim_\n    ) external override onlyWhileActive onlyOwner nonReentrant returns (uint256, uint256) {\n        // Cache variables into memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBLVaultManagerLido manager = manager();\n\n        // Cache OHM and wstETH balances before\n        uint256 ohmBefore = ohm.balanceOf(address(this));\n        uint256 wstethBefore = wsteth.balanceOf(address(this));\n\n        // Decrease total LP\n        manager.decreaseTotalLp(lpAmount_);\n\n        // Unstake from Aura\n        auraRewardPool().withdrawAndUnwrap(lpAmount_, claim_);\n\n        // Exit Balancer pool\n        _exitBalancerPool(lpAmount_, minTokenAmounts_);\n\n        // Calculate OHM and wstETH amounts received\n        uint256 ohmAmountOut = ohm.balanceOf(address(this)) - ohmBefore;\n        uint256 wstethAmountOut = wsteth.balanceOf(address(this)) - wstethBefore;\n\n        // Calculate oracle expected wstETH received amount\n        // getTknOhmPrice returns the amount of wstETH per 1 OHM based on the oracle price\n        uint256 wstethOhmPrice = manager.getTknOhmPrice();\n        uint256 expectedWstethAmountOut = (ohmAmountOut * wstethOhmPrice) / _OHM_DECIMALS;\n\n        // Take any arbs relative to the oracle price for the Treasury and return the rest to the owner\n        uint256 wstethToReturn = wstethAmountOut > expectedWstethAmountOut\n            ? expectedWstethAmountOut\n            : wstethAmountOut;\n        if (wstethAmountOut > wstethToReturn)\n            wsteth.safeTransfer(TRSRY(), wstethAmountOut - wstethToReturn);\n\n        // Burn OHM\n        ohm.increaseAllowance(MINTR(), ohmAmountOut);\n        manager.burnOhmFromVault(ohmAmountOut);\n\n        // Return wstETH to owner\n        wsteth.safeTransfer(msg.sender, wstethToReturn);\n\n        // Return rewards to owner\n        if (claim_) _sendRewards();\n\n        // Emit event\n        emit Withdraw(ohmAmountOut, wstethToReturn);\n\n        return (ohmAmountOut, wstethToReturn);\n    }\n\n    //============================================================================================//\n    //                                       REWARDS FUNCTIONS                                    //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function claimRewards() external override onlyWhileActive onlyOwner nonReentrant {\n        // Claim rewards from Aura\n        auraRewardPool().getReward(owner(), true);\n\n        // Send rewards to owner\n        _sendRewards();\n    }\n\n    //============================================================================================//\n    //                                        VIEW FUNCTIONS                                      //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function getLpBalance() public view override returns (uint256) {\n        return auraRewardPool().balanceOf(address(this));\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function getUserPairShare() public view override returns (uint256) {\n        // If total supply is 0 return 0\n        if (liquidityPool().totalSupply() == 0) return 0;\n\n        // Get user's LP balance\n        uint256 userLpBalance = getLpBalance();\n\n        // Get pool balances\n        (, uint256[] memory balances, ) = vault().getPoolTokens(liquidityPool().getPoolId());\n\n        // Get user's share of the wstETH\n        uint256 userWstethShare = (userLpBalance * balances[1]) / liquidityPool().totalSupply();\n\n        // Check pool against oracle price\n        // getTknOhmPrice returns the amount of wstETH per 1 OHM based on the oracle price\n        uint256 wstethOhmPrice = manager().getTknOhmPrice();\n        uint256 userOhmShare = (userLpBalance * balances[0]) / liquidityPool().totalSupply();\n        uint256 expectedWstethShare = (userOhmShare * wstethOhmPrice) / _OHM_DECIMALS;\n\n        return userWstethShare > expectedWstethShare ? expectedWstethShare : userWstethShare;\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function getOutstandingRewards() public view override returns (RewardsData[] memory) {\n        uint256 numExtraRewards = auraRewardPool().extraRewardsLength();\n        RewardsData[] memory rewards = new RewardsData[](numExtraRewards + 2);\n\n        // Get Bal reward\n        uint256 balRewards = auraRewardPool().earned(address(this));\n        rewards[0] = RewardsData({rewardToken: address(bal()), outstandingRewards: balRewards});\n\n        // Get Aura rewards\n        uint256 auraRewards = manager().auraMiningLib().convertCrvToCvx(balRewards);\n        rewards[1] = RewardsData({rewardToken: address(aura()), outstandingRewards: auraRewards});\n\n        // Get extra rewards\n        for (uint256 i; i < numExtraRewards; ) {\n            IAuraRewardPool extraRewardPool = IAuraRewardPool(auraRewardPool().extraRewards(i));\n\n            address extraRewardToken = extraRewardPool.rewardToken();\n            uint256 extraRewardAmount = extraRewardPool.earned(address(this));\n\n            rewards[i + 2] = RewardsData({\n                rewardToken: extraRewardToken,\n                outstandingRewards: extraRewardAmount\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return rewards;\n    }\n\n    //============================================================================================//\n    //                                      INTERNAL FUNCTIONS                                    //\n    //============================================================================================//\n\n    function _joinBalancerPool(\n        uint256 ohmAmount_,\n        uint256 wstethAmount_,\n        uint256 minLpAmount_\n    ) internal {\n        // Cache variables to memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IVault vault = vault();\n\n        // Build join pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(wsteth);\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = ohmAmount_;\n        maxAmountsIn[1] = wstethAmount_;\n\n        JoinPoolRequest memory joinPoolRequest = JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: maxAmountsIn,\n            userData: abi.encode(1, maxAmountsIn, minLpAmount_),\n            fromInternalBalance: false\n        });\n\n        // Join pool\n        ohm.increaseAllowance(address(vault), ohmAmount_);\n        wsteth.approve(address(vault), wstethAmount_);\n        vault.joinPool(liquidityPool().getPoolId(), address(this), address(this), joinPoolRequest);\n    }\n\n    function _exitBalancerPool(uint256 lpAmount_, uint256[] calldata minTokenAmounts_) internal {\n        // Cache variables to memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBasePool liquidityPool = liquidityPool();\n        IVault vault = vault();\n\n        // Build exit pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(wsteth);\n\n        ExitPoolRequest memory exitPoolRequest = ExitPoolRequest({\n            assets: assets,\n            minAmountsOut: minTokenAmounts_,\n            userData: abi.encode(1, lpAmount_),\n            toInternalBalance: false\n        });\n\n        // Exit Balancer pool\n        liquidityPool.approve(address(vault), lpAmount_);\n        vault.exitPool(\n            liquidityPool.getPoolId(),\n            address(this),\n            payable(address(this)),\n            exitPoolRequest\n        );\n    }\n\n    function _sendRewards() internal {\n        // Send Bal rewards to owner\n        {\n            uint256 balRewards = bal().balanceOf(address(this));\n            uint256 balFee = (balRewards * fee()) / 10_000;\n            if (balRewards - balFee > 0) {\n                bal().safeTransfer(owner(), balRewards - balFee);\n                emit RewardsClaimed(address(bal()), balRewards - balFee);\n            }\n            if (balFee > 0) bal().safeTransfer(TRSRY(), balFee);\n        }\n\n        // Send Aura rewards to owner\n        {\n            uint256 auraRewards = aura().balanceOf(address(this));\n            uint256 auraFee = (auraRewards * fee()) / 10_000;\n            if (auraRewards - auraFee > 0) {\n                aura().safeTransfer(owner(), auraRewards - auraFee);\n                emit RewardsClaimed(address(aura()), auraRewards - auraFee);\n            }\n            if (auraFee > 0) aura().safeTransfer(TRSRY(), auraFee);\n        }\n\n        // Send extra rewards to owner\n        {\n            uint256 numExtraRewards = auraRewardPool().extraRewardsLength();\n            for (uint256 i; i < numExtraRewards; ) {\n                IAuraRewardPool extraRewardPool = IAuraRewardPool(auraRewardPool().extraRewards(i));\n                ERC20 extraRewardToken = ERC20(extraRewardPool.rewardToken());\n\n                uint256 extraRewardAmount = extraRewardToken.balanceOf(address(this));\n                uint256 extraRewardFee = (extraRewardAmount * fee()) / 10_000;\n                if (extraRewardAmount - extraRewardFee > 0) {\n                    extraRewardToken.safeTransfer(owner(), extraRewardAmount - extraRewardFee);\n                    emit RewardsClaimed(\n                        address(extraRewardToken),\n                        extraRewardAmount - extraRewardFee\n                    );\n                }\n                if (extraRewardFee > 0) extraRewardToken.safeTransfer(TRSRY(), extraRewardFee);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "sherlock-olympus/src/policies/BoostedLiquidity/BLVaultManagerLido.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport {MINTRv1} from \"src/modules/MINTR/MINTR.v1.sol\";\nimport {ROLESv1, RolesConsumer} from \"src/modules/ROLES/OlympusRoles.sol\";\nimport {TRSRYv1} from \"src/modules/TRSRY/TRSRY.v1.sol\";\nimport {BLREGv1} from \"src/modules/BLREG/BLREG.v1.sol\";\nimport \"src/Kernel.sol\";\n\n// Import external dependencies\nimport {AggregatorV3Interface} from \"interfaces/AggregatorV2V3Interface.sol\";\nimport {IAuraRewardPool, IAuraMiningLib} from \"policies/BoostedLiquidity/interfaces/IAura.sol\";\nimport {JoinPoolRequest, IVault, IBasePool, IBalancerHelper} from \"policies/BoostedLiquidity/interfaces/IBalancer.sol\";\nimport {IWsteth} from \"policies/BoostedLiquidity/interfaces/ILido.sol\";\n\n// Import vault dependencies\nimport {RewardsData} from \"policies/BoostedLiquidity/interfaces/IBLVaultLido.sol\";\nimport {IBLVaultManagerLido} from \"policies/BoostedLiquidity/interfaces/IBLVaultManagerLido.sol\";\nimport {BLVaultLido} from \"policies/BoostedLiquidity/BLVaultLido.sol\";\n\n// Import libraries\nimport {ClonesWithImmutableArgs} from \"clones/ClonesWithImmutableArgs.sol\";\n\ncontract BLVaultManagerLido is Policy, IBLVaultManagerLido, RolesConsumer {\n    using ClonesWithImmutableArgs for address;\n\n    // ========= ERRORS ========= //\n\n    error BLManagerLido_AlreadyActive();\n    error BLManagerLido_AlreadyInactive();\n    error BLManagerLido_Inactive();\n    error BLManagerLido_InvalidVault();\n    error BLManagerLido_LimitViolation();\n    error BLManagerLido_InvalidLpAmount();\n    error BLManagerLido_InvalidLimit();\n    error BLManagerLido_InvalidFee();\n    error BLManagerLido_BadPriceFeed();\n    error BLManagerLido_VaultAlreadyExists();\n\n    // ========= EVENTS ========= //\n\n    event VaultDeployed(address vault, address owner, uint64 fee);\n\n    // ========= STATE VARIABLES ========= //\n\n    // Modules\n    MINTRv1 public MINTR;\n    TRSRYv1 public TRSRY;\n    BLREGv1 public BLREG;\n\n    // Tokens\n    address public ohm;\n    address public pairToken; // wstETH for this implementation\n    address public aura;\n    address public bal;\n\n    // Exchange Info\n    string public exchangeName;\n    BalancerData public balancerData;\n\n    // Aura Info\n    AuraData public auraData;\n    IAuraMiningLib public auraMiningLib;\n\n    // Oracle Info\n    OracleFeed public ohmEthPriceFeed;\n    OracleFeed public stethEthPriceFeed;\n\n    // Vault Info\n    BLVaultLido public implementation;\n    mapping(BLVaultLido => address) public vaultOwners;\n    mapping(address => BLVaultLido) public userVaults;\n\n    // Vaults State\n    uint256 public totalLp;\n    uint256 public deployedOhm;\n    uint256 public circulatingOhmBurned;\n\n    // System Configuration\n    uint256 public ohmLimit;\n    uint64 public currentFee;\n    bool public isLidoBLVaultActive;\n\n    // Constants\n    uint32 public constant MAX_FEE = 10_000; // 100%\n\n    //============================================================================================//\n    //                                      POLICY SETUP                                          //\n    //============================================================================================//\n\n    constructor(\n        Kernel kernel_,\n        TokenData memory tokenData_,\n        BalancerData memory balancerData_,\n        AuraData memory auraData_,\n        address auraMiningLib_,\n        OracleFeed memory"
    }
  ]
}