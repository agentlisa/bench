{
  "Title": "[M-14] Wrong reward distribution in Bribe because `deliverReward()` won't set `tokenRewardsPerEpoch[token][epochStart]` to 0",
  "Content": "\n[Bribe.sol#L83-L90](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L83-L90)<br>\n\nFunction `deliverReward()` in `Bribe` contract won't set `tokenRewardsPerEpoch[token][epochStart]` to `0` after transferring rewards. `Gauge.getReward()` calls `Voter.distribute()` which calls `Gauge.deliverBribes()` which calls `Bribe.deliverReward()`. so if `Gauge.getReward()` or `Voter.distribute()` get called multiple times in same epoch then `deliverReward()` will transfer `Bribe` tokens multiple times because it doesn't set `tokenRewardsPerEpoch[token][epochStart]` to `0` after transferring.\n\n### Proof of Concept\n\nThis is `deliverReward()` code in `Bribe`:\n\n      function deliverReward(address token, uint epochStart) external lock returns (uint) {\n        require(msg.sender == gauge);\n        uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];\n        if (rewardPerEpoch > 0) {\n          _safeTransfer(token, address(gauge), rewardPerEpoch);\n        }\n        return rewardPerEpoch;\n      }\n\nAs you can see it doesn't set `tokenRewardsPerEpoch[token][epochStart]` value to `0`, so if this function get called multiple times it will transfer epoch rewards multiple times (it will use other epoch's rewards tokens).<br>\nfunction `Gauge.deliverBribes()` calls `Bribe.deliverReward()` and  `Gauge.deliverBribes()` is called by `Voter.distribute()` if the condition `claimable[_gauge] > DURATION` is `True`. This is those functions codes:\n\n        function deliverBribes() external lock {\n            require(msg.sender == voter);\n            IBribe sb = IBribe(bribe);\n            uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n            uint numRewards = sb.rewardsListLength();\n\n            for (uint i = 0; i < numRewards; i++) {\n                address token = sb.rewards(i);\n                uint epochRewards = sb.deliverReward(token, bribeStart);\n                if (epochRewards > 0) {\n                    _notifyBribeAmount(token, epochRewards, bribeStart);\n                }\n            }\n        }\n\n<!---->\n\n        function distribute(address _gauge) public lock {\n            require(isAlive[_gauge]); // killed gauges cannot distribute\n            uint dayCalc = block.timestamp % (7 days);\n            require((dayCalc < BRIBE_LAG) || (dayCalc > (DURATION + BRIBE_LAG)), \"cannot claim during votes period\");\n            IMinter(minter).update_period();\n            _updateFor(_gauge);\n            uint _claimable = claimable[_gauge];\n            if (_claimable > IGauge(_gauge).left(base) && _claimable / DURATION > 0) {\n                claimable[_gauge] = 0;\n                IGauge(_gauge).notifyRewardAmount(base, _claimable);\n                emit DistributeReward(msg.sender, _gauge, _claimable);\n                // distribute bribes & fees too\n                IGauge(_gauge).deliverBribes();\n            }\n        }\n\nalso `Gauge.getReward()` calls `Voter.getReward()`.<br>\ncondition `claimable[_gauge] > DURATION` in `Voter.distribute()` can be true multiple time in one epoch (`deliverBribes()` would be called multiple times) because `claimable[_gauge]` is based on `index` and `index` increase by `notifyRewardAmount()` in `Voter` anytime.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nSet `tokenRewardsPerEpoch[token][epochStart]` to `0` in `deliverReward`.\n\n**[pooltypes (Velodrome) confirmed and commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/141#issuecomment-1154100654):**\n > Thanks, this is an issue we discovered in prod. Issuing a fix soon.\n> \n > We're also taking the necessary steps to alert any users who may have funds at risk from this issue.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/141#issuecomment-1171804425):**\n > `tokenRewardsPerEpoch[token][epochStart]` is indeed not resetted on each claim\n> \n> Proving the finding is reliant on ` claimable[_gauge] += _share;` which is set in `_updateFor`\n> \n> Which is contingent on `index += _ratio;` in `notifyRewardAmount`\n> \n> Because `notifyRewardAmount` can be called by anyone, at the cost of an amount that just needs to be greater than or equal to `totalWeight / 1e18` which may be a negligible amount, then indeed `index` can increase, allowing the bribe to be called multiple times in one epoch.\n> \n> In terms of impact, because the Bribe contract only allows for an extremely basic, now or in 7 days, type queueing of bribes, the accounting of bribes is mostly unnecessary (as the contract will most of the times be sending all tokens anyway).\n> \n> Additionally the loss would amount to an incorrect amount of bribes emitted over 7 days instead of 14.\n> \n> For those reasons, I think Medium Severity to be more appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-05-velodrome",
  "Code": [
    {
      "filename": "contracts/contracts/Bribe.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGauge.sol';\n\ncontract Bribe is IBribe {\n  uint internal constant DURATION = 5 days; // rewards are released over the voting period\n  uint internal constant BRIBE_LAG = 1 days;\n  uint internal constant COOLDOWN = 12 hours;\n  uint internal constant MAX_REWARD_TOKENS = 16;\n\n  address public gauge;\n  mapping(address => mapping(uint => uint)) public tokenRewardsPerEpoch;\n  address[] public rewards;\n  mapping(address => bool) public isReward;\n\n  event NotifyReward(address indexed from, address indexed reward, uint epoch, uint amount);\n\n  // simple re-entrancy check\n  uint internal _unlocked = 1;\n  modifier lock() {\n      require(_unlocked == 1);\n      _unlocked = 2;\n      _;\n      _unlocked = 1;\n  }\n\n  function setGauge(address _gauge) external {\n    require(gauge == address(0), \"gauge already set\");\n    gauge = _gauge;\n  }\n\n  function getEpochStart(uint timestamp) public view returns (uint) {\n    uint bribeStart = timestamp - (timestamp % (7 days)) + BRIBE_LAG;\n    uint bribeEnd = bribeStart + DURATION - COOLDOWN;\n    return timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;\n  }\n\n  function notifyRewardAmount(address token, uint amount) external lock {\n      require(amount > 0);\n      if (!isReward[token]) {\n        require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      }\n      // bribes kick in at the start of next bribe period\n      uint adjustedTstamp = getEpochStart(block.timestamp);\n      uint epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];\n\n      _safeTransferFrom(token, msg.sender, address(this), amount);\n      tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\n\n      if (!isReward[token]) {\n          isReward[token] = true;\n          rewards.push(token);\n          IGauge(gauge).addBribeRewardToken(token);\n      }\n\n      emit NotifyReward(msg.sender, token, adjustedTstamp, amount);\n  }\n\n  function rewardsListLength() external view returns (uint) {\n      return rewards.length;\n  }\n\n  function addRewardToken(address token) external {\n    require(msg.sender == gauge);\n    if (!isReward[token]) {\n      require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      isReward[token] = true;\n      rewards.push(token);\n    }\n  }\n\n  function swapOutRewardToken(uint i, address oldToken, address newToken) external {\n    require(msg.sender == gauge);\n    require(rewards[i] == oldToken);\n    isReward[oldToken] = false;\n    isReward[newToken] = true;\n    rewards[i] = newToken;\n  }\n\n  function deliverReward(address token, uint epochStart) external lock returns (uint) {\n    require(msg.sender == gauge);\n    uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];\n    if (rewardPerEpoch > 0) {\n      _safeTransfer(token, address(gauge), rewardPerEpoch);\n    }\n    return rewardPerEpoch;\n  }\n\n  function _safeTransfer(address token, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n\n  function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n}"
    }
  ]
}