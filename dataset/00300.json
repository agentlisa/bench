{
  "Title": "Loss of funds due to malicious forcing of `mintRecipient` onto Circle blacklist when CCTP message is in-flight",
  "Content": "**Description:** A scenario has been identified in which it may not be possible for the `mintRecipient` to execute redemption on the target domain due to the actions of a bad actor while an otherwise valid CCTP message is in-flight. It is ostensibly the responsibility of the user to correctly configure the `mintRecipient`; however, one could reasonably assume the case where an attacker dusts the `mintRecipient` address with funds stolen in a recent exploit, that may have been deposited to and subsequently withdrawn from an external protocol, or an OFAC-sanctioned token such as TORN, to force this address to become blacklisted by Circle on the target domain while the message is in-flight, thereby causing both the original sender and their intended target recipient to lose access to the tokens.\n\nIn the current design, it is not possible to update the `mintRecipient` for a given deposit due to the multicast nature of VAAs. CCTP exposes [`MessageTransmitter::replaceMessage`](https://github.com/circlefin/evm-cctp-contracts/blob/1662356f9e60bb3f18cb6d09f95f628f0cc3637f/src/MessageTransmitter.sol#L129-L181) which allows the original source caller to update the destination caller for a given message and its corresponding attestation; however, the Wormhole CCTP integration currently provides no access to this function and has no similar functionality of its own to allow updates to the target `mintRecipient` of the VAA. Without any method for replacing potentially affected VAAs with new VAAs specifying an updated `mintRecipient`, this could result in permanent denial-of-service on the `mintRecipient` receiving tokens on the target domain – the source USDC/EURC will be burnt, but it may be very unlikely that the legitimate recipient is ever able to mint the funds on the destination domain, and once the tokens are burned, there is no path to recovery on the source domain.\n\nThis type of scenario is likely to occur primarily where a bad actor intentionally attempts to sabotage a cross-chain transfer of funds that the source caller otherwise expects to be successful. A rational actor would not knowingly attempt a cross-chain transfer to a known blacklisted address, especially if the intended recipient is not a widely-used protocol, which tend to be exempt from sanctions even when receiving funds from a known attacker, but rather an independent EOA. In this case, the destination call to [`Logic::redeemTokensWithPayload`](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/contracts/CircleIntegration/Logic.sol#L61-L108) will fail when the CCTP contracts attempt to mint the tokens and can only be retried if the `mintRecipient` address somehow comes back off the Circle blacklist, the [mechanics of which](https://www.circle.com/hubfs/Blog%20Posts/Circle%20Stablecoin%20Access%20Denial%20Policy_pdf.pdf) are not overly clear. It is also possible that request(s) made by law-enforcement agencies for the blacklisting of an entire protocol X, as the mint recipient on target domain Y, will cause innocent users to also lose access to their bridged funds.\n\nIt is understood that the motivation for restricting message replacement functionality is due to the additional complexity in handling this edge case and ensuring that the VAA of the original message cannot be redeemed with the replaced CCTP attestation, given the additional attack surface. Given that it is not entirely clear how the Circle blacklisting policy would apply in this case, it would be best for someone with the relevant context to aid in making the decision based on this cost/benefit analysis. If it is the case that a victim can be forced onto the blacklist without a clear path to resolution, then this clearly is not ideal. Even if they are eventually able to have this issue resolved, the impact could be time-sensitive in nature, thinking in the context of cross-chain actions that may need to perform some rebalancing/liquidation function, plus a sufficiently motivated attacker could potentially repeatedly front-run any subsequent attempts at minting on the target domain. It is not entirely clear how likely this final point is in practice, once the messages are no longer in-flight and simply ready for execution on the destination, since it is assumed the blacklist would not likely be updated that quickly. In any case, it is agreed that allowing message replacement will add a non-trivial amount of complexity and does indeed increase the attack surface, as previously identified. So depending on how the blacklist is intended to function, it may be worth allowing message replacement, but it is not possible to say with certainty whether this issue is worth addressing.\n\n**Impact:** There is only a single address that is permitted to execute a given VAA on the target domain; however, there exists a scenario in which this `mintReceipient` may be permanently unable to perform redemption due to the malicious addition of this address to the Circle blacklist. In this case, there is a material loss of funds with reasonable likelihood.\n\n**Proof of Concept:**\n1. Alice burns 10,000 USDC on CCTP Domain A to be transferred to her EOA on CCTP Domain B.\n2. While this CCTP message is in-flight, an attacker withdraws a non-trivial amount of USDC, that was previously obtained from a recent exploit, from protocol X to Alice's EOA on CCTP domain B.\n3. Law enforcement notifies Circle to blacklist Alice's EOA, which now holds stolen funds.\n4. Alice attempts to redeem 10,000 USDC on CCTP Domain B, but minting fails because her EOA is now blacklisted on the USDC contract.\n5. The 10,000 USDC remains burnt and cannot be minted on the target domain since the VAA containing the attested CCTP message can never be executed without the USDC mint reverting.\n\n**Recommended Mitigation:** Consider allowing VAAs to be replaced by new VAAs for a given CCTP message and corresponding attestation, so long as they have not already been consumed on the target domain. Alternatively, consider adding an additional Governance action dedicated to the purpose of recovering the USDC burnt by a VAA that has not yet been consumed on the target domain due to malicious blacklisting.\n\n**Wormhole Foundation:** Although CCTP has the ability to replace messages, it is also subject to this same issue since the original message recipient [can’t be changed](https://github.com/circlefin/evm-cctp-contracts/blob/adb2a382b09ea574f4d18d8af5b6706e8ed9b8f2/src/MessageTransmitter.sol#L170-L175).\n\n**Cyfrin:** Acknowledged.\n\n\\clearpage",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/MessageTransmitter.sol",
      "content": "/*\n * Copyright (c) 2022, Circle Internet Financial Limited.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npragma solidity 0.7.6;\n\nimport \"@memview-sol/contracts/TypedMemView.sol\";\nimport \"./interfaces/IMessageTransmitter.sol\";\nimport \"./interfaces/IMessageHandler.sol\";\nimport \"./messages/Message.sol\";\nimport \"./roles/Pausable.sol\";\nimport \"./roles/Rescuable.sol\";\nimport \"./roles/Attestable.sol\";\n\n/**\n * @title MessageTransmitter\n * @notice Contract responsible for sending and receiving messages across chains.\n */\ncontract MessageTransmitter is\n    IMessageTransmitter,\n    Pausable,\n    Rescuable,\n    Attestable\n{\n    // ============ Events ============\n    /**\n     * @notice Emitted when a new message is dispatched\n     * @param message Raw bytes of message\n     */\n    event MessageSent(bytes message);\n\n    /**\n     * @notice Emitted when a new message is received\n     * @param caller Caller (msg.sender) on destination domain\n     * @param sourceDomain The source domain this message originated from\n     * @param nonce The nonce unique to this message\n     * @param sender The sender of this message\n     * @param messageBody message body bytes\n     */\n    event MessageReceived(\n        address indexed caller,\n        uint32 sourceDomain,\n        uint64 indexed nonce,\n        bytes32 sender,\n        bytes messageBody\n    );\n\n    /**\n     * @notice Emitted when max message body size is updated\n     * @param newMaxMessageBodySize new maximum message body size, in bytes\n     */\n    event MaxMessageBodySizeUpdated(uint256 newMaxMessageBodySize);\n\n    // ============ Libraries ============\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n    using Message for bytes29;\n\n    // ============ State Variables ============\n    // Domain of chain on which the contract is deployed\n    uint32 public immutable localDomain;\n\n    // Message Format version\n    uint32 public immutable version;\n\n    // Maximum size of message body, in bytes.\n    // This value is set by owner.\n    uint256 public maxMessageBodySize;\n\n    // Next available nonce from this source domain\n    uint64 public nextAvailableNonce;\n\n    // Maps a bytes32 hash of (sourceDomain, nonce) -> uint256 (0 if unused, 1 if used)\n    mapping(bytes32 => uint256) public usedNonces;\n\n    // ============ Constructor ============\n    constructor(\n        uint32 _localDomain,\n        address _attester,\n        uint32 _maxMessageBodySize,\n        uint32 _version\n    ) Attestable(_attester) {\n        localDomain = _localDomain;\n        maxMessageBodySize = _maxMessageBodySize;\n        version = _version;\n    }\n\n    // ============ External Functions  ============\n    /**\n     * @notice Send the message to the destination domain and recipient\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination chain as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes calldata messageBody\n    ) external override whenNotPaused returns (uint64) {\n        bytes32 _emptyDestinationCaller = bytes32(0);\n        uint64 _nonce = _reserveAndIncrementNonce();\n        bytes32 _messageSender = Message.addressToBytes32(msg.sender);\n\n        _sendMessage(\n            destinationDomain,\n            recipient,\n            _emptyDestinationCaller,\n            _messageSender,\n            _nonce,\n            messageBody\n        );\n\n        return _nonce;\n    }\n\n    /**\n     * @notice Replace a message with a new message body and/or destination caller.\n     * @dev The `originalAttestation` must be a valid attestation of `originalMessage`.\n     * Reverts if msg.sender does not match sender of original message, or if the source domain of the original message\n     * does not match this MessageTransmitter's local domain.\n     * @param originalMessage original message to replace\n     * @param originalAttestation attestation of `originalMessage`\n     * @param newMessageBody new message body of replaced message\n     * @param newDestinationCaller the new destination caller, which may be the\n     * same as the original destination caller, a new destination caller, or an empty\n     * destination caller (bytes32(0), indicating that any destination caller is valid.)\n     */\n    function replaceMessage(\n        bytes calldata originalMessage,\n        bytes calldata originalAttestation,\n        bytes calldata newMessageBody,\n        bytes32 newDestinationCaller\n    ) external override whenNotPaused {\n        // Validate each signature in the attestation\n        _verifyAttestationSignatures(originalMessage, originalAttestation);\n\n        bytes29 _originalMsg = originalMessage.ref(0);\n\n        // Validate message format\n        _originalMsg._validateMessageFormat();\n\n        // Validate message sender\n        bytes32 _sender = _originalMsg._sender();\n        require(\n            msg.sender == Message.bytes32ToAddress(_sender),\n            \"Sender not permitted to use nonce\"\n        );\n\n        // Validate source domain\n        uint32 _sourceDomain = _originalMsg._sourceDomain();\n        require(\n            _sourceDomain == localDomain,\n            \"Message not originally sent from this domain\"\n        );\n\n        uint32 _destinationDomain = _originalMsg._destinationDomain();\n        bytes32 _recipient = _originalMsg._recipient();\n        uint64 _nonce = _originalMsg._nonce();\n\n        _sendMessage(\n            _destinationDomain,\n            _recipient,\n            newDestinationCaller,\n            _sender,\n            _nonce,\n            newMessageBody\n        );\n    }\n\n    /**\n     * @notice Send the message to the destination domain and recipient, for a specified `destinationCaller` on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external override whenNotPaused returns (uint64) {\n        require(\n            destinationCaller != bytes32(0),\n            \"Destination caller must be nonzero\"\n        );\n\n        uint64 _nonce = _reserveAndIncrementNonce();\n        bytes32 _messageSender = Message.addressToBytes32(msg.sender);\n\n        _sendMessage(\n            destinationDomain,\n            recipient,\n            destinationCaller,\n            _messageSender,\n            _nonce,\n            messageBody\n        );\n\n        return _nonce;\n    }\n\n    /**\n     * @notice Receive a message. Messages with a given nonce\n     * can only be broadcast once for a (sourceDomain, destinationDomain)\n     * pair. The message body of a valid message is passed to the\n     * specified recipient for further processing.\n     *\n     * @dev Attestation format:\n     * A valid attestation is the concatenated 65-byte signature(s) of exactly\n     * `thresholdSignature` signatures, in increasing order of attester address.\n     * ***If the attester addresses recovered from signatures are not in\n     * increasing order, signature verification will fail.***\n     * If incorrect number of signatures or duplicate signatures are supplied,\n     * signature verification will fail.\n     *\n     * Message format:\n     * Field                 Bytes      Type       Index\n     * version               4          uint32     0\n     * sourceDomain          4          uint32     4\n     * destinationDomain     4          uint32     8\n     * nonce                 8          uint64     12\n     * sender                32         bytes32    20\n     * recipient             32         bytes32    52\n     * messageBody           dynamic    bytes      84\n     * @param message Message bytes\n     * @param attestation Concatenated 65-byte signature(s) of `message`, in increasing order\n     * of the attester address recovered from signatures.\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata attestation)\n        external\n        override\n        whenNotPaused\n        returns (bool success)\n    {\n        // Validate each signature in the attestation\n        _verifyAttestationSignatures(message, attestation);\n\n        bytes29 _msg = message.ref(0);\n\n        // Validate message format\n        _msg._validateMessageFormat();\n\n        // Validate domain\n        require(\n            _msg._destinationDomain() == localDomain,\n            \"Invalid destination domain\"\n        );\n\n        // Validate destination caller\n        if (_msg._destinationCaller() != bytes32(0)) {\n            require(\n                _msg._destinationCaller() ==\n                    Message.addressToBytes32(msg.sender),\n                \"Invalid caller for message\"\n            );\n        }\n\n        // Validate version\n        require(_msg._version() == version, \"Invalid message version\");\n\n        // Validate nonce is available\n        uint32 _sourceDomain = _msg._sourceDomain();\n        uint64 _nonce = _msg._nonce();\n        bytes32 _sourceAndNonce = _hashSourceAndNonce(_sourceDomain, _nonce);\n        require(usedNonces[_sourceAndNonce] == 0, \"Nonce already used\");\n        // Mark nonce used\n        usedNonces[_sourceAndNonce] = 1;\n\n        // Handle receive message\n        bytes32 _sender = _msg._sender();\n        bytes memory _messageBody = _msg._messageBody().clone();\n        require(\n            IMessageHandler(Message.bytes32ToAddress(_msg._recipient()))\n                .handleReceiveMessage(_sourceDomain, _sender, _messageBody),\n            \"handleReceiveMessage() failed\"\n        );\n\n        // Emit MessageReceived event\n        emit MessageReceived(\n            msg.sender,\n            _sourceDomain,\n            _nonce,\n            _sender,\n            _messageBody\n        );\n        return true;\n    }\n\n    /**\n     * @notice Sets the max message body size\n     * @dev This value should not be reduced without good reason,\n     * to avoid impacting users who rely on large messages.\n     * @param newMaxMessageBodySize new max message body size, in bytes\n     */\n    function setMaxMessageBodySize(uint256 newMaxMessageBodySize)\n        external\n        onlyOwner\n    {\n        maxMessageBodySize = newMaxMessageBodySize;\n        emit MaxMessageBodySizeUpdated(maxMessageBodySize);\n    }\n\n    // ============ Internal Utils ============\n    /**\n     * @notice Send the message to the destination domain and recipient. If `_destinationCaller` is not equal to bytes32(0),\n     * the message can only be received on the destination chain when called by `_destinationCaller`.\n     * @dev Format the message and emit `MessageSent` event with message information.\n     * @param _destinationDomain Domain of destination chain\n     * @param _recipient Address of message recipient on destination domain as bytes32\n     * @param _destinationCaller caller on the destination domain, as bytes32\n     * @param _sender message sender, as bytes32\n     * @param _nonce nonce reserved for message\n     * @param _messageBody Raw bytes content of message\n     */\n    function _sendMessage(\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        bytes32 _destinationCaller,\n        bytes32 _sender,\n        uint64 _nonce,\n        bytes calldata _messageBody\n    ) internal {\n        // Validate message body length\n        require(\n            _messageBody.length <= maxMessageBodySize,\n            \"Message body exceeds max size\"\n        );\n\n        require(_recipient != bytes32(0), \"Recipient must be nonzero\");\n\n        // serialize message\n        bytes memory _message = Message._formatMessage(\n            version,\n            localDomain,\n            _destinationDomain,\n            _nonce,\n            _sender,\n            _recipient,\n            _destinationCaller,\n            _messageBody\n        );\n\n        // Emit MessageSent event\n        emit MessageSent(_message);\n    }\n\n    /**\n     * @notice hashes `_source` and `_nonce`.\n     * @param _source Domain of chain where the transfer originated\n     * @param _nonce The unique identifier for the message from source to\n              destination\n     * @return hash of source and nonce\n     */\n    function _hashSourceAndNonce(uint32 _source, uint64 _nonce)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_source, _nonce));\n    }\n\n    /**\n     * Reserve and increment next available nonce\n     * @return nonce reserved\n     */\n    function _reserveAndIncrementNonce() internal returns (uint64) {\n        uint64 _nonceReserved = nextAvailableNonce;\n        nextAvailableNonce = nextAvailableNonce + 1;\n        return _nonceReserved;\n    }\n}"
    },
    {
      "filename": "evm/src/contracts/CircleIntegration/Logic.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IWormhole} from \"src/interfaces/IWormhole.sol\";\nimport {IMessageTransmitter} from \"src/interfaces/IMessageTransmitter.sol\";\nimport {ITokenMessenger} from \"src/interfaces/ITokenMessenger.sol\";\nimport {ITokenMinter} from \"src/interfaces/ITokenMinter.sol\";\nimport {ICircleIntegration} from \"src/interfaces/ICircleIntegration.sol\";\n\nimport {Utils} from \"src/libraries/Utils.sol\";\nimport {WormholeCctpMessages} from \"src/libraries/WormholeCctpMessages.sol\";\n\nimport {Governance} from \"./Governance.sol\";\nimport {\n    getChainToDomain,\n    getConsumedVaas,\n    getDomainToChain,\n    getInitializedImplementations,\n    getRegisteredEmitters\n} from \"./Storage.sol\";\n\nabstract contract Logic is ICircleIntegration, Governance {\n    using Utils for address;\n    using SafeERC20 for IERC20;\n    using WormholeCctpMessages for *;\n\n    /// @inheritdoc ICircleIntegration\n    function transferTokensWithPayload(\n        TransferParameters calldata transferParams,\n        uint32 wormholeNonce,\n        bytes calldata payload\n    ) public payable returns (uint64 wormholeSequence) {\n        // Is the foreign Wormhole Circle Integration registered?\n        bytes32 destinationCaller = getRegisteredEmitters()[transferParams.targetChain];\n        require(destinationCaller != 0, \"target contract not registered\");\n\n        // Deposit tokens into this contract to prepare for burning.\n        IERC20(transferParams.token).safeTransferFrom(\n            msg.sender, address(this), transferParams.amount\n        );\n\n        // Approve the Token Messenger to spend tokens.\n        setTokenMessengerApproval(transferParams.token, transferParams.amount);\n\n        // Invoke Token Messenger to burn tokens and emit a CCTP token burn message.\n        (wormholeSequence,) = burnAndPublish(\n            destinationCaller,\n            getChainToDomain()[transferParams.targetChain],\n            transferParams.token,\n            transferParams.amount,\n            transferParams.mintRecipient,\n            wormholeNonce,\n            payload,\n            msg.value\n        );\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function redeemTokensWithPayload(RedeemParameters calldata params)\n        public\n        returns (DepositWithPayload memory deposit)\n    {\n        // This check prevents this contract existing on this network's potential fork, where it was\n        // not freshly deployed. This is a safety measure to prevent replay attacks on the forked\n        // network.\n        require(evmChain() == block.chainid, \"invalid evm chain\");\n\n        // Verify the VAA and mint tokens. Set the deposit struct with WormholeCctpTokenMessenger's\n        // return values.\n        IWormhole.VM memory vaa;\n        (\n            vaa,\n            deposit.token,\n            deposit.amount,\n            deposit.sourceDomain,\n            deposit.targetDomain,\n            deposit.nonce,\n            deposit.fromAddress,\n            deposit.mintRecipient,\n            deposit.payload\n        ) = verifyVaaAndMintLegacy(\n            params.encodedCctpMessage, params.cctpAttestation, params.encodedVaa\n        );\n\n        // Confirm that the caller is the `mintRecipient` to ensure atomic execution.\n        require(\n            msg.sender.toUniversalAddress() == deposit.mintRecipient, \"caller must be mintRecipient\"\n        );\n\n        // If this VAA does not come from a registered Wormhole Circle Integration contract, revert.\n        requireEmitterLegacy(vaa, getRegisteredEmitters()[vaa.emitterChainId]);\n\n        mapping(bytes32 => bool) storage consumedVaas = getConsumedVaas();\n\n        // Revert if this message has been consumed already. This check is meant to prevent replay\n        // attacks, but it may not be necessary because the CCTP Message Transmitter already keeps\n        // track of used nonces.\n        require(!consumedVaas[vaa.hash], \"message already consumed\");\n\n        // Mark as consumed.\n        consumedVaas[vaa.hash] = true;\n\n        // Emit Redeemed event.\n        emit Redeemed(vaa.emitterChainId, vaa.emitterAddress, vaa.sequence);\n    }\n\n    // getters\n\n    /// @inheritdoc ICircleIntegration\n    function fetchLocalTokenAddress(uint32 remoteDomain, bytes32 remoteToken)\n        public\n        view\n        returns (bytes32)\n    {\n        return fetchLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function addressToBytes32(address evmAddr) public pure returns (bytes32 converted) {\n        converted = evmAddr.toUniversalAddress();\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function decodeDepositWithPayload(bytes memory encoded)\n        public\n        pure\n        returns (DepositWithPayload memory deposit)\n    {\n        // This is a hack to get around using the decodeDeposit method. This is not a real VM\n        // obviously.\n        //\n        // Plus, this getter should never be used in practice.\n        IWormhole.VM memory fakeVaa;\n        fakeVaa.payload = encoded;\n        (\n            deposit.token,\n            deposit.amount,\n            deposit.sourceDomain,\n            deposit.targetDomain,\n            deposit.nonce,\n            deposit.fromAddress,\n            deposit.mintRecipient,\n            deposit.payload\n        ) = fakeVaa.decodeDeposit();\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function encodeDepositWithPayload(DepositWithPayload memory message)\n        public\n        pure\n        returns (bytes memory encoded)\n    {\n        encoded = message.token.encodeDeposit(\n            message.amount,\n            message.sourceDomain,\n            message.targetDomain,\n            message.nonce,\n            message.fromAddress,\n            message.mintRecipient,\n            message.payload\n        );\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function isInitialized(address impl) public view returns (bool) {\n        return getInitializedImplementations()[impl];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function wormhole() public view returns (IWormhole) {\n        return _wormhole;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function chainId() public view returns (uint16) {\n        return _chainId;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function wormholeFinality() public pure returns (uint8) {\n        return _MESSAGE_FINALITY;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function circleBridge() public view returns (ITokenMessenger) {\n        return _tokenMessenger;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function circleTokenMinter() public view returns (ITokenMinter) {\n        return _tokenMinter;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function circleTransmitter() public view returns (IMessageTransmitter) {\n        return _messageTransmitter;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function getRegisteredEmitter(uint16 chain) public view returns (bytes32) {\n        return getRegisteredEmitters()[chain];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function isAcceptedToken(address token) public view returns (bool) {\n        return _tokenMinter.burnLimitsPerMessage(token) > 0;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function getDomainFromChainId(uint16 chain) public view returns (uint32) {\n        return getChainToDomain()[chain];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function getChainIdFromDomain(uint32 cctpDomain) public view returns (uint16) {\n        return getDomainToChain()[cctpDomain];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function isMessageConsumed(bytes32 vaaHash) public view returns (bool) {\n        return getConsumedVaas()[vaaHash];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function localDomain() public view returns (uint32) {\n        return _localCctpDomain;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function evmChain() public view returns (uint256) {\n        return _evmChain;\n    }\n}"
    },
    {
      "filename": "src/MessageTransmitter.sol",
      "content": "/*\n * Copyright (c) 2022, Circle Internet Financial Limited.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npragma solidity 0.7.6;\n\nimport \"@memview-sol/contracts/TypedMemView.sol\";\nimport \"./interfaces/IMessageTransmitter.sol\";\nimport \"./interfaces/IMessageHandler.sol\";\nimport \"./messages/Message.sol\";\nimport \"./roles/Pausable.sol\";\nimport \"./roles/Rescuable.sol\";\nimport \"./roles/Attestable.sol\";\n\n/**\n * @title MessageTransmitter\n * @notice Contract responsible for sending and receiving messages across chains.\n */\ncontract MessageTransmitter is\n    IMessageTransmitter,\n    Pausable,\n    Rescuable,\n    Attestable\n{\n    // ============ Events ============\n    /**\n     * @notice Emitted when a new message is dispatched\n     * @param message Raw bytes of message\n     */\n    event MessageSent(bytes message);\n\n    /**\n     * @notice Emitted when a new message is received\n     * @param caller Caller (msg.sender) on destination domain\n     * @param sourceDomain The source domain this message originated from\n     * @param nonce The nonce unique to this message\n     * @param sender The sender of this message\n     * @param messageBody message body bytes\n     */\n    event MessageReceived(\n        address indexed caller,\n        uint32 sourceDomain,\n        uint64 indexed nonce,\n        bytes32 sender,\n        bytes messageBody\n    );\n\n    /**\n     * @notice Emitted when max message body size is updated\n     * @param newMaxMessageBodySize new maximum message body size, in bytes\n     */\n    event MaxMessageBodySizeUpdated(uint256 newMaxMessageBodySize);\n\n    // ============ Libraries ============\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n    using Message for bytes29;\n\n    // ============ State Variables ============\n    // Domain of chain on which the contract is deployed\n    uint32 public immutable localDomain;\n\n    // Message Format version\n    uint32 public immutable version;\n\n    // Maximum size of message body, in bytes.\n    // This value is set by owner.\n    uint256 public maxMessageBodySize;\n\n    // Next available nonce from this source domain\n    uint64 public nextAvailableNonce;\n\n    // Maps a bytes32 hash of (sourceDomain, nonce) -> uint256 (0 if unused, 1 if used)\n    mapping(bytes32 => uint256) public usedNonces;\n\n    // ============ Constructor ============\n    constructor(\n        uint32 _localDomain,\n        address _attester,\n        uint32 _maxMessageBodySize,\n        uint32 _version\n    ) Attestable(_attester) {\n        localDomain = _localDomain;\n        maxMessageBodySize = _maxMessageBodySize;\n        version = _version;\n    }\n\n    // ============ External Functions  ============\n    /**\n     * @notice Send the message to the destination domain and recipient\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination chain as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes calldata messageBody\n    ) external override whenNotPaused returns (uint64) {\n        bytes32 _emptyDestinationCaller = bytes32(0);\n        uint64 _nonce = _reserveAndIncrementNonce();\n        bytes32 _messageSender = Message.addressToBytes32(msg.sender);\n\n        _sendMessage(\n            destinationDomain,\n            recipient,\n            _emptyDestinationCaller,\n            _messageSender,\n            _nonce,\n            messageBody\n        );\n\n        return _nonce;\n    }\n\n    /**\n     * @notice Replace a message with a new message body and/or destination caller.\n     * @dev The `originalAttestation` must be a valid attestation of `originalMessage`.\n     * Reverts if msg.sender does not match sender of original message, or if the source domain of the original message\n     * does not match this MessageTransmitter's local domain.\n     * @param originalMessage original message to replace\n     * @param originalAttestation attestation of `originalMessage`\n     * @param newMessageBody new message body of replaced message\n     * @param newDestinationCaller the new destination caller, which may be the\n     * same as the original destination caller, a new destination caller, or an empty\n     * destination caller (bytes32(0), indicating that any destination caller is valid.)\n     */\n    function replaceMessage(\n        bytes calldata originalMessage,\n        bytes calldata originalAttestation,\n        bytes calldata newMessageBody,\n        bytes32 newDestinationCaller\n    ) external override whenNotPaused {\n        // Validate each signature in the attestation\n        _verifyAttestationSignatures(originalMessage, originalAttestation);\n\n        bytes29 _originalMsg = originalMessage.ref(0);\n\n        // Validate message format\n        _originalMsg._validateMessageFormat();\n\n        // Validate message sender\n        bytes32 _sender = _originalMsg._sender();\n        require(\n            msg.sender == Message.bytes32ToAddress(_sender),\n            \"Sender not permitted to use nonce\"\n        );\n\n        // Validate source domain\n        uint32 _sourceDomain = _originalMsg._sourceDomain();\n        require(\n            _sourceDomain == localDomain,\n            \"Message not originally sent from this domain\"\n        );\n\n        uint32 _destinationDomain = _originalMsg._destinationDomain();\n        bytes32 _recipient = _originalMsg._recipient();\n        uint64 _nonce = _originalMsg._nonce();\n\n        _sendMessage(\n            _destinationDomain,\n            _recipient,\n            newDestinationCaller,\n            _sender,\n            _nonce,\n            newMessageBody\n        );\n    }\n\n    /**\n     * @notice Send the message to the destination domain and recipient, for a specified `destinationCaller` on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external override whenNotPaused returns (uint64) {\n        require(\n            destinationCaller != bytes32(0),\n            \"Destination caller must be nonzero\"\n        );\n\n        uint64 _nonce = _reserveAndIncrementNonce();\n        bytes32 _messageSender = Message.addressToBytes32(msg.sender);\n\n        _sendMessage(\n            destinationDomain,\n            recipient,\n            destinationCaller,\n            _messageSender,\n            _nonce,\n            messageBody\n        );\n\n        return _nonce;\n    }\n\n    /**\n     * @notice Receive a message. Messages with a given nonce\n     * can only be broadcast once for a (sourceDomain, destinationDomain)\n     * pair. The message body of a valid message is passed to the\n     * specified recipient for further processing.\n     *\n     * @dev Attestation format:\n     * A valid attestation is the concatenated 65-byte signature(s) of exactly\n     * `thresholdSignature` signatures, in increasing order of attester address.\n     * ***If the attester addresses recovered from signatures are not in\n     * increasing order, signature verification will fail.***\n     * If incorrect number of signatures or duplicate signatures are supplied,\n     * signature verification will fail.\n     *\n     * Message format:\n     * Field                 Bytes      Type       Index\n     * version               4          uint32     0\n     * sourceDomain          4          uint32     4\n     * destinationDomain     4          uint32     8\n     * nonce                 8          uint64     12\n     * sender                32         bytes32    20\n     * recipient             32         bytes32    52\n     * messageBody           dynamic    bytes      84\n     * @param message Message bytes\n     * @param attestation Concatenated 65-byte signature(s) of `message`, in increasing order\n     * of the attester address recovered from signatures.\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata attestation)\n        external\n        override\n        whenNotPaused\n        returns (bool success)\n    {\n        // Validate each signature in the attestation\n        _verifyAttestationSignatures(message, attestation);\n\n        bytes29 _msg = message.ref(0);\n\n        // Validate message format\n        _msg._validateMessageFormat();\n\n        // Validate domain\n        require(\n            _msg._destinationDomain() == localDomain,\n            \"Invalid destination domain\"\n        );\n\n        // Validate destination caller\n        if (_msg._destinationCaller() != bytes32(0)) {\n            require(\n                _msg._destinationCaller() ==\n                    Message.addressToBytes32(msg.sender),\n                \"Invalid caller for message\"\n            );\n        }\n\n        // Validate version\n        require(_msg._version() == version, \"Invalid message version\");\n\n        // Validate nonce is available\n        uint32 _sourceDomain = _msg._sourceDomain();\n        uint64 _nonce = _msg._nonce();\n        bytes32 _sourceAndNonce = _hashSourceAndNonce(_so"
    }
  ]
}