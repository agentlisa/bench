{
  "Title": "M-3: Post-proposal vote quorum/threshold checks use a stale total supply value",
  "Content": "# Issue M-3: Post-proposal vote quorum/threshold checks use a stale total supply value \n\nSource: https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance-judging/issues/102 \n\n## Found by \nIllIllI, hals\n## Summary\n\nThe pessimistic vote casting [approach](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/tree/main/bophades/audit/2024-01_governance#vote-casting) stores its cutoffs based on the total supply during proposal creation, rather than looking up the current value for each check.\n\n\n## Vulnerability Detail\n\n`gOHM token holders can delegate their voting rights either to themselves or to an address of their choice. Due to the elasticity in the gOHM supply, and unlike the original implementation of Governor Bravo, the Olympus governance system relies on dynamic thresholds based on the total gOHM supply. This mechanism sets specific thresholds for each proposal, based on the current supply at that time, ensuring that the requirements (in absolute gOHM terms) for proposing and executing proposals scale with the token supply.`\nhttps://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/tree/main/bophades/audit/2024-01_governance#olympus-governor-bravo-implementation\n\nThe above means that over time, due to dynamic minting and burning, the total supply will be different at different times, whereas the thresholds/quorums checked against are solely the ones set during proposal creation.\n\n\n## Impact\n\nDoS of the voting system, preventing proposals from ever passing, under certain circumstances\n\nConsider the case of a bug where there is some sort of runaway death spiral bug or attack in the dymamic burning of gOHM (e.g. opposite of Terra/Luna), and the only fix is to pass a proposal to disable the module(s) causing a problem where everyone is periodically having their tokens [`burn()`-from-ed](https://etherscan.io/token/0x0ab87046fBb341D058F17CBC4c1133F25a20a52f#code#L654). At proposal creation there are sufficient votes to pass the threshold, but after the minimum [3-day](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L25-L31) waiting period, the total supply has been halved, and the original proposer no longer has a sufficient quorum to execute the proposal (or some malicious user decides to cancel it, and there is no user for which `isWhitelisted()` returns true). No proposal can fix the issue, since no proposal will have enough votes to pass, by the time it's time to vote. Finally, once the total supply reaches low wei amounts, the treasury can be stolen by any remaining holders, due to loss of precision:\n\n* `getProposalThresholdVotes()`: min threshold is 1_000, so if supply is <100, don't need any votes to pass anything\n* `getQuorumVotes()`: quorum percent is hard-coded to 20_000 (20%), so if supply drops below 5, quorum is zero\n* `getHighRiskQuorumVotes()`: high percent is hard-coded to 30_000 (30%), so if supply drops below 4, quorum is zero for high risk\n\n\n## Code Snippet\n\nThe quorum comes from the total supply...\n```solidity\n// File: src/external/governance/GovernorBravoDelegate.sol : GovernorBravoDelegate.getHighRiskQuorumVotes()   #1\n\n698        function getQuorumVotes() public view returns (uint256) {\n699            return (gohm.totalSupply() * quorumPct) / 100_000;\n700        }\n...\n706        function getHighRiskQuorumVotes() public view returns (uint256) {\n707            return (gohm.totalSupply() * highRiskQuorum) / 100_000;\n708:       }\n```\nhttps://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L696-L708\n\n...and is set during [`propose()`](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L169-L182), and checked as-is against the eventual vote:\n```solidity\n// File: src/external/governance/GovernorBravoDelegate.sol : GovernorBravoDelegate.getVoteOutcome()   #2\n\n804            } else if (\n805                (proposal.forVotes * 100_000) / (proposal.forVotes + proposal.againstVotes) <\n806 @>             approvalThresholdPct ||\n807 @>             proposal.forVotes < proposal.quorumVotes\n808            ) {\n809                return false;\n810:           }\n```\nhttps://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L804-L810\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nAlways calculate the quorum and thresholds based on the current `gohm.totalSupply()` as is done in the OZ [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a5c4cd8182103aa96c2147433bf1bfb8fde63ca9/contracts/governance/extensions/GovernorVotesQuorumFraction.sol#L69-L74), and consider making votes based on the fraction of total supply held, rather than a raw amount, since vote tallies are affected too\n\n\n\n\n## Discussion\n\n**0xLienid**\n\nIf votes are locked in at a maximum of the value a voter had at the time the proposal started I don't think it makes sense to use the current `totalSupply` at proposal queueing to determine success/meeting quorum. you want it to be a comparable value to the votes values, hence lock it in at proposal creation\n\n**IllIllI000**\n\nSince the votes are locked in at the proposal start, then shouldn't the quorum be based on the total supply at that starting block, in order to have a comparable value? Right now the code is consistent with the proposal time only, which may have a vastly different total supply. Shouldn't the code always be consistent with total supply of whichever block is being checked? The votes would still be at the time of the start of voting, but when determining whether a proposal should be queueable/executable/cancelable, if everyone's token counts and the total supply has be halved, there has been no change in who logically would be best positioned to vote, but since the code compares against a stored raw value rather than a ratio, the proposal can fail through no fault of the proposer. They would be able to propose a new vote but be unable to use their old proposal, even though the ownership percentage is the same as before.\n\n**nevillehuang**\n\n@0xLienid I think @IllIllI000 highlights a valid scenario where this can cause a significant issue, and makes a good point as to why OZ implements quorums and thresholds computation that way.\n\nHowever, I can also see how this is speculating on emergency situations etc.., but I think in the context of a governance, it is reasonable given it is where sensitive actions are performed. @Czar102 What do you think of this?\n\n**0xLienid**\n\nI just don't agree that you want the quorum to be subject to deviations in supply during the voting period. It allows user manipulation of the ease/difficulty required to pass a proposal.\n\n> shouldn't the quorum be based on the total supply at that starting block, in order to have a comparable value?\n\nyes, but that's impossible with gOHM\n\nFrankly, I feel like if there is a critical bug in the core voting token then it's pretty expected that the governance system is also broken. \n\nThe only tenable option I guess is getting rid of the pessimistic voting.\n\n**0xLienid**\n\n@nevillehuang @IllIllI000 Do you guys have additional thoughts on this? I'm trying to think about how severe it actually is, and if there's any path to fixing it other than using the live total supply which feels more or less similar to using votes not pinned to a block which is bad.\n\n**IllIllI000**\n\n@0xLienid When you say it's impossible with gOHM, I believe you mean that once the starting block has passed, that there's no way to get the total supply from that prior block. If that's what you meant, in order to get the total supply at the starting block, you could require that the proposal creator actually trigger the start of voting (within some grace period) with another transaction at some point after the projected start block based on the delay, and have that operation update the stored quorums and start block at that point, assuming that the old quorums are still valid. In reality, the proposer controls the block during which the start occurs anyway, since the proposal block is under their control, and the delay is known.\n\nAs for the remainder of the issue, I'm not familiar with all that is planned, but I don't think it would have to be a bug in the core voting token itself - it could be a kernel module that has a role that allows it to mint/burn gOHM, given some algorithm with a time delay. Once things are decentralized, it's difficult to be able to predict that that won't happen. You could create a new gOHM that checkpoints the prior total supply, and migrate the old token, but yeah, that would be a big change, and would likely require larger changes than can be done for this contest.\n\n**nevillehuang**\n\nActually @IllIllI000 will there even ever be a situation where gOHM would be burned to literal 100, 5 and 4 given gOHM holds 18 decimals? I think on second look this is low severity, given the protocol can easily just implement a sanity check where they block any proposals creation/execution/queue and allow cancellation once totalSupply reaches this extreme small values.\n\nI'm guessing your issue also points to the possible decrease in absolute quorums not just solely small amounts, but I think that example is not realistic and representative enough. Or am I missing a possible scenario where gOHM supply can reach literal small weis of value?\n\n@0xLienid maybe a possible fix would be to make quorum percentages adjustable? This could open to front-running attacks though so I'll have to think through it more.\n\n**IllIllI000**\n\n@nevillehuang the 100/5/4 scenario is the end point after which everything can get stolen. Prior to that, this bug outlines that they can't stop an ongoing attack because creating a proposal to do so would never pass quorums due to the bug. This bug essentially was an elaboration of the issue described in the duplicate #74, to show that it's an issue with the underlying mechanics, rather than a one-time total supply discrepancy\n\n**nevillehuang**\n\n@IllIllI000 Yup that is my initial thoughts as well, sorry that I got confused by that scenario. I will likely maintain this issue as medium severity, and facilitate discussions between us and sponsor for a potential fix, since it seems to be non trivial.\n\n**0xLienid**\n\nOk @IllIllI000 @nevillehuang just talked with the other devs for a bit and here's what we came up with.\n\n1. Separate out proposal activation to another function so we can snapshot total supply more accurately\n2. Set a minimum total supply such that proposing/queuing/executing ends up in the hands of an admin (and block the standard behavior for end users) if we fall below that. If you think about a burn bug of this magnitude it's a critical implosion of the protocol and so it makes sense to not rely on full on chain governance\n\nThoughts?\n\n**IllIllI000**\n\nBy activation, you mean the triggering of the start of voting like I described above, or do you mean something else? \nThe docs mention a veto guardian that will eventually be set to the zero address. If there is a new admin for this case, it won't be able to do the same sort of relinquishment without having the end result of the attack being a locked treasury (assuming there's no governance bypass to access funds some other way). If that's acceptable, I believe your two changes will solve the issue.\n\n**0xLienid**\n\nYep, triggering of the start of voting.\n\n**0xrusowsky**\n\n- https://github.com/OlympusDAO/bophades/pull/303\n\n@IllIllI000 ready for review\n\n**RealLTDingZhen**\n\nI thought about this issue while the contest was going on and didn't submit it, because I thought it's a design choice——Due to the highly variable totalsupply of gOHM, the proposer may need far more tokens than its initial amount to ensure that the proposal is not canceled, and opponents can use fewer votes to reject the proposal by mint more gOHM.\nBy the way, the solution given by LSR is flawed——Attackers can manipulate totalsupply to cancel the proposer's proposal through flashloan.\n\n**IllIllI000**\n\nThe [PR](https://github.com/OlympusDAO/bophades/pull/303) implements part of the [discussed](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance-judging/issues/102#issuecomment-1915038664) changes. There is a new gOHM total supply threshold, under which only emergency votes are allowed. The level is correctly many orders of magnitude above the levels at which quorums have loss of precision. Calls to `propose()` are prevented when the total supply falls below the cutoff. A new `emergencyPropose()` is added, which can only be called during emergencies, by the veto guardian. It does not have any threshold requirements, or any limit to the number of outstanding proposals (both good), and does not update `latestProposalIds` (ok). Besides those differences, the code looks like `propose()`. For `propose()` the end block and quorum are no longer initially set, and require the user to call `activate()` to set them instead. The `activate()` function requires a non-emergency, pending state, for the start block to have been passed, and to not have been activated before. The proposal can be reentrantly re-activated in the same way #62, but there aren't any negative effects outside of extra events. There is no cut-off of when a proposal can be activated, which may allow proposals to stay dormant for years, until they're finally activated. `activate()` cannot be called during emergencies, so proposals created before an emergency will expire if things don't get resolved. This also means `emergencyPropose()` does not require activation or any actual votes - just that delays have been respected (seems to be intended behavior). The `execute()` function does not require any specific state during emergencies for the veto admin, but `timelock.executeTransaction()` prevents calling it multiple times. The `state()` function has a new state for `Emergency`, which applies to any proposal created by the veto admin via `emergencyPropose()`.\n\tBug Med: the proposal.proposalThreshold isn't updated during activate(), which can be many years after the initial proposal.\n\tBug Low: extra events if reentrantly called\n\tBug Low: emergency proposals (more than one is allowed) created during one emergency, can be executed during a later emergency\n\n**0xLienid**\n\nRefix: https://github.com/OlympusDAO/bophades/pull/334\n\nWe added a activation grace period (which is checked in the `state` call) so that proposals cannot sit unactivated for months or years. We believe this sufficiently reduces the `proposalThreshold` concern. We chose not to update the `proposalThreshold` at the time of activation with this added check because it feels backwards from a governance perspective to brick someone's proposal after proposing if their balance has not changed.\n\nWe also shifted certain components of the `proposal` struct modification above the `_isHighRiskProposalCheck` to prevent reentrancy.\n\n**IllIllI000**\n\nThe [PR](https://github.com/OlympusDAO/bophades/pull/334) correctly addresses the Medium and one of the Lows from item 7 of 9 of the prior review, while leaving the remaining Low about emergency proposals being able to be used across emergencies. \n\tThe extra events issue is fixed by moving up the state variable assignments to above the high risk proposal checks. \n\tThe Medium is addressed by introducing a new state variable to GovernorBravoDelegateStorageV1, rather than to GovernorBravoDelegateStorageV2, for a grace period. There is no setter for the variable, so it must be set during the call to `initialize()` as the penultimate argument, which is properly done, or by creating a new implementation with a setter function. The `initialize()` call bounds the value within reasonable limits. \n\tThe min amount is set to 17280, which is 2.4 days, and the max is set to 50400, which is exactly 7 days.\n\tThe `state()` function is properly changed to convert `Pending` to `Expired`, after the activation grace period. The code reverts with `GovernorBravo_Vote_Closed()` when activation is attempted after the grace period.\n\tThe PR adds tests for the grace period and for the reentrancy issue\n\tWith the death spiral issue and the activation grace period issue resolved, the issue of the total supply changing has been mitigated to low.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/155",
  "Code": [
    {
      "filename": "bophades/src/external/governance/GovernorBravoDelegate.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.15;\n\nimport {IgOHM} from \"src/interfaces/IgOHM.sol\";\nimport {ITimelock} from \"./interfaces/ITimelock.sol\";\nimport {IGovernorBravoEventsAndErrors} from \"./interfaces/IGovernorBravoEvents.sol\";\n\nimport {GovernorBravoDelegateStorageV2} from \"./abstracts/GovernorBravoStorage.sol\";\n\nimport \"src/Kernel.sol\";\n\ncontract GovernorBravoDelegate is GovernorBravoDelegateStorageV2, IGovernorBravoEventsAndErrors {\n    // --- CONSTANTS ---------------------------------------------------------------\n\n    /// @notice The name of this contract\n    string public constant name = \"Olympus Governor Bravo\";\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_PCT = 1_000; // 1% (out of 100_000)\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_PCT = 90_000; // 90% (out of 100_000)\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 21600; // About 3 days (12s block time)\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 100800; // About 2 weeks (12s block time)\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 21600; // About 3 days (12s block time)\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 50400; // About 1 week (12s block time)\n\n    /// @notice The percentage of total supply in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    /// @dev    Olympus has a variable supply system, that actively fluctuates fairly significantly, so it is better to use\n    ///         a percentage of total supply, rather than a fixed number of tokens.\n    uint256 public constant quorumPct = 20_000; // 20% (out of 100_000)\n\n    /// @notice The percentage of total supply in support of a proposal related to a high risk module in the Default system required\n    ///         in order for a quorum to be reached and for a vote to succeed\n    /// @dev    Olympus has a variable supply system, that actively fluctuates fairly significantly, so it is better to use\n    ///         a percentage of total supply, rather than a fixed number of tokens.\n    uint256 public constant highRiskQuorum = 30_000; // 30% (out of 100_000)\n\n    /// @notice The percentage of votes that must be in favor of a proposal for it to succeed\n    uint256 public constant approvalThresholdPct = 55_000; // 55% (out of 100_000)\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The central hub of the Default Framework system that manages modules and policies\n    /// @dev    Used in this adaptation of Governor Bravo to identify high risk proposals\n    address public kernel;\n\n    /// @notice Modules in the Default system that are considered high risk\n    /// @dev    In Default Framework, Keycodes are used to uniquely identify modules. They are a\n    ///         wrapper over the bytes5 data type, and allow us to easily check if a proposal is\n    ///         touching any specific modules\n    mapping(Keycode => bool) public isKeycodeHighRisk;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n\n    // --- INITIALIZE --------------------------------------------------------------\n\n    /**\n     * @notice Used to initialize the contract during delegator constructor\n     * @param timelock_ The address of the Timelock\n     * @param gohm_ The address of the gOHM token\n     * @param kernel_ The address of the kernel\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThreshold_ The initial proposal threshold (percentage of total supply. out of 1000)\n     */\n    function initialize(\n        address timelock_,\n        address gohm_,\n        address kernel_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThreshold_\n    ) public virtual {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        if (address(timelock) != address(0)) revert GovernorBravo_AlreadyInitialized();\n        if (timelock_ == address(0) || gohm_ == address(0) || kernel_ == address(0))\n            revert GovernorBravo_AddressZero();\n        if (votingPeriod_ < MIN_VOTING_PERIOD || votingPeriod_ > MAX_VOTING_PERIOD)\n            revert GovernorBravo_InvalidPeriod();\n        if (votingDelay_ < MIN_VOTING_DELAY || votingDelay_ > MAX_VOTING_DELAY)\n            revert GovernorBravo_InvalidDelay();\n        if (\n            proposalThreshold_ < MIN_PROPOSAL_THRESHOLD_PCT ||\n            proposalThreshold_ > MAX_PROPOSAL_THRESHOLD_PCT\n        ) revert GovernorBravo_InvalidThreshold();\n\n        // Set up contract dependencies\n        timelock = ITimelock(timelock_);\n        gohm = IgOHM(gohm_);\n        kernel = kernel_;\n\n        // Configure voting parameters\n        vetoGuardian = msg.sender;\n        votingDelay = votingDelay_;\n        votingPeriod = votingPeriod_;\n        proposalThreshold = proposalThreshold_;\n        isKeycodeHighRisk[toKeycode(bytes5(\"TRSRY\"))] = true;\n        isKeycodeHighRisk[toKeycode(bytes5(\"MINTR\"))] = true;\n    }\n\n    // --- GOVERNANCE LOGIC --------------------------------------------------------\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        // Allow addresses above proposal threshold and whitelisted addresses to propose\n        if (\n            gohm.getPriorVotes(msg.sender, block.number - 1) <= getProposalThresholdVotes() &&\n            !isWhitelisted(msg.sender)\n        ) revert GovernorBravo_Proposal_ThresholdNotMet();\n        if (\n            targets.length != values.length ||\n            targets.length != signatures.length ||\n            targets.length != calldatas.length\n        ) revert GovernorBravo_Proposal_LengthMismatch();\n        if (targets.length == 0) revert GovernorBravo_Proposal_NoActions();\n        if (targets.length > proposalMaxOperations) revert GovernorBravo_Proposal_TooManyActions();\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            if (proposersLatestProposalState == ProposalState.Active)\n                revert GovernorBravo_Proposal_AlreadyActive();\n            if (proposersLatestProposalState == ProposalState.Pending)\n                revert GovernorBravo_Proposal_AlreadyPending();\n        }\n\n        uint256 startBlock = block.number + votingDelay;\n        uint256 endBlock = startBlock + votingPeriod;\n\n        proposalCount++;\n        uint256 newProposalID = proposalCount;\n\n        {\n            // Given Olympus's dynamic supply, we need to capture quorum and proposal thresholds in terms\n            // of the total supply at the time of proposal creation.\n            uint256 quorumVotes;\n            uint256 proposalThresholdVotes = getProposalThresholdVotes();\n\n            // Identify the quorum level to use\n            if (_isHighRiskProposal(targets, signatures, calldatas)) {\n                quorumVotes = getHighRiskQuorumVotes();\n            } else {\n                quorumVotes = getQuorumVotes();\n            }\n\n            Proposal storage newProposal = proposals[newProposalID];\n            // This should never happen but add a check in case.\n            if (newProposal.id != 0) revert GovernorBravo_Proposal_IdCollision();\n\n            newProposal.id = newProposalID;\n            newProposal.proposer = msg.sender;\n            newProposal.proposalThreshold = proposalThresholdVotes;\n            newProposal.quorumVotes = quorumVotes;\n            newProposal.targets = targets;\n            newProposal.values = values;\n            newProposal.signatures = signatures;\n            newProposal.calldatas = calldatas;\n            newProposal.startBlock = startBlock;\n            newProposal.endBlock = endBlock;\n\n            latestProposalIds[newProposal.proposer] = newProposal.id;\n        }\n\n        emit ProposalCreated(\n            newProposalID,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            startBlock,\n            endBlock,\n            description\n        );\n        return newProposalID;\n    }\n\n    /**\n     * @notice Queues a successful proposal\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        if (state(proposalId) != ProposalState.Succeeded)\n            revert GovernorBravo_Queue_FailedProposal();\n\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = block.timestamp + timelock.delay();\n\n        // Check that proposer has not fallen below proposal threshold since proposal creation\n        // If proposer is whitelisted, they can queue regardless of threshold\n        if (\n            !isWhitelisted(proposal.proposer) &&\n            gohm.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold\n        ) revert GovernorBravo_Queue_BelowThreshold();\n\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevertInternal(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function _queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        if (timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))))\n            revert GovernorBravo_Queue_AlreadyQueued();\n\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external payable {\n        if (state(proposalId) != ProposalState.Queued) revert GovernorBravo_Execute_NotQueued();\n\n        Proposal storage proposal = proposals[proposalId];\n\n        // Check that proposer has not fallen below proposal threshold since proposal creation\n        // If proposer is whitelisted, they can execute regardless of threshold\n        if (\n            !isWhitelisted(proposal.proposer) &&\n            gohm.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold\n        ) revert GovernorBravo_Execute_BelowThreshold();\n\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value: proposal.values[i]}(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        if (state(proposalId) == ProposalState.Executed)\n            revert GovernorBravo_Cancel_AlreadyExecuted();\n\n        Proposal storage proposal = proposals[proposalId];\n\n        // Proposer can cancel\n        if (msg.sender != proposal.proposer) {\n            // Whitelisted proposers can't be canceled for falling below proposal threshold\n            if (isWhitelisted(proposal.proposer)) {\n                if (\n                    (gohm.getPriorVotes(proposal.proposer, block.number - 1) >=\n                        proposal.proposalThreshold) || msg.sender != whitelistGuardian\n                ) revert GovernorBravo_Cancel_WhitelistedProposer();\n            } else {\n                if (\n                    gohm.getPriorVotes(proposal.proposer, block.number - 1) >=\n                    proposal.proposalThreshold\n                ) revert GovernorBravo_Cancel_AboveThreshold();\n            }\n        }\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Vetoes a proposal only if sender is the veto guardian\n     * @param proposalId The id of the proposal to veto\n     */\n    function veto(uint256 proposalId) external {\n        if (msg.sender != vetoGuardian) revert GovernorBravo_OnlyVetoGuardian();\n        if (state(proposalId) == ProposalState.Executed)\n            revert GovernorBravo_Veto_AlreadyExecuted();\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.vetoed = true;\n        for (uint256 i; i < proposal.targets.length; ) {\n            // If the proposal has been queued, cancel on the timelock\n            if (\n                timelock.queuedTransactions(\n                    keccak256(\n                        abi.encode(\n                            proposal.targets[i],\n                            proposal.values[i],\n                            proposal.signatures[i],\n                            proposal.calldatas[i],\n                            proposal.eta\n                        )\n                    )\n                )\n            ) {\n                timelock.cancelTransaction(\n                    proposal.targets[i],\n                    proposal.values[i],\n                    proposal.signatures[i],\n                    proposal.calldatas[i],\n                    proposal.eta\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalVetoed(proposalId);\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(\n            msg.sender,\n            proposalId,\n            support,\n            castVoteInternal(msg.sender, proposalId, support),\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        emit VoteCast(\n            msg.sender,\n            proposalId,\n            support,\n            castVoteInternal(msg.sender, proposalId, support),\n            reason\n        );\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        if (signatory == address(0)) revert GovernorBravo_InvalidSignature();\n        emit VoteCast(\n            signatory,\n            proposalId,\n            support,\n            castVoteInternal(signatory, proposalId, support),\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param voter The voter that is casting their vote\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(\n        address voter,\n        uint256 proposalId,\n        uint8 support\n    ) internal returns (uint256) {\n        if (state(proposalId) != ProposalState.Active) revert GovernorBravo_Vote_Closed();\n        if (support > 2) revert GovernorBravo_Vote_InvalidType();\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        if (receipt.hasVoted) revert GovernorBravo_Vote_AlreadyCast();\n\n        // Get the user's votes at the start of the proposal and at the time of voting. Take the minimum.\n        uint256 originalVotes = gohm.getPriorVotes(voter, proposal.startBlock);\n        uint256 currentVotes = gohm.getPriorVotes(voter, block.number);\n        uint256 votes = currentVotes > originalVotes ? originalVotes : currentVotes;\n\n        if (support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    }\n\n    // --- ADMIN FUNCTIONS ---------------------------------------------------------\n\n    /**\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 newVotingDelay) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        if (newVotingDelay < MIN_VOTING_DELAY || newVotingDelay > MAX_VOTING_DELAY)\n            revert GovernorBravo_InvalidDelay();\n\n        uint256 oldVotingDelay = votingDelay;\n        votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay, votingDelay);\n    }\n\n    /**\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        if (newVotingPeriod < MIN_VOTING_PERIOD || newVotingPeriod > MAX_VOTING_PERIOD)\n            revert GovernorBravo_InvalidPeriod();\n\n        uint256 oldVotingPeriod = votingPeriod;\n        votingPeriod = newVotingPeriod;\n\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n    }\n\n    /**\n     * @notice Admin function for setting the proposal threshold\n     * @dev newProposalThreshold must be greater than the hardcoded min\n     * @param newProposalThreshold new proposal threshold\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        if (\n            newProposalThreshold < MIN_PROPOSAL_THRESHOLD_PCT ||\n            newProposalThreshold > MAX_PROPOSAL_THRESHOLD_PCT\n        ) revert GovernorBravo_InvalidThreshold();\n\n        uint256 oldProposalThreshold = proposalThreshold;\n        proposalThreshold = newProposalThreshold;\n\n        emit ProposalThresholdSet(oldProposalThreshold, proposalThreshold);\n    }\n\n    /**\n     * @notice Admin function for setting the whitelist expiration as a timestamp for an account. Whitelist status allows accounts to propose without meeting threshold\n     * @param account Account address to set whitelist expiration for\n     * @param expiration Expiration for account whitelist status as timestamp (if now < expiration, whitelisted)\n     */\n    function _setWhitelistAccountExpiration(address account, uint256 expiration) external {\n        if (msg.sender != admin && msg.sender != whitelistGuardian)\n            revert GovernorBravo_OnlyAdmin();\n        whitelistAccountExpirations[account] = expiration;\n\n        emit WhitelistAccountExpirationSet(account, expiration);\n    }\n\n    /**\n     * @notice Admin function for setting the whitelistGuardian. WhitelistGuardian can cancel proposals from whitelisted addresses\n     * @param account Account to set whitelistGuardian to (0x0 to remove whitelistGuardian)\n     */\n    function _setWhitelistGuardian(address account) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        address oldGuardian = whitelistGuardian;\n        whitelistGuardian = account;\n\n        emit WhitelistGuardianSet(oldGuardian, whitelistGuardian);\n    }\n\n    /**\n     * @notice Admin function for setting the vetoGuardian. vetoGuardian can veto any proposal\n     * @param account Account to set vetoGuardian to (0x0 to remove vetoGuardian)\n     */\n    function _setVetoGuardian(address account) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        address oldGuardian = vetoGuardian;\n        vetoGuardian = account;\n\n        emit VetoGuardianSet(oldGuardian, vetoGuardian);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     */\n    function _setPendingAdmin(address newPendingAdmin) external {\n        // Check caller = admin\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     */\n    function _acceptAdmin() external {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0))\n            revert GovernorBravo_OnlyPendingAdmin();\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n\n    /**\n     * @notice Sets whether a module is considered high risk\n     * @dev Admin function to set whether a module in the Default Framework is considered high risk\n     * @param module_ The module to set the risk of\n     * @param isHighRisk_ If the module is high risk\n     */\n    function _setModuleRiskLevel(bytes5 module_, bool isHighRisk_) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        isKeycodeHighRisk[toKeycode(module_)] = isHighRisk_;\n    }\n\n    // --- HELPER FUNCTIONS: INTERNAL ----------------------------------------------\n\n    /**\n     * @dev Checks if a proposal is high risk by identifying actions where the Default Framework kernel\n     *      is the target, if so, checking if it's installing or deactivating a policy, and if so,\n     *      checking if the policy is touching a high risk module.\n     */\n    function _isHighRiskProposal(\n        address[] memory targets,\n        string[] memory signatures,\n        bytes[] memory calldatas\n    ) internal returns (bool) {\n        // If proposal interacts with the kernel, and is touching a policy that interacts with\n        // a flagged module, then it is high risk.\n        uint256 numActions = targets.length;\n\n        for (uint256 i = 0; i < numActions; i++) {\n            address target = targets[i];\n            string memory signature = signatures[i];\n            bytes memory data = calldatas[i];\n\n            if (target == kernel) {\n                // Get function selector\n                bytes4 selector = bytes(signature).length == 0\n                    ? bytes4(data)\n                    : bytes4(keccak256(bytes(signature)));\n\n                // Check if the action is making a core change to system via the kernel\n                if (selector == Kernel.executeAction.selector) {\n                    uint8 action;\n                    address actionTarget;\n\n                    if (bytes(signature).length == 0 && data.length == 0x44) {\n                        assembly {\n                            action := mload(add(data, 0x24)) // accounting for length and selector in first 4 bytes\n                            actionTarget := mload(add(data, 0x44))\n                        }\n                    } else if (data.length == 0x40) {\n                        (action, actionTarget) = abi.decode(data, (uint8, address));\n                    } else {\n                        continue;\n                    }\n\n                    // If the action is upgrading a module (1)\n                    if (action == 1) {\n                        // Check if the module has a high risk keycode\n                        if (isKeycodeHighRisk[Module(actionTarget).KEYCODE()]) return true;\n                    }\n                    // If the action is installing (2) or deactivating (3) a policy, pull the list of dependencies\n                    else if (action == 2 || action == 3) {\n                        // Call `configureDependencies` on the policy\n                        Keycode[] memory dependencies = Policy(actionTarget)\n                            .configureDependencies();\n\n                        // Iterate over dependencies and looks for high risk keycodes\n                        uint256 numDeps = dependencies.length;\n                        for (uint256 j; j < numDeps; j++) {\n                            Keycode dep = dependencies[j];\n                            if (isKeycodeHighRisk[dep]) return true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    // --- GETTER FUNCTIONS: SYSTEM ------------------------------------------------\n\n    /**\n     * @notice View function that gets the chain ID of the current network\n     * @return The chain ID\n     */\n    function getChainIdInternal() internal view returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\n    /**\n     * @notice View function that gets the proposal threshold in number of gOHM based on current supply\n     * @return The proposal threshold in number of gOHM\n     */\n    function getProposalThresholdVotes() public view returns (uint256) {\n        return (gohm.totalSupply() * proposalThreshold) / 100_000;\n    }\n\n    /**\n     * @notice View function that gets the quorum in number of gOHM based on current supply\n     * @return The quorum in number of gOHM\n     */\n    function getQuorumVotes() public view returns (uint256) {\n        return (gohm.totalSupply() * quorumPct) / 100_000;\n    }\n\n    /**\n     * @notice View function that gets the high risk quorum in number of gOHM based on current supply\n     * @return The high risk quorum in number of gOHM\n     */\n    function getHighRiskQuorumVotes() public view returns (uint256) {\n        return (gohm.totalSupply() * highRiskQuorum) / 100_000;\n    }\n\n    /**\n     * @notice View function which returns if an account is whitelisted\n     * @param account Account to check white list status of\n     * @return If the account is whitelisted\n     */\n    function isWhitelisted(address account) public view returns (bool) {\n        return (whitelistAccountExpirations[account] > block.timestamp);\n    }\n\n    // --- GETTER FUNCTIONS: PROPOSAL ----------------------------------------------\n\n    /**\n     * @notice Gets the quorum required for a given proposal\n     * @param proposalId the id of the proposal\n     * @return The quorum required for the given proposal\n     */\n    function getProposalQuorum(uint256 proposalId) external view returns (uint256) {\n        return proposals[proposalId].quorumVotes;\n    }\n\n    /**\n     * @notice Gets the proposer votes threshold required for a given proposal\n     * @param proposalId the id of the proposal\n     * @return The proposer votes threshold required for the given proposal\n     */\n    function getProposalThreshold(uint256 proposalId) external view returns (uint256) {\n        return proposals[proposalId].proposalThreshold;\n    }\n\n    /**\n     * @notice Gets the eta value for a given proposal\n     * @param proposalId the id of the proposal\n     * @return The eta value for the given proposal\n     */\n    function getProposalEta(uint256 proposalId) external view returns (uint256) {\n        return proposals[proposalId].eta;\n    }\n\n    /**\n     * @notice Gets the against, for, and abstain votes for a given proposal\n     * @param proposalId the id of the proposal\n     * @return The against, for, and abstain votes for the given proposal\n     */\n    function getProposalVotes(\n        uint256 proposalId\n    ) external view returns (uint256, uint256, uint256) {\n        Proposal storage p = proposals[proposalId];\n        return (p.againstVotes, p.forVotes, p.abstainVotes);\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets of the proposal actions\n     * @return values of the proposal actions\n     * @return signatures of the proposal actions\n     * @return calldatas of the proposal actions\n     */\n    function getActions(\n        uint256 proposalId\n    )\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Gets the voting outcome of the proposal\n     * @param proposalId the id of proposal\n     * @return The voting outcome\n     */\n    function getVoteOutcome(uint256 proposalId) public view returns (bool) {\n        Proposal storage proposal = proposals[proposalId];\n\n        if (proposal.forVotes == 0 && proposal.againstVotes == 0) {\n            return false;\n        } else if (\n            (proposal.forVotes * 100_000) / (proposal.forVotes + proposal.againstVotes) <\n            approvalThresholdPct ||\n            proposal.forVotes < proposal.quorumVotes\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        if (proposalCount"
    }
  ]
}