{
  "Title": "[H-32] Incorrectly reading the offset from the received data parameter to get the `depositNonce` in the `BranchBridgeAgent::anyFallback()` function",
  "Content": "\nNot reading the correct offset where the `depositNonce` is located can lead to setting the status of the wrong deposit to \"Failed\" when the [`_clearDeposit() function`](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L988-L996) is called.\n\nThe consequences of setting the incorrect `depositNonce` to False can be:\n- The deposits are getting stuck from the real `depositNonce` that is sent to the `anyFallback()` because that `depositNonce` won't be marked as \"Failed\".\n- Causing troubles to other `depositNonces` that should not be marked as \"Failed\".\n\n### Proof of Concept\n\nThe structure of the data was encoded depending on the type of operation. That means, the `depositNonce` will be located at a different offset depending on the flag. To see where exactly the `depositNonce` is located, it is required to check the corresponding operation where the data was packed. Depending on the type of operation (flag), it will be the function we'll need to analyze to determine the correct offset where the `depositNonce` was packed.\n\nLet's analyze the encoded data, flag by flag, to determine the correct offset of the `depositNonce` for each flag:\n\n1. **`flag == 0x00`** - When [encoding the data for the flag 0x00](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L480-L481), we can see that the `depositNonce` is located at the `data[1:5]`.\n\n```solidity\nbytes memory packedData =\n          abi.encodePacked(bytes1(0x00), depositNonce, _params, gasToBridgeOut, _remoteExecutionGas);\n\n// data[0]    ==> flag === 0x00\n// data[1:5]  ==> depositNonce\n```\n\n2. **`flag == 0x01`** - When [encoding the data for the flag 0x01](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L656-L657), we can see that the `depositNonce` is located at the `data[1:5]`.\n\n```solidity\nbytes memory packedData =\n        abi.encodePacked(bytes1(0x01), depositNonce, _params, _gasToBridgeOut, _remoteExecutionGas);\n\n// data[0]    ==> flag === 0x01\n// data[1:5]  ==> depositNonce\n```\n\n3. **`flag == 0x02`**- When [encoding the data for the flag 0x02](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L680-L692), we can see that the `depositNonce` is located at the `data[1:5]`.\n\n```solidity\nbytes memory packedData = abi.encodePacked(\n    bytes1(0x02),\n    depositNonce,\n    _dParams.hToken,\n    _dParams.token,\n    _dParams.amount,\n    _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n    _dParams.toChain,\n    _params,\n    _gasToBridgeOut,\n    _remoteExecutionGas\n);\n\n// data[0]    ==> flag === 0x02\n// data[1:5]  ==> depositNonce\n```\n\n4.  **`flag == 0x03`** - When [encoding the data for the flag 0x03](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L723-L736), we can see that the `depositNonce` is located at the `data[2:6]`.\n\n```solidity\nbytes memory packedData = abi.encodePacked(\n    bytes1(0x03),\n    uint8(_dParams.hTokens.length),\n    depositNonce,\n    _dParams.hTokens,\n    _dParams.tokens,\n    _dParams.amounts,\n    deposits,\n    _dParams.toChain,\n    _params,\n    _gasToBridgeOut,\n    _remoteExecutionGas\n);\n\n// data[0]    ==> flag === 0x03\n// data[1]    ==> hTones.length\n// data[2:6]  ==> depositNonce\n```\n\n5. **`flag == 0x04`**- When [encoding the data for the flag 0x04](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L225-L228), we can see that the `depositNonce` is located at the `data[21:25]`.\n\n```solidity\nbytes memory packedData = abi.encodePacked(\n    bytes1(0x04), msg.sender, depositNonce, _params, msg.value.toUint128(), _remoteExecutionGas\n);\n\n// data[0]    ==> flag === 0x04\n// data[1:21] ==> msg.sender\n// data[21:25]  ==> depositNonce\n```\n\n6. **`flag == 0x05`** - When [encoding the data for the flag 0x05](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L244-L257), we can see that the `depositNonce` is located at the `data[21:25]`.\n\n```solidity\nbytes memory packedData = abi.encodePacked(\n    bytes1(0x05),\n    msg.sender,\n    depositNonce,\n    _dParams.hToken,\n    _dParams.token,\n    _dParams.amount,\n    _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n    _dParams.toChain,\n    _params,\n    msg.value.toUint128(),\n    _remoteExecutionGas\n);\n\n// data[0]    ==> flag === 0x05\n// data[1:21] ==> msg.sender\n// data[21:25]  ==> depositNonce\n```\n\n7. **`flag == 0x06`** - When [encoding the data for the flag 0x06](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L287-L301), we can see that the `depositNonce` is located at the `data[22:26]`.\n\n```solidity\nbytes memory packedData = abi.encodePacked(\n    bytes1(0x06),\n    msg.sender,\n    uint8(_dParams.hTokens.length),\n    depositNonce,\n    _dParams.hTokens,\n    _dParams.tokens,\n    _dParams.amounts,\n    _deposits,\n    _dParams.toChain,\n    _params,\n    msg.value.toUint128(),\n    _remoteExecutionGas\n);\n\n// data[0]     ==> flag === 0x06\n// data[1:21]  ==> msg.sender\n// data[21]    ==> hTokens.length\n// data[22:26] ==> depositNonce\n```\n\nAt this point now, we know the exact offset where the `depositNonce` is located at for all the possible deposit options. Now, it is time to analyze the offsets that are been read, depending on the flag in the `anyFallback()` and validate that the correct offset is been read.\n\n1. For `flags 0x00, 0x01 and 0x02`, the `depositNonce` is been read from the offset `data[PARAMS_START:PARAMS_TKN_START]`, which is the same as `data[1:5]` ([PARAMS_START == 1](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L68) and [PARAMS_TKN_START == 5](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L78)). These 3 flags read the `depositNonce` correctly.\n\n2. For `flag 0x03`, the `depositNonce` is been read from the offset `data[PARAMS_START + PARAMS_START:PARAMS_TKN_START + PARAMS_START]`, which is the same as `data[2:6]` ([PARAMS_START == 1](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L68) and [PARAMS_TKN_START == 5](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L78)). This flag also reads the `depositNonce` correctly.\n\n3. For `flag 0x04 and 0x05`, the `depositNonce` is been read from the offset `data[PARAMS_START_SIGNED:PARAMS_START_SIGNED + PARAMS_TKN_START]`, which is the same as `data[21:26]` ([PARAMS_START_SIGNED == 21](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L70) and [PARAMS_TKN_START == 5](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L78)). These flags are reading the `depositNonce` INCORRECTLY.\n\nFrom the above analysis to detect where the `depositNonce` is located at, for `flags 0x04 and 0x05`, the `depositNonce` is located at the offset `data[21:25]`.\n\nThe PoC below demonstrates the correct offset of the `depositNonce` when data is encoded similar to how `flags 0x04 and 0x05` encodes it (see the above analysis for more details).\n\n- Call the `generateData()` function and copy+paste the generated bytes on the rest of the functions.\n- Notice how the `readNonce()` returns the correct value of the nonce and is reading the offset `data[21:25]`:\n\n```solidity\npragma solidity 0.8.18;\n\ncontract offset {\n    uint32 nonce = 3;\n\n    function generateData() external view returns (bytes memory) {\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x01),\n            msg.sender,\n            nonce\n        );\n        return packedData;\n    }\n\n    function readFlag(bytes calldata data) external view returns(bytes1) {\n        return data[0];\n    }\n\n    function readMsgSender(bytes calldata data) external view returns (address) {\n        return address(uint160(bytes20(data[1:21])));\n    }\n\n    function readNonce(bytes calldata data) external view returns (uint32) {\n        return uint32(\n            bytes4(data[21:25])\n        );\n    }   \n\n}\n```\n\n4. For `flag 0x06`, the `depositNonce` is been read from the offset `data[PARAMS_START_SIGNED + PARAMS_START:PARAMS_START_SIGNED + PARAMS_TKN_START + PARAMS_START]`, which is the same as `data[22:27]` ([PARAMS_START_SIGNED == 21](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L70), [PARAMS_START == 1](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L68) and [PARAMS_TKN_START == 5](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L78)). This flag is also reading the `depositNonce` INCORRECTLY.\n\nFrom the above analysis to detect where the `depositNonce` is located at, for `flag 0x06`, the `depositNonce` is located at the offset `data[22:26]`.\n\nThe PoC below demonstrates the correct offset of the `depositNonce` when data is encoded similar to how `flag 0x06` encodes it (see the above analysis for more details).\n\n- Call the `generateData()` function and copy+paste the generated bytes on the rest of the functions.\n- Notice how the `readNonce()` returns the correct value of the nonce and is reading the offset `data[22:26]`:\n\n```solidity\npragma solidity 0.8.18;\n\ncontract offset {\n    uint32 nonce = 3;\n\n    function generateData() external view returns (bytes memory) {\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x01),\n            msg.sender,\n            uint8(1),\n            nonce\n        );\n        return packedData;\n    }\n\n    function readFlag(bytes calldata data) external view returns(bytes1) {\n        return data[0];\n    }\n\n    function readMsgSender(bytes calldata data) external view returns (address) {\n        return address(uint160(bytes20(data[1:21])));\n    }\n\n    function readThirdParameter(bytes calldata data) external view returns(uint8) {\n        return uint8(bytes1(data[21]));\n    }\n\n    function readNonce(bytes calldata data) external view returns (uint32) {\n        return uint32(\n            bytes4(data[22:26])\n        );\n    }\n\n}\n```\n\n### Recommended Mitigation Steps\n\nMake sure to read the `depositNonce` from the correct offset. Depending on the flag, it will be the offset where `depositNonce` is located at:\n\nFor `flags 0x04 & 0x05`, read the offset as follows, either of the two options are correct:\n- `depositNonce` is located at: `data[21:25]`\n\n```solidity\n_depositNonce = uint32(bytes4(data[PARAMS_START_SIGNED : PARAMS_START_SIGNED]));\n_depositNonce = uint32(bytes4(data[21:25]));\n```\n\nFor `flag 0x06`, read the offset as follows, either of the two options are correct:\n- `depositNonce` is located at: `data[22:26]`\n\n```solidity\n_depositNonce = uint32(bytes4(data[PARAMS_START_SIGNED + PARAMS_START : PARAMS_START_SIGNED + PARAMS_TKN_START]));\n_depositNonce = uint32(bytes4(data[22:26]));\n```\n\n### Assessed type\n\nen/de-code\n\n**[0xBugsy (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/169#issuecomment-1632452314)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/169#issuecomment-1709930063):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/commit/e0b8a72f3dcc850cf8373f8c6bb851c3083ed2a1).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-omnichain/BranchBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"./interfaces/IWETH9.sol\";\n\nimport {AnycallFlags} from \"./lib/AnycallFlags.sol\";\nimport {IAnycallProxy} from \"./interfaces/IAnycallProxy.sol\";\nimport {IAnycallConfig} from \"./interfaces/IAnycallConfig.sol\";\nimport {IAnycallExecutor} from \"./interfaces/IAnycallExecutor.sol\";\nimport {IApp, IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IBranchRouter as IRouter} from \"./interfaces/IBranchRouter.sol\";\nimport {IBranchPort as IPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {ERC20hTokenBranch as ERC20hToken} from \"./token/ERC20hTokenBranch.sol\";\nimport {BranchBridgeAgentExecutor, DeployBranchBridgeAgentExecutor} from \"./BranchBridgeAgentExecutor.sol\";\nimport {\n    Deposit,\n    DepositStatus,\n    DepositInput,\n    DepositMultipleInput,\n    DepositParams,\n    DepositMultipleParams,\n    SettlementParams,\n    SettlementMultipleParams\n} from \"./interfaces/IBranchBridgeAgent.sol\";\n\n/// @title Library for Branch Bridge Agent Deployment\nlibrary DeployBranchBridgeAgent {\n    function deploy(\n        WETH9 _wrappedNativeToken,\n        uint256 _rootChainId,\n        uint256 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) external returns (BranchBridgeAgent) {\n        return new BranchBridgeAgent(\n            _wrappedNativeToken,\n            _rootChainId,\n            _localChainId,\n            _rootBridgeAgentAddress,\n            _localAnyCallAddress,\n            _localAnyCallExecutorAddress,\n            _localRouterAddress,\n            _localPortAddress\n        );\n    }\n}\n\n/// @title Branch Bridge Agent Contract\ncontract BranchBridgeAgent is IBranchBridgeAgent {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                            ENCODING CONSTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// AnyExec Decode Consts\n\n    uint8 internal constant PARAMS_START = 1;\n\n    uint8 internal constant PARAMS_START_SIGNED = 21;\n\n    uint8 internal constant PARAMS_ENTRY_SIZE = 32;\n\n    uint8 internal constant PARAMS_GAS_OUT = 16;\n\n    /// ClearTokens Decode Consts\n\n    uint8 internal constant PARAMS_TKN_START = 5;\n\n    uint8 internal constant PARAMS_AMT_OFFSET = 64;\n\n    uint8 internal constant PARAMS_DEPOSIT_OFFSET = 96;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain Id for Root Chain where liqudity is virtualized(e.g. 4).\n    uint256 public immutable rootChainId;\n\n    /// @notice Chain Id for Local Chain.\n    uint256 public immutable localChainId;\n\n    /// @notice Address for Local Wrapped Native Token.\n    WETH9 public immutable wrappedNativeToken;\n\n    /// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.\n    address public immutable rootBridgeAgentAddress;\n\n    /// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.\n    address public immutable localAnyCallAddress;\n\n    /// @notice Address for Local Anyexec Address where cross-chain requests from the Root Chain Router are received locally.\n    address public immutable localAnyCallExecutorAddress;\n\n    /// @notice Address for Local Router used for custom actions for different hApps.\n    address public immutable localRouterAddress;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are kept, managed and supplied to different Port Strategies.\n    address public immutable localPortAddress;\n\n    address public bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSITS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying transaction.\n    uint32 public depositNonce;\n\n    /// @notice Mapping from Pending deposits hash to Deposit Struct.\n    mapping(uint32 => Deposit) public getDeposit;\n\n    /*///////////////////////////////////////////////////////////////\n                            EXECUTOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, bridge agent has already served a request with this nonce from  a given chain. Chain -> Nonce -> Bool\n    mapping(uint32 => bool) public executionHistory;\n\n    /*///////////////////////////////////////////////////////////////\n                        GAS MANAGEMENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public remoteCallDepositedGas;\n\n    uint256 internal constant MIN_FALLBACK_RESERVE = 185_000; // 100_000 for anycall + 85_000 fallback execution overhead\n    uint256 internal constant MIN_EXECUTION_OVERHEAD = 160_000; // 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executions\n    uint256 internal constant TRANSFER_OVERHEAD = 24_000;\n\n    constructor(\n        WETH9 _wrappedNativeToken,\n        uint256 _rootChainId,\n        uint256 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) {\n        require(_rootBridgeAgentAddress != address(0), \"Root Bridge Agent Address cannot be the zero address.\");\n        require(_localAnyCallAddress != address(0), \"AnyCall Address cannot be the zero address.\");\n        require(_localAnyCallExecutorAddress != address(0), \"AnyCall Executor Address cannot be the zero address.\");\n        require(_localRouterAddress != address(0), \"Local Router Address cannot be the zero address.\");\n        require(_localPortAddress != address(0), \"Local Port Address cannot be the zero address.\");\n\n        wrappedNativeToken = _wrappedNativeToken;\n        localChainId = _localChainId;\n        rootChainId = _rootChainId;\n        rootBridgeAgentAddress = _rootBridgeAgentAddress;\n        localAnyCallAddress = _localAnyCallAddress;\n        localAnyCallExecutorAddress = _localAnyCallExecutorAddress;\n        localRouterAddress = _localRouterAddress;\n        localPortAddress = _localPortAddress;\n        bridgeAgentExecutorAddress = DeployBranchBridgeAgentExecutor.deploy();\n        depositNonce = 1;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function getDepositEntry(uint32 _depositNonce) external view returns (Deposit memory) {\n        return getDeposit[_depositNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOut(bytes calldata _params, uint128 _remoteExecutionGas) external payable lock requiresFallbackGas {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call without deposit\n        _callOut(msg.sender, _params, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call with deposit\n        _callOutAndBridge(msg.sender, _params, _dParams, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresFallbackGas {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call with multiple deposits\n        _callOutAndBridgeMultiple(msg.sender, _params, _dParams, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSigned(bytes calldata _params, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x04), msg.sender, depositNonce, _params, msg.value.toUint128(), _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Signed Call without deposit\n        _noDepositCall(msg.sender, packedData, msg.value.toUint128());\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x05),\n            msg.sender,\n            depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n            _dParams.toChain,\n            _params,\n            msg.value.toUint128(),\n            _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCall(\n            msg.sender,\n            packedData,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _dParams.deposit,\n            msg.value.toUint128()\n        );\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresFallbackGas {\n        //Normalize Deposits\n        uint256[] memory _deposits = new uint256[](_dParams.hTokens.length);\n\n        for (uint256 i = 0; i < _dParams.hTokens.length; i++) {\n            _deposits[i] = _normalizeDecimals(_dParams.deposits[i], ERC20(_dParams.tokens[i]).decimals());\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x06),\n            msg.sender,\n            uint8(_dParams.hTokens.length),\n            depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _deposits,\n            _dParams.toChain,\n            _params,\n            msg.value.toUint128(),\n            _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCallMultiple(\n            msg.sender,\n            packedData,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            msg.value.toUint128()\n        );\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retryDeposit(\n        bool _isSigned,\n        uint32 _depositNonce,\n        bytes calldata _params,\n        uint128 _remoteExecutionGas,\n        uint24 _toChain\n    ) external payable lock requiresFallbackGas {\n        //Check if deposit belongs to message sender\n        if (getDeposit[_depositNonce].owner != msg.sender) revert NotDepositOwner();\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData;\n\n        if (uint8(getDeposit[_depositNonce].hTokens.length) == 1) {\n            if (_isSigned) {\n                packedData = abi.encodePacked(\n                    bytes1(0x05),\n                    msg.sender,\n                    _depositNonce,\n                    getDeposit[_depositNonce].hTokens[0],\n                    getDeposit[_depositNonce].tokens[0],\n                    getDeposit[_depositNonce].amounts[0],\n                    _normalizeDecimals(\n                        getDeposit[_depositNonce].deposits[0], ERC20(getDeposit[_depositNonce].tokens[0]).decimals()\n                    ),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            } else {\n                packedData = abi.encodePacked(\n                    bytes1(0x02),\n                    _depositNonce,\n                    getDeposit[_depositNonce].hTokens[0],\n                    getDeposit[_depositNonce].tokens[0],\n                    getDeposit[_depositNonce].amounts[0],\n                    _normalizeDecimals(\n                        getDeposit[_depositNonce].deposits[0], ERC20(getDeposit[_depositNonce].tokens[0]).decimals()\n                    ),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            }\n        } else if (uint8(getDeposit[_depositNonce].hTokens.length) > 1) {\n            //Nonce\n            uint32 nonce = _depositNonce;\n\n            if (_isSigned) {\n                packedData = abi.encodePacked(\n                    bytes1(0x06),\n                    msg.sender,\n                    uint8(getDeposit[_depositNonce].hTokens.length),\n                    nonce,\n                    getDeposit[nonce].hTokens,\n                    getDeposit[nonce].tokens,\n                    getDeposit[nonce].amounts,\n                    _normalizeDecimalsMultiple(getDeposit[nonce].deposits, getDeposit[nonce].tokens),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            } else {\n                packedData = abi.encodePacked(\n                    bytes1(0x03),\n                    uint8(getDeposit[nonce].hTokens.length),\n                    _depositNonce,\n                    getDeposit[nonce].hTokens,\n                    getDeposit[nonce].tokens,\n                    getDeposit[nonce].amounts,\n                    _normalizeDecimalsMultiple(getDeposit[nonce].deposits, getDeposit[nonce].tokens),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            }\n        }\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Deposit Gas to Port\n        _depositGas(msg.value.toUint128());\n\n        //Ensure success Status\n        getDeposit[_depositNonce].status = DepositStatus.Success;\n\n        //Update Deposited Gas\n        getDeposit[_depositNonce].depositedGas = msg.value.toUint128();\n\n        //Perform Call\n        _performCall(packedData);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrySettlement(uint32 _settlementNonce, uint128 _gasToBoostSettlement)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x07), depositNonce++, _settlementNonce, msg.value.toUint128(), _gasToBoostSettlement\n        );\n        //Update State and Perform Call\n        _sendRetrieveOrRetry(packedData);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrieveDeposit(uint32 _depositNonce) external payable lock requiresFallbackGas {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(bytes1(0x08), _depositNonce, msg.value.toUint128(), uint128(0));\n\n        //Update State and Perform Call\n        _sendRetrieveOrRetry(packedData);\n    }\n\n    function _sendRetrieveOrRetry(bytes memory _data) internal {\n        //Deposit Gas for call.\n        _createGasDeposit(msg.sender, msg.value.toUint128());\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function redeemDeposit(uint32 _depositNonce) external lock {\n        //Update Deposit\n        if (getDeposit[_depositNonce].status != DepositStatus.Failed) {\n            revert DepositRedeemUnavailable();\n        }\n        _redeemDeposit(_depositNonce);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRANCH ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performSystemCallOut(\n        address _depositor,\n        bytes calldata _params,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData =\n            abi.encodePacked(bytes1(0x00), depositNonce, _params, gasToBridgeOut, _remoteExecutionGas);\n\n        //Perform Call\n        _noDepositCall(_depositor, packedData, gasToBridgeOut);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOut(\n        address _depositor,\n        bytes calldata _params,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOut(_depositor, _params, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOutAndBridge(\n        address _depositor,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOutAndBridge(_depositor, _params, _dParams, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOutAndBridgeMultiple(\n        address _depositor,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOutAndBridgeMultiple(_depositor, _params, _dParams, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function clearToken(address _recipient, address _hToken, address _token, uint256 _amount, uint256 _deposit)\n        external\n        requiresAgentExecutor\n    {\n        _clearToken(_recipient, _hToken, _token, _amount, _deposit);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function clearTokens(bytes calldata _sParams, address _recipient)\n        external\n        requiresAgentExecutor\n        returns (SettlementMultipleParams memory)\n    {\n        //Parse Params\n        uint8 numOfAssets = uint8(bytes1(_sParams[0]));\n        uint32 nonce = uint32(bytes4(_sParams[PARAMS_START:PARAMS_TKN_START]));\n\n        address[] memory _hTokens = new address[](numOfAssets);\n        address[] memory _tokens = new address[](numOfAssets);\n        uint256[] memory _amounts = new uint256[](numOfAssets);\n        uint256[] memory _deposits = new uint256[](numOfAssets);\n\n        //Transfer token to recipient\n        for (uint256 i = 0; i < numOfAssets;) {\n            //Parse Params\n            _hTokens[i] = address(\n                uint160(\n                    bytes20(\n                        bytes32(\n                            _sParams[\n                                PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * i) + 12:\n                                    PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * (PARAMS_START + i))\n                            ]\n                        )\n                    )\n                )\n            );\n            _tokens[i] = address(\n                uint160(\n                    bytes20(\n                        _sParams[\n                            PARAMS_TKN_START + PARAMS_ENTRY_SIZE * uint16(i + numOfAssets) + 12:\n                                PARAMS_TKN_START + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i + numOfAssets)\n                        ]\n                    )\n                )\n            );\n            _amounts[i] = uint256(\n                bytes32(\n                    _sParams[\n                        PARAMS_TKN_START + PARAMS_AMT_OFFSET * uint16(numOfAssets) + (PARAMS_ENTRY_SIZE * uint16(i)):\n                            PARAMS_TKN_START + PARAMS_AMT_OFFSET * uint16(numOfAssets)\n                                + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i)\n                    ]\n                )\n            );\n            _deposits[i] = uint256(\n                bytes32(\n                    _sParams[\n                        PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * uint16(numOfAssets) + (PARAMS_ENTRY_SIZE * uint16(i)):\n                            PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * uint16(numOfAssets)\n                                + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i)\n                    ]\n                )\n            );\n            //Clear Tokens to destination\n            if (_amounts[i] - _deposits[i] > 0) {\n                IPort(localPortAddress).bridgeIn(_recipient, _hTokens[i], _amounts[i] - _deposits[i]);\n            }\n\n            if (_deposits[i] > 0) {\n                IPort(localPortAddress).withdraw(_recipient, _tokens[i], _deposits[i]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return SettlementMultipleParams(numOfAssets, _recipient, nonce, _hTokens, _tokens, _amounts, _deposits);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                LOCAL USER DEPOSIT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router without token deposit.\n     *   @param _depositor address of the user that will deposit the funds.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 1 (Call without deposit)\n     *\n     */\n    function _callOut(address _depositor, bytes calldata _params, uint128 _gasToBridgeOut, uint128 _remoteExecutionGas)\n        internal\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData =\n            abi.encodePacked(bytes1(0x01), depositNonce, _params, _gasToBridgeOut, _remoteExecutionGas);\n\n        //Perform Call\n        _noDepositCall(_depositor, packedData, _gasToBridgeOut);\n    }\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router while depositing a single asset.\n     *   @param _depositor address of the user that will deposit the funds.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _dParams additional token deposit parameters.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 2 (Call with single deposit)\n     *\n     */\n    function _callOutAndBridge(\n        address _depositor,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) internal {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x02),\n            depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n            _dParams.toChain,\n            _params,\n            _gasToBridgeOut,\n            _remoteExecutionGas\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCall(\n            _depositor, packedData, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit, _gasToBridgeOut\n        );\n    }\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router while depositing two or more assets.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _dParams additional token deposit parameters.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 3 (Call with multiple deposit)\n     *\n     */\n    function _callOutAndBridgeMultiple(\n        address _depositor,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) internal {\n        //Normalize Deposits\n        uint256[] memory deposits = new uint256[](_dParams.hTokens.length);\n\n        for (uint256 i = 0; i < _dParams.hTokens.length; i++) {\n            deposits[i] = _normalizeDecimals(_dParams.deposits[i], ERC20(_dParams.tokens[i]).decimals());\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x03),\n            uint8(_dParams.hTokens.length),\n            depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            deposits,\n            _dParams.toChain,\n            _params,\n            _gasToBridgeOut,\n            _remoteExecutionGas\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCallMultiple(\n            _depositor,\n            packedData,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            _gasToBridgeOut\n        );\n    }\n\n    /**\n     * @notice Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _noDepositCall(address _depositor, bytes memory _data, uint128 _gasToBridgeOut) internal {\n        //Deposit Gas for call.\n        _createGasDeposit(_depositor, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @notice Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _hToken Local Input hToken Address.\n     *   @param _token Native / Underlying Token Address.\n     *   @param _amount Amount of Local hTokens deposited for trade.\n     *   @param _deposit Amount of native tokens deposited for trade.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _depositAndCall(\n        address _depositor,\n        bytes memory _data,\n        address _hToken,\n        address _token,\n        uint256 _amount,\n        uint256 _deposit,\n        uint128 _gasToBridgeOut\n    ) internal {\n        //Deposit and Store Info\n        _createDepositSingle(_depositor, _hToken, _token, _amount, _deposit, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @dev Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _hTokens Local Input hToken Address.\n     *   @param _tokens Native / Underlying Token Address.\n     *   @param _amounts Amount of Local hTokens deposited for trade.\n     *   @param _deposits  Amount of native tokens deposited for trade.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _depositAndCallMultiple(\n        address _depositor,\n        bytes memory _data,\n        address[] memory _hTokens,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        uint128 _gasToBridgeOut\n    ) internal {\n        //Validate Input\n        if (\n            _hTokens.length != _tokens.length || _tokens.length != _amounts.length\n                || _amounts.length != _deposits.length\n        ) revert InvalidInput();\n\n        //Deposit and Store Info\n        _createDepositMultiple(_depositor, _hTokens, _tokens, _amounts, _deposits, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @dev Function to create a pending deposit.\n     *    @param _user user address.\n     *    @param _gasToBridgeOut gas allocated for omnichain execution.\n     *\n     */\n    function _createGasDeposit(address _user, uint128 _gasToBridgeOut) internal {\n        //Deposit Gas to Port\n        _depositGas(_gasToBridgeOut);\n\n        // Update State\n        getDeposit[_getAndIncrementDepositNonce()] = Deposit({\n            owner: _user,\n            hTokens: new address[](0),\n            tokens: new address[](0),\n            amounts: new uint256[](0),\n            deposits: new uint256[](0),\n            status: DepositStatus.Success,\n            depositedGas: _gasToBridgeOut\n        });\n    }\n\n    /**\n     * @dev Function to create a pending deposit.\n     *    @param _user user address.\n     *    @param _hToken deposited local hToken addresses.\n     *    @param _token deposited native / underlying Token addresses.\n     *    @param _amount amounts of hTokens input.\n     *    @param _deposit amount of deposited underlying / native tokens.\n     *    @param _gasToBridgeOut gas allocated for omnichain execution.\n     *\n     */\n    function _createDepositSingle(\n        address _user,\n        address _hToken,"
    }
  ]
}