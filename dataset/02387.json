{
  "Title": "M-2: Protection can be bought in late pools, allowing buyers to pay minimal premium and increase the chance of a compensation",
  "Content": "# Issue M-2: Protection can be bought in late pools, allowing buyers to pay minimal premium and increase the chance of a compensation \n\nSource: https://github.com/sherlock-audit/2023-02-carapace-judging/issues/252 \n\n## Found by \nJeiwan, libratus, monrel, ctf\\_sec, rvierdiiev, ast3ros, Allarious, 0Kage, Kumpa, mahdikarimi\n\n## Summary\nA buyer can buy a protection for a pool that's already late on a payment. The buyer can pay the minimal premium and get a higher chance of getting a compensation. Protection sellers may bear higher losses due to reduced premium amounts and the increased chance of protection payments.\n## Vulnerability Detail\nThe protocol allows lenders on Goldfinch to get an insurance on the funds they lent. The insurance is paid after [a repayment was late](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/DefaultStateManager.sol#L324-L335). The protocol [doesn't allow protection buyers to buy protections for pools that's already late](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/libraries/ProtectionPoolHelper.sol#L407-L435) to disallow buyers abusing the protections payment mechanism. To do this, the `_verifyLendingPoolIsActive` function [checks the current status of a pool](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/libraries/ProtectionPoolHelper.sol#L412-L415) and [reverts if it's late](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/libraries/ProtectionPoolHelper.sol#L421-L426).\n\nHowever, `poolStatus` is cached and can be outdated when the function is called, since it's not updated in the call. Pool statuses are updated in [assessStates](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/DefaultStateManager.sol#L119) and [assessStateBatch](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/DefaultStateManager.sol#L137), which are triggered on schedule separately. This allows buyers to buy protections in pools that's already late in Goldfinch but still active in Carapace.\n\nConsider this scenario:\n1. A pool is in the active state after `assessStates` is run.\n1. Before the next `assessStates` call, the pool gets into the late state, due to a missed repayment. However, in the protocol, the pool is still in the active state since `assessStates` hasn't been called.\n1. The malicious buyer front runts the next `assessStates` call and submits their transactions that buys a protection with the minimal duration for the pool. The `_verifyLendingPoolIsActive` function passes because the pool's state hasn't been updated in the contracts yet.\n1. The `assessStates` call changes the status of the pool to `LateWithinGracePeriod`, which disallows buying protections for the pool.\n1. If the pool eventually gets into the default state (chances of that is higher since there's already a late payment), the malicious buyer will be eligible for a compensation.\n## Impact\nProtection buyers can increase their chances of getting a compensation, while buying protections with the minimal duration and paying the minimal premium. Protection sellers will bear increased loses due to reduced premium amounts and the increased chance of a compensation.\n## Code Snippet\n1. `_verifyLendingPoolIsActive` checks the current status of a pool and reverts if it's not active:\n[ProtectionPoolHelper.sol#L412-L415](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/libraries/ProtectionPoolHelper.sol#L412-L415)\n1. Pool statuses are cached and are stored in `DefaultStateManager`:\n[DefaultStateManager.sol#L278-L280](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/DefaultStateManager.sol#L278-L280)\n1. Pool statuses are updated in `DefaultStateManager.assessStates`:\n[DefaultStateManager.sol#L119](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/DefaultStateManager.sol#L119)\n1. `DefaultStateManager.assessStates` is not called by `ProtectionPool.buyProtection`:\n[ProtectionPool.sol#L162](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/pool/ProtectionPool.sol#L162)\n## Tool used\nManual Review\n## Recommendation\nIn `ProtectionPoolHelper._verifyLendingPoolIsActive`, consider calling `DefaultStateManager._assessState` to update the status of the pool for which a protection is bought.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/40",
  "Code": [
    {
      "filename": "contracts/core/DefaultStateManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ERC20SnapshotUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\n\nimport {UUPSUpgradeableBase} from \"../UUPSUpgradeableBase.sol\";\nimport {IReferenceLendingPools, LendingPoolStatus} from \"../interfaces/IReferenceLendingPools.sol\";\nimport {ILendingProtocolAdapter} from \"../interfaces/ILendingProtocolAdapter.sol\";\nimport {IProtectionPool} from \"../interfaces/IProtectionPool.sol\";\nimport {IDefaultStateManager, ProtectionPoolState, LockedCapital, LendingPoolStatusDetail} from \"../interfaces/IDefaultStateManager.sol\";\nimport \"../libraries/Constants.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title DefaultStateManager\n * @author Carapace Finance\n * @notice Contract to assess status updates and the resultant state transitions of all lending pools of all protection pools\n * @dev This contract is upgradeable using the UUPS pattern.\n */\ncontract DefaultStateManager is UUPSUpgradeableBase, IDefaultStateManager {\n  /////////////////////////////////////////////////////\n  ///             STORAGE - START                   ///\n  /////////////////////////////////////////////////////\n  /**\n   * @dev DO NOT CHANGE THE ORDER OF THESE VARIABLES ONCE DEPLOYED\n   */\n\n  /// @notice address of the contract factory which is the only contract allowed to register protection pools.\n  address public contractFactoryAddress;\n\n  /// @dev stores the current state of all protection pools in the system.\n  /// @dev Array is used for enumerating all pools during state assessment.\n  ProtectionPoolState[] private protectionPoolStates;\n\n  /// @notice tracks an index of ProtectionPoolState for each pool in protectionPoolStates array.\n  mapping(address => uint256) private protectionPoolStateIndexes;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE - END                     ///\n  /////////////////////////////////////////////////////\n\n  /*** modifiers ***/\n\n  /// @dev modifier to restrict access to the contract factory address.\n  modifier onlyContractFactory() {\n    if (msg.sender != contractFactoryAddress) {\n      revert NotContractFactory(msg.sender);\n    }\n    _;\n  }\n\n  /*** initializer ***/\n\n  /**\n   * @notice Initializes the contract.\n   */\n  function initialize() external initializer {\n    __UUPSUpgradeableBase_init();\n\n    /// create a dummy pool state to reserve index 0.\n    /// this is to ensure that protectionPoolStateIndexes[pool] is always greater than 0,\n    /// which is used to check if a pool is registered or not.\n    protectionPoolStates.push();\n  }\n\n  /*** state-changing functions ***/\n\n  /// @inheritdoc IDefaultStateManager\n  /// @dev This function is marked as payable for gas optimization.\n  function setContractFactory(address _contractFactoryAddress)\n    external\n    payable\n    override\n    onlyOwner\n  {\n    if (_contractFactoryAddress == Constants.ZERO_ADDRESS) {\n      revert ZeroContractFactoryAddress();\n    }\n\n    contractFactoryAddress = _contractFactoryAddress;\n    emit ContractFactoryUpdated(_contractFactoryAddress);\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function registerProtectionPool(address _protectionPoolAddress)\n    external\n    payable\n    override\n    onlyContractFactory\n  {\n    /// if the protection pool is already registered, revert\n    if (\n      protectionPoolStates[protectionPoolStateIndexes[_protectionPoolAddress]]\n        .updatedTimestamp > 0\n    ) {\n      revert ProtectionPoolAlreadyRegistered(_protectionPoolAddress);\n    }\n\n    /// Protection pool will be inserted at the end of the array\n    uint256 newIndex = protectionPoolStates.length;\n\n    /// Insert new empty pool state at the end of the array\n    /// and update the state\n    protectionPoolStates.push();\n    ProtectionPoolState storage poolState = protectionPoolStates[newIndex];\n    poolState.protectionPool = IProtectionPool(_protectionPoolAddress);\n\n    /// Store the index of the pool state in the array\n    protectionPoolStateIndexes[_protectionPoolAddress] = newIndex;\n\n    /// Assess the state of the newly registered protection pool\n    _assessState(poolState);\n\n    emit ProtectionPoolRegistered(_protectionPoolAddress);\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function assessStates() external override {\n    /// gas optimizations:\n    /// 1. capture length in memory & don't read from storage for each iteration\n    /// 2. uncheck incrementing pool index\n    uint256 _length = protectionPoolStates.length;\n\n    /// assess the state of all registered protection pools except the dummy pool at index 0\n    for (uint256 _poolIndex = 1; _poolIndex < _length; ) {\n      _assessState(protectionPoolStates[_poolIndex]);\n      unchecked {\n        ++_poolIndex;\n      }\n    }\n\n    emit ProtectionPoolStatesAssessed();\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function assessStateBatch(address[] calldata _pools) external override {\n    uint256 _length = _pools.length;\n    for (uint256 _poolIndex; _poolIndex < _length; ) {\n      /// Get the state of the pool by looking up the index in the mapping from the given pool address\n      ProtectionPoolState storage poolState = protectionPoolStates[\n        protectionPoolStateIndexes[_pools[_poolIndex]]\n      ];\n\n      /// Only assess the state if the protection pool is registered\n      if (poolState.updatedTimestamp > 0) {\n        _assessState(poolState);\n      }\n\n      unchecked {\n        ++_poolIndex;\n      }\n    }\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  /// @dev This method is only callable by a protection pool\n  function calculateAndClaimUnlockedCapital(address _seller)\n    external\n    override\n    returns (uint256 _claimedUnlockedCapital)\n  {\n    /// Get the state of the pool by looking up the index in the mapping from sender address\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[msg.sender]\n    ];\n\n    /// Only assess the state if the protection pool is registered\n    if (poolState.updatedTimestamp == 0) {\n      revert ProtectionPoolNotRegistered(msg.sender);\n    }\n\n    /// Get the list of all lending pools for the protection pool\n    address[] memory _lendingPools = poolState\n      .protectionPool\n      .getPoolInfo()\n      .referenceLendingPools\n      .getLendingPools();\n\n    /// Iterate through all lending pools for a given protection pool\n    /// and calculate the total claimable amount for the seller\n    uint256 _length = _lendingPools.length;\n    for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n      address _lendingPool = _lendingPools[_lendingPoolIndex];\n\n      /// Calculate the claimable amount across all the locked capital instances for a given protection pool\n      (\n        uint256 _unlockedCapitalPerLendingPool,\n        uint256 _snapshotId\n      ) = _calculateClaimableAmount(poolState, _lendingPool, _seller);\n      _claimedUnlockedCapital += _unlockedCapitalPerLendingPool;\n\n      /// update the last claimed snapshot id for the seller for the given lending pool,\n      /// so that the next time the seller claims, the calculation starts from the last claimed snapshot id\n      poolState.lastClaimedSnapshotIds[_lendingPool][_seller] = _snapshotId;\n\n      unchecked {\n        ++_lendingPoolIndex;\n      }\n    }\n  }\n\n  /** view functions */\n\n  /**\n   * @notice Returns the timestamp of the protection pool state update.\n   */\n  function getPoolStateUpdateTimestamp(address _pool)\n    external\n    view\n    returns (uint256)\n  {\n    return\n      protectionPoolStates[protectionPoolStateIndexes[_pool]].updatedTimestamp;\n  }\n\n  /**\n   * @notice Returns the list of locked capital instances for a given protection pool and lending pool.\n   */\n  function getLockedCapitals(address _protectionPool, address _lendingPool)\n    external\n    view\n    returns (LockedCapital[] memory _lockedCapitals)\n  {\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[_protectionPool]\n    ];\n    _lockedCapitals = poolState.lockedCapitals[_lendingPool];\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function calculateClaimableUnlockedAmount(\n    address _protectionPool,\n    address _seller\n  ) external view override returns (uint256 _claimableUnlockedCapital) {\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[_protectionPool]\n    ];\n\n    /// Calculate the claimable amount only if the protection pool is registered\n    if (poolState.updatedTimestamp > 0) {\n      /// Get the list of all lending pools for the protection pool\n      address[] memory _lendingPools = poolState\n        .protectionPool\n        .getPoolInfo()\n        .referenceLendingPools\n        .getLendingPools();\n\n      /// Iterate through all lending pools for a given protection pool\n      /// and calculate the total claimable amount for the seller\n      uint256 _length = _lendingPools.length;\n      for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n        address _lendingPool = _lendingPools[_lendingPoolIndex];\n\n        /// Calculate the claimable amount across all the locked capital instances for a given protection pool\n        (uint256 _unlockedCapitalPerLendingPool, ) = _calculateClaimableAmount(\n          poolState,\n          _lendingPool,\n          _seller\n        );\n\n        /// add the unlocked/claimable amount for the given lending pool to the total claimable amount\n        _claimableUnlockedCapital += _unlockedCapitalPerLendingPool;\n\n        unchecked {\n          ++_lendingPoolIndex;\n        }\n      }\n    }\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function getLendingPoolStatus(\n    address _protectionPoolAddress,\n    address _lendingPoolAddress\n  ) external view override returns (LendingPoolStatus) {\n    return\n      protectionPoolStates[protectionPoolStateIndexes[_protectionPoolAddress]]\n        .lendingPoolStateDetails[_lendingPoolAddress]\n        .currentStatus;\n  }\n\n  /** internal functions */\n\n  /**\n   * @dev assess the state of a given protection pool and\n   * update state changes & initiate related actions as needed.\n   */\n  function _assessState(ProtectionPoolState storage poolState) internal {\n    poolState.updatedTimestamp = block.timestamp;\n\n    /// assess the state of all reference lending pools of this protection pool\n    (\n      address[] memory _lendingPools,\n      LendingPoolStatus[] memory _currentStatuses\n    ) = poolState\n        .protectionPool\n        .getPoolInfo()\n        .referenceLendingPools\n        .assessState();\n\n    /// Compare previous and current status of each lending pool and perform the required state transition\n    uint256 _length = _lendingPools.length;\n    for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n      /// Get the lending pool state details\n      address _lendingPool = _lendingPools[_lendingPoolIndex];\n      LendingPoolStatusDetail storage lendingPoolStateDetail = poolState\n        .lendingPoolStateDetails[_lendingPool];\n\n      /// Get the previous and current status of the lending pool\n      LendingPoolStatus _previousStatus = lendingPoolStateDetail.currentStatus;\n      LendingPoolStatus _currentStatus = _currentStatuses[_lendingPoolIndex];\n\n      if (_previousStatus != _currentStatus) {\n        console.log(\n          \"DefaultStateManager: Lending pool %s status is changed from %s to  %s\",\n          _lendingPool,\n          uint256(_previousStatus),\n          uint256(_currentStatus)\n        );\n      }\n\n      /// State transition 1: Active or LateWithinGracePeriod -> Late\n      if (\n        (_previousStatus == LendingPoolStatus.Active ||\n          _previousStatus == LendingPoolStatus.LateWithinGracePeriod) &&\n        _currentStatus == LendingPoolStatus.Late\n      ) {\n        /// Update the current status of the lending pool to Late\n        /// and move the lending pool to the locked state\n        lendingPoolStateDetail.currentStatus = LendingPoolStatus.Late;\n        _moveFromActiveToLockedState(poolState, _lendingPool);\n\n        /// Capture the timestamp when the lending pool became late\n        lendingPoolStateDetail.lateTimestamp = block.timestamp;\n      } else if (_previousStatus == LendingPoolStatus.Late) {\n        /// Once there is a late payment, we wait for 2 payment periods.\n        /// After 2 payment periods are elapsed, either full payment is going to be made or not.\n        /// If all missed payments(full payment) are made, then a pool goes back to active.\n        /// If full payment is not made, then this lending pool is in the default state.\n        if (\n          block.timestamp >\n          (lendingPoolStateDetail.lateTimestamp +\n            _getTwoPaymentPeriodsInSeconds(poolState, _lendingPool))\n        ) {\n          /// State transition 2: Late -> Active\n          if (_currentStatus == LendingPoolStatus.Active) {\n            /// Update the current status of the lending pool to Active\n            /// and move the lending pool to the active state\n            lendingPoolStateDetail.currentStatus = LendingPoolStatus.Active;\n            _moveFromLockedToActiveState(poolState, _lendingPool);\n\n            /// Clear the late timestamp\n            lendingPoolStateDetail.lateTimestamp = 0;\n          }\n          /// State transition 3: Late -> Defaulted\n          else if (_currentStatus == LendingPoolStatus.Late) {\n            /// Update the current status of the lending pool to Active\n            lendingPoolStateDetail.currentStatus = LendingPoolStatus.Defaulted;\n\n            // Default state transition will be implemented in the next version of the protocol\n            // _moveFromLockedToDefaultedState(poolState, _lendingPool);\n          }\n        }\n      } else if (\n        _previousStatus == LendingPoolStatus.Defaulted ||\n        _previousStatus == LendingPoolStatus.Expired\n      ) {\n        /// no state transition for Defaulted or Expired state\n      } else {\n        /// Only update the status in storage if it is changed\n        if (_previousStatus != _currentStatus) {\n          lendingPoolStateDetail.currentStatus = _currentStatus;\n          /// No action required for any other state transition\n        }\n      }\n\n      unchecked {\n        ++_lendingPoolIndex;\n      }\n    }\n  }\n\n  /**\n   * @dev Moves the lending pool from active state to locked state.\n   * Meaning that the capital is locked in the protection pool.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   */\n  function _moveFromActiveToLockedState(\n    ProtectionPoolState storage poolState,\n    address _lendingPool\n  ) internal {\n    IProtectionPool _protectionPool = poolState.protectionPool;\n\n    /// step 1: calculate & lock the capital amount in the protection pool\n    (uint256 _lockedCapital, uint256 _snapshotId) = _protectionPool.lockCapital(\n      _lendingPool\n    );\n\n    /// step 2: create and store an instance of locked capital for the lending pool\n    poolState.lockedCapitals[_lendingPool].push(\n      LockedCapital({\n        snapshotId: _snapshotId,\n        amount: _lockedCapital,\n        locked: true\n      })\n    );\n\n    emit LendingPoolLocked(\n      _lendingPool,\n      address(_protectionPool),\n      _snapshotId,\n      _lockedCapital\n    );\n  }\n\n  /**\n   * @dev Releases the locked capital, so investors can claim their share of the unlocked capital\n   * The capital is released/unlocked from last locked capital instance.\n   * Because new lock capital instance can not be created until the latest one is active again.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   */\n  function _moveFromLockedToActiveState(\n    ProtectionPoolState storage poolState,\n    address _lendingPool\n  ) internal {\n    /// For each lending pool, every active -> late state change creates a new instance of the locked capital.\n    /// So last item in the array represents the latest state change.\n    LockedCapital storage lockedCapital = _getLatestLockedCapital(\n      poolState,\n      _lendingPool\n    );\n    lockedCapital.locked = false;\n\n    emit LendingPoolUnlocked(\n      _lendingPool,\n      address(poolState.protectionPool),\n      lockedCapital.amount\n    );\n  }\n\n  /**\n   * @dev Calculates the claimable amount across all locked capital instances for the given seller address for a given lending pool.\n   * locked capital can be only claimed when it is released and has not been claimed before.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   * @param _seller The address of the seller\n   * @return _claimableUnlockedCapital The claimable amount across all locked capital instances in underlying tokens\n   * @return _latestClaimedSnapshotId The snapshot id of the latest locked capital instance from which the claimable amount is calculated\n   */\n  function _calculateClaimableAmount(\n    ProtectionPoolState storage poolState,\n    address _lendingPool,\n    address _seller\n  )\n    internal\n    view\n    returns (\n      uint256 _claimableUnlockedCapital,\n      uint256 _latestClaimedSnapshotId\n    )\n  {\n    /// Retrieve the last claimed snapshot id for the seller from storage\n    uint256 _lastClaimedSnapshotId = poolState.lastClaimedSnapshotIds[\n      _lendingPool\n    ][_seller];\n\n    /// Retrieve the locked capital instances for the given lending pool\n    LockedCapital[] storage lockedCapitals = poolState.lockedCapitals[\n      _lendingPool\n    ];\n\n    /// Iterate over the locked capital instances and calculate the claimable amount\n    uint256 _length = lockedCapitals.length;\n    for (uint256 _index = 0; _index < _length; ) {\n      LockedCapital storage lockedCapital = lockedCapitals[_index];\n      uint256 _snapshotId = lockedCapital.snapshotId;\n\n      console.log(\n        \"lockedCapital.locked: %s, amt: %s\",\n        lockedCapital.locked,\n        lockedCapital.amount\n      );\n\n      /// Verify that the seller does not claim the same snapshot twice\n      if (!lockedCapital.locked && _snapshotId > _lastClaimedSnapshotId) {\n        ERC20SnapshotUpgradeable _poolSToken = ERC20SnapshotUpgradeable(\n          address(poolState.protectionPool)\n        );\n\n        console.log(\n          \"balance of seller: %s, total supply: %s at snapshot: %s\",\n          _poolSToken.balanceOfAt(_seller, _snapshotId),\n          _poolSToken.totalSupplyAt(_snapshotId),\n          _snapshotId\n        );\n\n        /// The claimable amount for the given seller is proportional to the seller's share of the total supply at the snapshot\n        /// claimable amount = (seller's snapshot balance / total supply at snapshot) * locked capital amount\n        _claimableUnlockedCapital =\n          (_poolSToken.balanceOfAt(_seller, _snapshotId) *\n            lockedCapital.amount) /\n          _poolSToken.totalSupplyAt(_snapshotId);\n\n        /// Update the last claimed snapshot id for the seller\n        _latestClaimedSnapshotId = _snapshotId;\n\n        console.log(\n          \"Claimable amount for seller %s is %s\",\n          _seller,\n          _claimableUnlockedCapital\n        );\n      }\n\n      unchecked {\n        ++_index;\n      }\n    }\n  }\n\n  /**\n   * @dev Returns the latest locked capital instance for a given lending pool.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   */\n  function _getLatestLockedCapital(\n    ProtectionPoolState storage poolState,\n    address _lendingPool\n  ) internal view returns (LockedCapital storage _lockedCapital) {\n    /// Return the last locked capital instance in the array\n    LockedCapital[] storage lockedCapitals = poolState.lockedCapitals[\n      _lendingPool\n    ];\n    _lockedCapital = lockedCapitals[lockedCapitals.length - 1];\n  }\n\n  /**\n   * @dev Returns the two payment periods in seconds for a given lending pool.\n   * @param poolState The stored state of the protection pool\n   * @param _lendingPool The address of the lending pool\n   * @return The two payment periods in seconds for a given lending pool\n   */\n  function _getTwoPaymentPeriodsInSeconds(\n    ProtectionPoolState storage poolState,\n    address _lendingPool\n  ) internal view returns (uint256) {\n    /// Retrieve the payment period in days for the given lending pool and convert it to seconds\n    return\n      (poolState\n        .protectionPool\n        .getPoolInfo()\n        .referenceLendingPools\n        .getPaymentPeriodInDays(_lendingPool) * 2) *\n      Constants.SECONDS_IN_DAY_UINT;\n  }\n}"
    },
    {
      "filename": "contracts/core/DefaultStateManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ERC20SnapshotUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\n\nimport {UUPSUpgradeableBase} from \"../UUPSUpgradeableBase.sol\";\nimport {IReferenceLendingPools, LendingPoolStatus} from \"../interfaces/IReferenceLendingPools.sol\";\nimport {ILendingProtocolAdapter} from \"../interfaces/ILendingProtocolAdapter.sol\";\nimport {IProtectionPool} from \"../interfaces/IProtectionPool.sol\";\nimport {IDefaultStateManager, ProtectionPoolState, LockedCapital, LendingPoolStatusDetail} from \"../interfaces/IDefaultStateManager.sol\";\nimport \"../libraries/Constants.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title DefaultStateManager\n * @author Carapace Finance\n * @notice Contract to assess status updates and the resultant state transitions of all lending pools of all protection pools\n * @dev This contract is upgradeable using the UUPS pattern.\n */\ncontract DefaultStateManager is UUPSUpgradeableBase, IDefaultStateManager {\n  /////////////////////////////////////////////////////\n  ///             STORAGE - START                   ///\n  /////////////////////////////////////////////////////\n  /**\n   * @dev DO NOT CHANGE THE ORDER OF THESE VARIABLES ONCE DEPLOYED\n   */\n\n  /// @notice address of the contract factory which is the only contract allowed to register protection pools.\n  address public contractFactoryAddress;\n\n  /// @dev stores the current state of all protection pools in the system.\n  /// @dev Array is used for enumerating all pools during state assessment.\n  ProtectionPoolState[] private protectionPoolStates;\n\n  /// @notice tracks an index of ProtectionPoolState for each pool in protectionPoolStates array.\n  mapping(address => uint256) private protectionPoolStateIndexes;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE - END                     ///\n  /////////////////////////////////////////////////////\n\n  /*** modifiers ***/\n\n  /// @dev modifier to restrict access to the contract factory address.\n  modifier onlyContractFactory() {\n    if (msg.sender != contractFactoryAddress) {\n      revert NotContractFactory(msg.sender);\n    }\n    _;\n  }\n\n  /*** initializer ***/\n\n  /**\n   * @notice Initializes the contract.\n   */\n  function initialize() external initializer {\n    __UUPSUpgradeableBase_init();\n\n    /// create a dummy pool state to reserve index 0.\n    /// this is to ensure that protectionPoolStateIndexes[pool] is always greater than 0,\n    /// which is used to check if a pool is registered or not.\n    protectionPoolStates.push();\n  }\n\n  /*** state-changing functions ***/\n\n  /// @inheritdoc IDefaultStateManager\n  /// @dev This function is marked as payable for gas optimization.\n  function setContractFactory(address _contractFactoryAddress)\n    external\n    payable\n    override\n    onlyOwner\n  {\n    if (_contractFactoryAddress == Constants.ZERO_ADDRESS) {\n      revert ZeroContractFactoryAddress();\n    }\n\n    contractFactoryAddress = _contractFactoryAddress;\n    emit ContractFactoryUpdated(_contractFactoryAddress);\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function registerProtectionPool(address _protectionPoolAddress)\n    external\n    payable\n    override\n    onlyContractFactory\n  {\n    /// if the protection pool is already registered, revert\n    if (\n      protectionPoolStates[protectionPoolStateIndexes[_protectionPoolAddress]]\n        .updatedTimestamp > 0\n    ) {\n      revert ProtectionPoolAlreadyRegistered(_protectionPoolAddress);\n    }\n\n    /// Protection pool will be inserted at the end of the array\n    uint256 newIndex = protectionPoolStates.length;\n\n    /// Insert new empty pool state at the end of the array\n    /// and update the state\n    protectionPoolStates.push();\n    ProtectionPoolState storage poolState = protectionPoolStates[newIndex];\n    poolState.protectionPool = IProtectionPool(_protectionPoolAddress);\n\n    /// Store the index of the pool state in the array\n    protectionPoolStateIndexes[_protectionPoolAddress] = newIndex;\n\n    /// Assess the state of the newly registered protection pool\n    _assessState(poolState);\n\n    emit ProtectionPoolRegistered(_protectionPoolAddress);\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function assessStates() external override {\n    /// gas optimizations:\n    /// 1. capture length in memory & don't read from storage for each iteration\n    /// 2. uncheck incrementing pool index\n    uint256 _length = protectionPoolStates.length;\n\n    /// assess the state of all registered protection pools except the dummy pool at index 0\n    for (uint256 _poolIndex = 1; _poolIndex < _length; ) {\n      _assessState(protectionPoolStates[_poolIndex]);\n      unchecked {\n        ++_poolIndex;\n      }\n    }\n\n    emit ProtectionPoolStatesAssessed();\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function assessStateBatch(address[] calldata _pools) external override {\n    uint256 _length = _pools.length;\n    for (uint256 _poolIndex; _poolIndex < _length; ) {\n      /// Get the state of the pool by looking up the index in the mapping from the given pool address\n      ProtectionPoolState storage poolState = protectionPoolStates[\n        protectionPoolStateIndexes[_pools[_poolIndex]]\n      ];\n\n      /// Only assess the state if the protection pool is registered\n      if (poolState.updatedTimestamp > 0) {\n        _assessState(poolState);\n      }\n\n      unchecked {\n        ++_poolIndex;\n      }\n    }\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  /// @dev This method is only callable by a protection pool\n  function calculateAndClaimUnlockedCapital(address _seller)\n    external\n    override\n    returns (uint256 _claimedUnlockedCapital)\n  {\n    /// Get the state of the pool by looking up the index in the mapping from sender address\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[msg.sender]\n    ];\n\n    /// Only assess the state if the protection pool is registered\n    if (poolState.updatedTimestamp == 0) {\n      revert ProtectionPoolNotRegistered(msg.sender);\n    }\n\n    /// Get the list of all lending pools for the protection pool\n    address[] memory _lendingPools = poolState\n      .protectionPool\n      .getPoolInfo()\n      .referenceLendingPools\n      .getLendingPools();\n\n    /// Iterate through all lending pools for a given protection pool\n    /// and calculate the total claimable amount for the seller\n    uint256 _length = _lendingPools.length;\n    for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n      address _lendingPool = _lendingPools[_lendingPoolIndex];\n\n      /// Calculate the claimable amount across all the locked capital instances for a given protection pool\n      (\n        uint256 _unlockedCapitalPerLendingPool,\n        uint256 _snapshotId\n      ) = _calculateClaimableAmount(poolState, _lendingPool, _seller);\n      _claimedUnlockedCapital += _unlockedCapitalPerLendingPool;\n\n      /// update the last claimed snapshot id for the seller for the given lending pool,\n      /// so that the next time the seller claims, the calculation starts from the last claimed snapshot id\n      poolState.lastClaimedSnapshotIds[_lendingPool][_seller] = _snapshotId;\n\n      unchecked {\n        ++_lendingPoolIndex;\n      }\n    }\n  }\n\n  /** view functions */\n\n  /**\n   * @notice Returns the timestamp of the protection pool state update.\n   */\n  function getPoolStateUpdateTimestamp(address _pool)\n    external\n    view\n    returns (uint256)\n  {\n    return\n      protectionPoolStates[protectionPoolStateIndexes[_pool]].updatedTimestamp;\n  }\n\n  /**\n   * @notice Returns the list of locked capital instances for a given protection pool and lending pool.\n   */\n  function getLockedCapitals(address _protectionPool, address _lendingPool)\n    external\n    view\n    returns (LockedCapital[] memory _lockedCapitals)\n  {\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[_protectionPool]\n    ];\n    _lockedCapitals = poolState.lockedCapitals[_lendingPool];\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function calculateClaimableUnlockedAmount(\n    address _protectionPool,\n    address _seller\n  ) external view override returns (uint256 _claimableUnlockedCapital) {\n    ProtectionPoolState storage poolState = protectionPoolStates[\n      protectionPoolStateIndexes[_protectionPool]\n    ];\n\n    /// Calculate the claimable amount only if the protection pool is registered\n    if (poolState.updatedTimestamp > 0) {\n      /// Get the list of all lending pools for the protection pool\n      address[] memory _lendingPools = poolState\n        .protectionPool\n        .getPoolInfo()\n        .referenceLendingPools\n        .getLendingPools();\n\n      /// Iterate through all lending pools for a given protection pool\n      /// and calculate the total claimable amount for the seller\n      uint256 _length = _lendingPools.length;\n      for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n        address _lendingPool = _lendingPools[_lendingPoolIndex];\n\n        /// Calculate the claimable amount across all the locked capital instances for a given protection pool\n        (uint256 _unlockedCapitalPerLendingPool, ) = _calculateClaimableAmount(\n          poolState,\n          _lendingPool,\n          _seller\n        );\n\n        /// add the unlocked/claimable amount for the given lending pool to the total claimable amount\n        _claimableUnlockedCapital += _unlockedCapitalPerLendingPool;\n\n        unchecked {\n          ++_lendingPoolIndex;\n        }\n      }\n    }\n  }\n\n  /// @inheritdoc IDefaultStateManager\n  function getLendingPoolStatus(\n    address _protectionPoolAddress,\n    address _lendingPoolAddress\n  ) external view override returns (LendingPoolStatus) {\n    return\n      protectionPoolStates[protectionPoolStateIndexes[_protectionPoolAddress]]\n        .lendingPoolStateDetails[_lendingPoolAddress]\n        .currentStatus;\n  }\n\n  /** internal functions */\n\n  /**\n   * @dev assess the state of a given protection pool and\n   * update state changes & initiate related actions as needed.\n   */\n  function _assessState(ProtectionPoolState storage poolState) internal {\n    poolState.updatedTimestamp = block.timestamp;\n\n    /// assess the state of all reference lending pools of this protection pool\n    (\n      address[] memory _lendingPools,\n      LendingPoolStatus[] memory _currentStatuses\n    ) = poolState\n        .protectionPool\n        .getPoolInfo()\n        .referenceLendingPools\n        .assessState();\n\n    /// Compare previous and current status of each lending pool and perform the required state transition\n    uint256 _length = _lendingPools.length;\n    for (uint256 _lendingPoolIndex; _lendingPoolIndex < _length; ) {\n      /// Get the lending pool state details\n      address _lendingPool = _lendingPools[_lendingPoolIndex];\n      LendingPoolStatusDetail storage lendingPoolStateDetail = poolState\n        .lendingPoolStateDetails[_lendingPool];\n\n      /// Get the previous and current status of the lending pool\n      LendingPoolStatus _previousStatus = lendingPoolStateDetail.currentStatus;\n      LendingPoolStatus _currentStatus = _currentStatuses[_lendingPoolIndex];\n\n      if (_previousStatus != _currentStatus) {\n        console.log(\n          \"DefaultStateManager: Lending pool %s status is changed from %s to  %s\",\n          _lendingPool,\n          uint256(_previousStatus),\n          uint256(_currentStatus)\n        );\n      }\n\n      /// State transition 1: Active or LateWithinGracePeriod -> Late\n      if (\n        (_previousStatus == LendingPoolStatus.Active ||\n          _previousStatus == LendingPoolStatus.LateWithinGracePeriod) &&\n        _currentStatus == LendingPoolStatus.Late\n      ) {\n        /// Update the current status of the lending pool to Late\n        /// and move the lending pool to the locked state\n        lendingPoolStateDetail.currentStatus = LendingPoolStatus.Late;\n        _moveFromActiveToLockedState(poolState, _lendingPool);\n\n        /// Capture the timestamp when the lending pool became late\n        lendingPoolStateDetail.lateTimestamp = block.timestamp;\n      } else if (_previousStatus == LendingPoolStatus.L"
    }
  ]
}