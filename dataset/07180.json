{
  "Title": "[G-21] Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead",
  "Content": "\nWhen using elements that are smaller than 32 bytes, your contracts gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\nhttps://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html \n\nUse a larger size then downcast where needed.\n\n23 results - 4 files:\n```solidity\npackages\\v2-library\\src\\SafeCast.sol:\n  20:    result = uint16(value);\n\n  38:    result = uint160(value);\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/SafeCast.sol#L20\n\n```solidity\npackages\\v2-pool\\src\\TimeswapV2Pool.sol:\n  104:   return pools[strike][maturity].liquidity;\n\n  109:   return pools[strike][maturity].sqrtInterestRate;\n\n  114:   return pools[strike][maturity].liquidityPositions[owner].liquidity;\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/TimeswapV2Pool.sol#L104\n\n```solidity\npackages\\v2-pool\\src\\libraries\\ConstantProduct.sol:\n  67:    liquidityAmount = getLiquidityGivenLong(rate, longAmount, !isAdd);\n\n  82:    liquidityAmount = getLiquidityGivenShort(rate, shortAmount, duration, !isAdd);\n\n  104:   liquidityAmount = getLiquidityGivenLong(rate, amount, !isAdd);\n\n  110:   liquidityAmount = getLiquidityGivenShort(rate, amount, duration, !isAdd);\n\n  142:   newRate = isAdd ? rate + deltaRate : rate - deltaRate;\n\n  174:   newRate = getNewSqrtInterestRateGivenLong(liquidity, rate, longAmount + (isAdd ? 0 : fees), isAdd);\n\n  206:   (newRate, deltaRate) = getNewSqrtInterestRateGivenShort(liquidity, rate, shortAmount + (isAdd ? 0 : fees), duration, isAdd);\n\n  260:   return FullMath.mulDiv(uint256(rate), longAmount, uint256(1) << 96, roundUp).toUint160();\n\n  269:   return FullMath.mulDiv(shortAmount, uint256(1) << 192, uint256(rate).unsafeMul(duration), roundUp).toUint160();\n\n  296:   return numerator.div(denominator2, true).toUint160();\n\n  316:   deltaRate = FullMath.mulDiv(shortAmount, uint256(1) << 192, denominator, !isAdd).toUint160();\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/libraries/ConstantProduct.sol#L67\n\n```solidity\npackages\\v2-pool\\src\\structs\\LiquidityPosition.sol:\n  66:    liquidityPosition.liquidity += liquidityAmount;\n\n  76:    liquidityPosition.liquidity -= liquidityAmount;\n\n  207:   pool.sqrtInterestRate = rate;\n\n  308:   liquidityAmount = param.delta.toUint160(),\n\n  398:   liquidityAmount = param.delta.toUint160(),\n\n  486:   param.delta.toUint160(),\n\n  572:   param.delta.toUint160(),\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/structs/LiquidityPosition.sol#L66\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-library/src/SafeCast.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nlibrary SafeCast {\n    /// @dev Reverts when overflows over uint16.\n    error Uint16Overflow();\n\n    /// @dev Reverts when overflows over uint96.\n    error Uint96Overflow();\n\n    /// @dev Reverts when overflows over uint160.\n    error Uint160Overflow();\n\n    /// @dev Safely cast a uint256 number to uint16.\n    /// @dev Reverts when number is greater than uint16.\n    /// @param value The uint256 number to be safecasted.\n    /// @param result The uint16 result.\n    function toUint16(uint256 value) internal pure returns (uint16 result) {\n        if (value > type(uint16).max) revert Uint16Overflow();\n        result = uint16(value);\n    }\n\n    /// @dev Safely cast a uint256 number to uint96.\n    /// @dev Reverts when number is greater than uint96.\n    /// @param value The uint256 number to be safecasted.\n    /// @param result The uint96 result.\n    function toUint96(uint256 value) internal pure returns (uint96 result) {\n        if (value > type(uint96).max) revert Uint96Overflow();\n        result = uint96(value);\n    }\n\n    /// @dev Safely cast a uint256 number to uint160.\n    /// @dev Reverts when number is greater than uint160.\n    /// @param value The uint256 number to be safecasted.\n    /// @param result The uint160 result.\n    function toUint160(uint256 value) internal pure returns (uint160 result) {\n        if (value > type(uint160).max) revert Uint160Overflow();\n        result = uint160(value);\n    }\n}"
    },
    {
      "filename": "packages/v2-pool/src/TimeswapV2Pool.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Ownership} from \"@timeswap-labs/v2-library/src/Ownership.sol\";\n\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {ITimeswapV2Option} from \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\n\nimport {TimeswapV2OptionPosition} from \"@timeswap-labs/v2-option/src/enums/Position.sol\";\n\nimport {StrikeAndMaturity} from \"@timeswap-labs/v2-option/src/structs/StrikeAndMaturity.sol\";\n\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\n\nimport {ITimeswapV2Pool} from \"./interfaces/ITimeswapV2Pool.sol\";\nimport {ITimeswapV2PoolFactory} from \"./interfaces/ITimeswapV2PoolFactory.sol\";\nimport {ITimeswapV2PoolDeployer} from \"./interfaces/ITimeswapV2PoolDeployer.sol\";\n\nimport {ITimeswapV2PoolMintCallback} from \"./interfaces/callbacks/ITimeswapV2PoolMintCallback.sol\";\nimport {ITimeswapV2PoolBurnCallback, ITimeswapV2PoolBurn2Callback} from \"./interfaces/callbacks/ITimeswapV2PoolBurnCallback.sol\";\nimport {ITimeswapV2PoolDeleverageCallback} from \"./interfaces/callbacks/ITimeswapV2PoolDeleverageCallback.sol\";\nimport {ITimeswapV2PoolLeverageCallback} from \"./interfaces/callbacks/ITimeswapV2PoolLeverageCallback.sol\";\nimport {ITimeswapV2PoolRebalanceCallback} from \"./interfaces/callbacks/ITimeswapV2PoolRebalanceCallback.sol\";\n\nimport {ReentrancyGuard} from \"./libraries/ReentrancyGuard.sol\";\n\nimport {LiquidityPosition, LiquidityPositionLibrary} from \"./structs/LiquidityPosition.sol\";\n\nimport {Pool, PoolLibrary} from \"./structs/Pool.sol\";\nimport {TimeswapV2PoolCollectParam, TimeswapV2PoolMintParam, TimeswapV2PoolBurnParam, TimeswapV2PoolDeleverageParam, TimeswapV2PoolLeverageParam, TimeswapV2PoolRebalanceParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2PoolMintChoiceCallbackParam, TimeswapV2PoolMintCallbackParam, TimeswapV2PoolBurnChoiceCallbackParam, TimeswapV2PoolBurnCallbackParam, TimeswapV2PoolDeleverageChoiceCallbackParam, TimeswapV2PoolDeleverageCallbackParam, TimeswapV2PoolLeverageCallbackParam, TimeswapV2PoolLeverageChoiceCallbackParam, TimeswapV2PoolRebalanceCallbackParam} from \"./structs/CallbackParam.sol\";\n\nimport {TimeswapV2PoolMint, TimeswapV2PoolBurn, TimeswapV2PoolDeleverage, TimeswapV2PoolLeverage, TimeswapV2PoolRebalance, TransactionLibrary} from \"./enums/Transaction.sol\";\n\ncontract TimeswapV2Pool is ITimeswapV2Pool, NoDelegateCall {\n    using PoolLibrary for Pool;\n    using Ownership for address;\n    using LiquidityPositionLibrary for LiquidityPosition;\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    address public immutable override poolFactory;\n    /// @inheritdoc ITimeswapV2Pool\n    address public immutable override optionPair;\n    /// @inheritdoc ITimeswapV2Pool\n    uint256 public immutable override transactionFee;\n    /// @inheritdoc ITimeswapV2Pool\n    uint256 public immutable override protocolFee;\n\n    mapping(uint256 => mapping(uint256 => uint96)) private reentrancyGuards;\n    mapping(uint256 => mapping(uint256 => Pool)) private pools;\n\n    StrikeAndMaturity[] private listOfPools;\n\n    function addPoolEnumerationIfNecessary(uint256 strike, uint256 maturity) private {\n        if (reentrancyGuards[strike][maturity] == ReentrancyGuard.NOT_INTERACTED) {\n            reentrancyGuards[strike][maturity] = ReentrancyGuard.NOT_ENTERED;\n            listOfPools.push(StrikeAndMaturity({strike: strike, maturity: maturity}));\n        }\n    }\n\n    /* ===== MODIFIER ===== */\n\n    function raiseGuard(uint256 strike, uint256 maturity) private {\n        ReentrancyGuard.check(reentrancyGuards[strike][maturity]);\n        reentrancyGuards[strike][maturity] = ReentrancyGuard.ENTERED;\n    }\n\n    function lowerGuard(uint256 strike, uint256 maturity) private {\n        reentrancyGuards[strike][maturity] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /* ===== INIT ===== */\n\n    constructor() NoDelegateCall() {\n        (poolFactory, optionPair, transactionFee, protocolFee) = ITimeswapV2PoolDeployer(msg.sender).parameter();\n    }\n\n    // Can be overidden for testing purposes.\n    function blockTimestamp(uint96 durationForward) internal view virtual returns (uint96) {\n        return uint96(block.timestamp + durationForward); // truncation is desired\n    }\n\n    /* ===== VIEW ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    function getByIndex(uint256 id) external view override returns (StrikeAndMaturity memory) {\n        return listOfPools[id];\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function numberOfPools() external view override returns (uint256) {\n        return listOfPools.length;\n    }\n\n    function hasLiquidity(uint256 strike, uint256 maturity) private view {\n        if (pools[strike][maturity].liquidity == 0) Error.requireLiquidity();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLiquidity(uint256 strike, uint256 maturity) external view override returns (uint160) {\n        return pools[strike][maturity].liquidity;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function sqrtInterestRate(uint256 strike, uint256 maturity) external view override returns (uint160) {\n        return pools[strike][maturity].sqrtInterestRate;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function liquidityOf(uint256 strike, uint256 maturity, address owner) external view override returns (uint160) {\n        return pools[strike][maturity].liquidityPositions[owner].liquidity;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function feeGrowth(uint256 strike, uint256 maturity) external view override returns (uint256 long0FeeGrowth, uint256 long1FeeGrowth, uint256 shortFeeGrowth) {\n        return pools[strike][maturity].feeGrowth();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function feesEarnedOf(uint256 strike, uint256 maturity, address owner) external view override returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees) {\n        return pools[strike][maturity].feesEarnedOf(owner);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function protocolFeesEarned(uint256 strike, uint256 maturity) external view override returns (uint256 long0ProtocolFees, uint256 long1ProtocolFees, uint256 shortProtocolFees) {\n        return pools[strike][maturity].protocolFeesEarned();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLongBalance(uint256 strike, uint256 maturity) external view override returns (uint256 long0Amount, uint256 long1Amount) {\n        Pool storage pool = pools[strike][maturity];\n        long0Amount = pool.long0Balance;\n        long1Amount = pool.long1Balance;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLongBalanceAdjustFees(uint256 strike, uint256 maturity) external view override returns (uint256 long0Amount, uint256 long1Amount) {\n        (long0Amount, long1Amount) = pools[strike][maturity].totalLongBalanceAdjustFees(transactionFee);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalPositions(uint256 strike, uint256 maturity) external view override returns (uint256 longAmount, uint256 shortAmount) {\n        (longAmount, shortAmount) = pools[strike][maturity].totalPositions(maturity, blockTimestamp(0));\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    function transferLiquidity(uint256 strike, uint256 maturity, address to, uint160 liquidityAmount) external override {\n        hasLiquidity(strike, maturity);\n\n        if (blockTimestamp(0) > maturity) Error.alreadyMatured(maturity, blockTimestamp(0));\n        if (to == address(0)) Error.zeroAddress();\n        if (liquidityAmount == 0) Error.zeroInput();\n\n        pools[strike][maturity].transferLiquidity(to, liquidityAmount, blockTimestamp(0));\n\n        emit TransferLiquidity(strike, maturity, msg.sender, to, liquidityAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function transferFees(uint256 strike, uint256 maturity, address to, uint256 long0Fees, uint256 long1Fees, uint256 shortFees) external override {\n        if (to == address(0)) Error.zeroAddress();\n        if (long0Fees == 0 && long1Fees == 0 && shortFees == 0) Error.zeroInput();\n\n        pools[strike][maturity].transferFees(maturity, to, long0Fees, long1Fees, shortFees, blockTimestamp(0));\n\n        emit TransferFees(strike, maturity, msg.sender, to, long0Fees, long1Fees, shortFees);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function initialize(uint256 strike, uint256 maturity, uint160 rate) external override noDelegateCall {\n        if (maturity < blockTimestamp(0)) Error.alreadyMatured(maturity, blockTimestamp(0));\n        if (rate == 0) Error.cannotBeZero();\n        addPoolEnumerationIfNecessary(strike, maturity);\n\n        pools[strike][maturity].initialize(rate);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function collectProtocolFees(TimeswapV2PoolCollectParam calldata param) external override noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {\n        ParamLibrary.check(param);\n        raiseGuard(param.strike, param.maturity);\n\n        // Can only be called by the TimeswapV2Pool factory owner.\n        ITimeswapV2PoolFactory(poolFactory).owner().checkIfOwner();\n\n        // Calculate the main logic of protocol fee.\n        (long0Amount, long1Amount, shortAmount) = pools[param.strike][param.maturity].collectProtocolFees(param.long0Requested, param.long1Requested, param.shortRequested);\n\n        collect(param.strike, param.maturity, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit CollectProtocolFees(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function collectTransactionFees(TimeswapV2PoolCollectParam calldata param) external override noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {\n        ParamLibrary.check(param);\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of transaction fee.\n        (long0Amount, long1Amount, shortAmount) = pools[param.strike][param.maturity].collectTransactionFees(\n            param.maturity,\n            param.long0Requested,\n            param.long1Requested,\n            param.shortRequested,\n            blockTimestamp(0)\n        );\n\n        collect(param.strike, param.maturity, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit CollectTransactionFee(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @dev Transfer long0 positions, long1 positions, and/or short positions to the receipients.\n    /// @param strike The strike price of the pool.\n    /// @param maturity The maturity of the pool.\n    /// @param long0To The receipient of long0 positions.\n    /// @param long1To The receipient of long1 positions.\n    /// @param shortTo The receipient of short positions.\n    /// @param long0Amount The amount of long0 positions wanted.\n    /// @param long1Amount The amount of long1 positions wanted.\n    /// @param shortAmount The amount of short positions wanted.\n    function collect(uint256 strike, uint256 maturity, address long0To, address long1To, address shortTo, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) private {\n        if (long0Amount != 0) ITimeswapV2Option(optionPair).transferPosition(strike, maturity, long0To, TimeswapV2OptionPosition.Long0, long0Amount);\n\n        if (long1Amount != 0) ITimeswapV2Option(optionPair).transferPosition(strike, maturity, long1To, TimeswapV2OptionPosition.Long1, long1Amount);\n\n        if (shortAmount != 0) ITimeswapV2Option(optionPair).transferPosition(strike, maturity, shortTo, TimeswapV2OptionPosition.Short, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function mint(TimeswapV2PoolMintParam calldata param) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return mint(param, false, 0);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function mint(\n        TimeswapV2PoolMintParam calldata param,\n        uint96 durationForward\n    ) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return mint(param, true, durationForward);\n    }\n\n    function mint(\n        TimeswapV2PoolMintParam calldata param,\n        bool isQuote,\n        uint96 durationForward\n    ) private noDelegateCall returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        ParamLibrary.check(param, blockTimestamp(durationForward));\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of mint function.\n        (liquidityAmount, long0Amount, long1Amount, shortAmount, data) = pools[param.strike][param.maturity].mint(param, blockTimestamp(durationForward));\n\n        // Calculate the amount of long0 position, long1 position, and short position required by the pool.\n\n        // long0Amount chosen could be zero. Skip the calculation for gas efficiency.\n        uint256 long0BalanceTarget;\n        if (long0Amount != 0) long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + long0Amount;\n\n        // long1Amount chosen could be zero. Skip the calculation for gas efficiency.\n        uint256 long1BalanceTarget;\n        if (long1Amount != 0) long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + long1Amount;\n\n        // shortAmount cannot be zero.\n        uint256 shortBalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + shortAmount;\n\n        // Ask the msg.sender to transfer the positions into this address.\n        data = ITimeswapV2PoolMintCallback(msg.sender).timeswapV2PoolMintCallback(\n            TimeswapV2PoolMintCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                long0Amount: long0Amount,\n                long1Amount: long1Amount,\n                shortAmount: shortAmount,\n                liquidityAmount: liquidityAmount,\n                data: data\n            })\n        );\n\n        if (isQuote) revert Quote();\n\n        // Check when the position balance targets are reached.\n\n        if (long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n\n        if (long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n\n        Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), shortBalanceTarget);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Mint(param.strike, param.maturity, msg.sender, param.to, liquidityAmount, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function burn(TimeswapV2PoolBurnParam calldata param) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return burn(param, false, 0);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function burn(\n        TimeswapV2PoolBurnParam calldata param,\n        uint96 durationForward\n    ) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return burn(param, true, durationForward);\n    }\n\n    function burn(\n        TimeswapV2PoolBurnParam calldata param,\n        bool isQuote,\n        uint96 durationForward\n    ) private noDelegateCall returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        hasLiquidity(param.strike, param.maturity);\n\n        ParamLibrary.check(param, blockTimestamp(durationForward));\n        raiseGuard(param.strike, param.maturity);\n\n        Pool storage pool = pools[param.strike][param.maturity];\n\n        // Calculate the main logic of burn function.\n        (liquidityAmount, long0Amount, long1Amount, shortAmount, data) = pool.burn(param, blockTimestamp(durationForward));\n\n        // Transfer the positions to the receipients.\n\n        // Long0 amount can be zero.\n        if (long0Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long0To, TimeswapV2OptionPosition.Long0, long0Amount);\n\n        // Long1 amount can be zero.\n        if (long1Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long1To, TimeswapV2OptionPosition.Long1, long1Amount);\n\n        // Short amount cannot be zero.\n        ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.shortTo, TimeswapV2OptionPosition.Short, shortAmount);\n\n        data = ITimeswapV2PoolBurn2Callback(msg.sender).timeswapV2PoolBurnCallback(\n            TimeswapV2PoolBurnCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                long0Amount: long0Amount,\n                long1Amount: long1Amount,\n                shortAmount: shortAmount,\n                liquidityAmount: liquidityAmount,\n                data: data\n            })\n        );\n\n        if (isQuote) revert Quote();\n\n        pool.liquidityPositions[msg.sender].burn(liquidityAmount);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Burn(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, liquidityAmount, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function deleverage(TimeswapV2PoolDeleverageParam calldata param) external override returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return deleverage(param, false, 0);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function deleverage(\n        TimeswapV2PoolDeleverageParam calldata param,\n        uint96 durationForward\n    ) external override returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return deleverage(param, true, durationForward);\n    }\n\n    function deleverage(\n        TimeswapV2PoolDeleverageParam calldata param,\n        bool isQuote,\n        uint96 durationForward\n    ) private noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        hasLiquidity(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp(durationForward));\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of deleverage function.\n        (long0Amount, long1Amount, shortAmount, data) = pools[param.strike][param.maturity].deleverage(param, transactionFee, protocolFee, blockTimestamp(durationForward));\n\n        // Calculate the amount of long0 position and long1 position required by the pool.\n\n        // long0Amount chosen could be zero. Skip the calculation for gas efficiency.\n        uint256 long0BalanceTarget;\n        if (long0Amount != 0) long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + long0Amount;\n\n        // long1Amount chosen could be zero. Skip the calculation for gas efficiency.\n        uint256 long1BalanceTarget;\n        if (long1Amount != 0) long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + long1Amount;\n\n        // Transfer short positions to the receipient.\n        ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.to, TimeswapV2OptionPosition.Short, shortAmount);\n\n        // Ask the msg.sender to transfer the positions into this address.\n        data = ITimeswapV2PoolDeleverageCallback(msg.sender).timeswapV2PoolDeleverageCallback(\n            TimeswapV2PoolDeleverageCallbackParam({strike: param.strike, maturity: param.maturity, long0Amount: long0Amount, long1Amount: long1Amount, shortAmount: shortAmount, data: data})\n        );\n\n        if (isQuote) revert Quote();\n\n        // Check when the position balance targets are reached.\n\n        if (long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n\n        if (long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Deleverage(param.strike, param.maturity, msg.sender, param.to, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function leverage(TimeswapV2PoolLeverageParam calldata param) external override returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return leverage(param, false, 0);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function leverage(TimeswapV2PoolLeverageParam calldata param, uint96 durationForward) external override returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return leverage(param, true, durationForward);\n    }\n\n    function leverage(\n        TimeswapV2PoolLeverageParam calldata param,\n        bool isQuote,\n        uint96 durationForward\n    ) private noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        hasLiquidity(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp(durationForward));\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of leverage function.\n        (long0Amount, long1Amount, shortAmount, data) = pools[param.strike][param.maturity].leverage(param, transactionFee, protocolFee, blockTimestamp(durationForward));\n\n        // Calculate the amount of short position required by the pool.\n\n        uint256 balanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + shortAmount;\n\n        // Transfer the positions to the receipients.\n\n        if (long0Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long0To, TimeswapV2OptionPosition.Long0, long0Amount);\n\n        if (long1Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long1To, TimeswapV2OptionPosition.Long1, long1Amount);\n\n        // Ask the msg.sender to transfer the positions into this address.\n        data = ITimeswapV2PoolLeverageCallback(msg.sender).timeswapV2PoolLeverageCallback(\n            TimeswapV2PoolLeverageCallbackParam({strike: param.strike, maturity: param.maturity, long0Amount: long0Amount, long1Amount: long1Amount, shortAmount: shortAmount, data: data})\n        );\n\n        if (isQuote) revert Quote();\n\n        // Check when the position balance targets are reached.\n\n        Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), balanceTarget);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Leverage(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function rebalance(TimeswapV2PoolRebalanceParam calldata param) external override noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, bytes memory data) {\n        hasLiquidity(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp(0));\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of rebalance function.\n        (long0Amount, long1Amount) = pools[param.strike][param.maturity].rebalance(param, transactionFee, protocolFee);\n\n        // Calculate the amount of long position required by the pool.\n\n        uint256 balanceTarget = ITimeswapV2Option(optionPair).positionOf(\n            param.strike,\n            param.maturity,\n            address(this),\n            param.isLong0ToLong1 ? TimeswapV2OptionPosition.Long0 : TimeswapV2OptionPosition.Long1\n        ) + (param.isLong0ToLong1 ? long0Amount : long1Amount);\n\n        // Transfer the positions to the receipients.\n\n        ITimeswapV2Option(optionPair).transferPosition(\n            param.strike,\n            param.maturity,\n            param.to,\n            param.isLong0ToLong1 ? TimeswapV2OptionPosition.Long1 : TimeswapV2OptionPosition.Long0,\n            param.isLong0ToLong1 ? long1Amount : long0Amount\n        );\n\n        // Ask the msg.sender to transfer the positions into this address.\n        data = ITimeswapV2PoolRebalanceCallback(msg.sender).timeswapV2PoolRebalanceCallback(\n            TimeswapV2PoolRebalanceCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                isLong0ToLong1: param.isLong0ToLong1,\n                long0Amount: long0Amount,\n                long1Amount: long1Amount,\n                data: param.data\n            })\n        );\n\n        // Check when the position balance targets are reached.\n\n        Error.checkEnough(\n            ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), param.isLong0ToLong1 ? TimeswapV2OptionPosition.Long0 : TimeswapV2OptionPosition.Long1),\n            balanceTarget\n        );\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Rebalance(param.strike, param.maturity, msg.sender, param.to, param.isLong0ToLong1, long0Amount, long1Amount);\n    }\n}"
    },
    {
      "filename": "packages/v2-pool/src/libraries/ConstantProduct.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Math} from \"@timeswap-labs/v2-library/src/Math.sol\";\nimport {FullMath} from \"@timeswap-labs/v2-library/src/FullMath.sol\";\n\nimport {SafeCast} from \"@timeswap-labs/v2-library/src/SafeCast.sol\";\n\nimport {FeeCalculation} from \"./FeeCalculation.sol\";\n\n/// @title Constant Product Library that returns the Constant Product given certain parameters\nlibrary ConstantProduct {\n    using Math for uint256;\n    using SafeCast for uint256;\n\n    /// @dev Reverts when calculation overflows or underflows.\n    error CalculationOverload();\n\n    /// @dev Reverts when there is not enough time value liqudity to receive when lending.\n    error NotEnoughLiquidityToLend();\n\n    /// @dev Reverts when there is not enough principal liquidity to borrow from.\n    error NotEnoughLiquidityToBorrow();\n\n    /// @dev Returns the Long position given liquidity.\n    /// @param liquidity The liquidity given.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param roundUp Rounds up the result when true. Rounds down the result when false.\n    function getLong(uint160 liquidity, uint160 rate, bool roundUp) internal pure returns (uint256) {\n        return (uint256(liquidity) << 96).div(rate, roundUp);\n    }\n\n    /// @dev Returns the Short position given liquidity.\n    /// @param liquidity The liquidity given.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param duration The time duration in seconds.\n    /// @param roundUp Rounds up the result when true. Rounds down the result when false.\n    function getShort(uint160 liquidity, uint160 rate, uint96 duration, bool roundUp) internal pure returns (uint256) {\n        return FullMath.mulDiv(uint256(liquidity).unsafeMul(duration), uint256(rate), uint256(1) << 192, roundUp);\n    }\n\n    /// @dev Calculate the amount of long positions in base denomination and short positions from change of liquidity.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param deltaLiquidity The change in liquidity amount.\n    /// @param duration The time duration in seconds.\n    /// @param isAdd Increase liquidity amount if true. Decrease liquidity amount if false.\n    /// @return longAmount The amount of long positions in base denomination to deposit when increasing liquidity.\n    /// The amount of long positions in base denomination to withdraw when decreasing liquidity.\n    /// @return shortAmount The amount of short positions to deposit when increasing liquidity.\n    /// The amount of short positions to withdraw when decreasing liquidity.\n    function calculateGivenLiquidityDelta(uint160 rate, uint160 deltaLiquidity, uint96 duration, bool isAdd) internal pure returns (uint256 longAmount, uint256 shortAmount) {\n        longAmount = getLong(deltaLiquidity, rate, isAdd);\n\n        shortAmount = getShort(deltaLiquidity, rate, duration, isAdd);\n    }\n\n    /// @dev Calculate the amount of liquidity positions and amount of short positions from given long positions in base denomination.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param longAmount The amount of long positions.\n    /// @param duration The time duration in seconds.\n    /// @param isAdd Deposit long amount in base denomination if true. Withdraw long amount in base denomination if false.\n    /// @return liquidityAmount The amount of liquidity positions minted when depositing long positions.\n    /// The amount of liquidity positions burnt when withdrawing long positions.\n    /// @return shortAmount The amount of short positions to deposit when depositing long positions.\n    /// The amount of short positions to withdraw when withdrawing long positions.\n    function calculateGivenLiquidityLong(uint160 rate, uint256 longAmount, uint96 duration, bool isAdd) internal pure returns (uint160 liquidityAmount, uint256 shortAmount) {\n        liquidityAmount = getLiquidityGivenLong(rate, longAmount, !isAdd);\n\n        shortAmount = getShort(liquidityAmount, rate, duration, isAdd);\n    }\n\n    /// @dev Calculate the amount of liquidity positions and amount of long positions in base denomination from given short positions.\n    /// @param rate The pool's squared root Interest Rate.\n    /// @param shortAmount The amount of short positions.\n    /// @param duration The time duration in seconds.\n    /// @param isAdd Deposit short amount if true. Withdraw short amount if false.\n    /// @return liquidityAmount The amount of liquidity positions minted when depositing short positions.\n    /// The amount of liquidity positions burnt when withdrawing short positions.\n    /// @return longAmount The amount of long positions in base denomination to deposit when depositing short positions.\n    /// The amount of long positions in base denomination to withdraw when withdrawing short positions.\n    function calculateGivenLiquidityShort(uint160 rate, uint256 shortAmount, uint96"
    }
  ]
}