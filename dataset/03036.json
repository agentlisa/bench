{
  "Title": "H-6: `updateState()` should be called in `depositEth()` and `redeemEth()`",
  "Content": "# Issue H-6: `updateState()` should be called in `depositEth()` and `redeemEth()` \nSource: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/085-H \n## Found by \nLambda, Ruhum, bytehat, WATCHPUG, xiaoming90, pashov, cccz, GimelSec\n\n## Summary\n\nWhenever the liquidity of a LToken changes, `getRateFactor` will be changed.\n\nTherefore, `updateState()` must be called prior to the change to settle the pending interests.\n\n## Vulnerability Detail\n\nAlice is a liquidity provider for LEther, Bob is a borrower.\n\n1. Alice added 1000 ETH;\n2. Bob borrowed 500 ETH; In which `updateState()` is called. The `util` in `getBorrowRatePerSecond` is `0.5` now.\n2. One year later (no one interacts with the `asset` for 1 year), Alice redeemed 500 ETH with `redeemEth()`, in which `updateState()` is not called. The `util` in `getBorrowRatePerSecond` is `1` now.\n3. Bob called `repay()`, in which `updateState()` is called to calculates the pending interest:\n\nFor Bob the borrower, the sum of principal and interest is:\n\n$$\nBorrow Rate Per Second = c3 \\cdot (util \\cdot c1 + util^{32} \\cdot c1 + util^{64} \\cdot c2) \\div secsPerYear = 5545529241\n$$\n\n$$\nrateFactor = Borrow Rate Per Second \\cdot secsPerYear \\div 1e18 = 175000000081490720\n$$\n\n$$\nsum = borrow \\cdot rateFactor \\div 1e18 + borrow = 587\n$$\n\nBut the actual sum is as below, due to `updateState()` is not called in `redeemEth()`:\n\n$$\nBorrow Rate Per Second = c3 \\cdot (util \\cdot c1 + util^{32} \\cdot c1 + util^{64} \\cdot c2) \\div secsPerYear = 55455292386\n$$\n\n$$\nrateFactor = Borrow Rate Per Second \\cdot secsPerYear \\div 1e18 = 1750000000000000000\n$$\n\n$$\nsum = borrow \\cdot rateFactor \\div 1e18 + borrow = 1375\n$$\n\n\nAs a result, Bob the borrower is now paying `1375` instead of `587` for the interest, which is 2x the expected amount.\n\nOn the other hand, if another liquidity provider called `depositEth()` before Bob repays the loan, the actual interest can be lower than expected, which constitutes a loss of yields to Alice.\n\n## Impact\n\nIncorrect amounts of interests will be paid by the borrowers, which can result in loss of yields to the lenders or overpaid interest for the borrowers.\n\n## Code Snippet\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/tokens/LToken.sol#L200-L227\n\n```solidity\n    function updateState() public {\n        if (lastUpdated == block.timestamp) return;\n        uint rateFactor = getRateFactor();\n        uint interestAccrued = borrows.mulWadUp(rateFactor);\n        borrows += interestAccrued;\n        reserves += interestAccrued.mulWadUp(reserveFactor);\n        lastUpdated = block.timestamp;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @dev Rate Factor = Timestamp Delta * 1e18 (Scales timestamp delta to 18 decimals) * Interest Rate Per Block\n            Timestamp Delta = Number of seconds since last update\n    */\n    function getRateFactor() internal view returns (uint) {\n        return (block.timestamp == lastUpdated) ?\n            0 :\n            ((block.timestamp - lastUpdated)*1e18)\n            .mulWadUp(\n                rateModel.getBorrowRatePerSecond(\n                    asset.balanceOf(address(this)),\n                    borrows\n                )\n            );\n    }\n```\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/DefaultRateModel.sol#L51-L77\n\n```solidity\nfunction getBorrowRatePerSecond(\n        uint liquidity,\n        uint borrows\n    )\n        external\n        view\n        returns (uint)\n    {\n        uint util = _utilization(liquidity, borrows);\n        return c3.mulDivDown(\n            (\n                util.mulWadDown(c1)\n                + util.rpow(32, SCALE).mulWadDown(c1)\n                + util.rpow(64, SCALE).mulWadDown(c2)\n            ),\n            secsPerYear\n        );\n    }\n\n    function _utilization(uint liquidity, uint borrows)\n        internal\n        pure\n        returns (uint)\n    {\n        uint totalAssets = liquidity + borrows;\n        return (totalAssets == 0) ? 0 : borrows.divWadDown(totalAssets);\n    }\n```\n\n\n`updatestate` must be called everytime balance of asset is changed.\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/tokens/LEther.sol#L26-L53\n\n```solidity\n    /**\n        @notice Wraps Eth sent by the user and deposits into the LP\n            Transfers shares to the user denoting the amount of Eth deposited\n        @dev Emits Deposit(caller, owner, assets, shares)\n    */\n    function depositEth() external payable {\n        uint assets = msg.value;\n        uint shares = previewDeposit(assets);\n        require(shares != 0, \"ZERO_SHARES\");\n        IWETH(address(asset)).deposit{value: assets}();\n        _mint(msg.sender, shares);\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /**\n        @notice Unwraps Eth and transfers it to the caller\n            Amount of Eth transferred will be the total underlying assets that\n            are represented by the shares\n        @dev Emits Withdraw(caller, receiver, owner, assets, shares);\n        @param shares Amount of shares to redeem\n    */\n    function redeemEth(uint shares) external {\n        uint assets = previewRedeem(shares);\n        _burn(msg.sender, shares);\n        emit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n        IWETH(address(asset)).withdraw(assets);\n        msg.sender.safeTransferEth(assets);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`beforeDeposit()` should be called in `depositEth()` and `redeemEth()`:\n\n```solidity\n    /**\n        @notice Wraps Eth sent by the user and deposits into the LP\n            Transfers shares to the user denoting the amount of Eth deposited\n        @dev Emits Deposit(caller, owner, assets, shares)\n    */\n    function depositEth() external payable {\n        uint assets = msg.value;\n        uint shares = previewDeposit(assets);\n        require(shares != 0, \"ZERO_SHARES\");\n        beforeDeposit(assets, shares);\n        IWETH(address(asset)).deposit{value: assets}();\n        _mint(msg.sender, shares);\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /**\n        @notice Unwraps Eth and transfers it to the caller\n            Amount of Eth transferred will be the total underlying assets that\n            are represented by the shares\n        @dev Emits Withdraw(caller, receiver, owner, assets, shares);\n        @param shares Amount of shares to redeem\n    */\n    function redeemEth(uint shares) external {\n        uint assets = previewRedeem(shares);\n        beforeWithdraw(assets, shares);\n        _burn(msg.sender, shares);\n        emit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n        IWETH(address(asset)).withdraw(assets);\n        msg.sender.safeTransferEth(assets);\n    }\n```\n## Sentiment Team\nFixed as recommended. PR [here](https://github.com/sentimentxyz/protocol/pull/230).\n\n## Lead Senior Watson\nConfirmed fix. \n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/1",
  "Code": [
    {
      "filename": "src/tokens/LToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"./utils/ERC4626.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRateModel} from \"../interface/core/IRateModel.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\n\n/**\n    @title Lending Token\n    @notice Lending token with ERC4626 implementation\n*/\ncontract LToken is Pausable, ERC4626, ILToken {\n    using FixedPointMathLib for uint;\n    using SafeTransferLib for ERC20;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Rate Model\n    IRateModel public rateModel;\n\n    /// @notice Account Manager\n    address public accountManager;\n\n    /// @notice Protocol treasury\n    address public treasury;\n\n    /// @notice Total amount of borrows\n    uint public borrows;\n\n    /// @notice Timestamp of when the state of the LToken was last updated\n    uint public lastUpdated;\n\n    /// @notice Protocol reserves\n    uint public reserves;\n\n    /// @notice Reserve factor\n    uint public reserveFactor;\n\n    /// @notice Total borrow shares minted\n    uint public totalBorrowShares;\n\n    /// @notice Mapping of account to borrow in terms of shares\n    mapping (address => uint) public borrowsOf;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   EVENTS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event ReservesRedeemed(address indexed treasury, uint amt);\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier accountManagerOnly() {\n        if (msg.sender != accountManager) revert Errors.AccountManagerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract initialization function\n        @dev Can only be invoked once\n        @param _asset Underlying ERC20 token\n        @param _name Name of LToken\n        @param _symbol Symbol of LToken\n        @param _registry Address of Registry\n        @param _reserveFactor Borrow Fee\n        @param _treasury Protocol treasury\n    */\n    function init(\n        ERC20 _asset,\n        string calldata _name,\n        string calldata _symbol,\n        IRegistry _registry,\n        uint _reserveFactor,\n        address _treasury\n    ) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n\n        if (\n            address(_asset) == address(0) ||\n            address(_registry) == address(0) ||\n            _treasury == address(0)\n        ) revert Errors.ZeroAddress();\n\n        initialized = true;\n        initPausable(msg.sender);\n        initERC4626(_asset, _name, _symbol);\n        registry = _registry;\n        reserveFactor = _reserveFactor;\n        treasury = _treasury;\n    }\n\n    /**\n        @notice Initializes external dependencies\n        @param _rateModel Name of rate model contract\n    */\n    function initDep(string calldata _rateModel) external adminOnly {\n        rateModel = IRateModel(registry.getAddress(_rateModel));\n        accountManager = registry.getAddress('ACCOUNT_MANAGER');\n    }\n\n    /**\n        @notice Lends a specified amount of underlying asset to an account\n        @param account Address of account\n        @param amt Amount of token to lend\n        @return isFirstBorrow Returns if the account is borrowing the asset for\n            the first time\n    */\n    function lendTo(address account, uint amt)\n        external\n        whenNotPaused\n        accountManagerOnly\n        returns (bool isFirstBorrow)\n    {\n        updateState();\n        isFirstBorrow = (borrowsOf[account] == 0);\n\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        totalBorrowShares += borrowShares;\n        borrowsOf[account] += borrowShares;\n\n        borrows += amt;\n        asset.safeTransfer(account, amt);\n        return isFirstBorrow;\n    }\n\n    /**\n        @notice Collects a specified amount of underlying asset from an account\n        @param account Address of account\n        @param amt Amount of token to collect\n        @return bool Returns true if account has no debt\n    */\n    function collectFrom(address account, uint amt)\n        external\n        accountManagerOnly\n        returns (bool)\n    {\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        borrowsOf[account] -= borrowShares;\n        totalBorrowShares -= borrowShares;\n\n        borrows -= amt;\n        return (borrowsOf[account] == 0);\n    }\n\n    /**\n        @notice Returns Borrow balance of given account\n        @param account Address of account\n        @return borrowBalance Amount of underlying tokens borrowed\n    */\n    function getBorrowBalance(address account) external view returns (uint) {\n        return convertBorrowSharesToAsset(borrowsOf[account]);\n    }\n\n    function getReserves() public view returns (uint) {\n        return reserves + borrows.mulWadUp(getRateFactor())\n        .mulWadUp(reserveFactor);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Returns total amount of underlying assets\n            totalAssets = underlying balance + totalBorrows + delta\n            delta = totalBorrows * RateFactor\n        @return totalAssets Total amount of underlying assets\n    */\n    function totalAssets() public view override returns (uint) {\n        return asset.balanceOf(address(this)) + getBorrows() - getReserves();\n    }\n\n    function getBorrows() public view returns (uint) {\n        return borrows + borrows.mulWadUp(getRateFactor());\n    }\n\n    /// @notice Updates state of the lending pool\n    function updateState() public {\n        if (lastUpdated == block.timestamp) return;\n        uint rateFactor = getRateFactor();\n        uint interestAccrued = borrows.mulWadUp(rateFactor);\n        borrows += interestAccrued;\n        reserves += interestAccrued.mulWadUp(reserveFactor);\n        lastUpdated = block.timestamp;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @dev Rate Factor = Timestamp Delta * 1e18 (Scales timestamp delta to 18 decimals) * Interest Rate Per Block\n            Timestamp Delta = Number of seconds since last update\n    */\n    function getRateFactor() internal view returns (uint) {\n        return (block.timestamp == lastUpdated) ?\n            0 :\n            ((block.timestamp - lastUpdated)*1e18)\n            .mulWadUp(\n                rateModel.getBorrowRatePerSecond(\n                    asset.balanceOf(address(this)),\n                    borrows\n                )\n            );\n    }\n\n    function convertAssetToBorrowShares(uint amt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? amt : amt.mulDivUp(supply, getBorrows());\n    }\n\n    function convertBorrowSharesToAsset(uint debt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? debt : debt.mulDivDown(getBorrows(), supply);\n    }\n\n    function beforeDeposit(uint, uint) internal override { updateState(); }\n    function beforeWithdraw(uint, uint) internal override { updateState(); }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               ADMIN FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    function redeemReserves(uint amt) external adminOnly {\n        updateState();\n        reserves -= amt;\n        emit ReservesRedeemed(treasury, amt);\n        asset.safeTransfer(treasury, amt);\n    }\n}"
    },
    {
      "filename": "src/core/DefaultRateModel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {IRateModel} from \"../interface/core/IRateModel.sol\";\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n    @title Default Rate Model\n    @notice Rate model contract used by Lending pools to calculate borrow rate\n    per block\n*/\ncontract DefaultRateModel is IRateModel {\n    using FixedPointMathLib for uint;\n\n    /// @notice Constant coefficients with 18 decimals\n    uint immutable c1;\n    uint immutable c2;\n    uint immutable c3;\n\n    /// @notice Number of seconds per year\n    uint immutable secsPerYear;\n\n    uint constant SCALE = 1e18;\n\n    /**\n        @notice Contract constructor\n        @param _c1 constant coefficient, default value = 1 * 1e17\n        @param _c2 constant coefficient, default value = 3 * 1e17\n        @param _c3 constant coefficient, default value = 35 * 1e17\n        @param _secsPerYear secs in a year, default value = 31556952 * 1e18\n    */\n    constructor(uint _c1, uint _c2, uint _c3, uint _secsPerYear) {\n        if (_c1 == 0 || _c2 == 0 || _c3 == 0 || _secsPerYear == 0)\n            revert Errors.IncorrectConstructorArgs();\n        c1 = _c1;\n        c2 = _c2;\n        c3 = _c3;\n        secsPerYear = _secsPerYear;\n    }\n\n    /**\n        @notice Calculates Borrow rate per second\n        Borrow Rate Per Second =\n        c3 * (util * c1 + util^32 * c1 + util^64 * c2) / secsPerYear\n        where util = borrows / (liquidity + borrows)\n        @param liquidity total balance of the underlying asset in the pool\n        @param borrows balance of underlying assets borrowed from the pool\n        @return uint borrow rate per sec\n    */\n    function getBorrowRatePerSecond(\n        uint liquidity,\n        uint borrows\n    )\n        external\n        view\n        returns (uint)\n    {\n        uint util = _utilization(liquidity, borrows);\n        return c3.mulDivDown(\n            (\n                util.mulWadDown(c1)\n                + util.rpow(32, SCALE).mulWadDown(c1)\n                + util.rpow(64, SCALE).mulWadDown(c2)\n            ),\n            secsPerYear\n        );\n    }\n\n    function _utilization(uint liquidity, uint borrows)\n        internal\n        pure\n        returns (uint)\n    {\n        uint totalAssets = liquidity + borrows;\n        return (totalAssets == 0) ? 0 : borrows.divWadDown(totalAssets);\n    }\n}"
    },
    {
      "filename": "src/tokens/LEther.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {LToken} from \"./LToken.sol\";\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Helpers} from \"../utils/Helpers.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\n\ninterface IWETH {\n    function withdraw(uint) external;\n    function deposit() external payable;\n}\n\n/**\n    @title Lending Token for Ether\n    @notice Lending Token contract for Ether with WETH as underlying asset\n*/\ncontract LEther is LToken {\n    using Helpers for address;\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Wraps Eth sent by the user and deposits into the LP\n            Transfers shares to the user denoting the amount of Eth deposited\n        @dev Emits Deposit(caller, owner, assets, shares)\n    */\n    function depositEth() external payable {\n        uint assets = msg.value;\n        uint shares = previewDeposit(assets);\n        require(shares != 0, \"ZERO_SHARES\");\n        IWETH(address(asset)).deposit{value: assets}();\n        _mint(msg.sender, shares);\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /**\n        @notice Unwraps Eth and transfers it to the caller\n            Amount of Eth transferred will be the total underlying assets that\n            are represented by the shares\n        @dev Emits Withdraw(caller, receiver, owner, assets, shares);\n        @param shares Amount of shares to redeem\n    */\n    function redeemEth(uint shares) external {\n        uint assets = previewRedeem(shares);\n        _burn(msg.sender, shares);\n        emit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n        IWETH(address(asset)).withdraw(assets);\n        msg.sender.safeTransferEth(assets);\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}