{
  "Title": "[M-01] Supply cap of VariableSupplyERC20Token is not properly enforced",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-09-vtvl/blob/main/contracts/token/VariableSupplyERC20Token.sol#L36-L46\n\n\n# Vulnerability details\n\n## Impact\nThe admin of the token is not constrained to minting `maxSupply_`, they can mint any number of tokens.\n\n## Proof of Concept\n```js\n// If we're using maxSupply, we need to make sure we respect it\n// mintableSupply = 0 means mint at will\nif(mintableSupply > 0) {\n\trequire(amount <= mintableSupply, \"INVALID_AMOUNT\");\n\t// We need to reduce the amount only if we're using the limit, if not just leave it be\n\tmintableSupply -= amount;\n}\n```\nThe logic is as follows: if the amount that can be minted is zero, treat this as an infinite mint. Else require that the minted amount is not larger than mintable supply.\n\nOne can note that it is possible to mint all mintable supply. Then the mintable supply will be `0` which will be interpreted as infinity and any number of tokens will be possible to be minted.\n\n## Tools Used\nManual analysis\n\n## Recommended Mitigation Steps\nTreat `2 ** 256 - 1` as infinity instead of `0`.\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-vtvl-contest",
  "Code": [
    {
      "filename": "contracts/token/VariableSupplyERC20Token.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.14;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../AccessProtected.sol\";\n\n/**\n@notice A ERC20 token contract that allows minting at will, with limited or unlimited supply.\n */\ncontract VariableSupplyERC20Token is ERC20, AccessProtected {\n    uint256 public mintableSupply;\n\n    /**\n    @notice A ERC20 token contract that allows minting at will, with limited or unlimited supply. No burning possible\n    @dev\n    @param name_ - Name of the token\n    @param symbol_ - Symbol of the token\n    @param initialSupply_ - How much to immediately mint (saves another transaction). If 0, no mint at the beginning.\n    @param maxSupply_ - What's the maximum supply. The contract won't allow minting over this amount. Set to 0 for no limit.\n    */\n    constructor(string memory name_, string memory symbol_, uint256 initialSupply_, uint256 maxSupply_) ERC20(name_, symbol_) {\n        // max supply == 0 means mint at will. \n        // initialSupply_ == 0 means nothing preminted\n        // Therefore, we have valid scenarios if either of them is 0\n        // However, if both are 0 we might have a valid scenario as well - user just wants to create a token but doesn't want to mint anything\n        // Should we allow this?\n        require(initialSupply_ > 0 || maxSupply_ > 0, \"INVALID_AMOUNT\");\n        mintableSupply = maxSupply_;\n        \n        // Note: the check whether initial supply is less than or equal than mintableSupply will happen in mint fn.\n        if(initialSupply_ > 0) {\n            mint(_msgSender(), initialSupply_);\n        }\n    }\n\n    function mint(address account, uint256 amount) public onlyAdmin {\n        require(account != address(0), \"INVALID_ADDRESS\");\n        // If we're using maxSupply, we need to make sure we respect it\n        // mintableSupply = 0 means mint at will\n        if(mintableSupply > 0) {\n            require(amount <= mintableSupply, \"INVALID_AMOUNT\");\n            // We need to reduce the amount only if we're using the limit, if not just leave it be\n            mintableSupply -= amount;\n        }\n        _mint(account, amount);\n    }\n\n    // We can't really have burn, because that could make our vesting contract not work.\n    // Example: if the user can burn tokens already assigned to vesting schedules, it could be unable to pay its obligations.\n}"
    }
  ]
}