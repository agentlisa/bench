{
  "Title": "[M02] ERC20 compliant assets may not be used",
  "Content": "A new oToken can be created by calling the [`createOtoken` function](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/OtokenFactory.sol#L55) from the `OtokenFactory` contract and passing the whitelisted assets, among other parameters.\n\n\nDuring the [initialization of the new oToken](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Otoken.sol#L68), the code calls the [`_getNameAndSymbol` function](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Otoken.sol#L107) which retrieves the standardized symbol and name for that oToken.\n\n\nNevertheless, the same function [calls every single asset involved in the oToken to get their symbol](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Otoken.sol#L108-L110), but because the [`symbol` and `name` function from the ERC20 standard are optionals](https://eips.ethereum.org/EIPS/eip-20#specification), these external calls may fail if those are not implemented and the oToken will not be created.\n\n\nSimilarly, the `decimals` function is optional and ERC20 compliant assets may not include such function. Although in this scenario an oToken could be created using those assets, any action that would trigger the [`_verifyFinalState` function](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Controller.sol#L514) from the `Controller` contract will revert either in line [90](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/MarginCalculator.sol#L90) or [101](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/MarginCalculator.sol#L101) from `MarginCalculator.sol`.\n\n\nConsider being as general as possible and assuming that these functions may not be implemented in the whitelisted assets.\n\n\n**Update:** *The Opyn team explained their views regarding this issue in a follow-up discussion. They decided not to implement any fixes and, instead, they will rely on the admin process of whitelisting underlying ERC20 tokens that conform to the requirements of their system. In the future, if the need arises, they intend to upgrade the system to support a broader range of ERC20 tokens.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/OtokenFactory.sol",
      "content": "pragma solidity =0.6.10;\n\nimport {OtokenSpawner} from \"./OtokenSpawner.sol\";\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\nimport {AddressBookInterface} from \"./interfaces/AddressBookInterface.sol\";\nimport {OtokenInterface} from \"./interfaces/OtokenInterface.sol\";\nimport {WhitelistInterface} from \"./interfaces/WhitelistInterface.sol\";\n\n/**\n * SPDX-License-Identifier: UNLICENSED\n * @title A factory to create Opyn oTokens\n * @author Opyn Team\n * @notice Create new oTokens and keep track of all created tokens\n * @dev Calculate contract address before each creation with CREATE2\n * and deploy eip-1167 minimal proxies for oToken logic contract\n */\ncontract OtokenFactory is OtokenSpawner {\n    using SafeMath for uint256;\n    /// @notice Opyn AddressBook contract that records the address of the Whitelist module and the Otoken impl address. */\n    address public addressBook;\n\n    /// @notice array of all created otokens */\n    address[] public otokens;\n\n    /// @dev mapping from parameters hash to its deployed address\n    mapping(bytes32 => address) private idToAddress;\n\n    constructor(address _addressBook) public {\n        addressBook = _addressBook;\n    }\n\n    /// @notice emitted when the factory creates a new Option\n    event OtokenCreated(\n        address indexed tokenAddress,\n        address indexed creator,\n        address underlying,\n        address strike,\n        address collateral,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    );\n\n    /**\n     * @notice create new oTokens\n     * @dev deploy an eip-1167 minimal proxy with CREATE2 and register it to the whitelist module\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return newOtoken address of the newly created option\n     */\n    function createOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external returns (address) {\n        require(_expiry > now, \"OtokenFactory: Can't create expired option\");\n        require(_expiry < 11865398400, \"OtokenFactory: Can't create option with expiry > 2345/12/31\");\n        require(_expiry.sub(28800).mod(86400) == 0, \"OtokenFactory: Option has to expire 08:00 UTC\");\n        bytes32 id = _getOptionId(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut);\n        require(idToAddress[id] == address(0), \"OtokenFactory: Option already created\");\n\n        address whitelist = AddressBookInterface(addressBook).getWhitelist();\n        require(\n            WhitelistInterface(whitelist).isWhitelistedProduct(\n                _underlyingAsset,\n                _strikeAsset,\n                _collateralAsset,\n                _isPut\n            ),\n            \"OtokenFactory: Unsupported Product\"\n        );\n\n        require(!_isPut || _strikePrice > 0, \"OtokenFactory: Can't create a $0 strike put option\");\n\n        address otokenImpl = AddressBookInterface(addressBook).getOtokenImpl();\n\n        bytes memory initializationCalldata = abi.encodeWithSelector(\n            OtokenInterface(otokenImpl).init.selector,\n            addressBook,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n\n        address newOtoken = _spawn(otokenImpl, initializationCalldata);\n\n        idToAddress[id] = newOtoken;\n        otokens.push(newOtoken);\n        WhitelistInterface(whitelist).whitelistOtoken(newOtoken);\n\n        emit OtokenCreated(\n            newOtoken,\n            msg.sender,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n\n        return newOtoken;\n    }\n\n    /**\n     * @notice get the total oTokens created by the factory\n     * @return length of the oTokens array\n     */\n    function getOtokensLength() external view returns (uint256) {\n        return otokens.length;\n    }\n\n    /**\n     * @notice get the oToken address for an already created oToken, if no oToken has been created with these parameters, it will return address(0)\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return the address of target otoken.\n     */\n    function getOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address) {\n        bytes32 id = _getOptionId(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut);\n        return idToAddress[id];\n    }\n\n    /**\n     * @notice get the address at which a new oToken with these parameters would be deployed\n     * @dev return the exact address that will be deployed at with _computeAddress\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return targetAddress the address this oToken would be deployed at\n     */\n    function getTargetOtokenAddress(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address) {\n        address otokenImpl = AddressBookInterface(addressBook).getOtokenImpl();\n        bytes memory initializationCalldata = abi.encodeWithSelector(\n            OtokenInterface(otokenImpl).init.selector,\n            addressBook,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n        return _computeAddress(AddressBookInterface(addressBook).getOtokenImpl(), initializationCalldata);\n    }\n\n    /**\n     * @dev hash oToken parameters and return a unique option id\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return id the unique id of an oToken\n     */\n    function _getOptionId(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut)\n            );\n    }\n}"
    },
    {
      "filename": "contracts/Otoken.sol",
      "content": "/* SPDX-License-Identifier: UNLICENSED */\npragma solidity =0.6.10;\n\nimport {ERC20Initializable} from \"./packages/oz/upgradeability/ERC20Initializable.sol\";\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\nimport {Strings} from \"./packages/oz/Strings.sol\";\nimport {BokkyPooBahsDateTimeLibrary} from \"./packages/BokkyPooBahsDateTimeLibrary.sol\";\nimport {AddressBookInterface} from \"./interfaces/AddressBookInterface.sol\";\n\n/**\n * @title Otoken\n * @author Opyn Team\n * @notice Otoken is the ERC20 token for an option\n * @dev The Otoken inherits ERC20Initializable because we need to use the init instead of constructor\n */\ncontract Otoken is ERC20Initializable {\n    using SafeMath for uint256;\n\n    /// @notice address of the AddressBook module\n    address public addressBook;\n\n    /// @notice asset that the option references\n    address public underlyingAsset;\n\n    /// @notice asset that the strike price is denominated in\n    address public strikeAsset;\n\n    /// @notice asset that is held as collateral against short/written options\n    address public collateralAsset;\n\n    /// @notice strike price with decimals = 8\n    uint256 public strikePrice;\n\n    /// @notice expiration timestamp of the option, represented as a unix timestamp\n    uint256 public expiryTimestamp;\n\n    /// @notice True if a put option, False if a call option\n    bool public isPut;\n\n    uint256 private constant STRIKE_PRICE_SCALE = 1e8;\n    uint256 private constant STRIKE_PRICE_DIGITS = 8;\n\n    /**\n     * @notice initialize the oToken\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 8\n     * @param _expiryTimestamp expiration timestamp of the option, represented as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     */\n    function init(\n        address _addressBook,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTimestamp,\n        bool _isPut\n    ) external initializer {\n        addressBook = _addressBook;\n        underlyingAsset = _underlyingAsset;\n        strikeAsset = _strikeAsset;\n        collateralAsset = _collateralAsset;\n        strikePrice = _strikePrice;\n        expiryTimestamp = _expiryTimestamp;\n        isPut = _isPut;\n        (string memory tokenName, string memory tokenSymbol) = _getNameAndSymbol();\n        __ERC20_init_unchained(tokenName, tokenSymbol);\n        _setupDecimals(8);\n    }\n\n    /**\n     * @notice mint oToken for an account\n     * @dev Controller only method where access control is taken care of by _beforeTokenTransfer hook\n     * @param account account to mint token to\n     * @param amount amount to mint\n     */\n    function mintOtoken(address account, uint256 amount) external {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getController(),\n            \"Otoken: Only Controller can mint Otokens\"\n        );\n        _mint(account, amount);\n    }\n\n    /**\n     * @notice burn oToken from an account.\n     * @dev Controller only method where access control is taken care of by _beforeTokenTransfer hook\n     * @param account account to burn token from\n     * @param amount amount to burn\n     */\n    function burnOtoken(address account, uint256 amount) external {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getController(),\n            \"Otoken: Only Controller can burn Otokens\"\n        );\n        _burn(account, amount);\n    }\n\n    /**\n     * @notice generates the name and symbol for an option\n     * @dev this function uses a named return variable to avoid the stack-too-deep error\n     * @return tokenName (ex: ETHUSDC 05-September-2020 200 Put USDC Collateral)\n     * @return tokenSymbol (ex: oETHUSDC-05SEP20-200P)\n     */\n    function _getNameAndSymbol() internal view returns (string memory tokenName, string memory tokenSymbol) {\n        string memory underlying = ERC20Initializable(underlyingAsset).symbol();\n        string memory strike = ERC20Initializable(strikeAsset).symbol();\n        string memory collateral = ERC20Initializable(collateralAsset).symbol();\n        string memory displayStrikePrice = _getDisplayedStrikePrice(strikePrice);\n\n        // convert expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary.timestampToDate(expiryTimestamp);\n\n        // get option type string\n        (string memory typeSymbol, string memory typeFull) = _getOptionType(isPut);\n\n        //get option month string\n        (string memory monthSymbol, string memory monthFull) = _getMonth(month);\n\n        // concatenated name string: ETHUSDC 05-September-2020 200 Put USDC Collateral\n        tokenName = string(\n            abi.encodePacked(\n                underlying,\n                strike,\n                \" \",\n                _uintTo2Chars(day),\n                \"-\",\n                monthFull,\n                \"-\",\n                Strings.toString(year),\n                \" \",\n                displayStrikePrice,\n                typeFull,\n                \" \",\n                collateral,\n                \" Collateral\"\n            )\n        );\n\n        // concatenated symbol string: oETHUSDC-05SEP20-200P\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"o\",\n                underlying,\n                strike,\n                \"-\",\n                _uintTo2Chars(day),\n                monthSymbol,\n                _uintTo2Chars(year),\n                \"-\",\n                displayStrikePrice,\n                typeSymbol\n            )\n        );\n    }\n\n    /**\n     * @dev convert strike price scaled by 1e8 to human readable number string\n     * @param _strikePrice strike price scaled by 1e8\n     * @return strike price string\n     */\n    function _getDisplayedStrikePrice(uint256 _strikePrice) internal pure returns (string memory) {\n        uint256 remainder = _strikePrice.mod(STRIKE_PRICE_SCALE);\n        uint256 quotient = _strikePrice.div(STRIKE_PRICE_SCALE);\n        string memory quotientStr = Strings.toString(quotient);\n\n        if (remainder == 0) return quotientStr;\n\n        uint256 trailingZeroes = 0;\n        while (remainder.mod(10) == 0) {\n            remainder = remainder / 10;\n            trailingZeroes += 1;\n        }\n\n        // pad the number with \"1 + starting zeroes\"\n        remainder += 10**(STRIKE_PRICE_DIGITS - trailingZeroes);\n\n        string memory tmpStr = Strings.toString(remainder);\n        tmpStr = _slice(tmpStr, 1, 1 + STRIKE_PRICE_DIGITS - trailingZeroes);\n\n        string memory completeStr = string(abi.encodePacked(quotientStr, \".\", tmpStr));\n        return completeStr;\n    }\n\n    /**\n     * @dev return a representation of a number using 2 characters, adds a leading 0 if one digit, uses two trailing digits if a 3 digit number\n     * @return 2 characters that corresponds to a number\n     */\n    function _uintTo2Chars(uint256 number) internal pure returns (string memory) {\n        if (number > 99) number = number % 100;\n        string memory str = Strings.toString(number);\n        if (number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n        return str;\n    }\n\n    /**\n     * @dev return string representation of option type\n     * @return shortString a 1 character representation of option type (P or C)\n     * @return longString a full length string of option type (Put or Call)\n     */\n    function _getOptionType(bool _isPut) internal pure returns (string memory shortString, string memory longString) {\n        if (_isPut) {\n            return (\"P\", \"Put\");\n        } else {\n            return (\"C\", \"Call\");\n        }\n    }\n\n    /**\n     * @dev cut string s into s[start:end]\n     * @param _s the string to cut\n     * @param _start the starting index\n     * @param _end the ending index (excluded in the substring)\n     */\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure returns (string memory) {\n        bytes memory a = new bytes(_end - _start);\n        for (uint256 i = 0; i < _end - _start; i++) {\n            a[i] = bytes(_s)[_start + i];\n        }\n        return string(a);\n    }\n\n    /**\n     * @dev return string representation of a month\n     * @return shortString a 3 character representation of a month (ex: SEP, DEC, etc)\n     * @return longString a full length string of a month (ex: September, December, etc)\n     */\n    function _getMonth(uint256 _month) internal pure returns (string memory shortString, string memory longString) {\n        if (_month == 1) {\n            return (\"JAN\", \"January\");\n        } else if (_month == 2) {\n            return (\"FEB\", \"February\");\n        } else if (_month == 3) {\n            return (\"MAR\", \"March\");\n        } else if (_month == 4) {\n            return (\"APR\", \"April\");\n        } else if (_month == 5) {\n            return (\"MAY\", \"May\");\n        } else if (_month == 6) {\n            return (\"JUN\", \"June\");\n        } else if (_month == 7) {\n            return (\"JUL\", \"July\");\n        } else if (_month == 8) {\n            return (\"AUG\", \"August\");\n        } else if (_month == 9) {\n            return (\"SEP\", \"September\");\n        } else if (_month == 10) {\n            return (\"OCT\", \"October\");\n        } else if (_month == 11) {\n            return (\"NOV\", \"November\");\n        } else {\n            return (\"DEC\", \"December\");\n        }\n    }\n}"
    },
    {
      "filename": "contracts/Otoken.sol",
      "content": "/* SPDX-License-Identifier: UNLICENSED */\npragma solidity =0.6.10;\n\nimport {ERC20Initializable} from \"./packages/oz/upgradeability/ERC20Initializable.sol\";\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\nimport {Strings} from \"./packages/oz/Strings.sol\";\nimport {BokkyPooBahsDateTimeLibrary} from \"./packages/BokkyPooBahsDateTimeLibrary.sol\";\nimport {AddressBookInterface} from \"./interfaces/AddressBookInterface.sol\";\n\n/**\n * @title Otoken\n * @author Opyn Team\n * @notice Otoken is the ERC20 token for an option\n * @dev The Otoken inherits ERC20Initializable because we need to use the init instead of constructor\n */\ncontract Otoken is ERC20Initializable {\n    using SafeMath for uint256;\n\n    /// @notice address of the AddressBook module\n    address public addressBook;\n\n    /// @notice asset that the option references\n    address public underlyingAsset;\n\n    /// @notice asset that the strike price is denominated in\n    address public strikeAsset;\n\n    /// @notice asset that is held as collateral against short/written options\n    address public collateralAsset;\n\n    /// @notice strike price with decimals = 8\n    uint256 public strikePrice;\n\n    /// @notice expiration timestamp of the option, represented as a unix timestamp\n    uint256 public expiryTimestamp;\n\n    /// @notice True if a put option, False if a call option\n    bool public isPut;\n\n    uint256 private constant STRIKE_PRICE_SCALE = 1e8;\n    uint256 private constant STRIKE_PRICE_DIGITS = 8;\n\n    /**\n     * @notice initialize the oToken\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 8\n     * @param _expiryTimestamp expiration timestamp of the option, represented as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     */\n    function init(\n        address _addressBook,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTimestamp,\n        bool _isPut\n    ) external initializer {\n        addressBook = _addressBook;\n        underlyingAsset = _underlyingAsset;\n        strikeAsset = _strikeAsset;\n        collateralAsset = _collateralAsset;\n        strikePrice = _strikePrice;\n        expiryTimestamp = _expiryTimestamp;\n        isPut = _isPut;\n        (string memory tokenName, string memory tokenSymbol) = _getNameAndSymbol();\n        __ERC20_init_unchained(tokenName, tokenSymbol);\n        _setupDecimals(8);\n    }\n\n    /**\n     * @notice mint oToken for an account\n     * @dev Controller only method where access control is taken care of by _beforeTokenTransfer hook\n     * @param account account to mint token to\n     * @param amount amount to mint\n     */\n    function mintOtoken(address account, uint256 amount) external {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getController(),\n            \"Otoken: Only Controller can mint Otokens\"\n        );\n        _mint(account, amount);\n    }\n\n    /**\n     * @notice burn oToken from an account.\n     * @dev Controller only method where access control is taken care of by _beforeTokenTransfer hook\n     * @param account account to burn token from\n     * @param amount amount to burn\n     */\n    function burnOtoken(address account, uint256 amount) external {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getController(),\n            \"Otoken: Only Controller can burn Otokens\"\n        );\n        _burn(account, amount);\n    }\n\n    /**\n     * @notice generates the name and symbol for an option\n     * @dev this function uses a named return variable to avoid the stack-too-deep error\n     * @return tokenName (ex: ETHUSDC 05-September-2020 200 Put USDC Collateral)\n     * @return tokenSymbol (ex: oETHUSDC-05SEP20-200P)\n     */\n    function _getNameAndSymbol() internal view returns (string memory tokenName, string memory tokenSymbol) {\n        string memory underlying = ERC20Initializable(underlyingAsset).symbol();\n        string memory strike = ERC20Initializable(strikeAsset).symbol();\n        string memory collateral = ERC20Initializable(collateralAsset).symbol();\n        string memory displayStrikePrice = _getDisplayedStrikePrice(strikePrice);\n\n        // convert expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary.timestampToDate(expiryTimestamp);\n\n        // get option type string\n        (string memory typeSymbol, string memory typeFull) = _getOptionType(isPut);\n\n        //get option month string\n        (string memory monthSymbol, string memory monthFull) = _getMonth(month);\n\n        // concatenated name string: ETHUSDC 05-September-2020 200 Put USDC Collateral\n        tokenName = string(\n            abi.encodePacked(\n                underlying,\n                strike,\n                \" \",\n                _uintTo2Chars(day),\n                \"-\",\n                monthFull,\n                \"-\",\n                Strings.toString(year),\n                \" \",\n                displayStrikePrice,\n                typeFull,\n                \" \",\n                collateral,\n                \" Collateral\"\n            )\n        );\n\n        // concatenated symbol string: oETHUSDC-05SEP20-200P\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"o\",\n                underlying,\n                strike,\n                \"-\",\n                _uintTo2Chars(day),\n                monthSymbol,\n                _uintTo2Chars(year),\n                \"-\",\n                displayStrikePrice,\n                typeSymbol\n            )\n        );\n    }\n\n    /**\n     * @dev convert strike price scaled by 1e8 to human readable number string\n     * @param _strikePrice strike price scaled by 1e8\n     * @return strike price string\n     */\n    function _getDisplayedStrikePrice(uint256 _strikePrice) internal pure returns (string memory) {\n        uint256 remainder = _strikePrice.mod(STRIKE_PRICE_SCALE);\n        uint256 quotient = _strikePrice.div(STRIKE_PRICE_SCALE);\n        string memory quotientStr = Strings.toString(quotient);\n\n        if (remainder == 0) return quotientStr;\n\n        uint256 trailingZeroes = 0;\n        while (remainder.mod(10) == 0) {\n            remainder = remainder / 10;\n            trailingZeroes += 1;\n        }\n\n        // pad the number with \"1 + starting zeroes\"\n        remainder += 10**(STRIKE_PRICE_DIGITS - trailingZeroes);\n\n        string memory tmpStr = Strings.toString(remainder);\n        tmpStr = _slice(tmpStr, 1, 1 + STRIKE_PRICE_DIGITS - trailingZeroes);\n\n        string memory completeStr = string(abi.encodePacked(quotientStr, \".\", tmpStr));\n        return completeStr;\n    }\n\n    /**\n     * @dev return a representation of a number using 2 characters, adds a leading 0 if one digit, uses two trailing digits if a 3 digit number\n     * @return 2 characters that corresponds to a number\n     */\n    function _uintTo2Chars(uint256 number) internal pure returns (string memory) {\n        if (number > 99) number = number % 100;\n        string memory str = Strings.toString(number);\n        if (number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n        return str;\n    }\n\n    /**\n     * @dev return string representation of option type\n     * @return shortString a 1 character representation of option type (P or C)\n     * @return longString a full length string of option type (Put or Call)\n     */\n    function _getOptionType(bool _isPut) internal pure returns (string memory shortString, string memory longString) {\n        if (_isPut) {\n            return (\"P\", \"Put\");\n        } else {\n            return (\"C\", \"Call\");\n        }\n    }\n\n    /**\n     * @dev cut string s into s[start:end]\n     * @param _s the string to cut\n     * @param _start the starting index\n     * @param _end the ending index (excluded in the substring)\n     */\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure returns (string memory) {\n        bytes memory a = new bytes(_end - _start);\n        for (uint256 i = 0; i < _end - _start; i++) {\n            a[i] = bytes(_s)[_start + i];\n        }\n        return string(a);\n    }\n\n    /**\n     * @dev return string representation of a month\n     * @return shortString a 3 character representation of a month (ex: SEP, DEC, etc)\n     * @return longString a full length string of a month (ex: September, December, etc)\n     */\n    function _getMonth(uint256 _month) internal pure returns (string memory shortString, string memory longString) {\n        if (_month == 1) {\n            return (\"JAN\", \"January\");\n        } else if (_month == 2) {\n            return (\"FEB\", \"February\");\n        } else if (_month == 3) {\n            return (\"MAR\", \"March\");\n        } else if (_month == 4) {\n            return (\"APR\", \"April\");\n        } else if (_month == 5) {\n            return (\"MAY\", \"May\");\n        } else if (_month == 6) {\n            return (\"JUN\", \"June\");\n        } else if (_month == 7) {\n            return (\"JUL\", \"July\");\n        } else if (_month == 8) {\n            return (\"AUG\", \"August\");\n        } else if (_month == 9) {\n            return (\"SEP\", \"September\");\n        } else if (_month == 10) {\n            return (\"OCT\", \"October\");\n        } else if (_month == 11) {\n            return (\"NOV\", \"November\");\n        } else {\n            return (\"DEC\", \"December\");\n        }\n    }\n}"
    },
    {
      "filename": "contracts/Controller.sol",
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport {OwnableUpgradeSafe} from \"./packages/oz/upgradeability/OwnableUpgradeSafe.sol\";\nimport {ReentrancyGuardUpgradeSafe} from \"./packages/oz/upgradeability/ReentrancyGuardUpgradeSafe.sol\";\nimport {Initializable} from \"./packages/oz/upgradeability/Initializable.sol\";\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\nimport {MarginVault} from \"./libs/MarginVault.sol\";\nimport {Actions} from \"./libs/Actions.sol\";\nimport {AddressBookInterface} from \"./interfaces/AddressBookInterface.sol\";\nimport {OtokenInterface} from \"./interfaces/OtokenInterface.sol\";\nimport {MarginCalculatorInterface} from \"./interfaces/MarginCalculatorInterface.sol\";\nimport {OracleInterface} from \"./interfaces/OracleInterface.sol\";\nimport {WhitelistInterface} from \"./interfaces/WhitelistInterface.sol\";\nimport {MarginPoolInterface} from \"./interfaces/MarginPoolInterface.sol\";\nimport {CalleeInterface} from \"./interfaces/CalleeInterface.sol\";\n\n/**\n * @title Controller\n * @author Opyn Team\n * @notice Contract that controls the Gamma Protocol and the interaction of all sub contracts\n */\ncontract Controller is Initializable, OwnableUpgradeSafe, ReentrancyGuardUpgradeSafe {\n    using MarginVault for MarginVault.Vault;\n    using SafeMath for uint256;\n\n    AddressBookInterface public addressbook;\n    WhitelistInterface public whitelist;\n    OracleInterface public oracle;\n    MarginCalculatorInterface public calculator;\n    MarginPoolInterface public pool;\n\n    ///@dev scale used in MarginCalculator\n    uint256 internal constant BASE = 8;\n\n    /// @notice address that has permission to partially pause the system, where system functionality is paused\n    /// except redeem and settleVault\n    address public partialPauser;\n\n    /// @notice address that has permission to fully pause the system, where all system functionality is paused\n    address public fullPauser;\n\n    /// @notice True if all system functionality is paused other than redeem and settle vault\n    bool public systemPartiallyPaused;\n\n    /// @notice True if all system functionality is paused\n    bool public systemFullyPaused;\n\n    /// @notice True if a call action can only be executed to a whitelisted callee\n    bool public callRestricted;\n\n    /// @dev mapping between an owner address and the number of owner address vaults\n    mapping(address => uint256) internal accountVaultCounter;\n    /// @dev mapping between an owner address and a specific vault using a vault id\n    mapping(address => mapping(uint256 => MarginVault.Vault)) internal vaults;\n    /// @dev mapping between an account owner and their approved or unapproved account operators\n    mapping(address => mapping(address => bool)) internal operators;\n\n    /// @notice emits an event when an account operator is updated for a specific account owner\n    event AccountOperatorUpdated(address indexed accountOwner, address indexed operator, bool isSet);\n    /// @notice emits an event when a new vault is opened\n    event VaultOpened(address indexed accountOwner, uint256 vaultId);\n    /// @notice emits an event when a long oToken is deposited into a vault\n    event LongOtokenDeposited(\n        address indexed otoken,\n        address indexed accountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a long oToken is withdrawn from a vault\n    event LongOtokenWithdrawed(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a collateral asset is deposited into a vault\n    event CollateralAssetDeposited(\n        address indexed asset,\n        address indexed accountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a collateral asset is withdrawn from a vault\n    event CollateralAssetWithdrawed(\n        address indexed asset,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a short oToken is minted from a vault\n    event ShortOtokenMinted(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a short oToken is burned\n    event ShortOtokenBurned(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when an oToken is redeemed\n    event Redeem(\n        address indexed otoken,\n        address indexed redeemer,\n        address indexed receiver,\n        address collateralAsset,\n        uint256 otokenBurned,\n        uint256 payout\n    );\n    /// @notice emits an event when a vault is settled\n    event VaultSettled(address indexed AccountOwner, address indexed to, uint256 vaultId, uint256 payout);\n    /// @notice emits an event when a call action is executed\n    event CallExecuted(\n        address indexed from,\n        address indexed to,\n        address indexed vaultOwner,\n        uint256 vaultId,\n        bytes data\n    );\n    /// @notice emits an event when the fullPauser address changes\n    event FullPauserUpdated(address indexed oldFullPauser, address indexed newFullPauser);\n    /// @notice emits an event when the partialPauser address changes"
    }
  ]
}