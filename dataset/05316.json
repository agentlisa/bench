{
  "Title": "[G-05] Cache external calls outside of loop to avoid re-calling function on each iteration",
  "Content": "Performing STATICCALLs that do not depend on variables incremented in loops should always try to be avoided within the loop. In the instance, we are able to cache the external calls outside of the loop to save a STATICCALL (100 gas) per loop iteration.\n\n### 1 Instance\n1. ### Perform the external calls `orderType.isPayOrder()` and `orderType.isBaseOrder()` outside the loop and cache their results.\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L255\n\nThe external calls `orderType.isPayOrder()` and `orderType.isBaseOrder()` should be made outside the loop and the result cached since their returned values are not dependent on the loop iterations. The diff below shows how the code should be refactored:\n\n<details>\n\n```solidity\nfile: src/modules/PaymentEscrow.sol\n\n215:    function _settlePayment(\n216:        Item[] calldata items,\n217:        OrderType orderType,\n218:        address lender,\n219:        address renter,\n220:        uint256 start,\n221:        uint256 end\n222:    ) internal {\n223:        // Calculate the time values.\n224:        uint256 elapsedTime = block.timestamp - start;\n225:        uint256 totalTime = end - start;\n226:\n227:        // Determine whether the rental order has ended.\n228:        bool isRentalOver = elapsedTime >= totalTime;\n229:\n230:        // Loop through each item in the order.\n231:        for (uint256 i = 0; i < items.length; ++i) {\n232:            // Get the item.\n233:            Item memory item = items[i];\n234:\n235:            // Check that the item is a payment.\n236:            if (item.isERC20()) {\n237:                // Set a placeholder payment amount which can be reduced in the\n238:                // presence of a fee.\n239:                uint256 paymentAmount = item.amount;\n240:\n241:                // Take a fee on the payment amount if the fee is on.\n242:                if (fee != 0) {\n243:                    // Calculate the new fee.\n244:                    uint256 paymentFee = _calculateFee(paymentAmount);\n245:\n246:                    // Adjust the payment amount by the fee.\n247:                    paymentAmount -= paymentFee;\n248:                }\n249:\n250:                // Effect: Decrease the token balance. Use the payment amount pre-fee\n251:                // so that fees can be taken.\n252:                _decreaseDeposit(item.token, item.amount);\n253:\n254:                // If its a PAY order but the rental hasn't ended yet.\n255:                if (orderType.isPayOrder() && !isRentalOver) {  //@audit make orderType.isPayOrder() outside loop\n256:                    // Interaction: a PAY order which hasnt ended yet. Payout is pro-rata.\n257:                    _settlePaymentProRata(\n258:                        item.token,\n259:                        paymentAmount,\n260:                        lender,\n261:                        renter,\n262:                        elapsedTime,\n263:                        totalTime\n264:                    );\n265:                }\n266:                // If its a PAY order and the rental is over, or, if its a BASE order.\n267:                else if (\n268:                    (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()   //@audit make orderType.isPayOrder() and orderType.isBaseOrder() outside loop\n269:                ) {\n270:                    // Interaction: a pay order or base order which has ended. Payout is in full.\n271:                    _settlePaymentInFull(\n272:                        item.token,\n273:                        paymentAmount,\n274:                        item.settleTo,\n275:                        lender,\n276:                        renter\n277:                    );\n278:                } else {\n279:                    revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n280:                }\n281:            }\n282:        }\n283:    }\n```\n```diff\ndiff --git a/src/modules/PaymentEscrow.sol b/src/modules/PaymentEscrow.sol\nindex 34c4f4c..988b175 100644\n--- a/src/modules/PaymentEscrow.sol\n+++ b/src/modules/PaymentEscrow.sol\n@@ -226,6 +226,8 @@ contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n\n         // Determine whether the rental order has ended.\n         bool isRentalOver = elapsedTime >= totalTime;\n+        bool isPayOrder = orderType.isPayOrder();\n+        bool isBaseOrder = orderType.isBaseOrder();\n\n         // Loop through each item in the order.\n         for (uint256 i = 0; i < items.length; ++i) {\n@@ -252,7 +254,7 @@ contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n                 _decreaseDeposit(item.token, item.amount);\n\n                 // If its a PAY order but the rental hasn't ended yet.\n-                if (orderType.isPayOrder() && !isRentalOver) {\n+                if (isPayOrder && !isRentalOver) {\n                     // Interaction: a PAY order which hasnt ended yet. Payout is pro-rata.\n                     _settlePaymentProRata(\n                         item.token,\n@@ -265,7 +267,7 @@ contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n                 }\n                 // If its a PAY order and the rental is over, or, if its a BASE order.\n                 else if (\n-                    (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n+                    (isPayOrder && isRentalOver) || isBaseOrder\n                 ) {\n                     // Interaction: a pay order or base order which has ended. Payout is in full.\n                     _settlePaymentInFull(\n```\n```\nEstimated gas saved: 300 gas units\n```\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/modules/PaymentEscrow.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\n\nimport {Kernel, Module, Keycode} from \"@src/Kernel.sol\";\nimport {Proxiable} from \"@src/proxy/Proxiable.sol\";\nimport {\n    RentalOrder,\n    Item,\n    ItemType,\n    SettleTo,\n    OrderType\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\n\n/**\n * @title PaymentEscrowBase\n * @notice Storage exists in its own base contract to avoid storage slot mismatch during upgrades.\n */\ncontract PaymentEscrowBase {\n    // Keeps a record of the current token balances in the escrow.\n    mapping(address token => uint256 amount) public balanceOf;\n\n    // Fee percentage taken from payments.\n    uint256 public fee;\n}\n\n/**\n * @title PaymentEscrow\n * @notice Module dedicated to escrowing rental payments while rentals are active. When\n *         rentals are stopped, this module will determine payouts to all parties and a\n *         fee will be reserved to be withdrawn later by a protocol admin.\n */\ncontract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n    using RentalUtils for Item;\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Module Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Instantiate this contract as a module. When using a proxy, the kernel address\n     *      should be set to address(0).\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    /**\n     * @notice Instantiates this contract as a module via a proxy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    function MODULE_PROXY_INSTANTIATION(\n        Kernel kernel_\n    ) external onlyByProxy onlyUninitialized {\n        kernel = kernel_;\n        initialized = true;\n    }\n\n    /**\n     * @notice Specifies which version of a module is being implemented.\n     */\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /**\n     * @notice Defines the keycode for this module.\n     */\n    function KEYCODE() public pure override returns (Keycode) {\n        return Keycode.wrap(\"ESCRW\");\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Calculates the fee based on the fee numerator set by an admin.\n     *\n     * @param amount Amount for which to calculate the fee.\n     */\n    function _calculateFee(uint256 amount) internal view returns (uint256) {\n        // Uses 10,000 as a denominator for the fee.\n        return (amount * fee) / 10000;\n    }\n\n    /**\n     * @dev Safe transfer for ERC20 tokens that do not consistently renturn true/false.\n     *\n     * @param token Asset address which is being sent.\n     * @param to    Destination address for the transfer.\n     * @param value Amount of the asset being transferred.\n     */\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        // Call transfer() on the token.\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n        );\n\n        // Because both reverting and returning false are allowed by the ERC20 standard\n        // to indicate a failed transfer, we must handle both cases.\n        //\n        // If success is false, the ERC20 contract reverted.\n        //\n        // If success is true, we must check if return data was provided. If no return\n        // data is provided, then no revert occurred. But, if return data is provided,\n        // then it must be decoded into a bool which will indicate the success of the\n        // transfer.\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n            revert Errors.PaymentEscrowModule_PaymentTransferFailed(token, to, value);\n        }\n    }\n\n    /**\n     * @dev Calculates the pro-rata split based on the amount of time that has elapsed in\n     *      a rental order. If there are not enough funds to split perfectly, rounding is\n     *      done to make the split as fair as possible.\n     *\n     * @param amount      Amount of tokens for which to calculate the split.\n     * @param elapsedTime Elapsed time since the rental started.\n     * @param totalTime   Total time window of the rental from start to end.\n     *\n     * @return renterAmount Payment amount to send to the renter.\n     * @return lenderAmount Payment amoutn to send to the lender.\n     */\n    function _calculatePaymentProRata(\n        uint256 amount,\n        uint256 elapsedTime,\n        uint256 totalTime\n    ) internal pure returns (uint256 renterAmount, uint256 lenderAmount) {\n        // Calculate the numerator and adjust by a multiple of 1000.\n        uint256 numerator = (amount * elapsedTime) * 1000;\n\n        // Calculate the result, but bump by 500 to add a rounding adjustment. Then,\n        // reduce by a multiple of 1000.\n        renterAmount = ((numerator / totalTime) + 500) / 1000;\n\n        // Calculate lender amount from renter amount so no tokens are left behind.\n        lenderAmount = amount - renterAmount;\n    }\n\n    /**\n     * @dev Settles a payment via a pro-rata split. After payments are calculated, they\n     *      are transferred to their respective recipients.\n     *\n     * @param token       Token address for which to settle a payment.\n     * @param amount      Amount of the token to settle.\n     * @param lender      Lender account.\n     * @param renter      Renter accoutn.\n     * @param elapsedTime Elapsed time since the rental started.\n     * @param totalTime   Total time window of the rental from start to end.\n     */\n    function _settlePaymentProRata(\n        address token,\n        uint256 amount,\n        address lender,\n        address renter,\n        uint256 elapsedTime,\n        uint256 totalTime\n    ) internal {\n        // Calculate the pro-rata payment for renter and lender.\n        (uint256 renterAmount, uint256 lenderAmount) = _calculatePaymentProRata(\n            amount,\n            elapsedTime,\n            totalTime\n        );\n\n        // Send the lender portion of the payment.\n        _safeTransfer(token, lender, lenderAmount);\n\n        // Send the renter portion of the payment.\n        _safeTransfer(token, renter, renterAmount);\n    }\n\n    /**\n     * @dev Settles a payment by sending the full amount to one address.\n     *\n     * @param token    Token address for which to settle a payment.\n     * @param amount   Amount of the token to settle.\n     * @param settleTo Specifies whether to settle to the lender or the renter.\n     * @param lender   Lender account.\n     * @param renter   Renter account.\n     */\n    function _settlePaymentInFull(\n        address token,\n        uint256 amount,\n        SettleTo settleTo,\n        address lender,\n        address renter\n    ) internal {\n        // Determine the address that this payment will settle to.\n        address settleToAddress = settleTo == SettleTo.LENDER ? lender : renter;\n\n        // Send the payment.\n        _safeTransfer(token, settleToAddress, amount);\n    }\n\n    /**\n     * @dev Settles alls payments contained in the given item. Uses a pro-rata or in full\n     *      scheme depending on the order type and when the order was stopped.\n     *\n     * @param items     Items present in the order.\n     * @param orderType Type of the order.\n     * @param lender    Lender account.\n     * @param renter    Renter account.\n     * @param start     Timestamp that the rental began.\n     * @param end       Timestamp that the rental expires at.\n     */\n    function _settlePayment(\n        Item[] calldata items,\n        OrderType orderType,\n        address lender,\n        address renter,\n        uint256 start,\n        uint256 end\n    ) internal {\n        // Calculate the time values.\n        uint256 elapsedTime = block.timestamp - start;\n        uint256 totalTime = end - start;\n\n        // Determine whether the rental order has ended.\n        bool isRentalOver = elapsedTime >= totalTime;\n\n        // Loop through each item in the order.\n        for (uint256 i = 0; i < items.length; ++i) {\n            // Get the item.\n            Item memory item = items[i];\n\n            // Check that the item is a payment.\n            if (item.isERC20()) {\n                // Set a placeholder payment amount which can be reduced in the\n                // presence of a fee.\n                uint256 paymentAmount = item.amount;\n\n                // Take a fee on the payment amount if the fee is on.\n                if (fee != 0) {\n                    // Calculate the new fee.\n                    uint256 paymentFee = _calculateFee(paymentAmount);\n\n                    // Adjust the payment amount by the fee.\n                    paymentAmount -= paymentFee;\n                }\n\n                // Effect: Decrease the token balance. Use the payment amount pre-fee\n                // so that fees can be taken.\n                _decreaseDeposit(item.token, item.amount);\n\n                // If its a PAY order but the rental hasn't ended yet.\n                if (orderType.isPayOrder() && !isRentalOver) {\n                    // Interaction: a PAY order which hasnt ended yet. Payout is pro-rata.\n                    _settlePaymentProRata(\n                        item.token,\n                        paymentAmount,\n                        lender,\n                        renter,\n                        elapsedTime,\n                        totalTime\n                    );\n                }\n                // If its a PAY order and the rental is over, or, if its a BASE order.\n                else if (\n                    (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n                ) {\n                    // Interaction: a pay order or base order which has ended. Payout is in full.\n                    _settlePaymentInFull(\n                        item.token,\n                        paymentAmount,\n                        item.settleTo,\n                        lender,\n                        renter\n                    );\n                } else {\n                    revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Decreases the tracked token balance of a particular token on the payment\n     *      escrow contract.\n     *\n     * @param token  Token address.\n     * @param amount Amount to decrease the balance by.\n     */\n    function _decreaseDeposit(address token, uint256 amount) internal {\n        // Directly decrease the synced balance.\n        balanceOf[token] -= amount;\n    }\n\n    /**\n     * @dev Increases the tracked token balance of a particular token on the payment\n     *      escrow contract.\n     *\n     * @param token  Token address.\n     * @param amount Amount to increase the balance by.\n     */\n    function _increaseDeposit(address token, uint256 amount) internal {\n        // Directly increase the synced balance.\n        balanceOf[token] += amount;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Settles the payment for a rental order by transferring all items marked as\n     *         payments to their destination accounts. During the settlement process, if\n     *         active, a fee is taken on the payment.\n     *\n     * @param order Rental order for which to settle a payment.\n     */\n    function settlePayment(RentalOrder calldata order) external onlyByProxy permissioned {\n        // Settle all payments for the order.\n        _settlePayment(\n            order.items,\n            order.orderType,\n            order.lender,\n            order.renter,\n            order.startTimestamp,\n            order.endTimestamp\n        );\n    }\n\n    /**\n     * @notice Settles the payments for multiple orders by looping through each one.\n     *\n     * @param orders Rental ordesr for which to settle payments.\n     */\n    function settlePaymentBatch(\n        RentalOrder[] calldata orders\n    ) external onlyByProxy permissioned {\n        // Loop through each order.\n        for (uint256 i = 0; i < orders.length; ++i) {\n            // Settle all payments for the order.\n            _settlePayment(\n                orders[i].items,\n                orders[i].orderType,\n                orders[i].lender,\n                orders[i].renter,\n                orders[i].startTimestamp,\n                orders[i].endTimestamp\n            );\n        }\n    }\n\n    /**\n     * @notice When fungible tokens are transferred to the payment escrow contract,\n     *         their balances should be increased.\n     *\n     * @param token  Token address for the asset.\n     * @param amount Amount of the token transferred to the escrow\n     */\n    function increaseDeposit(\n        address token,\n        uint256 amount\n    ) external onlyByProxy permissioned {\n        // Cannot accept a payment of zero.\n        if (amount == 0) {\n            revert Errors.PaymentEscrow_ZeroPayment();\n        }\n\n        // Increase the deposit\n        _increaseDeposit(token, amount);\n    }\n\n    /**\n     * @notice Sets the numerator for the fee. The denominator will always be set at\n     *         10,000.\n     *\n     * @param feeNumerator Numerator of the fee.\n     */\n    function setFee(uint256 feeNumerator) external onlyByProxy permissioned {\n        // Cannot accept a fee numerator greater than 10000.\n        if (feeNumerator > 10000) {\n            revert Errors.PaymentEscrow_InvalidFeeNumerator();\n        }\n\n        // Set the fee.\n        fee = feeNumerator;\n    }\n\n    /**\n     * @notice Used to collect protocol fees. In addition, if funds are accidentally sent\n     *         to the payment escrow contract, this function can be used to skim them off.\n     *\n     * @param token Address of the token to skim.\n     * @param to    Address to send the collected tokens.\n     */\n    function skim(address token, address to) external onlyByProxy permissioned {\n        // Fetch the currently synced balance of the escrow.\n        uint256 syncedBalance = balanceOf[token];\n\n        // Fetch the true token balance of the escrow.\n        uint256 trueBalance = IERC20(token).balanceOf(address(this));\n\n        // Calculate the amount to skim.\n        uint256 skimmedBalance = trueBalance - syncedBalance;\n\n        // Send the difference to the specified address.\n        _safeTransfer(token, to, skimmedBalance);\n\n        // Emit event with fees taken.\n        emit Events.FeeTaken(token, skimmedBalance);\n    }\n\n    /**\n     * @notice Upgrades the contract to a different implementation. This implementation\n     *         contract must be compatible with ERC-1822 or else the upgrade will fail.\n     *\n     * @param newImplementation Address of the implementation contract to upgrade to.\n     */\n    function upgrade(address newImplementation) external onlyByProxy permissioned {\n        // _upgrade is implemented in the Proxiable contract.\n        _upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the contract which prevents upgrading the implementation contract.\n     *         There is no way to unfreeze once a contract has been frozen.\n     */\n    function freeze() external onlyByProxy permissioned {\n        // _freeze is implemented in the Proxiable contract.\n        _freeze();\n    }\n}"
    }
  ]
}