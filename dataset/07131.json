{
  "Title": "[M-05] When rewardToken is erc1155/erc777, an attacker can reenter and cause funds to be stuck in the contract forever",
  "Content": "# Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/068d628f019e9469aecbf676370075c1f6c980fd/contracts/Quest.sol#L113-L116\n\n\n# Vulnerability details\n\n## Impact\nIf the reward token is `erc1155/erc777` an attacker can reenter and then buy/transfer another unclaimed token to the attacker address and then  the var \n`redeemTokens` wont be equal to how many tokens were actually redeemed. \n\n## Proof of Concept\nex:\nreward token is an erc1155 that has  `_afterTokenTransfer` \nAlice(attacker) has 2  receipt tokens, the first one is on a  smart contract that will do the reentrancy, and the second  one is on Alice's address but is approved   to transfer to  the  smart contract(the own that holds the first receipt)\n1. Alice calls the sc to `claim` rewards\n```solidity\n IERC1155(rewardToken).safeTransferFrom(address(this), msg.sender, rewardAmountInWeiOrTokenId, amount_, '0x00');\n``` \n2. `_afterTokenTransfer`  which causes the sc  to  call a function in its fallback function that transfers  the approved token to  the sc\n```solidity\n   try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n```\n3. We then reenter with  recipient,not yet claimed token  and we claim it \nresult:\n the invariant that `redeemedTokens` = tokens that are redeemed is false because it doesn't account for the first token that we reentered.\n The issue is worse  with `erc777` tokens because of  the fact  that accounting will be in  the `withdrawRemainingTokens` function\n```solidity \n\n        uint256 unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n        uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n        IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n\n```\nafter the reentrancy \nex: `redeemedTokens=9` but should be 10\n`receiptRedeemers()=12` \n`rewardAmountInWeiOrTokenId=1e5`\n`unclaimedTokens=300000 `\nassuming they are some tokens left \n`balance(address(this)=201000` and `protocolFee=500`\n`nonClaimableTokens=201000 - 500 - 300000` it would revert ( negative numbers  with uint) and   funds would be stuck in the contract forever\nThe real estimate for `nonClaimableTokens=201000-500-200000=500` and the owner can get funds out \nbut 500 wei will be lost in the contract \nand  it can get worse with large amounts of quests and the attacker  reentering multiple times to cause a bigger gap between the real `redeemedTokens`  \n## Tools Used\n\n## Recommended Mitigation Steps\nadd  nonReentrancy modifier ",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-rabbithole-quest-protocol-contest",
  "Code": [
    {
      "filename": "contracts/Quest.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IQuest} from './interfaces/IQuest.sol';\nimport {RabbitHoleReceipt} from './RabbitHoleReceipt.sol';\nimport {ECDSA} from '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\n\n/// @title Quest\n/// @author RabbitHole.gg\n/// @notice This contract is the base contract for all Quests. The Erc20Quest and Erc1155Quest contracts inherit from this contract.\ncontract Quest is Ownable, IQuest {\n    RabbitHoleReceipt public immutable rabbitHoleReceiptContract;\n    address public immutable rewardToken;\n    uint256 public immutable endTime;\n    uint256 public immutable startTime;\n    uint256 public immutable totalParticipants;\n    uint256 public immutable rewardAmountInWeiOrTokenId;\n    bool public hasStarted;\n    bool public isPaused;\n    string public questId;\n    uint256 public redeemedTokens;\n\n    mapping(uint256 => bool) private claimedList;\n\n    constructor(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountInWeiOrTokenId_,\n        string memory questId_,\n        address receiptContractAddress_\n    ) {\n        if (endTime_ <= block.timestamp) revert EndTimeInPast();\n        if (startTime_ <= block.timestamp) revert StartTimeInPast();\n        if (endTime_ <= startTime_) revert EndTimeLessThanOrEqualToStartTime();\n        endTime = endTime_;\n        startTime = startTime_;\n        rewardToken = rewardTokenAddress_;\n        totalParticipants = totalParticipants_;\n        rewardAmountInWeiOrTokenId = rewardAmountInWeiOrTokenId_;\n        questId = questId_;\n        rabbitHoleReceiptContract = RabbitHoleReceipt(receiptContractAddress_);\n        redeemedTokens = 0;\n    }\n\n    /// @notice Starts the Quest\n    /// @dev Only the owner of the Quest can call this function\n    function start() public virtual onlyOwner {\n        isPaused = false;\n        hasStarted = true;\n    }\n\n    /// @notice Pauses the Quest\n    /// @dev Only the owner of the Quest can call this function. Also requires that the Quest has started (not by date, but by calling the start function)\n    function pause() public onlyOwner onlyStarted {\n        isPaused = true;\n    }\n\n    /// @notice Unpauses the Quest\n    /// @dev Only the owner of the Quest can call this function. Also requires that the Quest has started (not by date, but by calling the start function)\n    function unPause() public onlyOwner onlyStarted {\n        isPaused = false;\n    }\n\n    /// @notice Marks token ids as claimed\n    /// @param tokenIds_ The token ids to mark as claimed\n    function _setClaimed(uint256[] memory tokenIds_) private {\n        for (uint i = 0; i < tokenIds_.length; i++) {\n            claimedList[tokenIds_[i]] = true;\n        }\n    }\n\n    /// @notice Prevents reward withdrawal until the Quest has ended\n    modifier onlyAdminWithdrawAfterEnd() {\n        if (block.timestamp < endTime) revert NoWithdrawDuringClaim();\n        _;\n    }\n\n    /// @notice Checks if the Quest has started at the function level\n    modifier onlyStarted() {\n        if (!hasStarted) revert NotStarted();\n        _;\n    }\n\n    /// @notice Checks if quest has started both at the function level and at the start time\n    modifier onlyQuestActive() {\n        if (!hasStarted) revert NotStarted();\n        if (block.timestamp < startTime) revert ClaimWindowNotStarted();\n        _;\n    }\n\n    /// @notice Allows user to claim the rewards entitled to them\n    /// @dev User can claim based on the (unclaimed) number of tokens they own of the Quest\n    function claim() public virtual onlyQuestActive {\n        if (isPaused) revert QuestPaused();\n\n        uint[] memory tokens = rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest(questId, msg.sender);\n\n        if (tokens.length == 0) revert NoTokensToClaim();\n\n        uint256 redeemableTokenCount = 0;\n        for (uint i = 0; i < tokens.length; i++) {\n            if (!isClaimed(tokens[i])) {\n                redeemableTokenCount++;\n            }\n        }\n\n        if (redeemableTokenCount == 0) revert AlreadyClaimed();\n\n        uint256 totalRedeemableRewards = _calculateRewards(redeemableTokenCount);\n        _setClaimed(tokens);\n        _transferRewards(totalRedeemableRewards);\n        redeemedTokens += redeemableTokenCount;\n\n        emit Claimed(msg.sender, totalRedeemableRewards);\n    }\n\n    /// @notice Calculate the amount of rewards\n    /// @dev This function must be implemented in the child contracts\n    function _calculateRewards(uint256 redeemableTokenCount_) internal virtual returns (uint256) {\n        revert MustImplementInChild();\n    }\n\n    /// @notice Transfer the rewards to the user\n    /// @dev This function must be implemented in the child contracts\n    /// @param amount_ The amount of rewards to transfer\n    function _transferRewards(uint256 amount_) internal virtual {\n        revert MustImplementInChild();\n    }\n\n    /// @notice Checks if a Receipt token id has been used to claim a reward\n    /// @param tokenId_ The token id to check\n    function isClaimed(uint256 tokenId_) public view returns (bool) {\n        return claimedList[tokenId_] == true;\n    }\n\n    /// @dev Returns the reward amount\n    function getRewardAmount() public view returns (uint256) {\n        return rewardAmountInWeiOrTokenId;\n    }\n\n    /// @dev Returns the reward token address\n    function getRewardToken() public view returns (address) {\n        return rewardToken;\n    }\n\n    /// @notice Allows the owner of the Quest to withdraw any remaining rewards after the Quest has ended\n    function withdrawRemainingTokens(address to_) public virtual onlyOwner onlyAdminWithdrawAfterEnd {}\n}"
    }
  ]
}