{
  "Title": "[M-09] Potential lock of rewards in the custody contracts",
  "Content": "\nThe `swap_to_stable_denom` function in the custody contracts swaps all other native tokens into a specific one. The function creates swap messages for all the other native tokens and adds them as sub-messages, and handles the reply only when the last sub-message succeeds. Upon receiving the reply, the contract sends the swapped tokens (i.e., rewards) to the overseer contract.\n\nIn cases where the last sub-message fails, the custody contract will not receive a reply, and therefore the rewards are left in the contract. The rewards are locked in the contract until someone triggers `swap_to_stable_denom` again, and the last swap succeeds. However, if the last swap consistently fails in some period for any reason, the total rewards will be locked in the contract during that period. As a result, users cannot get the rewards they are supposed to receive in that period.\n\n### Proof of Concept\n\nReferenced code:<br>\n[`custody_beth/src/distribution.rs#L110-L115`](https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/money-market-contracts/contracts/custody_beth/src/distribution.rs#L110-L115)<br>\n[`custody_bluna/src/distribution.rs#L109-L114`](https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/money-market-contracts/contracts/custody_bluna/src/distribution.rs#L109-L114)<br>\n\n### Recommended Mitigation Steps\n\nConsider handling the reply on either success or failure, i.e., using `ReplyOn::Always`, to avoid the failure of the swap to cause tokens to be locked.\n\n**[bitn8 (Anchor) disagreed with severity](https://github.com/code-423n4/2022-02-anchor-findings/issues/71)**\n\n**[Alex the Entreprenerd (triage) commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/71#issuecomment-1205890442):**\n > Reliant on external conditions. Severity seems appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts/money-market-contracts/contracts/custody_beth/src/distribution.rs",
      "content": "use cosmwasm_bignumber::Uint256;\nuse cosmwasm_std::{\n    attr, to_binary, Addr, BankMsg, Coin, CosmosMsg, Deps, DepsMut, Env, MessageInfo, QueryRequest,\n    ReplyOn, Response, StdResult, SubMsg, Uint128, WasmMsg, WasmQuery,\n};\n\nuse crate::contract::{CLAIM_REWARDS_OPERATION, SWAP_TO_STABLE_OPERATION};\nuse crate::error::ContractError;\nuse crate::external::handle::{RewardContractExecuteMsg, RewardContractQueryMsg};\nuse crate::state::{read_config, BETHAccruedRewardsResponse, Config};\n\nuse moneymarket::querier::{deduct_tax, query_all_balances, query_balance};\nuse terra_cosmwasm::{create_swap_msg, TerraMsgWrapper};\n\n// REWARD_THRESHOLD\n// This value is used as the minimum reward claim amount\n// thus if a user's reward is less than 1 ust do not send the ClaimRewards msg\nconst REWARDS_THRESHOLD: Uint128 = Uint128::new(1000000);\n\n/// Request withdraw reward operation to\n/// reward contract and execute `distribute_hook`\n/// Executor: overseer\npub fn distribute_rewards(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n) -> Result<Response<TerraMsgWrapper>, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n\n    let contract_addr = env.contract.address;\n\n    if config.overseer_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let reward_contract = deps.api.addr_humanize(&config.reward_contract)?;\n\n    let accrued_rewards =\n        get_accrued_rewards(deps.as_ref(), reward_contract.clone(), contract_addr)?;\n    if accrued_rewards < REWARDS_THRESHOLD {\n        return Ok(Response::default());\n    }\n\n    // Do not emit the event logs here\n    Ok(Response::new().add_submessage(SubMsg::reply_on_success(\n        CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: reward_contract.to_string(),\n            funds: vec![],\n            msg: to_binary(&RewardContractExecuteMsg::ClaimRewards { recipient: None })?,\n        }),\n        CLAIM_REWARDS_OPERATION,\n    )))\n}\n\n/// Apply swapped reward to global index\n/// Executor: itself\npub fn distribute_hook(\n    deps: DepsMut,\n    env: Env,\n) -> Result<Response<TerraMsgWrapper>, ContractError> {\n    let contract_addr = env.contract.address;\n    let config: Config = read_config(deps.storage)?;\n\n    let overseer_contract = deps.api.addr_humanize(&config.overseer_contract)?;\n\n    // reward_amount = (prev_balance + reward_amount) - prev_balance\n    // = (0 + reward_amount) - 0 = reward_amount = balance\n    let reward_amount: Uint256 = query_balance(\n        deps.as_ref(),\n        contract_addr,\n        config.stable_denom.to_string(),\n    )?;\n    let mut messages: Vec<CosmosMsg<TerraMsgWrapper>> = vec![];\n    if !reward_amount.is_zero() {\n        messages.push(CosmosMsg::Bank(BankMsg::Send {\n            to_address: overseer_contract.to_string(),\n            amount: vec![deduct_tax(\n                deps.as_ref(),\n                Coin {\n                    denom: config.stable_denom,\n                    amount: reward_amount.into(),\n                },\n            )?],\n        }));\n    }\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"distribute_rewards\"),\n        attr(\"buffer_rewards\", reward_amount),\n    ]))\n}\n\n/// Swap all coins to stable_denom\n/// and execute `swap_hook`\n/// Executor: itself\npub fn swap_to_stable_denom(\n    deps: DepsMut,\n    env: Env,\n) -> Result<Response<TerraMsgWrapper>, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n\n    let contract_addr = env.contract.address;\n    let balances: Vec<Coin> = query_all_balances(deps.as_ref(), contract_addr)?;\n    let mut messages: Vec<SubMsg<TerraMsgWrapper>> = balances\n        .iter()\n        .filter(|x| x.denom != config.stable_denom)\n        .map(|coin: &Coin| SubMsg::new(create_swap_msg(coin.clone(), config.stable_denom.clone())))\n        .collect();\n\n    if let Some(last) = messages.last_mut() {\n        last.id = SWAP_TO_STABLE_OPERATION;\n        last.reply_on = ReplyOn::Success;\n    }\n\n    Ok(Response::new().add_submessages(messages))\n}\n\npub(crate) fn get_accrued_rewards(\n    deps: Deps,\n    reward_contract_addr: Addr,\n    contract_addr: Addr,\n) -> StdResult<Uint128> {\n    let rewards: BETHAccruedRewardsResponse =\n        deps.querier.query(&QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: reward_contract_addr.to_string(),\n            msg: to_binary(&RewardContractQueryMsg::AccruedRewards {\n                address: contract_addr.to_string(),\n            })?,\n        }))?;\n\n    Ok(rewards.rewards)\n}"
    },
    {
      "filename": "contracts/money-market-contracts/contracts/custody_bluna/src/distribution.rs",
      "content": "use cosmwasm_bignumber::Uint256;\nuse cosmwasm_std::{\n    attr, to_binary, Addr, BankMsg, Coin, CosmosMsg, Deps, DepsMut, Env, MessageInfo, QueryRequest,\n    ReplyOn, Response, StdResult, SubMsg, Uint128, WasmMsg, WasmQuery,\n};\n\nuse crate::contract::{CLAIM_REWARDS_OPERATION, SWAP_TO_STABLE_OPERATION};\nuse crate::error::ContractError;\nuse crate::external::handle::{RewardContractExecuteMsg, RewardContractQueryMsg};\nuse crate::state::{read_config, BLunaAccruedRewardsResponse, Config};\n\nuse moneymarket::querier::{deduct_tax, query_all_balances, query_balance};\nuse terra_cosmwasm::{create_swap_msg, TerraMsgWrapper};\n\n// REWARD_THRESHOLD\n// This value is used as the minimum reward claim amount\n// thus if a user's reward is less than 1 ust do not send the ClaimRewards msg\nconst REWARDS_THRESHOLD: Uint128 = Uint128::new(1000000);\n\n/// Request withdraw reward operation to\n/// reward contract and execute `distribute_hook`\n/// Executor: overseer\npub fn distribute_rewards(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n) -> Result<Response<TerraMsgWrapper>, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    if config.overseer_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let contract_addr = env.contract.address;\n    let reward_contract = deps.api.addr_humanize(&config.reward_contract)?;\n\n    let accrued_rewards =\n        get_accrued_rewards(deps.as_ref(), reward_contract.clone(), contract_addr)?;\n    if accrued_rewards < REWARDS_THRESHOLD {\n        return Ok(Response::default());\n    }\n\n    // Do not emit the event logs here\n    Ok(\n        Response::new().add_submessages(vec![SubMsg::reply_on_success(\n            CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: reward_contract.to_string(),\n                funds: vec![],\n                msg: to_binary(&RewardContractExecuteMsg::ClaimRewards { recipient: None })?,\n            }),\n            CLAIM_REWARDS_OPERATION,\n        )]),\n    )\n}\n\n/// Apply swapped reward to global index\n/// Executor: itself\npub fn distribute_hook(\n    deps: DepsMut,\n    env: Env,\n) -> Result<Response<TerraMsgWrapper>, ContractError> {\n    let contract_addr = env.contract.address;\n    let config: Config = read_config(deps.storage)?;\n    let overseer_contract = deps.api.addr_humanize(&config.overseer_contract)?;\n\n    // reward_amount = (prev_balance + reward_amount) - prev_balance\n    // = (0 + reward_amount) - 0 = reward_amount = balance\n    let reward_amount: Uint256 = query_balance(\n        deps.as_ref(),\n        contract_addr,\n        config.stable_denom.to_string(),\n    )?;\n    let mut messages: Vec<CosmosMsg<TerraMsgWrapper>> = vec![];\n    if !reward_amount.is_zero() {\n        messages.push(CosmosMsg::Bank(BankMsg::Send {\n            to_address: overseer_contract.to_string(),\n            amount: vec![deduct_tax(\n                deps.as_ref(),\n                Coin {\n                    denom: config.stable_denom,\n                    amount: reward_amount.into(),\n                },\n            )?],\n        }));\n    }\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"distribute_rewards\"),\n        attr(\"buffer_rewards\", reward_amount),\n    ]))\n}\n\n/// Swap all coins to stable_denom\n/// and execute `swap_hook`\n/// Executor: itself\npub fn swap_to_stable_denom(\n    deps: DepsMut,\n    env: Env,\n) -> Result<Response<TerraMsgWrapper>, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n\n    let contract_addr = env.contract.address;\n    let balances: Vec<Coin> = query_all_balances(deps.as_ref(), contract_addr)?;\n    let mut messages: Vec<SubMsg<TerraMsgWrapper>> = balances\n        .iter()\n        .filter(|x| x.denom != config.stable_denom)\n        .map(|coin: &Coin| SubMsg::new(create_swap_msg(coin.clone(), config.stable_denom.clone())))\n        .collect();\n\n    if let Some(last) = messages.last_mut() {\n        last.id = SWAP_TO_STABLE_OPERATION;\n        last.reply_on = ReplyOn::Success;\n    }\n\n    Ok(Response::new().add_submessages(messages))\n}\n\npub(crate) fn get_accrued_rewards(\n    deps: Deps,\n    reward_contract_addr: Addr,\n    contract_addr: Addr,\n) -> StdResult<Uint128> {\n    let rewards: BLunaAccruedRewardsResponse =\n        deps.querier.query(&QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: reward_contract_addr.to_string(),\n            msg: to_binary(&RewardContractQueryMsg::AccruedRewards {\n                address: contract_addr.to_string(),\n            })?,\n        }))?;\n\n    Ok(rewards.rewards)\n}"
    }
  ]
}