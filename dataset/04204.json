{
  "Title": "Non-Null Addresses",
  "Content": "\n[strategy-curve-scrv-v4_1.sol#L49](https://github.com/pickle-finance/protocol/blob/master/src/strategies/curve/strategy-curve-scrv-v4_1.sol#L49)\n\n[strategy-base.sol#L44](https://github.com/pickle-finance/protocol/blob/a808366db95b07c0b8940e919ec72d80e2deaca7/src/strategies/strategy-base.sol#L44) \n\nSince all the operations with `address`-typed `StrategyCurveSCRVv4_1` and `StrategyBase` contract fields are being performed with `safeTransfer` or `_approve` functions, checking if an `address`-typed argument is not `0`, it is recommended to implement additional `require`s in contract constructor, checking if each of input arguments `!= address(0)`, to avoid potential issues in newcoming contract updates (according to\n`harvest()` functions comment).\n\n*This issue was resolved with the following PR: https://github.com/pickle-finance/protocol/pull/7.*\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/strategies/curve/strategy-curve-scrv-v4_1.sol",
      "content": "// https://etherscan.io/address/0x594a198048501a304267e63b3bad0f0638da7628#code\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\nimport \"../../lib/erc20.sol\";\nimport \"../../lib/safe-math.sol\";\n\nimport \"./scrv-voter.sol\";\nimport \"./crv-locker.sol\";\n\nimport \"../../interfaces/jar.sol\";\nimport \"../../interfaces/curve.sol\";\nimport \"../../interfaces/uniswapv2.sol\";\nimport \"../../interfaces/controller.sol\";\n\nimport \"../strategy-base.sol\";\n\ncontract StrategyCurveSCRVv4_1 is StrategyBase {\n    // Curve\n    address public scrv = 0xC25a3A3b969415c80451098fa907EC722572917F;\n    address public susdv2_gauge = 0xA90996896660DEcC6E997655E065b23788857849;\n    address public susdv2_pool = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\n    address public escrow = 0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2;\n\n    // curve dao\n    address public gauge;\n    address public curve;\n    address public mintr = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\n\n    // tokens we're farming\n    address public constant crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;\n    address public constant snx = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n\n    // stablecoins\n    address public dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address public usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address public susd = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\n\n    // How much CRV tokens to keep\n    uint256 public keepCRV = 500;\n    uint256 public keepCRVMax = 10000;\n\n    // crv-locker and voter\n    address public scrvVoter;\n    address public crvLocker;\n\n    constructor(\n        address _scrvVoter,\n        address _crvLocker,\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    )\n        public\n        StrategyBase(scrv, _governance, _strategist, _controller, _timelock)\n    {\n        curve = susdv2_pool;\n        gauge = susdv2_gauge;\n\n        scrvVoter = _scrvVoter;\n        crvLocker = _crvLocker;\n    }\n\n    // **** Getters ****\n\n    function balanceOfPool() public override view returns (uint256) {\n        return SCRVVoter(scrvVoter).balanceOf(gauge);\n    }\n\n    function getName() external override pure returns (string memory) {\n        return \"StrategyCurveSCRVv4_1\";\n    }\n\n    function getHarvestable() external returns (uint256) {\n        return ICurveGauge(gauge).claimable_tokens(crvLocker);\n    }\n\n    function getMostPremium() public view returns (address, uint8) {\n        uint256[] memory balances = new uint256[](4);\n        balances[0] = ICurveFi_4(curve).balances(0); // DAI\n        balances[1] = ICurveFi_4(curve).balances(1).mul(10**12); // USDC\n        balances[2] = ICurveFi_4(curve).balances(2).mul(10**12); // USDT\n        balances[3] = ICurveFi_4(curve).balances(3); // sUSD\n\n        // DAI\n        if (\n            balances[0] < balances[1] &&\n            balances[0] < balances[2] &&\n            balances[0] < balances[3]\n        ) {\n            return (dai, 0);\n        }\n\n        // USDC\n        if (\n            balances[1] < balances[0] &&\n            balances[1] < balances[2] &&\n            balances[1] < balances[3]\n        ) {\n            return (usdc, 1);\n        }\n\n        // USDT\n        if (\n            balances[2] < balances[0] &&\n            balances[2] < balances[1] &&\n            balances[2] < balances[3]\n        ) {\n            return (usdt, 2);\n        }\n\n        // SUSD\n        if (\n            balances[3] < balances[0] &&\n            balances[3] < balances[1] &&\n            balances[3] < balances[2]\n        ) {\n            return (susd, 3);\n        }\n\n        // If they're somehow equal, we just want DAI\n        return (dai, 0);\n    }\n\n    // **** Setters ****\n\n    function setKeepCRV(uint256 _keepCRV) external {\n        require(msg.sender == governance, \"!governance\");\n        keepCRV = _keepCRV;\n    }\n\n    // **** State Mutations ****\n\n    function deposit() public override {\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            IERC20(want).safeTransfer(scrvVoter, _want);\n            SCRVVoter(scrvVoter).deposit(gauge, want);\n        }\n    }\n\n    function _withdrawSome(uint256 _amount)\n        internal\n        override\n        returns (uint256)\n    {\n        return SCRVVoter(scrvVoter).withdraw(gauge, want, _amount);\n    }\n\n    function harvest() public override onlyBenevolent {\n        // Anyone can harvest it at any given time.\n        // I understand the possibility of being frontrun / sandwiched\n        // But ETH is a dark forest, and I wanna see how this plays out\n        // i.e. will be be heavily frontrunned/sandwiched?\n        //      if so, a new strategy will be deployed.\n\n        // stablecoin we want to convert to\n        (address to, uint256 toIndex) = getMostPremium();\n\n        // Collects crv tokens\n        // Don't bother voting in v1\n        SCRVVoter(scrvVoter).harvest(gauge);\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\n        if (_crv > 0) {\n            // How much CRV to keep to restake?\n            uint256 _keepCRV = _crv.mul(keepCRV).div(keepCRVMax);\n            IERC20(crv).safeTransfer(address(crvLocker), _keepCRV);\n\n            // How much CRV to swap?\n            _crv = _crv.sub(_keepCRV);\n            _swapUniswap(crv, to, _crv);\n        }\n\n        // Collects SNX tokens\n        SCRVVoter(scrvVoter).claimRewards();\n        uint256 _snx = IERC20(snx).balanceOf(address(this));\n        if (_snx > 0) {\n            _swapUniswap(snx, to, _snx);\n        }\n\n        // Adds liquidity to curve.fi's susd pool\n        // to get back want (scrv)\n        uint256 _to = IERC20(to).balanceOf(address(this));\n        if (_to > 0) {\n            IERC20(to).safeApprove(curve, 0);\n            IERC20(to).safeApprove(curve, _to);\n            uint256[4] memory liquidity;\n            liquidity[toIndex] = _to;\n            ICurveFi_4(curve).add_liquidity(liquidity, 0);\n        }\n\n        // We want to get back sCRV\n        _distributePerformanceFeesAndDeposit();\n    }\n}"
    },
    {
      "filename": "src/strategies/strategy-base.sol",
      "content": "pragma solidity ^0.6.7;\n\nimport \"../lib/erc20.sol\";\nimport \"../lib/safe-math.sol\";\n\nimport \"../interfaces/jar.sol\";\nimport \"../interfaces/staking-rewards.sol\";\nimport \"../interfaces/uniswapv2.sol\";\nimport \"../interfaces/controller.sol\";\n\n// Strategy Contract Basics\n\nabstract contract StrategyBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    // Perfomance fee 4.5%\n    uint256 public performanceFee = 450;\n    uint256 public constant performanceMax = 10000;\n\n    // Withdrawal fee 0.5%\n    // - 0.375% to treasury\n    // - 0.125% to dev fund\n    uint256 public treasuryFee = 375;\n    uint256 public constant treasuryMax = 100000;\n\n    uint256 public devFundFee = 125;\n    uint256 public constant devFundMax = 100000;\n\n    // Tokens\n    address public want;\n    address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // User accounts\n    address public governance;\n    address public controller;\n    address public strategist;\n    address public timelock;\n\n    // Dex\n    address public univ2Router2 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    constructor(\n        address _want,\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    ) public {\n        want = _want;\n        governance = _governance;\n        strategist = _strategist;\n        controller = _controller;\n        timelock = _timelock;\n    }\n\n    // **** Modifiers **** //\n\n    modifier onlyBenevolent {\n        require(\n            msg.sender == tx.origin ||\n                msg.sender == governance ||\n                msg.sender == strategist\n        );\n        _;\n    }\n\n    // **** Views **** //\n\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    function balanceOfPool() public virtual view returns (uint256);\n\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    function getName() external virtual pure returns (string memory);\n\n    // **** Setters **** //\n\n    function setDevFundFee(uint256 _devFundFee) external {\n        require(msg.sender == timelock, \"!timelock\");\n        devFundFee = _devFundFee;\n    }\n\n    function setTreasuryFee(uint256 _treasuryFee) external {\n        require(msg.sender == timelock, \"!timelock\");\n        treasuryFee = _treasuryFee;\n    }\n\n    function setPerformanceFee(uint256 _performanceFee) external {\n        require(msg.sender == timelock, \"!timelock\");\n        performanceFee = _performanceFee;\n    }\n\n    function setStrategist(address _strategist) external {\n        require(msg.sender == governance, \"!governance\");\n        strategist = _strategist;\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function setTimelock(address _timelock) external {\n        require(msg.sender == timelock, \"!timelock\");\n        timelock = _timelock;\n    }\n\n    function setController(address _controller) external {\n        require(msg.sender == timelock, \"!timelock\");\n        controller = _controller;\n    }\n\n    // **** State mutations **** //\n    function deposit() public virtual;\n\n    // Controller only function for creating additional rewards from dust\n    function withdraw(IERC20 _asset) external returns (uint256 balance) {\n        require(msg.sender == controller, \"!controller\");\n        require(want != address(_asset), \"want\");\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(controller, balance);\n    }\n\n    // Withdraw partial funds, normally used with a jar withdrawal\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == controller, \"!controller\");\n        uint256 _balance = IERC20(want).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n\n        uint256 _feeDev = _amount.mul(devFundFee).div(devFundMax);\n        IERC20(want).safeTransfer(IController(controller).devfund(), _feeDev);\n\n        uint256 _feeTreasury = _amount.mul(treasuryFee).div(treasuryMax);\n        IERC20(want).safeTransfer(\n            IController(controller).treasury(),\n            _feeTreasury\n        );\n\n        address _jar = IController(controller).jars(address(want));\n        require(_jar != address(0), \"!jar\"); // additional protection so we don't burn the funds\n\n        IERC20(want).safeTransfer(_jar, _amount.sub(_feeDev).sub(_feeTreasury));\n    }\n\n    // Withdraw all funds, normally used when migrating strategies\n    function withdrawAll() external returns (uint256 balance) {\n        require(msg.sender == controller, \"!controller\");\n        _withdrawAll();\n\n        balance = IERC20(want).balanceOf(address(this));\n\n        address _jar = IController(controller).jars(address(want));\n        require(_jar != address(0), \"!jar\"); // additional protection so we don't burn the funds\n        IERC20(want).safeTransfer(_jar, balance);\n    }\n\n    function _withdrawAll() internal {\n        _withdrawSome(balanceOfPool());\n    }\n\n    function _withdrawSome(uint256 _amount) internal virtual returns (uint256);\n\n    function harvest() public virtual;\n\n    // **** Emergency functions ****\n\n    function execute(address _target, bytes memory _data)\n        public\n        payable\n        returns (bytes memory response)\n    {\n        require(msg.sender == timelock, \"!timelock\");\n        require(_target != address(0), \"!target\");\n\n        // call contract in current context\n        assembly {\n            let succeeded := delegatecall(\n                sub(gas(), 5000),\n                _target,\n                add(_data, 0x20),\n                mload(_data),\n                0,\n                0\n            )\n            let size := returndatasize()\n\n            response := mload(0x40)\n            mstore(\n                0x40,\n                add(response, and(add(add(size, 0x20), 0x1f), not(0x1f)))\n            )\n            mstore(response, size)\n            returndatacopy(add(response, 0x20), 0, size)\n\n            switch iszero(succeeded)\n                case 1 {\n                    // throw if delegatecall failed\n                    revert(add(response, 0x20), size)\n                }\n        }\n    }\n\n    // **** Internal functions ****\n    function _swapUniswap(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        // Swap with uniswap\n        IERC20(_from).safeApprove(univ2Router2, 0);\n        IERC20(_from).safeApprove(univ2Router2, _amount);\n\n        address[] memory path;\n\n        if (_from == weth || _to == weth) {\n            path = new address[](2);\n            path[0] = _from;\n            path[1] = _to;\n        } else {\n            path = new address[](3);\n            path[0] = _from;\n            path[1] = weth;\n            path[2] = _to;\n        }\n\n        UniswapRouterV2(univ2Router2).swapExactTokensForTokens(\n            _amount,\n            0,\n            path,\n            address(this),\n            now.add(60)\n        );\n    }\n}"
    }
  ]
}