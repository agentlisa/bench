{
  "Title": "M-2: Fixed Term Bond tokens can be minted with non-rounded expiry",
  "Content": "# Issue M-2: Fixed Term Bond tokens can be minted with non-rounded expiry \n\nSource: https://github.com/sherlock-audit/2022-11-bond-judging/issues/32 \n\n## Found by \nobront\n\n## Summary\n\nFixed Term Tellers intend to mint tokens that expire once per day, to consolidate liquidity and create a uniform experience. However, this rounding is not enforced on the external `deploy()` function, which allows for tokens expiring at unexpected times.\n\n## Vulnerability Detail\n\nIn `BondFixedTermTeller.sol`, new tokenIds are deployed through the `_handlePayout()` function. The function calculates the expiry (rounded down to the nearest day), uses this expiry to create a tokenId, and — if that tokenId doesn't yet exist — deploys it.\n\n```solidity\n...\nexpiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\n\n// Fixed-term user payout information is handled in BondTeller.\n// Teller mints ERC-1155 bond tokens for user.\nuint256 tokenId = getTokenId(payoutToken_, expiry);\n\n// Create new bond token if it doesn't exist yet\nif (!tokenMetadata[tokenId].active) {\n    _deploy(tokenId, payoutToken_, expiry);\n}\n...\n```\nThis successfully consolidates all liquidity into one daily tokenId, which expires (as expected) at the time included in the tokenId.\n\nHowever, if the `deploy()` function is called directly, no such rounding occurs:\n\n```solidity\nfunction deploy(ERC20 underlying_, uint48 expiry_)\n    external\n    override\n    nonReentrant\n    returns (uint256)\n{\n    uint256 tokenId = getTokenId(underlying_, expiry_);\n    // Only creates token if it does not exist\n    if (!tokenMetadata[tokenId].active) {\n        _deploy(tokenId, underlying_, expiry_);\n    }\n    return tokenId;\n}\n```\nThis creates a mismatch between the tokenId time and the real expiry time, as tokenId is calculated by rounding the expiry down to the nearest day:\n```solidity\nuint256 tokenId = uint256(\n    keccak256(abi.encodePacked(underlying_, expiry_ / uint48(1 days)))\n);\n```\n... while the `_deploy()` function saves the original expiry:\n```solidity\ntokenMetadata[tokenId_] = TokenMetadata(\n    true,\n    underlying_,\n    uint8(underlying_.decimals()),\n    expiry_,\n    0\n);\n```\n\n## Impact\n\nThe `deploy()` function causes a number of issues:\n1) Tokens can be deployed that don't expire at the expected daily time, which may cause issues with your front end or break user's expectations\n2) Tokens can expire at times that don't align with the time included in the tokenId\n3) Malicious users can pre-deploy tokens at future timestamps to \"take over\" the token for a given day and lock it at a later time stamp, which then \"locks in\" that expiry time and can't be changed by the protocol\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L175-L187\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L243-L250\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L194-L212\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInclude the same rounding process in `deploy()` as is included in `_handlePayout()`:\n\n```solidity\nfunction deploy(ERC20 underlying_, uint48 expiry_)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        expiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n        ...\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree. We implemented rounding of the expiry value provided to `deploy` to match the calculation in `_handlePayouts`.\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/54b6833a46b5ae4c3a3ca183b9a55ca8c1266827\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/20",
  "Code": [
    {
      "filename": "src/BondFixedTermTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {BondBaseTeller, IBondAggregator, Authority} from \"./bases/BondBaseTeller.sol\";\nimport {IBondFixedTermTeller} from \"./interfaces/IBondFixedTermTeller.sol\";\n\nimport {TransferHelper} from \"./lib/TransferHelper.sol\";\nimport {FullMath} from \"./lib/FullMath.sol\";\nimport {ERC1155} from \"./lib/ERC1155.sol\";\n\n/// @title Bond Fixed Term Teller\n/// @notice Bond Fixed Term Teller Contract\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Bond Fixed Term Teller is an implementation of the\n///      Bond Base Teller contract specific to handling user bond transactions\n///      and tokenizing bond markets where purchases vest in a fixed amount of time\n///      (rounded to the day) as ERC1155 tokens.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\ncontract BondFixedTermTeller is BondBaseTeller, IBondFixedTermTeller, ERC1155 {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== EVENTS ========== */\n    event ERC1155BondTokenCreated(uint256 tokenId, ERC20 indexed underlying, uint48 indexed expiry);\n\n    /* ========== STATE VARIABLES ========== */\n\n    mapping(uint256 => TokenMetadata) public tokenMetadata; // metadata for bond tokens\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        address protocol_,\n        IBondAggregator aggregator_,\n        address guardian_,\n        Authority authority_\n    ) BondBaseTeller(protocol_, aggregator_, guardian_, authority_) {}\n\n    /* ========== PURCHASE ========== */\n\n    /// @notice             Handle payout to recipient\n    /// @param recipient_   Address to receive payout\n    /// @param payout_      Amount of payoutToken to be paid\n    /// @param payoutToken_   Token to be paid out\n    /// @param vesting_     Amount of time to vest from current timestamp\n    /// @return expiry      Timestamp when the payout will vest\n    function _handlePayout(\n        address recipient_,\n        uint256 payout_,\n        ERC20 payoutToken_,\n        uint48 vesting_\n    ) internal override returns (uint48 expiry) {\n        // If there is no vesting time, the deposit is treated as an instant swap.\n        // otherwise, deposit info is stored and payout is available at a future timestamp.\n        // instant swap is denoted by expiry == 0.\n        //\n        // bonds mature with a cliff at a set timestamp\n        // prior to the expiry timestamp, no payout tokens are accessible to the user\n        // after the expiry timestamp, the entire payout can be redeemed\n        //\n        // fixed-term bonds mature in a set amount of time from deposit\n        // i.e. term = 1 week. when alice deposits on day 1, her bond\n        // expires on day 8. when bob deposits on day 2, his bond expires day 9.\n        if (vesting_ != 0) {\n            // Normalizing fixed term vesting timestamps to the same time each day\n            expiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\n\n            // Fixed-term user payout information is handled in BondTeller.\n            // Teller mints ERC-1155 bond tokens for user.\n            uint256 tokenId = getTokenId(payoutToken_, expiry);\n\n            // Create new bond token if it doesn't exist yet\n            if (!tokenMetadata[tokenId].active) {\n                _deploy(tokenId, payoutToken_, expiry);\n            }\n\n            // Mint bond token to recipient\n            _mintToken(recipient_, tokenId, payout_);\n        } else {\n            // If no expiry, then transfer payout directly to user\n            payoutToken_.safeTransfer(recipient_, payout_);\n        }\n    }\n\n    /* ========== DEPOSIT/MINT ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function create(\n        ERC20 underlying_,\n        uint48 expiry_,\n        uint256 amount_\n    ) external override nonReentrant returns (uint256, uint256) {\n        // Revert if expiry is in the past\n        if (expiry_ < block.timestamp) revert Teller_InvalidParams();\n\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n\n        // Revert if no token exists, must call deploy first\n        if (!tokenMetadata[tokenId].active) revert Teller_TokenDoesNotExist(underlying_, expiry_);\n\n        // Transfer in underlying\n        // Check that amount received is not less than amount expected\n        // Handles edge cases like fee-on-transfer tokens (which are not supported)\n        uint256 oldBalance = underlying_.balanceOf(address(this));\n        underlying_.safeTransferFrom(msg.sender, address(this), amount_);\n        if (underlying_.balanceOf(address(this)) < oldBalance + amount_)\n            revert Teller_UnsupportedToken();\n\n        // If fee is greater than the create discount, then calculate the fee and store it\n        // Otherwise, fee is zero.\n        if (protocolFee > createFeeDiscount) {\n            // Calculate fee amount\n            uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n            rewards[_protocol][underlying_] += feeAmount;\n\n            // Mint new bond tokens\n            _mintToken(msg.sender, tokenId, amount_ - feeAmount);\n\n            return (tokenId, amount_ - feeAmount);\n        } else {\n            // Mint new bond tokens\n            _mintToken(msg.sender, tokenId, amount_);\n\n            return (tokenId, amount_);\n        }\n    }\n\n    /* ========== REDEEM ========== */\n\n    function _redeem(uint256 tokenId_, uint256 amount_) internal {\n        // Check that the tokenId is active\n        if (!tokenMetadata[tokenId_].active) revert Teller_InvalidParams();\n\n        // Cache token metadata\n        TokenMetadata memory meta = tokenMetadata[tokenId_];\n\n        // Check that the token has matured\n        if (block.timestamp < meta.expiry) revert Teller_TokenNotMatured(meta.expiry);\n\n        // Burn bond token and transfer underlying to sender\n        _burnToken(msg.sender, tokenId_, amount_);\n        meta.underlying.safeTransfer(msg.sender, amount_);\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function redeem(uint256 tokenId_, uint256 amount_) public override nonReentrant {\n        _redeem(tokenId_, amount_);\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function batchRedeem(uint256[] calldata tokenIds_, uint256[] calldata amounts_)\n        external\n        override\n        nonReentrant\n    {\n        uint256 len = tokenIds_.length;\n        if (len != amounts_.length) revert Teller_InvalidParams();\n        for (uint256 i; i < len; ++i) {\n            _redeem(tokenIds_[i], amounts_[i]);\n        }\n    }\n\n    /* ========== TOKENIZATION ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function deploy(ERC20 underlying_, uint48 expiry_)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n        // Only creates token if it does not exist\n        if (!tokenMetadata[tokenId].active) {\n            _deploy(tokenId, underlying_, expiry_);\n        }\n        return tokenId;\n    }\n\n    /// @notice             \"Deploy\" a new ERC1155 bond token and stores its ID\n    /// @dev                ERC1155 tokens used for fixed term bonds\n    /// @param tokenId_     Calculated ID of new bond token (from getTokenId)\n    /// @param underlying_  Underlying token to be paid out when the bond token vests\n    /// @param expiry_      Timestamp that the token will vest at\n    function _deploy(\n        uint256 tokenId_,\n        ERC20 underlying_,\n        uint48 expiry_\n    ) internal {\n        // Revert if expiry is in the past\n        if (uint256(expiry_) < block.timestamp) revert Teller_InvalidParams();\n\n        // Store token metadata\n        tokenMetadata[tokenId_] = TokenMetadata(\n            true,\n            underlying_,\n            uint8(underlying_.decimals()),\n            expiry_,\n            0\n        );\n\n        emit ERC1155BondTokenCreated(tokenId_, underlying_, expiry_);\n    }\n\n    /// @notice             Mint bond token and update supply\n    /// @param to_          Address to mint tokens to\n    /// @param tokenId_     ID of bond token to mint\n    /// @param amount_      Amount of bond tokens to mint\n    function _mintToken(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_\n    ) internal {\n        _mint(to_, tokenId_, amount_, bytes(\"\"));\n        tokenMetadata[tokenId_].supply += amount_;\n    }\n\n    /// @notice             Burn bond token and update supply\n    /// @param from_        Address to burn tokens from\n    /// @param tokenId_     ID of bond token to burn\n    /// @param amount_      Amount of bond token to burn\n    function _burnToken(\n        address from_,\n        uint256 tokenId_,\n        uint256 amount_\n    ) internal {\n        _burn(from_, tokenId_, amount_);\n        tokenMetadata[tokenId_].supply -= amount_;\n    }\n\n    /* ========== TOKEN NAMING ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function getTokenId(ERC20 underlying_, uint48 expiry_) public pure override returns (uint256) {\n        // Vesting is divided by 1 day (in seconds) since bond tokens are only unique\n        // to a day, not a specific timestamp.\n        uint256 tokenId = uint256(\n            keccak256(abi.encodePacked(underlying_, expiry_ / uint48(1 days)))\n        );\n        return tokenId;\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function getTokenNameAndSymbol(uint256 tokenId_)\n        external\n        view\n        override\n        returns (string memory, string memory)\n    {\n        TokenMetadata memory meta = tokenMetadata[tokenId_];\n        (string memory name, string memory symbol) = _getNameAndSymbol(\n            meta.underlying,\n            meta.expiry\n        );\n        return (name, symbol);\n    }\n}"
    },
    {
      "filename": "src/BondFixedTermTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {BondBaseTeller, IBondAggregator, Authority} from \"./bases/BondBaseTeller.sol\";\nimport {IBondFixedTermTeller} from \"./interfaces/IBondFixedTermTeller.sol\";\n\nimport {TransferHelper} from \"./lib/TransferHelper.sol\";\nimport {FullMath} from \"./lib/FullMath.sol\";\nimport {ERC1155} from \"./lib/ERC1155.sol\";\n\n/// @title Bond Fixed Term Teller\n/// @notice Bond Fixed Term Teller Contract\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Bond Fixed Term Teller is an implementation of the\n///      Bond Base Teller contract specific to handling user bond transactions\n///      and tokenizing bond markets where purchases vest in a fixed amount of time\n///      (rounded to the day) as ERC1155 tokens.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\ncontract BondFixedTermTeller is BondBaseTeller, IBondFixedTermTeller, ERC1155 {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== EVENTS ========== */\n    event ERC1155BondTokenCreated(uint256 tokenId, ERC20 indexed underlying, uint48 indexed expiry);\n\n    /* ========== STATE VARIABLES ========== */\n\n    mapping(uint256 => TokenMetadata) public tokenMetadata; // metadata for bond tokens\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        address protocol_,\n        IBondAggregator aggregator_,\n        address guardian_,\n        Authority authority_\n    ) BondBaseTeller(protocol_, aggregator_, guardian_, authority_) {}\n\n    /* ========== PURCHASE ========== */\n\n    /// @notice             Handle payout to recipient\n    /// @param recipient_   Address to receive payout\n    /// @param payout_      Amount of payoutToken to be paid\n    /// @param payoutToken_   Token to be paid out\n    /// @param vesting_     Amount of time to vest from current timestamp\n    /// @return expiry      Timestamp when the payout will vest\n    function _handlePayout(\n        address recipient_,\n        uint256 payout_,\n        ERC20 payoutToken_,\n        uint48 vesting_\n    ) internal override returns (uint48 expiry) {\n        // If there is no vesting time, the deposit is treated as an instant swap.\n        // otherwise, deposit info is stored and payout is available at a future timestamp.\n        // instant swap is denoted by expiry == 0.\n        //\n        // bonds mature with a cliff at a set timestamp\n        // prior to the expiry timestamp, no payout tokens are accessible to the user\n        // after the expiry timestamp, the entire payout can be redeemed\n        //\n        // fixed-term bonds mature in a set amount of time from deposit\n        // i.e. term = 1 week. when alice deposits on day 1, her bond\n        // expires on day 8. when bob deposits on day 2, his bond expires day 9.\n        if (vesting_ != 0) {\n            // Normalizing fixed term vesting timestamps to the same time each day\n            expiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\n\n            // Fixed-term user payout information is handled in BondTeller.\n            // Teller mints ERC-1155 bond tokens for user.\n            uint256 tokenId = getTokenId(payoutToken_, expiry);\n\n            // Create new bond token if it doesn't exist yet\n            if (!tokenMetadata[tokenId].active) {\n                _deploy(tokenId, payoutToken_, expiry);\n            }\n\n            // Mint bond token to recipient\n            _mintToken(recipient_, tokenId, payout_);\n        } else {\n            // If no expiry, then transfer payout directly to user\n            payoutToken_.safeTransfer(recipient_, payout_);\n        }\n    }\n\n    /* ========== DEPOSIT/MINT ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function create(\n        ERC20 underlying_,\n        uint48 expiry_,\n        uint256 amount_\n    ) external override nonReentrant returns (uint256, uint256) {\n        // Revert if expiry is in the past\n        if (expiry_ < block.timestamp) revert Teller_InvalidParams();\n\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n\n        // Revert if no token exists, must call deploy first\n        if (!tokenMetadata[tokenId].active) revert Teller_TokenDoesNotExist(underlying_, expiry_);\n\n        // Transfer in underlying\n        // Check that amount received is not less than amount expected\n        // Handles edge cases like fee-on-transfer tokens (which are not supported)\n        uint256 oldBalance = underlying_.balanceOf(address(this));\n        underlying_.safeTransferFrom(msg.sender, address(this), amount_);\n        if (underlying_.balanceOf(address(this)) < oldBalance + amount_)\n            revert Teller_UnsupportedToken();\n\n        // If fee is greater than the create discount, then calculate the fee and store it\n        // Otherwise, fee is zero.\n        if (protocolFee > createFeeDiscount) {\n            // Calculate fee amount\n            uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n            rewards[_protocol][underlying_] += feeAmount;\n\n            // Mint new bond tokens\n            _mintToken(msg.sender, tokenId, amount_ - feeAmount);\n\n            return (tokenId, amount_ - feeAmount);\n        } else {\n            // Mint new bond tokens\n            _mintToken(msg.sender, tokenId, amount_);\n\n            return (tokenId, amount_);\n        }\n    }\n\n    /* ========== REDEEM ========== */\n\n    function _redeem(uint256 tokenId_, uint256 amount_) internal {\n        // Check that the tokenId is active\n        if (!tokenMetadata[tokenId_].active) revert Teller_InvalidParams();\n\n        // Cache token metadata\n        TokenMetadata memory meta = tokenMetadata[tokenId_];\n\n        // Check that the token has matured\n        if (block.timestamp < meta.expiry) revert Teller_TokenNotMatured(meta.expiry);\n\n        // Burn bond token and transfer underlying to sender\n        _burnToken(msg.sender, tokenId_, amount_);\n        meta.underlying.safeTransfer(msg.sender, amount_);\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function redeem(uint256 tokenId_, uint256 amount_) public override nonReentrant {\n        _redeem(tokenId_, amount_);\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function batchRedeem(uint256[] calldata tokenIds_, uint256[] calldata amounts_)\n        external\n        override\n        nonReentrant\n    {\n        uint256 len = tokenIds_.length;\n        if (len != amounts_.length) revert Teller_InvalidParams();\n        for (uint256 i; i < len; ++i) {\n            _redeem(tokenIds_[i], amounts_[i]);\n        }\n    }\n\n    /* ========== TOKENIZATION ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function deploy(ERC20 underlying_, uint48 expiry_)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n        // Only creates token if it does not exist\n        if (!tokenMetadata[tokenId].active) {\n            _deploy(tokenId, underlying_, expiry_);\n        }\n        return tokenId;\n    }\n\n    /// @notice             \"Deploy\" a new ERC1155 bond token and stores its ID\n    /// @dev                ERC1155 tokens used for fixed term bonds\n    /// @param tokenId_     Calculated ID of new bond token (from getTokenId)\n    /// @param underlying_  Underlying token to be paid out when the bond token vests\n    /// @param expiry_      Timestamp that the token will vest at\n    function _deploy(\n        uint256 tokenId_,\n        ERC20 underlying_,\n        uint48 expiry_\n    ) internal {\n        // Revert if expiry is in the past\n        if (uint256(expiry_) < block.timestamp) revert Teller_InvalidParams();\n\n        // Store token metadata\n        tokenMetadata[tokenId_] = TokenMetadata(\n            true,\n            underlying_,\n            uint8(underlying_.decimals()),\n            expiry_,\n            0\n        );\n\n        emit ERC1155BondTokenCreated(tokenId_, underlying_, expiry_);\n    }\n\n    /// @notice             Mint bond token and update supply\n    /// @param to_          Address to mint tokens to\n    /// @param tokenId_     ID of bond token to mint\n    /// @param amount_      Amount of bond tokens to mint\n    function _mintToken(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_\n    ) internal {\n        _mint(to_, tokenId_, amount_, bytes(\"\"));\n        tokenMetadata[tokenId_].supply += amount_;\n    }\n\n    /// @notice             Burn bond token and update supply\n    /// @param from_        Address to burn tokens from\n    /// @param tokenId_     ID of bond token to burn\n    /// @param amount_      Amount of bond token to burn\n    function _burnToken(\n        address from_,\n        uint256 tokenId_,\n        uint256 amount_\n    ) internal {\n        _burn(from_, tokenId_, amount_);\n        tokenMetadata[tokenId_].supply -= amount_;\n    }\n\n    /* ========== TOKEN NAMING ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function getTokenId(ERC20 underlying_, uint48 expiry_) public pure override returns (uint256) {\n        // Vesting is divided by 1 day (in seconds) since bond tokens are only unique\n        // to a day, not a specific timestamp.\n        uint256 tokenId = uint256(\n            keccak256(abi.encodePacked(underlying_, expiry_ / uint48(1 days)))\n        );\n        return tokenId;\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function getTokenNameAndSymbol(uint256 tokenId_)\n        external\n        view\n        override\n        returns (string memory, string memory)\n    {\n        TokenMetadata memory meta = tokenMetadata[tokenId_];\n        (string memory name, string memory symbol) = _getNameAndSymbol(\n            meta.underlying,\n            meta.expiry\n        );\n        return (name, symbol);\n    }\n}"
    },
    {
      "filename": "src/BondFixedTermTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {BondBaseTeller, IBondAggregator, Authority} from \"./bases/BondBaseTeller.sol\";\nimport {IBondFixedTermTeller} from \"./interfaces/IBondFixedTermTeller.sol\";\n\nimport {TransferHelper} from \"./lib/TransferHelper.sol\";\nimport {FullMath} from \"./lib/FullMath.sol\";\nimport {ERC1155} from \"./lib/ERC1155.sol\";\n\n/// @title Bond Fixed Term Teller\n/// @notice Bond Fixed Term Teller Contract\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Bond Fixed Term Teller is an implementation of the\n///      Bond Base Teller contract specific to handling user bond transactions\n///      and tokenizing bond markets where purchases vest in a fixed amount of time\n///      (rounded to the day) as ERC1155 tokens.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\ncontract BondFixedTermTeller is BondBaseTeller, IBondFixedTermTeller, ERC1155 {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== EVENTS ========== */\n    event ERC1155BondTokenCreated(uint256 tokenId, ERC20 indexed underlying, uint48 indexed expiry);\n\n    /* ========== STATE VARIABLES ========== */\n\n    mapping(uint256 => TokenMetadata) public tokenMetadata; // metadata for bond tokens\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        address protocol_,\n        IBondAggregator aggregator_,\n        address guardian_,\n        Authority authority_\n    ) BondBaseTeller(protocol_, aggregator_, guardian_, authority_) {}\n\n    /* ========== PURCHASE ========== */\n\n    /// @notice             Handle payout to recipient\n    /// @param recipient_   Address to receive payout\n    /// @param payout_      Amount of payoutToken to be paid\n    /// @param payoutToken_   Token to be paid out\n    /// @param vesting_     Amount of time to vest from current timestamp\n    /// @return expiry      Timestamp when the payout will vest\n    function _handlePayout(\n        address recipient_,\n        uint256 payout_,\n        ERC20 payoutToken_,\n        uint48 vesting_\n    ) internal override returns (uint48 expiry) {\n        // If there is no vesting time, the deposit is treated as an instant swap.\n        // otherwise, deposit info is stored and payout is available at a future timestamp.\n        // instant swap is denoted by expiry == 0.\n        //\n        // bonds mature with a cliff at a set timestamp\n        // prior to the expiry timestamp, no payout tokens are accessible to the user\n        // after the expiry timestamp, the entire payout can be redeemed\n        //\n        // fixed-term bonds mature in a set amount of time from deposit\n        // i.e. term = 1 week. when alice deposits on day 1, her bond\n        // expires on day 8. when bob deposits on day 2, his bond expires day 9.\n        if (vesting_ != 0) {\n            // Normalizing fixed term vesting timestamps to the same time each day\n            expiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\n\n            // Fixed-term user payout information is handled in BondTeller.\n            // Teller mints ERC-1155 bond tokens for user.\n            uint256 tokenId = getTokenId(payoutToken_, expiry);\n\n            // Create new bond token if it doesn't exist yet\n            if (!tokenMetadata[tokenId].active) {\n                _deploy(tokenId, payoutToken_, expiry);\n            }\n\n            // Mint bond token to recipient\n            _mintToken(recipient_, tokenId, payout_);\n        } else {\n            // If no expiry, then transfer payout directly to user\n            payoutToken_.safeTransfer(recipient_, payout_);\n        }\n    }\n\n    /* ========== DEPOSIT/MINT ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function create(\n        ERC20 underlying_,\n        uint48 expiry_,\n        uint256 amount_\n    ) external override nonReentrant returns (uint256, uint256) {\n        // Revert if expiry is in the past\n        if (expiry_ < block.timestamp) revert Teller_InvalidParams();\n\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n\n        // Revert if no token exists, must call deploy first\n        if (!tokenMetadata[tokenId].active) revert Teller_TokenDoesNotExist(underlying_, expiry_);\n\n        // Transfer in underlying\n        // Check that amount received is not less than amount expected\n        // Handles edge cases like fee-on-transfer tokens (which are not supported)\n        uint256 oldBalance = underlying_.balanceOf(address(this));\n        underlying_.safeTransferFrom(msg.sender, address(this), amount_);\n        if (underlying_.balanceOf(address(this)) < oldBalance + amount_)\n            revert Teller_UnsupportedToken();\n\n        // If fee is greater than the create discount, then calculate the fee and store it\n        // Otherwise, fee is zero.\n        if (protocolFee > createFeeDiscount) {\n            // Calculate fee amount\n            uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n            rewards[_protocol][underlying_] += feeAmount;\n\n            // Mint new bond tokens\n            _mintToken(msg.sender, tokenId, amount_ - feeAmount);\n\n            return (tokenId, amount_ - feeAmount);\n        } else {\n            // Mint new bond tokens\n            _mintToken(msg.sender, tokenId, amount_);\n\n            return (tokenId, amount_);\n        }\n    }\n\n    /* ========== REDEEM ========== */\n\n    function _redeem(uint256 tokenId_, uint256 amount_) internal {\n        // Check that the tokenId is active\n        if (!tokenMetadata[tokenId_].active) revert Teller_InvalidParams();\n\n        // Cache token metadata\n        TokenMetadata memory meta = tokenMetadata[tokenId_];\n\n        // Check that the token has matured\n        if (block.timestamp < meta.expiry) revert Teller_TokenNotMatured(meta.expiry);\n\n        // Burn bond token and transfer underlying to sender\n        _burnToken(msg.sender, tokenId_, amount_);\n        meta.underlying.safeTransfer(msg.sender, amount_);\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function redeem(uint256 tokenId_, uint256 amount_) public override nonReentrant {\n        _redeem(tokenId_, amount_);\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function batchRedeem(uint256[] calldata tokenIds_, uint256[] calldata amounts_)\n        external\n        override\n        nonReentrant\n    {\n        uint256 len = tokenIds_.length;\n        if (len != amounts_.length) revert Teller_InvalidParams();\n        for (uint256 i; i < len; ++i) {\n            _redeem(tokenIds_[i], amounts_[i]);\n        }\n    }\n\n    /* ========== TOKENIZATION ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function deploy(ERC20 underlying_, uint48 expiry_)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n        // Only creates token if it does not exist\n        if (!tokenMetadata[tokenId].active) {\n            _deploy(tokenId, underlying_, expiry_);\n        }\n        return tokenId;\n    }\n\n    /// @notice             \"Deploy\" a new ERC1155 bond token and stores its ID\n    /// @dev                ERC1155 tokens used for fixed term bonds\n    /// @param tokenId_     Calculated ID of new bond token (from getTokenId)\n    /// @param underlying_  Underlying token to be paid out when the bond token vests\n    /// @param expiry_      Timestamp that the token will vest at\n    function _deploy(\n        uint256 tokenId_,\n        ERC20 underlying_,\n        uint48 expiry_\n    ) internal {\n        // Revert if expiry is in the past\n        if (uint256(expiry_) < block.timestamp) revert Teller_InvalidParams();\n\n        // Store token metadata\n        tokenMetadata[tokenId_] = TokenMetadata(\n            true,\n            underlying_,\n            uint8(underlying_.decimals()),\n            expiry_,\n            0\n        );\n\n        emit ERC1155BondTokenCreated(tokenId_, underlying_, expiry_);\n    }\n\n    /// @notice             Mint bond token and update supply\n    /// @param to_          Address to mint tokens to\n    /// @param tokenId_     ID of bond token to mint\n    /// @param amount_      Amount of bond tokens to mint\n    function _mintToken(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_\n    ) internal {\n        _mint(to_, tokenId_, amount_, bytes(\"\"));\n        tokenMetadata[tokenId_].supply += amount_;\n    }\n\n    /// @notice             Burn bond token and update supply\n    /// @param from_        Address to burn tokens from\n    /// @param tokenId_     ID of bond token to burn\n    /// @param amount_      Amount of bond token to burn\n    function _burnToken(\n        address from_,\n        uint256 tokenId_,\n        uint256 amount_\n    ) internal {\n        _burn(from_, tokenId_, amount_);\n        tokenMetadata[tokenId_].supply -= amount_;\n    }\n\n    /* ========== TOKEN NAMING ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function getTokenId(ERC20 underlying_, uint48 expiry_) public pure override returns (uint256) {\n        // Vesting is divided by 1 day (in seconds) since bond tokens are only unique\n        // to a day, not a specific timestamp.\n        uint256 tokenId = uint256(\n            keccak256(abi.encodePacked(underlying_, expiry_ / uint48(1 days)))\n        );\n        return tokenId;\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function getTokenNameAndSymbol(uint256 tokenId_)\n        external\n        view\n        override\n        returns (string memory, string memory)\n    {\n        TokenMetadata memory meta = tokenMetadata[tokenId_];\n        (string memory name, string memory symbol) = _getNameAndSymbol(\n            meta.underlying,\n            meta.expiry\n        );\n        return (name, symbol);\n    }\n}"
    }
  ]
}