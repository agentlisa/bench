{
  "Title": "[H-05]  `_getReferencePoolPriceX96()` will show incorrect price for negative tick deltas in current implementation cause it doesn't round up for them",
  "Content": "\nTake a look [here](https://github.com/code-423n4/2024-03-revert-lend/blob/457230945a49878eefdc1001796b10638c1e7584/src/V3Oracle.sol#L357-L374).\n\n```solidity\n    function _getReferencePoolPriceX96(IUniswapV3Pool pool, uint32 twapSeconds) internal view returns (uint256) {\n        uint160 sqrtPriceX96;\n        // if twap seconds set to 0 just use pool price\n        if (twapSeconds == 0) {\n            (sqrtPriceX96,,,,,,) = pool.slot0();\n        } else {\n            uint32[] memory secondsAgos = new uint32[](2);\n            secondsAgos[0] = 0; // from (before)\n            secondsAgos[1] = twapSeconds; // from (before)\n            (int56[] memory tickCumulatives,) = pool.observe(secondsAgos); // pool observe may fail when there is not enough history available (only use pool with enough history!)\n            //@audit\n            int24 tick = int24((tickCumulatives[0] - tickCumulatives[1]) / int56(uint56(twapSeconds)));\n            sqrtPriceX96 = TickMath.getSqrtRatioAtTick(tick);\n        }\n\n        return FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, Q96);\n    }\n```\n\nThis function is used to calculate the reference pool price. It uses either the latest slot price or TWAP based on twapSeconds.\n\nNow note that [unlike the original uniswap implementation](https://github.com/Uniswap/v3-periphery/blob/697c2474757ea89fec12a4e6db16a574fe259610/contracts/libraries/OracleLibrary.sol#L30), here the delta of the tick cumulative is being calculated in a different manner, i.e [protocol implements (`tickCumulatives`[0] - `tickCumulatives`[1]](https://github.com/code-423n4/2024-03-revert-lend/blob/457230945a49878eefdc1001796b10638c1e7584/src/V3Oracle.sol#L369) instead of `tickCumulatives[1] - (tickCumulatives[0]` which is because here, `secondsAgos[0] = 0;` and  `secondsAgos[1] = twapSeconds;`; unlike [in Uniswap OracleLibrary](https://github.com/Uniswap/v3-periphery/blob/697c2474757ea89fec12a4e6db16a574fe259610/contracts/libraries/OracleLibrary.sol#L23C1-L26C1) where `secondsAgos[0] = secondsAgo;` and `secondsAgos[1] = 0;`, so everything checks out and the tick deltas are calculated accurately, i.e in our case `tickCumulativesDelta = tickCumulatives[0] - tickCumulatives[1]`.\n\nThe problem now is that in the case if our `tickCumulativesDelta` is negative, i.e `int24(tickCumulatives[0] - tickCumulatives[1] < 0)` , then the tick should be rounded down, as it's done in the[ uniswap library](https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol#L36).\n\nBut this is not being done and as a result, in the case if `int24(tickCumulatives[0] - tickCumulatives[1])` is negative and `(tickCumulatives[0] - tickCumulatives[1]) % secondsAgo != 0`, then the returned tick will be bigger then it should be; which opens possibility for some price manipulations and arbitrage opportunities.\n\n### Impact\n\n1. In this case, if `int24(tickCumulatives[0] - tickCumulatives[1])` is negative and `((tickCumulatives[0] - tickCumulatives[1]) % secondsAgo != 0`, then returned tick will be bigger than it should be which places protocol wanting prices to be right not be able to achieve this goal. Note that whereas protocol in some cases relies on multiple sources of price, they still come down and end on weighing the differences between the prices and reverting if a certain limit is passed (`MIN_PRICE_DIFFERENCE`) between both the Chainlink price and Uniswap twap price.\n\n2. Now in the case where the implemented [pricing mode is only `TWAP`](https://github.com/code-423n4/2024-03-revert-lend/blob/457230945a49878eefdc1001796b10638c1e7584/src/V3Oracle.sol#L40), then the protocol would work with a flawed price since the returned price would be different than it really is; potentially leading to say, for example, some positions that should be liquidatable not being liquidated. Before liquidation, there is [a check to see if the loan is healthy](https://github.com/code-423n4/2024-03-revert-lend/blob/457230945a49878eefdc1001796b10638c1e7584/src/V3Vault.sol#L702-L703). Now this check [queries the value of this asset via getValue() ](https://github.com/code-423n4/2024-03-revert-lend/blob/457230945a49878eefdc1001796b10638c1e7584/src/V3Vault.sol#L1275) and if returned price is wrong then unhealthy loans could be pronounced as healthy and vice versa.\n\n3. Also, this indirectly curbs the access to functions like `borrow()`, `transform()` and `decreaseLiquidityAndCollect()`, since they all make a call to [`_requireLoanIsHealthy()`](https://github.com/code-423n4/2024-03-revert-lend/blob/457230945a49878eefdc1001796b10638c1e7584/src/V3Vault.sol#L1199-L1205), which would be unavailable due to it's dependence on [`_checkLoanIsHealthy()`](https://github.com/code-423n4/2024-03-revert-lend/blob/457230945a49878eefdc1001796b10638c1e7584/src/V3Vault.sol#L702-L703).\n\n4. This bug case causes the Automator's [`_getTWAPTick()` function to also return a wrong tick, which then leads to `_hasMaxTWAPTickDifference()` returning false data ](https://github.com/code-423n4/2024-03-revert-lend/blob/457230945a49878eefdc1001796b10638c1e7584/src/automators/Automator.sol#L168-L197), since the difference would now be bigger eventually leading to *wrongly* [disabling/enabling of swaps in `AutoCompound.sol`](https://github.com/code-423n4/2024-03-revert-lend/blob/457230945a49878eefdc1001796b10638c1e7584/src/transformers/AutoCompound.sol#L130-L139), whereas, it should be otherwise.\n\nNote that for the second/third case, the call route to get to `_getReferencePoolPriceX96()` is: `\"_checkLoanIsHealthy() -> getValue() -> _getReferenceTokenPriceX96 ->  _getTWAPPriceX96 -> _getReferencePoolPriceX96() \"` as can be seen [here](https://github.com/code-423n4/2024-03-revert-lend/blob/457230945a49878eefdc1001796b10638c1e7584/src/V3Oracle.sol).\n\n### Tools Used\n\n- [Uniswap V3's OracleLibrary](https://github.com/Uniswap/v3-periphery/blob/697c2474757ea89fec12a4e6db16a574fe259610/contracts/libraries/OracleLibrary.sol).\n- And a similar finding on [Code4rena](https://github.com/code-423n4/2024-01-salty-findings/issues?q=is%3Aissue+is%3Aopen+\\_getUniswapTwapWei%28%29+will+show+incorrect+price+for+negative+ticks+cause+it+doesn%27t+round+up+for+negative+ticks.) from Q1 2024.\n\n### Recommended Mitigation Steps\n\nAdd this line: `if (tickCumulatives[0] - tickCumulatives[1] < 0 && (tickCumulatives[0] - tickCumulatives[1]) % secondsAgo != 0) timeWeightedTick --;`.\n\n### Assessed type\n\nUniswap\n\n**[kalinbas (Revert) confirmed](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/127#issuecomment-2020681837)**\n\n**[Revert mitigated](https://github.com/code-423n4/2024-04-revert-mitigation?tab=readme-ov-file#scope):**\n> PR [here](https://github.com/revert-finance/lend/pull/10) - fixed calculation.\n\n**Status:** Mitigation confirmed. Full details in reports from [thank_you](https://github.com/code-423n4/2024-04-revert-mitigation-findings/issues/80), [b0g0](https://github.com/code-423n4/2024-04-revert-mitigation-findings/issues/26) and [ktg](https://github.com/code-423n4/2024-04-revert-mitigation-findings/issues/10).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-03-revert-lend",
  "Code": [
    {
      "filename": "src/V3Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"v3-core/interfaces/IUniswapV3Factory.sol\";\nimport \"v3-core/interfaces/IUniswapV3Pool.sol\";\n\nimport \"v3-core/libraries/TickMath.sol\";\n\nimport \"v3-periphery/libraries/PoolAddress.sol\";\nimport \"v3-periphery/libraries/LiquidityAmounts.sol\";\n\nimport \"v3-periphery/interfaces/INonfungiblePositionManager.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../lib/AggregatorV3Interface.sol\";\n\nimport \"./interfaces/IV3Oracle.sol\";\nimport \"./interfaces/IErrors.sol\";\n\n/// @title V3Oracle to be used in V3Vault to calculate position values\n/// @notice It uses both chainlink and uniswap v3 TWAP and provides emergency fallback mode\ncontract V3Oracle is IV3Oracle, Ownable, IErrors {\n    uint16 public constant MIN_PRICE_DIFFERENCE = 200; //2%\n\n    uint256 private constant Q96 = 2 ** 96;\n    uint256 private constant Q128 = 2 ** 128;\n\n    event TokenConfigUpdated(address indexed token, TokenConfig config);\n    event OracleModeUpdated(address indexed token, Mode mode);\n    event SetMaxPoolPriceDifference(uint16 maxPoolPriceDifference);\n    event SetEmergencyAdmin(address emergencyAdmin);\n\n    enum Mode {\n        NOT_SET,\n        CHAINLINK_TWAP_VERIFY, // using chainlink for price and TWAP to verify\n        TWAP_CHAINLINK_VERIFY, // using TWAP for price and chainlink to verify\n        CHAINLINK, // using only chainlink directly\n        TWAP // using TWAP directly\n    }\n\n    struct TokenConfig {\n        AggregatorV3Interface feed; // chainlink feed\n        uint32 maxFeedAge;\n        uint8 feedDecimals;\n        uint8 tokenDecimals;\n        IUniswapV3Pool pool; // reference pool\n        bool isToken0;\n        uint32 twapSeconds;\n        Mode mode;\n        uint16 maxDifference; // max price difference x10000\n    }\n\n    // token => config mapping\n    mapping(address => TokenConfig) public feedConfigs;\n\n    address public immutable factory;\n    INonfungiblePositionManager public immutable nonfungiblePositionManager;\n\n    // common token which is used in TWAP pools\n    address public immutable referenceToken;\n    uint8 public immutable referenceTokenDecimals;\n\n    uint16 public maxPoolPriceDifference = MIN_PRICE_DIFFERENCE; // max price difference between oracle derived price and pool price x10000\n\n    // common token which is used in chainlink feeds as \"pair\" (address(0) if USD or another non-token reference)\n    address public immutable chainlinkReferenceToken;\n\n    // address which can call special emergency actions without timelock\n    address public emergencyAdmin;\n\n    // constructor: sets owner of contract\n    constructor(\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        address _referenceToken,\n        address _chainlinkReferenceToken\n    ) {\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        factory = _nonfungiblePositionManager.factory();\n        referenceToken = _referenceToken;\n        referenceTokenDecimals = IERC20Metadata(_referenceToken).decimals();\n        chainlinkReferenceToken = _chainlinkReferenceToken;\n    }\n\n    /// @notice Gets value and prices of a uniswap v3 lp position in specified token\n    /// @dev uses configured oracles and verfies price on second oracle - if fails - reverts\n    /// @dev all involved tokens must be configured in oracle - otherwise reverts\n    /// @param tokenId tokenId of position\n    /// @param token address of token in which value and prices should be given\n    /// @return value value of complete position at current prices\n    /// @return feeValue value of positions fees only at current prices\n    /// @return price0X96 price of token0\n    /// @return price1X96 price of token1\n    function getValue(uint256 tokenId, address token)\n        external\n        view\n        override\n        returns (uint256 value, uint256 feeValue, uint256 price0X96, uint256 price1X96)\n    {\n        (address token0, address token1, uint24 fee,, uint256 amount0, uint256 amount1, uint256 fees0, uint256 fees1) =\n            getPositionBreakdown(tokenId);\n\n        uint256 cachedChainlinkReferencePriceX96;\n\n        (price0X96, cachedChainlinkReferencePriceX96) =\n            _getReferenceTokenPriceX96(token0, cachedChainlinkReferencePriceX96);\n        (price1X96, cachedChainlinkReferencePriceX96) =\n            _getReferenceTokenPriceX96(token1, cachedChainlinkReferencePriceX96);\n\n        uint256 priceTokenX96;\n        if (token0 == token) {\n            priceTokenX96 = price0X96;\n        } else if (token1 == token) {\n            priceTokenX96 = price1X96;\n        } else {\n            (priceTokenX96,) = _getReferenceTokenPriceX96(token, cachedChainlinkReferencePriceX96);\n        }\n\n        value = (price0X96 * (amount0 + fees0) / Q96 + price1X96 * (amount1 + fees1) / Q96) * Q96 / priceTokenX96;\n        feeValue = (price0X96 * fees0 / Q96 + price1X96 * fees1 / Q96) * Q96 / priceTokenX96;\n        price0X96 = price0X96 * Q96 / priceTokenX96;\n        price1X96 = price1X96 * Q96 / priceTokenX96;\n\n        // checks derived pool price for price manipulation attacks\n        // this prevents manipulations of pool to get distorted proportions of collateral tokens - for borrowing\n        // when a pool is in this state, liquidations will be disabled - but arbitrageurs (or liquidator himself)\n        // will move price back to reasonable range and enable liquidation\n        uint256 derivedPoolPriceX96 = price0X96 * Q96 / price1X96;\n        _checkPoolPrice(token0, token1, fee, derivedPoolPriceX96);\n    }\n\n    function _checkPoolPrice(address token0, address token1, uint24 fee, uint256 derivedPoolPriceX96) internal view {\n        IUniswapV3Pool pool = _getPool(token0, token1, fee);\n        uint256 priceX96 = _getReferencePoolPriceX96(pool, 0);\n        _requireMaxDifference(priceX96, derivedPoolPriceX96, maxPoolPriceDifference);\n    }\n\n    function _requireMaxDifference(uint256 priceX96, uint256 verifyPriceX96, uint256 maxDifferenceX10000)\n        internal\n        pure\n    {\n        uint256 differenceX10000 = priceX96 > verifyPriceX96\n            ? (priceX96 - verifyPriceX96) * 10000 / priceX96\n            : (verifyPriceX96 - priceX96) * 10000 / verifyPriceX96;\n        // if too big difference - revert\n        if (differenceX10000 >= maxDifferenceX10000) {\n            revert PriceDifferenceExceeded();\n        }\n    }\n\n    /// @notice Gets breakdown of a uniswap v3 position (tokens and fee tier, liquidity, current liquidity amounts, uncollected fees)\n    /// @param tokenId tokenId of position\n    /// @return token0 token0 of position\n    /// @return token1 token1 of position\n    /// @return fee fee tier of position\n    /// @return liquidity liquidity of position\n    /// @return amount0 current amount token0\n    /// @return amount1 current amount token1\n    /// @return fees0 current token0 fees of position\n    /// @return fees1 current token1 fees of position\n    function getPositionBreakdown(uint256 tokenId)\n        public\n        view\n        override\n        returns (\n            address token0,\n            address token1,\n            uint24 fee,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1,\n            uint128 fees0,\n            uint128 fees1\n        )\n    {\n        PositionState memory state = _initializeState(tokenId);\n        (token0, token1, fee) = (state.token0, state.token1, state.fee);\n        (amount0, amount1, fees0, fees1) = _getAmounts(state);\n        liquidity = state.liquidity;\n    }\n\n    /// @notice Sets the max pool difference parameter (onlyOwner)\n    /// @param _maxPoolPriceDifference Set max allowable difference between pool price and derived oracle pool price\n    function setMaxPoolPriceDifference(uint16 _maxPoolPriceDifference) external onlyOwner {\n        if (_maxPoolPriceDifference < MIN_PRICE_DIFFERENCE) {\n            revert InvalidConfig();\n        }\n        maxPoolPriceDifference = _maxPoolPriceDifference;\n        emit SetMaxPoolPriceDifference(_maxPoolPriceDifference);\n    }\n\n    /// @notice Sets or updates the feed configuration for a token (onlyOwner)\n    /// @param token Token to configure\n    /// @param feed Chainlink feed to this token (matching chainlinkReferenceToken)\n    /// @param maxFeedAge Max allowable chainlink feed age\n    /// @param pool TWAP reference pool (matching referenceToken)\n    /// @param twapSeconds TWAP period to use\n    /// @param mode Mode how both oracle should be used\n    /// @param maxDifference Max allowable difference between both oracle prices\n    function setTokenConfig(\n        address token,\n        AggregatorV3Interface feed,\n        uint32 maxFeedAge,\n        IUniswapV3Pool pool,\n        uint32 twapSeconds,\n        Mode mode,\n        uint16 maxDifference\n    ) external onlyOwner {\n        // can not be unset\n        if (mode == Mode.NOT_SET) {\n            revert InvalidConfig();\n        }\n\n        uint8 feedDecimals = feed.decimals();\n        uint8 tokenDecimals = IERC20Metadata(token).decimals();\n\n        TokenConfig memory config;\n\n        if (token != referenceToken) {\n            if (maxDifference < MIN_PRICE_DIFFERENCE) {\n                revert InvalidConfig();\n            }\n\n            address token0 = pool.token0();\n            address token1 = pool.token1();\n            if (!(token0 == token && token1 == referenceToken || token0 == referenceToken && token1 == token)) {\n                revert InvalidPool();\n            }\n            bool isToken0 = token0 == token;\n            config = TokenConfig(\n                feed, maxFeedAge, feedDecimals, tokenDecimals, pool, isToken0, twapSeconds, mode, maxDifference\n            );\n        } else {\n            config = TokenConfig(\n                feed, maxFeedAge, feedDecimals, tokenDecimals, IUniswapV3Pool(address(0)), false, 0, Mode.CHAINLINK, 0\n            );\n        }\n\n        feedConfigs[token] = config;\n\n        emit TokenConfigUpdated(token, config);\n        emit OracleModeUpdated(token, mode);\n    }\n\n    /// @notice Updates the oracle mode for a given token  - this method can be called by owner OR emergencyAdmin\n    /// @param token Token to configure\n    /// @param mode Mode to set\n    function setOracleMode(address token, Mode mode) external {\n        if (msg.sender != emergencyAdmin && msg.sender != owner()) {\n            revert Unauthorized();\n        }\n\n        // can not be unset\n        if (mode == Mode.NOT_SET) {\n            revert InvalidConfig();\n        }\n\n        feedConfigs[token].mode = mode;\n        emit OracleModeUpdated(token, mode);\n    }\n\n    /// @notice Updates emergency admin address (onlyOwner)\n    /// @param admin Emergency admin address\n    function setEmergencyAdmin(address admin) external onlyOwner {\n        emergencyAdmin = admin;\n        emit SetEmergencyAdmin(admin);\n    }\n\n    // Returns the price for a token using the selected oracle mode given as reference token value\n    // The price is calculated using Chainlink, Uniswap v3 TWAP, or both based on the mode\n    function _getReferenceTokenPriceX96(address token, uint256 cachedChainlinkReferencePriceX96)\n        internal\n        view\n        returns (uint256 priceX96, uint256 chainlinkReferencePriceX96)\n    {\n        if (token == referenceToken) {\n            return (Q96, chainlinkReferencePriceX96);\n        }\n\n        TokenConfig memory feedConfig = feedConfigs[token];\n\n        if (feedConfig.mode == Mode.NOT_SET) {\n            revert NotConfigured();\n        }\n\n        uint256 verifyPriceX96;\n\n        bool usesChainlink = (\n            feedConfig.mode == Mode.CHAINLINK_TWAP_VERIFY || feedConfig.mode == Mode.TWAP_CHAINLINK_VERIFY\n                || feedConfig.mode == Mode.CHAINLINK\n        );\n        bool usesTWAP = (\n            feedConfig.mode == Mode.CHAINLINK_TWAP_VERIFY || feedConfig.mode == Mode.TWAP_CHAINLINK_VERIFY\n                || feedConfig.mode == Mode.TWAP\n        );\n\n        if (usesChainlink) {\n            uint256 chainlinkPriceX96 = _getChainlinkPriceX96(token);\n            chainlinkReferencePriceX96 = cachedChainlinkReferencePriceX96 == 0\n                ? _getChainlinkPriceX96(referenceToken)\n                : cachedChainlinkReferencePriceX96;\n\n            chainlinkPriceX96 = (10 ** referenceTokenDecimals) * chainlinkPriceX96 * Q96 / chainlinkReferencePriceX96\n                / (10 ** feedConfig.tokenDecimals);\n\n            if (feedConfig.mode == Mode.TWAP_CHAINLINK_VERIFY) {\n                verifyPriceX96 = chainlinkPriceX96;\n            } else {\n                priceX96 = chainlinkPriceX96;\n            }\n        }\n\n        if (usesTWAP) {\n            uint256 twapPriceX96 = _getTWAPPriceX96(feedConfig);\n            if (feedConfig.mode == Mode.CHAINLINK_TWAP_VERIFY) {\n                verifyPriceX96 = twapPriceX96;\n            } else {\n                priceX96 = twapPriceX96;\n            }\n        }\n\n        if (feedConfig.mode == Mode.CHAINLINK_TWAP_VERIFY || feedConfig.mode == Mode.TWAP_CHAINLINK_VERIFY) {\n            _requireMaxDifference(priceX96, verifyPriceX96, feedConfig.maxDifference);\n        }\n    }\n\n    // calculates chainlink price given feedConfig\n    function _getChainlinkPriceX96(address token) internal view returns (uint256) {\n        if (token == chainlinkReferenceToken) {\n            return Q96;\n        }\n\n        TokenConfig memory feedConfig = feedConfigs[token];\n\n        // if stale data - revert\n        (, int256 answer,, uint256 updatedAt,) = feedConfig.feed.latestRoundData();\n        if (updatedAt + feedConfig.maxFeedAge < block.timestamp || answer < 0) {\n            revert ChainlinkPriceError();\n        }\n\n        return uint256(answer) * Q96 / (10 ** feedConfig.feedDecimals);\n    }\n\n    // calculates TWAP price given feedConfig\n    function _getTWAPPriceX96(TokenConfig memory feedConfig) internal view returns (uint256 poolTWAPPriceX96) {\n        // get reference pool price\n        uint256 priceX96 = _getReferencePoolPriceX96(feedConfig.pool, feedConfig.twapSeconds);\n\n        if (feedConfig.isToken0) {\n            poolTWAPPriceX96 = priceX96;\n        } else {\n            poolTWAPPriceX96 = Q96 * Q96 / priceX96;\n        }\n    }\n\n    // Calculates the reference pool price with scaling factor of 2^96\n    // It uses either the latest slot price or TWAP based on twapSeconds\n    function _getReferencePoolPriceX96(IUniswapV3Pool pool, uint32 twapSeconds) internal view returns (uint256) {\n        uint160 sqrtPriceX96;\n        // if twap seconds set to 0 just use pool price\n        if (twapSeconds == 0) {\n            (sqrtPriceX96,,,,,,) = pool.slot0();\n        } else {\n            uint32[] memory secondsAgos = new uint32[](2);\n            secondsAgos[0] = 0; // from (before)\n            secondsAgos[1] = twapSeconds; // from (before)\n            (int56[] memory tickCumulatives,) = pool.observe(secondsAgos); // pool observe may fail when there is not enough history available (only use pool with enough history!)\n            int24 tick = int24((tickCumulatives[0] - tickCumulatives[1]) / int56(uint56(twapSeconds)));\n            sqrtPriceX96 = TickMath.getSqrtRatioAtTick(tick);\n        }\n\n        return FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, Q96);\n    }\n\n    struct PositionState {\n        uint256 tokenId;\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n        uint128 tokensOwed0;\n        uint128 tokensOwed1;\n        IUniswapV3Pool pool;\n        uint160 sqrtPriceX96;\n        int24 tick;\n        uint160 sqrtPriceX96Lower;\n        uint160 sqrtPriceX96Upper;\n    }\n\n    function _initializeState(uint256 tokenId) internal view returns (PositionState memory state) {\n        (\n            ,\n            ,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        ) = nonfungiblePositionManager.positions(tokenId);\n        state.tokenId = tokenId;\n        state.token0 = token0;\n        state.token1 = token1;\n        state.fee = fee;\n        state.tickLower = tickLower;\n        state.tickUpper = tickUpper;\n        state.liquidity = liquidity;\n        state.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;\n        state.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;\n        state.tokensOwed0 = tokensOwed0;\n        state.tokensOwed1 = tokensOwed1;\n        state.pool = _getPool(token0, token1, fee);\n        (state.sqrtPriceX96, state.tick,,,,,) = state.pool.slot0();\n    }\n\n    // calculate position amounts given current price/tick\n    function _getAmounts(PositionState memory state)\n        internal\n        view\n        returns (uint256 amount0, uint256 amount1, uint128 fees0, uint128 fees1)\n    {\n        if (state.liquidity > 0) {\n            state.sqrtPriceX96Lower = TickMath.getSqrtRatioAtTick(state.tickLower);\n            state.sqrtPriceX96Upper = TickMath.getSqrtRatioAtTick(state.tickUpper);\n            (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n                state.sqrtPriceX96, state.sqrtPriceX96Lower, state.sqrtPriceX96Upper, state.liquidity\n            );\n        }\n\n        (fees0, fees1) = _getUncollectedFees(state, state.tick);\n        fees0 += state.tokensOwed0;\n        fees1 += state.tokensOwed1;\n    }\n\n    // calculate uncollected fees\n    function _getUncollectedFees(PositionState memory position, int24 tick)\n        internal\n        view\n        returns (uint128 fees0, uint128 fees1)\n    {\n        (uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128) = _getFeeGrowthInside(\n            position.pool,\n            position.tickLower,\n            position.tickUpper,\n            tick,\n            position.pool.feeGrowthGlobal0X128(),\n            position.pool.feeGrowthGlobal1X128()\n        );\n\n        // allow overflow - this is as designed by uniswap - see PositionValue library (for solidity < 0.8)\n        uint256 feeGrowth0;\n        uint256 feeGrowth1;\n        unchecked {\n            feeGrowth0 = feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128;\n            feeGrowth1 = feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128;\n        }\n\n        fees0 = uint128(FullMath.mulDiv(feeGrowth0, position.liquidity, Q128));\n        fees1 = uint128(FullMath.mulDiv(feeGrowth1, position.liquidity, Q128));\n    }\n\n    // calculate fee growth for uncollected fees calculation\n    function _getFeeGrowthInside(\n        IUniswapV3Pool pool,\n        int24 tickLower,\n        int24 tickUpper,\n        int24 tickCurrent,\n        uint256 feeGrowthGlobal0X128,\n        uint256 feeGrowthGlobal1X128\n    ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {\n        (,, uint256 lowerFeeGrowthOutside0X128, uint256 lowerFeeGrowthOutside1X128,,,,) = pool.ticks(tickLower);\n        (,, uint256 upperFeeGrowthOutside0X128, uint256 upperFeeGrowthOutside1X128,,,,) = pool.ticks(tickUpper);\n\n        // allow overflow - this is as designed by uniswap - see PositionValue library (for solidity < 0.8)\n        unchecked {\n            if (tickCurrent < tickLower) {\n                feeGrowthInside0X128 = lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n                feeGrowthInside1X128 = lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n            } else if (tickCurrent < tickUpper) {\n                feeGrowthInside0X128 = feeGrowthGlobal0X128 - lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n                feeGrowthInside1X128 = feeGrowthGlobal1X128 - lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n            } else {\n                feeGrowthInside0X128 = upperFeeGrowthOutside0X128 - lowerFeeGrowthOutside0X128;\n                feeGrowthInside1X128 = upperFeeGrowthOutside1X128 - lowerFeeGrowthOutside1X128;\n            }\n        }\n    }\n\n    // helper method to get pool for token\n    function _getPool(address tokenA, address tokenB, uint24 fee) internal view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factory, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n}"
    },
    {
      "filename": "contracts/libraries/OracleLibrary.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.8.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n    /// @param pool Address of the pool that we want to observe\n    /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\n    /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\n    /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\n    function consult(address pool, uint32 secondsAgo)\n        internal\n        view\n        returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)\n    {\n        require(secondsAgo != 0, 'BP');\n\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = secondsAgo;\n        secondsAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) =\n            IUniswapV3Pool(pool).observe(secondsAgos);\n\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        uint160 secondsPerLiquidityCumulativesDelta =\n            secondsPerLiquidityCumulativeX128s[1] - secondsPerLiquidityCumulativeX128s[0];\n\n        arithmeticMeanTick = int24(tickCumulativesDelta / secondsAgo);\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % secondsAgo != 0)) arithmeticMeanTick--;\n\n        // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128\n        uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;\n        harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n\n    /// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool\n    function getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {\n        (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n        require(observationCardinality > 0, 'NI');\n\n        (uint32 observationTimestamp, , , bool initialized) =\n            IUniswapV3Pool(pool).observations((observationIndex + 1) % observationCardinality);\n\n        // The next index might not be initialized if the cardinality is in the process of increasing\n        // In this case the oldest observation is always in index 0\n        if (!initialized) {\n            (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);\n        }\n\n        secondsAgo = uint32(block.timestamp) - observationTimestamp;\n    }\n\n    /// @notice Given a pool, it returns the tick value as of the start of the current block\n    /// @param pool Address of Uniswap V3 pool\n    /// @return The tick that the pool was in at the start of the current block\n    function getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {\n        (, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n\n        // 2 observations are needed to reliably calculate the block starting tick\n        require(observationCardinality > 1, 'NEO');\n\n        // If the latest observation occurred in the past, then no tick-changing trades have happened in this block\n        // therefore the tick in `slot0` is the same as at the beginning of the current block.\n        // We don't need to check if this observation is initialized - it is guaranteed to be.\n        (uint32 observationTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, ) =\n            IUniswapV3Pool(pool).observations(observationIndex);\n        if (observationTimestamp != uint32(block.timestamp)) {\n            return (tick, IUniswapV3Pool(pool).liquidity());\n        }\n\n        uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;\n        (\n            uint32 prevObservationTimestamp,\n            int56 prevTickCumulative,\n            uint160 prevSecondsPerLiquidityCumulativeX128,\n            bool prevInitialized\n        ) = IUniswapV3Pool(pool).observations(prevIndex);\n\n        require(prevInitialized, 'ONI');\n\n        uint32 delta = observationTimestamp - prevObservationTimestamp;\n        tick = int24((tickCumulative - prevTickCumulative) / delta);\n        uint128 liquidity =\n            uint128(\n                (uint192(delta) * type(uint160).max) /\n                    (uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) << 32)\n            );\n        return (tick, liquidity);\n    }\n\n    /// @notice Information for calculating a weighted arithmetic mean tick\n    struct WeightedTickData {\n        int24 tick;\n        uint128 weight;\n    }\n\n    /// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick\n    /// @param weightedTickData An array of ticks and weights\n    /// @return weightedArithmeticMeanTick The weighted arithmetic mean tick\n    /// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,\n    /// extreme care must be taken to ensure that ticks are comparable (including decimal differences).\n    /// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.\n    function getWeightedArithmeticMeanTick(WeightedTickData[] memory weightedTickData)\n        internal\n        pure\n        returns (int24 weightedArithmeticMeanTick)\n    {\n        // Accumulates the sum of products between each tick and its weight\n        int256 numerator;\n\n        // Accumulates the sum of the weights\n        uint256 denominator;\n\n        // Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic\n        for (uint256 i; i < weightedTickData.length; i++) {\n            numerator += weightedTickData[i].tick * int256(weightedTickData[i].weight);\n            denominator += weightedTickData[i].weight;\n        }\n\n        weightedArithmeticMeanTick = int24(numerator / int256(denominator));\n        // Always round to negative infinity\n        if (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;\n    }\n\n    /// @notice Returns the \"synthetic\" tick which represents the price of the first entry in `tokens` in terms of the last\n    /// @dev Useful for calculating relative prices along routes.\n    /// @dev There must be one tick for each pairwise set of tokens.\n    /// @param tokens The token contract addresses\n    /// @param ticks The ticks, representing the price of each token pair in `tokens`\n    /// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`\n    function getChainedPrice(address[] memory tokens, int24[] memory ticks)\n        internal\n        pure\n        returns (int256 syntheticTick)\n    {\n        require(tokens.length - 1 == ticks.length, 'DL');\n        for (uint256 i = 1; i <= ticks.length; i++) {\n            // check the tokens for address sort order, then accumulate the\n            // ticks into the running synthetic tick, ensuring that intermediate tokens \"cancel out\"\n            tokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/OracleLibrary.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.8.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n    /// @param pool Address of the pool that we want to observe\n    /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\n    /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\n    /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\n    function consult(address pool, uint32 secondsAgo)\n        internal\n        view\n        returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)\n    {\n        require(secondsAgo != 0, 'BP');\n\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = secondsAgo;\n        secondsAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) =\n            IUniswapV3Pool(pool).observe(secondsAgos);\n\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        uint160 secondsPerLiquidityCumulativesDelta =\n            secondsPerLiquidityCumulativeX128s[1] - secondsPerLiquidityCumulativeX128s[0];\n\n        arithmeticMeanTick = int24(tickCumulativesDelta / secondsAgo);\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % secondsAgo != 0)) arithmeticMeanTick--;\n\n        // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128\n        uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;\n        harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it do"
    }
  ]
}