{
  "Title": "M-1: Anyone can spend on behalf of roller periphery",
  "Content": "# Issue M-1: Anyone can spend on behalf of roller periphery \n\nSource: https://github.com/sherlock-audit/2022-11-sense-judging/issues/48 \n\n## Found by \n8olidity, 0x52, supernova, ctf\\_sec, pashov, cryptphi, minhquanym\n\n## Summary\nThe approve() function in RollerPeriphery contract allows anyone to spend ERC20 token owned by the contract\n\n## Vulnerability Detail\nRollerPeriphery.approve() does not have any access control, this allows any user to be able to call the approve call which would make an ERC20 approve call to the token inputed, and allowing the 'to' address to spend. In the cases where RollerPeriphery owns some ERC20 tokens. The user will be able to transfer the tokens from the contract as a spender.\n\n## Impact\nLoss of funds\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/RollerPeriphery.sol#L100-L102\n\n```solidity\nfunction approve(ERC20 token, address to, uint256 amount) public payable {\n        token.safeApprove(to, amount);\n    }\n```\n\nERC20 approve call is:\n```solidity\nfunction approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n```\n\n## Tool used\nManual Review\n\n## Recommendation\nThere should be some access control, according to the provided contracts, this function is called by RollerFactory, this can be the only address allowed to call the RollerPeriphery.approve() function.\n\n## Discussion\n\n**jparklev**\n\nWe don't expect that the Periphery will ever hold onto funds of its own, so this is acceptable behavior to us. However, the DOS version of this ticket #46 might be valid as a `medium`\n\n**Evert0x**\n\nGrouping all as medium as they point out the same flaw with different impacts.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/19",
  "Code": [
    {
      "filename": "contracts/src/RollerPeriphery.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.13;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { ERC4626 } from \"solmate/mixins/ERC4626.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\n\nimport { AutoRoller } from \"./AutoRoller.sol\";\n\n// Inspired by https://github.com/fei-protocol/ERC4626/blob/main/src/ERC4626Router.sol\ncontract RollerPeriphery {\n    using SafeTransferLib for ERC20;\n\n    /// @notice thrown when amount of assets received is below the min set by caller.\n    error MinAssetError();\n\n    /// @notice thrown when amount of shares received is below the min set by caller.\n    error MinSharesError();\n\n    /// @notice thrown when amount of assets received is above the max set by caller.\n    error MaxAssetError();\n\n    /// @notice thrown when amount of shares received is above the max set by caller.\n    error MaxSharesError();\n\n    /// @notice thrown when amount of assets or excess received is below the max set by caller.\n    error MinAssetsOrExcessError();\n\n    /// @notice Redeem vault shares with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param shares Number of shares to redeem\n    /// @param receiver Destination address for the returned assets\n    /// @param minAmountOut Minimum amount of assets returned\n    /// @return assets Amount of asset redeemable by the given number of shares\n    function redeem(ERC4626 vault, uint256 shares, address receiver, uint256 minAmountOut) external returns (uint256 assets) {\n        if ((assets = vault.redeem(shares, receiver, msg.sender)) < minAmountOut) {\n            revert MinAssetError();\n        }\n    }\n\n    /// @notice Withdraw underlying asset from vault with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param assets Amount of asset requested for withdrawal\n    /// @param receiver Destination address for the returned assets\n    /// @param maxSharesOut Maximum amount of shares burned\n    /// @return shares Number of shares to redeem\n    function withdraw(ERC4626 vault, uint256 assets, address receiver, uint256 maxSharesOut) external returns (uint256 shares) {\n        if ((shares = vault.withdraw(assets, receiver, msg.sender)) > maxSharesOut) {\n            revert MaxSharesError();\n        }\n    }\n\n    /// @notice Mint vault shares with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param shares Number of shares to mint\n    /// @param receiver Destination address for the returned shares\n    /// @param maxAmountIn Maximum amount of assets pulled from msg.sender\n    /// @return assets Amount of asset pulled from msg.sender and used to mint vault shares\n    function mint(ERC4626 vault, uint256 shares, address receiver, uint256 maxAmountIn) external returns (uint256 assets) {\n        ERC20(vault.asset()).safeTransferFrom(msg.sender, address(this), vault.previewMint(shares));\n\n        if ((assets = vault.mint(shares, receiver)) > maxAmountIn) {\n            revert MaxAssetError();\n        }\n    }\n\n    /// @notice Deposit underlying asset into vault with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param assets Amount of asset pulled from msg.sender and used to mint vault shares\n    /// @param receiver Destination address for the returned shares\n    /// @param minSharesOut Minimum amount of returned shares\n    /// @return shares Number of shares minted by the vault and returned to msg.sender\n    function deposit(ERC4626 vault, uint256 assets, address receiver, uint256 minSharesOut) external returns (uint256 shares) {\n        ERC20(vault.asset()).safeTransferFrom(msg.sender, address(this), assets);\n\n        if ((shares = vault.deposit(assets, receiver)) < minSharesOut) {\n            revert MinSharesError();\n        }\n    }\n\n    /// @notice Quick exit into the constituent assets with slippage protection\n    /// @param vault ERC4626 vault.\n    /// @param shares Number of shares to eject with.\n    /// @param receiver Destination address for the constituent assets.\n    /// @param minAssetsOut Minimum amount of assets returned\n    /// @param minExcessOut Minimum excess PT/YT returned \n    /// @return assets Amount of asset redeemable by the given number of shares.\n    /// @return excessBal Amount of excess PT or YT redeemable by the given number of shares.\n    /// @return isExcessPTs Whether the excess token is a YT or PT.\n    function eject(ERC4626 vault, uint256 shares, address receiver, uint256 minAssetsOut, uint256 minExcessOut)\n        external returns (uint256 assets, uint256 excessBal, bool isExcessPTs)\n    {\n        (assets, excessBal, isExcessPTs) = AutoRoller(address(vault)).eject(shares, receiver, msg.sender);\n\n        if (assets < minAssetsOut || excessBal < minExcessOut) {\n            revert MinAssetsOrExcessError();\n        }\n    }\n\n    function approve(ERC20 token, address to, uint256 amount) public payable {\n        token.safeApprove(to, amount);\n    }\n}"
    }
  ]
}