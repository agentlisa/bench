{
  "Title": "[H-03] Redeeming a Settlement won't work for unsigned messages when the communicating dApps have different addresses on the different chains",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/MulticallRootRouter.sol#L163-L171><br>\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/MulticallRootRouter.sol#L186-L194><br>\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootBridgeAgent.sol#L311-L315>\n\n### Impact\n\nFunds cannot be redeemed and remain stuck in a settlement.\n\n### Proof Of Concept\n\nIn `MulticallRootRouter`, `execute()` calls `_approveAndCallOut(...)`; however, it passes the Output Params recipient also as the refundee. This is dangerous because the recipient Dapp on the BranchChain can have a different address or not exist on the Root Chain. Therefore, if a settlement fails, it won't be able to be redeemed since the settlement owner is set as the refundee.\n\nHere is a scenario:\n\n1. dApp A  on a Branch Chain with (`address = 0xbeef`) initiates a  `CallOut(...) 0x01` with `OutputParams (0x01)` for the `RootRouter`.\n2. `RootBridgeAgent` executor calls `MulticallRootRouter` `execute()` which then performs some number of arbitrary calls and gets the `OutputParams` assets into the `MulticallRootRouter`.\n3. `MulticallRootRouter` attempts to bridge out the assets to the BranchChain and creates a settlement, passing the `recipient (address = 0xbeef)` but also sets the `refundee as (address = 0xbeef)`.\n4. If the settlement fails, there is no guarantee that `0xbeef` is a known dApp on the Root Chain and the assets won't be able to be redeemed.\n\n```solidity\nfunction execute(bytes calldata encodedData, uint16) external payable override lock requiresExecutor {\n        // Parse funcId\n        bytes1 funcId = encodedData[0];\n\t\t\t\t\n\t\t\t\t// code ...\n            /// FUNC ID: 2 (multicallSingleOutput)\n        } else if (funcId == 0x02) {\n            // Decode Params\n            (\n                IMulticall.Call[] memory callData,\n                OutputParams memory outputParams,\n                uint16 dstChainId,\n                GasParams memory gasParams\n            ) = abi.decode(_decode(encodedData[1:]), (IMulticall.Call[], OutputParams, uint16, GasParams));\n\n            // Perform Calls\n            _multicall(callData);\n\n            // Bridge Out assets\n            _approveAndCallOut(\n                outputParams.recipient,\n                outputParams.recipient,\n                outputParams.outputToken,\n                outputParams.amountOut,\n                outputParams.depositOut,\n                dstChainId,\n                gasParams\n            );\n\t\n\t\t\t\t}\n// code ...\n    }\n```\n\n```solidity\nfunction _createSettlement(\n        uint32 _settlementNonce,\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes memory _params,\n        address _globalAddress,\n        uint256 _amount,\n        uint256 _deposit,\n        bool _hasFallbackToggled\n    ) internal returns (bytes memory _payload) {\n        // code ...\n\n        // Update Settlement\n        settlement.owner = _refundee;\n        settlement.recipient = _recipient;\n\n\t\t\t\t// code ...\n      \n    }\n```\n\n```solidity\nfunction redeemSettlement(uint32 _settlementNonce) external override lock {\n        // Get settlement storage reference\n        Settlement storage settlement = getSettlement[_settlementNonce];\n\n        // Get deposit owner.\n        address settlementOwner = settlement.owner;\n\n        // Check if Settlement is redeemable.\n        if (settlement.status == STATUS_SUCCESS) revert SettlementRedeemUnavailable();\n        if (settlementOwner == address(0)) revert SettlementRedeemUnavailable();\n\n        // Check if Settlement Owner is msg.sender or msg.sender is the virtual account of the settlement owner.\n        if (msg.sender != settlementOwner) {\n            if (msg.sender != address(IPort(localPortAddress).getUserAccount(settlementOwner))) {\n                revert NotSettlementOwner();\n            }\n        }\n\t\t\t/// more code ...\n    }\n```\n\n### Recommended Mitigation Steps\n\nInclude an argument that enables users to specify the refundee when creating settlements without using a Virtual Account.\n\n### Assessed type\n\nContext\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-09-maia-findings/issues/679#issuecomment-1764927027)**\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/679#issuecomment-1807194267):**\n > Addressed [here](https://github.com/Maia-DAO/2023-09-maia-remediations/commit/b4297422e8fde59862d82687cd609e137e26f6ee).\n\n*Note: for full discussion, see [here](https://github.com/code-423n4/2023-09-maia-findings/issues/679).*\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/MulticallRootRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {IMulticall2 as IMulticall} from \"./interfaces/IMulticall2.sol\";\nimport {\n    GasParams,\n    IRootBridgeAgent as IBridgeAgent,\n    SettlementInput,\n    SettlementMultipleInput\n} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IRootRouter, DepositParams, DepositMultipleParams} from \"./interfaces/IRootRouter.sol\";\nimport {IVirtualAccount, Call} from \"./interfaces/IVirtualAccount.sol\";\n\nstruct OutputParams {\n    // Address to receive the output assets.\n    address recipient;\n    // Address of the output hToken.\n    address outputToken;\n    // Amount of output hTokens to send.\n    uint256 amountOut;\n    // Amount of output underlying token to send.\n    uint256 depositOut;\n}\n\nstruct OutputMultipleParams {\n    // Address to receive the output assets.\n    address recipient;\n    // Addresses of the output hTokens.\n    address[] outputTokens;\n    // Amounts of output hTokens to send.\n    uint256[] amountsOut;\n    // Amounts of output underlying tokens to send.\n    uint256[] depositsOut;\n}\n\n/**\n * @title  Multicall Root Router Contract\n * @author MaiaDAO\n * @notice Root Router implementation for interfacing with third-party dApps present in the Root Omnichain Environment.\n * @dev    Func IDs for calling these  functions through messaging layer:\n *\n *         CROSS-CHAIN MESSAGING FUNCIDs\n *         -----------------------------\n *         FUNC ID      | FUNC NAME\n *         -------------+---------------\n *         0x01         | multicallNoOutput\n *         0x02         | multicallSingleOutput\n *         0x03         | multicallMultipleOutput\n *         0x04         | multicallSignedNoOutput\n *         0x05         | multicallSignedSingleOutput\n *         0x06         | multicallSignedMultipleOutput\n *\n */\ncontract MulticallRootRouter is IRootRouter, Ownable {\n    using SafeTransferLib for address;\n\n    /*///////////////////////////////////////////////////////////////\n                    MULTICALL ROOT ROUTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Root Chain Layer Zero Identifier.\n    uint256 public immutable localChainId;\n\n    /// @notice Address for Local Port Address where assets are stored and managed.\n    address public immutable localPortAddress;\n\n    /// @notice Root Chain Multicall Address.\n    address public immutable multicallAddress;\n\n    /// @notice Bridge Agent to manage communications and cross-chain assets.\n    address payable public bridgeAgentAddress;\n\n    /// @notice Bridge Agent Executor Address.\n    address public bridgeAgentExecutorAddress;\n\n    /// @notice Re-entrancy lock modifier state.\n    uint256 internal _unlocked = 1;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Multicall Root Router.\n     * @param _localChainId local layer zero chain id.\n     * @param _localPortAddress address of the root Port.\n     * @param _multicallAddress address of the Multicall contract.\n     */\n    constructor(uint256 _localChainId, address _localPortAddress, address _multicallAddress) {\n        require(_localPortAddress != address(0), \"Local Port Address cannot be 0\");\n        require(_multicallAddress != address(0), \"Multicall Address cannot be 0\");\n\n        localChainId = _localChainId;\n        localPortAddress = _localPortAddress;\n        multicallAddress = _multicallAddress;\n        _initializeOwner(msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Initializes the Multicall Root Router.\n     * @param _bridgeAgentAddress The address of the Bridge Agent.\n     */\n    function initialize(address _bridgeAgentAddress) external onlyOwner {\n        require(_bridgeAgentAddress != address(0), \"Bridge Agent Address cannot be 0\");\n\n        bridgeAgentAddress = payable(_bridgeAgentAddress);\n        bridgeAgentExecutorAddress = IBridgeAgent(_bridgeAgentAddress).bridgeAgentExecutorAddress();\n        renounceOwnership();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        LAYERZERO FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootRouter\n    /// @dev This function will revert when called.\n    function executeResponse(bytes memory, uint16) external payable override {\n        revert();\n    }\n\n    /**\n     *  @inheritdoc IRootRouter\n     *  @dev FuncIDs\n     *\n     *  FUNC ID      | FUNC NAME\n     *  0x01         |  multicallNoOutput\n     *  0x02         |  multicallSingleOutput\n     *  0x03         |  multicallMultipleOutput\n     *\n     */\n    function execute(bytes calldata encodedData, uint16) external payable override lock requiresExecutor {\n        // Parse funcId\n        bytes1 funcId = encodedData[0];\n\n        /// FUNC ID: 1 (multicallNoOutput)\n        if (funcId == 0x01) {\n            // Decode Params\n            (IMulticall.Call[] memory callData) = abi.decode(_decode(encodedData[1:]), (IMulticall.Call[]));\n\n            // Perform Calls\n            _multicall(callData);\n\n            /// FUNC ID: 2 (multicallSingleOutput)\n        } else if (funcId == 0x02) {\n            // Decode Params\n            (\n                IMulticall.Call[] memory callData,\n                OutputParams memory outputParams,\n                uint16 dstChainId,\n                GasParams memory gasParams\n            ) = abi.decode(_decode(encodedData[1:]), (IMulticall.Call[], OutputParams, uint16, GasParams));\n\n            // Perform Calls\n            _multicall(callData);\n\n            // Bridge Out assets\n            _approveAndCallOut(\n                outputParams.recipient,\n                outputParams.recipient,\n                outputParams.outputToken,\n                outputParams.amountOut,\n                outputParams.depositOut,\n                dstChainId,\n                gasParams\n            );\n\n            /// FUNC ID: 3 (multicallMultipleOutput)\n        } else if (funcId == 0x03) {\n            // Decode Params\n            (\n                IMulticall.Call[] memory callData,\n                OutputMultipleParams memory outputParams,\n                uint16 dstChainId,\n                GasParams memory gasParams\n            ) = abi.decode(_decode(encodedData[1:]), (IMulticall.Call[], OutputMultipleParams, uint16, GasParams));\n\n            // Perform Calls\n            _multicall(callData);\n\n            // Bridge Out assets\n            _approveMultipleAndCallOut(\n                outputParams.recipient,\n                outputParams.recipient,\n                outputParams.outputTokens,\n                outputParams.amountsOut,\n                outputParams.depositsOut,\n                dstChainId,\n                gasParams\n            );\n            /// UNRECOGNIZED FUNC ID\n        } else {\n            revert UnrecognizedFunctionId();\n        }\n    }\n\n    ///@inheritdoc IRootRouter\n    function executeDepositSingle(bytes calldata, DepositParams calldata, uint16) external payable override {\n        revert();\n    }\n\n    ///@inheritdoc IRootRouter\n\n    function executeDepositMultiple(bytes calldata, DepositMultipleParams calldata, uint16) external payable {\n        revert();\n    }\n\n    /**\n     *  @inheritdoc IRootRouter\n     *  @dev FuncIDs\n     *\n     *  FUNC ID      | FUNC NAME\n     *  0x01         |  multicallNoOutput\n     *  0x02         |  multicallSingleOutput\n     *  0x03         |  multicallMultipleOutput\n     *\n     */\n    function executeSigned(bytes calldata encodedData, address userAccount, uint16)\n        external\n        payable\n        override\n        lock\n        requiresExecutor\n    {\n        // Parse funcId\n        bytes1 funcId = encodedData[0];\n\n        /// FUNC ID: 1 (multicallNoOutput)\n        if (funcId == 0x01) {\n            // Decode Params\n            Call[] memory calls = abi.decode(_decode(encodedData[1:]), (Call[]));\n\n            // Make requested calls\n            IVirtualAccount(userAccount).call(calls);\n\n            /// FUNC ID: 2 (multicallSingleOutput)\n        } else if (funcId == 0x02) {\n            // Decode Params\n            (Call[] memory calls, OutputParams memory outputParams, uint16 dstChainId, GasParams memory gasParams) =\n                abi.decode(_decode(encodedData[1:]), (Call[], OutputParams, uint16, GasParams));\n\n            // Make requested calls\n            IVirtualAccount(userAccount).call(calls);\n\n            // Withdraw assets from Virtual Account\n            IVirtualAccount(userAccount).withdrawERC20(outputParams.outputToken, outputParams.amountOut);\n\n            // Bridge Out assets\n            _approveAndCallOut(\n                IVirtualAccount(userAccount).userAddress(),\n                outputParams.recipient,\n                outputParams.outputToken,\n                outputParams.amountOut,\n                outputParams.depositOut,\n                dstChainId,\n                gasParams\n            );\n\n            /// FUNC ID: 3 (multicallMultipleOutput)\n        } else if (funcId == 0x03) {\n            // Decode Params\n            (\n                Call[] memory calls,\n                OutputMultipleParams memory outputParams,\n                uint16 dstChainId,\n                GasParams memory gasParams\n            ) = abi.decode(_decode(encodedData[1:]), (Call[], OutputMultipleParams, uint16, GasParams));\n\n            // Make requested calls\n            IVirtualAccount(userAccount).call(calls);\n\n            // Withdraw assets from Virtual Account\n            for (uint256 i = 0; i < outputParams.outputTokens.length;) {\n                IVirtualAccount(userAccount).withdrawERC20(outputParams.outputTokens[i], outputParams.amountsOut[i]);\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Bridge Out assets\n            _approveMultipleAndCallOut(\n                IVirtualAccount(userAccount).userAddress(),\n                outputParams.recipient,\n                outputParams.outputTokens,\n                outputParams.amountsOut,\n                outputParams.depositsOut,\n                dstChainId,\n                gasParams\n            );\n            /// UNRECOGNIZED FUNC ID\n        } else {\n            revert UnrecognizedFunctionId();\n        }\n    }\n\n    /**\n     *  @inheritdoc IRootRouter\n     *  @dev FuncIDs\n     *\n     *  FUNC ID      | FUNC NAME\n     *  0x01         |  multicallNoOutput\n     *  0x02         |  multicallSingleOutput\n     *  0x03         |  multicallMultipleOutput\n     *\n     */\n    function executeSignedDepositSingle(bytes calldata encodedData, DepositParams calldata, address userAccount, uint16)\n        external\n        payable\n        override\n        requiresExecutor\n        lock\n    {\n        // Parse funcId\n        bytes1 funcId = encodedData[0];\n\n        /// FUNC ID: 1 (multicallNoOutput)\n        if (funcId == 0x01) {\n            // Decode Params\n            Call[] memory calls = abi.decode(_decode(encodedData[1:]), (Call[]));\n\n            // Make requested calls\n            IVirtualAccount(userAccount).call(calls);\n\n            /// FUNC ID: 2 (multicallSingleOutput)\n        } else if (funcId == 0x02) {\n            // Decode Params\n            (Call[] memory calls, OutputParams memory outputParams, uint16 dstChainId, GasParams memory gasParams) =\n                abi.decode(_decode(encodedData[1:]), (Call[], OutputParams, uint16, GasParams));\n\n            // Make requested calls\n            IVirtualAccount(userAccount).call(calls);\n\n            // Withdraw assets from Virtual Account\n            IVirtualAccount(userAccount).withdrawERC20(outputParams.outputToken, outputParams.amountOut);\n\n            // Bridge Out assets\n            _approveAndCallOut(\n                IVirtualAccount(userAccount).userAddress(),\n                outputParams.recipient,\n                outputParams.outputToken,\n                outputParams.amountOut,\n                outputParams.depositOut,\n                dstChainId,\n                gasParams\n            );\n\n            /// FUNC ID: 3 (multicallMultipleOutput)\n        } else if (funcId == 0x03) {\n            // Decode Params\n            (\n                Call[] memory calls,\n                OutputMultipleParams memory outputParams,\n                uint16 dstChainId,\n                GasParams memory gasParams\n            ) = abi.decode(_decode(encodedData[1:]), (Call[], OutputMultipleParams, uint16, GasParams));\n\n            // Make requested calls\n            IVirtualAccount(userAccount).call(calls);\n\n            // Withdraw assets from Virtual Account\n            for (uint256 i = 0; i < outputParams.outputTokens.length;) {\n                IVirtualAccount(userAccount).withdrawERC20(outputParams.outputTokens[i], outputParams.amountsOut[i]);\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Bridge Out assets\n            _approveMultipleAndCallOut(\n                IVirtualAccount(userAccount).userAddress(),\n                outputParams.recipient,\n                outputParams.outputTokens,\n                outputParams.amountsOut,\n                outputParams.depositsOut,\n                dstChainId,\n                gasParams\n            );\n            /// UNRECOGNIZED FUNC ID\n        } else {\n            revert UnrecognizedFunctionId();\n        }\n    }\n\n    /**\n     *  @inheritdoc IRootRouter\n     *  @dev FuncIDs\n     *\n     *  FUNC ID      | FUNC NAME\n     *  0x01         |  multicallNoOutput\n     *  0x02         |  multicallSingleOutput\n     *  0x03         |  multicallMultipleOutput\n     *\n     */\n    function executeSignedDepositMultiple(\n        bytes calldata encodedData,\n        DepositMultipleParams calldata,\n        address userAccount,\n        uint16\n    ) external payable override requiresExecutor lock {\n        // Parse funcId\n        bytes1 funcId = encodedData[0];\n\n        /// FUNC ID: 1 (multicallNoOutput)\n        if (funcId == 0x01) {\n            // Decode Params\n            Call[] memory calls = abi.decode(_decode(encodedData[1:]), (Call[]));\n\n            // Make requested calls\n            IVirtualAccount(userAccount).call(calls);\n\n            /// FUNC ID: 2 (multicallSingleOutput)\n        } else if (funcId == 0x02) {\n            // Decode Params\n            (Call[] memory calls, OutputParams memory outputParams, uint16 dstChainId, GasParams memory gasParams) =\n                abi.decode(_decode(encodedData[1:]), (Call[], OutputParams, uint16, GasParams));\n\n            // Make requested calls\n            IVirtualAccount(userAccount).call(calls);\n\n            // Withdraw assets from Virtual Account\n            IVirtualAccount(userAccount).withdrawERC20(outputParams.outputToken, outputParams.amountOut);\n\n            // Bridge Out assets\n            _approveAndCallOut(\n                IVirtualAccount(userAccount).userAddress(),\n                outputParams.recipient,\n                outputParams.outputToken,\n                outputParams.amountOut,\n                outputParams.depositOut,\n                dstChainId,\n                gasParams\n            );\n\n            /// FUNC ID: 3 (multicallMultipleOutput)\n        } else if (funcId == 0x03) {\n            // Decode Params\n            (\n                Call[] memory calls,\n                OutputMultipleParams memory outputParams,\n                uint16 dstChainId,\n                GasParams memory gasParams\n            ) = abi.decode(_decode(encodedData[1:]), (Call[], OutputMultipleParams, uint16, GasParams));\n\n            // Make requested calls\n            IVirtualAccount(userAccount).call(calls);\n\n            // Withdraw assets from Virtual Account\n            for (uint256 i = 0; i < outputParams.outputTokens.length;) {\n                IVirtualAccount(userAccount).withdrawERC20(outputParams.outputTokens[i], outputParams.amountsOut[i]);\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Bridge Out assets\n            _approveMultipleAndCallOut(\n                IVirtualAccount(userAccount).userAddress(),\n                outputParams.recipient,\n                outputParams.outputTokens,\n                outputParams.amountsOut,\n                outputParams.depositsOut,\n                dstChainId,\n                gasParams\n            );\n            /// UNRECOGNIZED FUNC ID\n        } else {\n            revert UnrecognizedFunctionId();\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        MULTICALL FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     *   @notice Function to perform a set of actions on the omnichain environment without using the user's Virtual Acccount.\n     *   @param calls to be executed.\n     *\n     */\n    function _multicall(IMulticall.Call[] memory calls)\n        internal\n        returns (uint256 blockNumber, bytes[] memory returnData)\n    {\n        // Make requested calls\n        (blockNumber, returnData) = IMulticall(multicallAddress).aggregate(calls);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INTERNAL HOOKS\n    ////////////////////////////////////////////////////////////*/\n    /**\n     *  @notice Function to call 'clearToken' on the Root Port.\n     *  @param refundee settlement owner adn excess gas receiver.\n     *  @param recipient Address to receive the output hTokens.\n     *  @param outputToken Address of the output hToken.\n     *  @param amountOut Amount of output hTokens to send.\n     *  @param depositOut Amount of output hTokens to deposit.\n     *  @param dstChainId Chain Id of the destination chain.\n     */\n    function _approveAndCallOut(\n        address refundee,\n        address recipient,\n        address outputToken,\n        uint256 amountOut,\n        uint256 depositOut,\n        uint16 dstChainId,\n        GasParams memory gasParams\n    ) internal virtual {\n        // Save bridge agent address to memory\n        address _bridgeAgentAddress = bridgeAgentAddress;\n\n        // Approve Root Port to spend/send output hTokens.\n        outputToken.safeApprove(_bridgeAgentAddress, amountOut);\n\n        //Move output hTokens from Root to Branch and call 'clearToken'.\n        IBridgeAgent(_bridgeAgentAddress).callOutAndBridge{value: msg.value}(\n            payable(refundee),\n            recipient,\n            dstChainId,\n            \"\",\n            SettlementInput(outputToken, amountOut, depositOut),\n            gasParams,\n            true\n        );\n    }\n\n    /**\n     *  @notice Function to approve token spend before Bridge Agent interaction to Bridge Out of omnichain environment.\n     *  @param refundee settlement owner adn excess gas receiver.\n     *  @param recipient Address to receive the output tokens.\n     *  @param outputTokens Addresses of the output hTokens.\n     *  @param amountsOut Total amount of tokens to send.\n     *  @param depositsOut Amounts of tokens to withdraw from the destination port.\n     *\n     */\n    function _approveMultipleAndCallOut(\n        address refundee,\n        address recipient,\n        address[] memory outputTokens,\n        uint256[] memory amountsOut,\n        uint256[] memory depositsOut,\n        uint16 dstChainId,\n        GasParams memory gasParams\n    ) internal virtual {\n        // Save bridge agent address to memory\n        address _bridgeAgentAddress = bridgeAgentAddress;\n\n        // For each output token\n        for (uint256 i = 0; i < outputTokens.length;) {\n            // Approve Root Port to spend output hTokens.\n            outputTokens[i].safeApprove(_bridgeAgentAddress, amountsOut[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        //Move output hTokens from Root to Branch and call 'clearTokens'.\n        IBridgeAgent(_bridgeAgentAddress).callOutAndBridgeMultiple{value: msg.value}(\n            payable(refundee),\n            recipient,\n            dstChainId,\n            \"\",\n            SettlementMultipleInput(outputTokens, amountsOut, depositsOut),\n            gasParams,\n            true\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            DECODING FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    function _decode(bytes calldata data) internal pure virtual returns (bytes memory) {\n        return data;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    ////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier for a simple re-entrancy check.\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    /// @notice Modifier verifies the caller is the Bridge Agent Executor.\n    modifier requiresExecutor() {\n        _requiresExecutor();\n        _;\n    }\n\n    /// @notice Verifies the caller is the Bridge Agent Executor. Internal function used in modifier to reduce contract bytesize.\n    function _requiresExecutor() internal view {\n        if (msg.sender != bridgeAgentExecutorAddress) revert UnrecognizedBridgeAgentExecutor();\n    }\n}"
    },
    {
      "filename": "src/MulticallRootRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {IMulticall2 as IMulticall} from \"./interfaces/IMulticall2.sol\";\nimport {\n    GasParams,\n    IRootBridgeAgent as IBridgeAgent,\n    SettlementInput,\n    SettlementMultipleInput\n} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IRootRouter, DepositParams, DepositMultipleParams} from \"./interfaces/IRootRouter.sol\";\nimport {IVirtualAccount, Call} from \"./interfaces/IVirtualAccount.sol\";\n\nstruct OutputParams {\n    // Address to receive the output assets.\n    address recipient;\n    // Address of the output hToken.\n    address outputToken;\n    // Amount of output hTokens to send.\n    uint256 amountOut;\n    // Amount of output underlying token to send.\n    uint256 depositOut;\n}\n\nstruct OutputMultipleParams {\n    // Address to receive the output assets.\n    address recipient;\n    // Addresses of the output hTokens.\n    address[] outputTokens;\n    // Amounts of output hTokens to send.\n    uint256[] amountsOut;\n    // Amounts of output underlying tokens to send.\n    uint256[] depositsOut;\n}\n\n/**\n * @title  Multicall Root Router Contract\n * @author MaiaDAO\n * @notice Root Router implementation for interfacing with third-party dApps present in the Root Omnichain Environment.\n * @dev    Func IDs for calling these  functions through messaging layer:\n *\n *         CROSS-CHAIN MESSAGING FUNCIDs\n *         -----------------------------\n *         FUNC ID      | FUNC NAME\n *         -------------+---------------\n *         0x01         | multicallNoOutput\n *         0x02         | multicallSingleOutput\n *         0x03         | multicallMultipleOutput\n *         0x04         | multicallSignedNoOutput\n *         0x05         | multicallSignedSingleOutput\n *         0x06         | multicallSignedMultipleOutput\n *\n */\ncontract MulticallRootRouter is IRootRouter, Ownable {\n    using SafeTransferLib for address;\n\n    /*///////////////////////////////////////////////////////////////\n                    MULTICALL ROOT ROUTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Root Chain Layer Zero Identifier.\n    uint256 public immutable localChainId;\n\n    /// @notice Address for Local Port Address where assets are stored and managed.\n    address public immutable localPortAddress;\n\n    /// @notice Root Chain Multicall Address.\n    address public immutable multicallAddress;\n\n    /// @notice Bridge Agent to manage communications and cross-chain assets.\n    address payable public bridgeAgentAddress;\n\n    /// @notice Bridge Agent Executor Address.\n    address public bridgeAgentExecutorAddress;\n\n    /// @notice Re-entrancy lock modifier state.\n    uint256 internal _unlocked = 1;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Multicall Root Router.\n     * @param _localChainId local layer zero chain id.\n     * @param _localPortAddress address of the root Port.\n     * @param _multicallAddress address of the Multicall contract.\n     */\n    constructor(uint256 _localChainId, address _localPortAddress, address _multicallAddress) {\n        require(_localPortAddress != address(0), \"Local Port Address cannot be 0\");\n        require(_multicallAddress != address(0), \"Multicall Address cannot be 0\");\n\n        localChainId = _localChainId;\n        localPortAddress = _localPortAddress;\n        multicallAddress = _multicallAddress;\n        _initializeOwner(msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Initializes the Multicall Root Router.\n     * @param _bridgeAgentAddress The address of the Bridge Agent.\n     */\n    function initialize(address _bridgeAgentAddress) external onlyOwner {\n        require(_bridgeAgentAddress != address(0), \"Bridge Agent Address cannot be 0\");\n\n        bridgeAgentAddress = payable(_bridgeAgentAddress);\n        bridgeAgentExecutorAddress = IBridgeAgent(_bridgeAgentAddress).bridgeAgentExecutorAddress();\n        renounceOwnership();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        LAYERZERO FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootRouter\n    /// @dev This function will revert when called.\n    function executeResponse(bytes memory, uint16) external payable override {\n        revert();\n    }\n\n    /**\n     *  @inheritdoc IRootRouter\n     *  @dev FuncIDs\n     *\n     *  FUNC ID      | FUNC NAME\n     *  0x01         |  multicallNoOutput\n     *  0x02         |  multicallSingleOutput\n     *  0x03         |  multicallMultipleOutput\n     *\n     */\n    function execute(bytes calldata encodedData, uint16) external payable override lock requiresExecutor {\n        // Parse funcId\n        bytes1 funcId = encodedData[0];\n\n        /// FUNC ID: 1 (multicallNoOutput)\n        if (funcId == 0x01) {\n            // Decode Params\n            (IMulticall.Call[] memory callData) = abi.decode(_decode(encodedData[1:]), (IMulticall.Call[]));\n\n            // Perform Calls\n            _multicall(callData);\n\n            /// FUNC ID: 2 (multicallSingleOutput)\n        } else if (funcId == 0x02) {\n            // Decode Params\n            (\n                IMulticall.Call[] memory callData,\n                OutputParams memory outputParams,\n                uint16 dstChainId,\n                GasParams memory gasParams\n            ) = abi.decode(_decode(encodedData[1:]), (IMulticall.Call[], OutputParams, uint16, GasParams));\n\n            // Perform Calls\n            _multicall(callData);\n\n            // Bridge Out assets\n            _approveAndCallOut(\n                outputParams.recipient,\n                outputParams.recipient,\n                outputParams.outputToken,\n                outputParams.amountOut,\n                outputParams.depositOut,\n                dstChainId,\n                gasParams\n            );\n\n            /// FUNC ID: 3 (multicallMultipleOutput)\n        } else if (funcId == 0x03) {\n            // Decode Params\n            (\n                IMulticall.Call[] memory callData,\n                OutputMultipleParams memory outputParams,\n                uint16 dstChainId,\n                GasParams memory gasParams\n            ) = abi.decode(_decode(encodedData[1:]), (IMulticall.Call[], OutputMultipleParams, uint16, GasParams));\n\n            // Perform Calls\n            _multicall(callData);\n\n            // Bridge Out assets\n            _approveMultipleAndCallOut(\n                outputParams.recipient,\n                outputParams.recipient,\n                outputParams.outputTokens,\n                outputParams.amountsOut,\n                outputParams.depositsOut,\n                dstChainId,\n                gasParams\n            );\n            /// UNRECOGNIZED FUNC ID\n        } else {\n            revert UnrecognizedFunctionId();\n        }\n    }\n\n    ///@inheritdoc IRootRouter\n    function executeDepositSingle(bytes calldata, DepositParams calldata, uint16) external payable override {\n        revert();\n    }\n\n    ///@inheritdoc IRootRouter\n\n    function executeDepositMultiple(bytes calldata, DepositMultipleParams calldata, uint16) external payable {\n        revert();\n    }\n\n    /**\n     *  @inheritdoc IRootRouter\n     *  @dev FuncIDs\n     *\n     *  FUNC ID      | FUNC NAME\n     *  0x01         |  multicallNoOutput\n     *  0x02         |  multicallSingleOutput\n     *  0x03         |  multicallMultipleOutput\n     *\n     */\n    function executeSigned(bytes calldata encodedData, address userAccount, uint16)\n        external\n        payable\n        override\n        lock\n        requiresExecutor\n    {\n        // Parse funcId\n        bytes1 funcId = encodedData[0];\n\n        /// FUNC ID: 1 (multicallNoOutput)\n        if (funcId == 0x01) {\n            // Decode Params\n            Call[] memory calls = abi.decode(_decode(encodedData[1:]), (Call[]));\n\n            // Make requested calls\n            IVirtualAccount(userAccount).call(calls);\n\n            /// FUNC ID: 2 (multicallSingleOutput)\n        } else if (funcId == 0x02) {\n            // Decode Params\n            (Call[] memory calls, OutputParams memory outputParams, uint16 dstChainId, GasParams memory gasParams) =\n                abi.decode(_decode(encodedData[1:]), (Call[], OutputParams, uint16, GasParams));\n\n            // Make requested calls\n            IVirtualAccount(userAccount).call(calls);\n\n            // Withdraw assets from Virtual Account\n            IVirtualAccount(userAccount).withdrawERC20(outputParams.outputToken, outputParams.amountOut);\n\n            // Bridge Out assets\n            _approveAndCallOut(\n                IVirtualAccount(userAccount).userAddress(),\n                outputParams.recipient,\n                outputParams.outputToken,\n                outputParams.amountOut,\n                outputParams.depositOut,\n                dstChainId,\n                gasParams\n            );\n\n            /// FUNC ID: 3 (multicallMultipleOutput)\n        } else if (funcId == 0x03) {\n            // Decode Params\n            (\n                Call[] memory calls,\n                OutputMultipleParams memory outputParams,\n                uint16 dstChainId,\n                GasParams memory gasParams\n            ) = abi.decode(_decode(encodedData[1:]), (Call[], OutputMultipleParams, uint16, GasParams));\n\n            // Make requested calls\n            IVirtualAccount(userAccount).call(calls);\n\n            // Withdraw assets from Virtual Account\n            for (uint256 i = 0; i < outputParams.outputTokens.length;) {\n                IVirtualAccount(userAccount).withdrawERC20(outputParams.outputTokens[i], outputParams.amountsOut[i]);\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Bridge Out assets\n            _approveMultipleAndCallOut(\n                IVirtualAccount(userAccount).userAddress(),\n                outputParams.recipient,\n                outputParams.outputTokens,\n                outputParams.amountsOut,\n                outputParams.depositsOut,\n                dstChainId,\n                gasParams\n            );\n            /// UNRECOGNIZED FUNC ID\n        } else {\n            revert UnrecognizedFunctionId();\n        }\n    }\n\n    /**\n     *  @inheritdoc IRootRouter\n     *  @dev FuncIDs\n     *\n     *  FUNC ID      | FUNC NAME\n     *  0x01         |  multicallNoOutput\n     *  0x02         |  multicallSingleOutput\n     *  0x03         |  multicallMultipleOutput\n     *\n     */\n    function executeSignedDepositSingle(bytes calldata encodedData, DepositParams calldata, address userAccount, uint16)\n        external\n        payable\n        override\n        requiresExecutor\n        lock\n    {\n        // Parse funcId\n        bytes1 funcId = encodedData[0];\n\n        /// FUNC ID: 1 (multicallNoOutput)\n        if (funcId == 0x01) {"
    }
  ]
}