{
  "Title": "[H-02] `redeemToken` can fail for certain tokens",
  "Content": "_Submitted by cmichel, also found by hickuphh3, pauliax and jonah1005XXX_\n\nThe `SwappableYieldSource.redeemToken` function transfers tokens from the contract back to the sender, however, it uses the `ERC20.transferFrom(address(this), msg.sender, redeemableBalance)` function for this.\nSome deposit token implementations might fail as `transferFrom` checks if the contract approved itself for the `redeemableBalance` instead of skipping the allowance check in case the sender is the `from` address.\n\nThis can make the transaction revert and the deposited funds will be unrecoverable for the user.\n\nIt's recommended to use `_depositToken.safeTransfer(msg.sender, redeemableBalance)` instead.\n\n**[PierrickGT (PoolTogether) commented](https://github.com/code-423n4/2021-07-pooltogether-findings/issues/61#issuecomment-894368935):**\n > Duplicate of https://github.com/code-423n4/2021-07-pooltogether-findings/issues/25\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2021-07-pooltogether-findings/issues/61#issuecomment-904799020):**\n > re-opening this issue and marking #25 as a duplicate of this issue which clearly articulates the potential severity of unrecoverable user funds.\n\n**[PierrickGT (PoolTogether) resolved](https://github.com/code-423n4/2021-07-pooltogether-findings/issues/61#issuecomment-908446620):**\n > This issue has been fixed and we are now using `safeTransfer`: https://github.com/pooltogether/swappable-yield-source/blob/bf943b3818b81d5f5cb9d8ecc6f13ffecd33a1ff/contracts/SwappableYieldSource.sol#L235\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-07-pooltogether",
  "Code": [
    {
      "filename": "contracts/SwappableYieldSource.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@pooltogether/fixed-point/contracts/FixedPoint.sol\";\nimport \"@pooltogether/yield-source-interface/contracts/IYieldSource.sol\";\n\nimport \"./access/AssetManager.sol\";\n\n/// @title Swappable yield source contract to allow a PoolTogether prize pool to swap between different yield sources.\n/// @dev This contract adheres to the PoolTogether yield source interface.\n/// @dev This contract inherits AssetManager which extends OwnableUpgradable.\n/// @notice Swappable yield source for a PoolTogether prize pool that generates yield by depositing into the specified yield source.\ncontract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {\n  using SafeMathUpgradeable for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /// @notice Emitted when the swappable yield source is initialized.\n  /// @param yieldSource Address of yield source used to initialize this swappable yield source.\n  /// @param decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.\n  /// @param symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).\n  /// @param name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).\n  /// @param owner Swappable yield source owner.\n  event SwappableYieldSourceInitialized(\n    IYieldSource indexed yieldSource,\n    uint8 decimals,\n    string symbol,\n    string name,\n    address indexed owner\n  );\n\n  /// @notice Emitted when a yield source has been successfuly set.\n  /// @param yieldSource Yield source address that was set.\n  event SwappableYieldSourceSet(\n    IYieldSource indexed yieldSource\n  );\n\n  /// @notice Emitted when funds are successfully transferred from specified yield source to current yield source.\n  /// @param oldYieldSource Previous address of yield source that provided funds.\n  /// @param newYieldSource New address of yield source that received funds.\n  /// @param amount Amount of funds transferred.\n  event FundsTransferred(\n    IYieldSource indexed oldYieldSource,\n    IYieldSource indexed newYieldSource,\n    uint256 amount\n  );\n\n  /// @notice Emitted when ERC20 tokens other than yield source's tokens are withdrawn from the swappable yield source.\n  /// @param from Address that transferred funds.\n  /// @param to Address that received funds.\n  /// @param amount Amount of tokens transferred.\n  /// @param token ERC20 token transferred.\n  event TransferredERC20(\n    address indexed from,\n    address indexed to,\n    uint256 amount,\n    IERC20Upgradeable indexed token\n  );\n\n  /// @notice Yield source interface.\n  IYieldSource public yieldSource;\n\n  /// @notice Address of the ERC20 asset token deposited into the current yield source.\n  address public override depositToken;\n\n  /// @notice Mock Initializer to initialize implementations used by minimal proxies.\n  function freeze() external initializer {\n    //no-op\n  }\n\n  /// @notice Hack to determine if address passed is an actual yield source.\n  /// @dev If _depositTokenData.length is not superior to 0, then staticcall didn't return any data.\n  /// @param _yieldSource Yield source address to check.\n  /// @return _depositToken Address of the ERC20 token deposited into the yield source.\n  function _requireYieldSource(IYieldSource _yieldSource) internal view returns (address _depositToken) {\n    require(address(_yieldSource) != address(0), \"SwappableYieldSource/yieldSource-not-zero-address\");\n\n    (, bytes memory _depositTokenData) = address(_yieldSource).staticcall(abi.encodePacked(_yieldSource.depositToken.selector));\n\n    bool isValidYieldSource;\n\n    if (_depositTokenData.length > 0) {\n      (_depositToken) = abi.decode(_depositTokenData, (address));\n\n      isValidYieldSource = _depositToken != address(0);\n    }\n\n    require(isValidYieldSource, \"SwappableYieldSource/invalid-yield-source\");\n  }\n\n  /// @notice Initializes the swappable yield source with the yieldSource address provided.\n  /// @dev We approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI), to save gas for future calls.\n  /// @param _yieldSource Yield source address used to initialize this swappable yield source.\n  /// @param _decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.\n  /// @param _symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).\n  /// @param _name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).\n  /// @param _owner Swappable yield source owner.\n  /// @return true if operation is successful.\n  function initialize(\n    IYieldSource _yieldSource,\n    uint8 _decimals,\n    string calldata _symbol,\n    string calldata _name,\n    address _owner\n  ) external initializer returns (bool) {\n    address _depositToken = _requireYieldSource(_yieldSource);\n\n    depositToken = _depositToken;\n    yieldSource = _yieldSource;\n\n    __Ownable_init();\n    transferOwnership(_owner);\n\n    __ReentrancyGuard_init();\n\n    __ERC20_init(_name, _symbol);\n    _setupDecimals(_decimals);\n\n    IERC20Upgradeable(_depositToken).safeApprove(address(_yieldSource), type(uint256).max);\n\n    emit SwappableYieldSourceInitialized(\n      _yieldSource,\n      _decimals,\n      _symbol,\n      _name,\n      _owner\n    );\n\n    return true;\n  }\n\n  /// @notice Approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI).\n  /// @dev Emergency function to re-approve max amount if approval amount dropped too low.\n  /// @return true if operation is successful.\n  function approveMaxAmount() external onlyOwner returns (bool) {\n    address _yieldSource = address(yieldSource);\n    IERC20Upgradeable _depositToken = IERC20Upgradeable(depositToken);\n\n    uint256 _allowance = _depositToken.allowance(address(this), _yieldSource);\n    _depositToken.safeIncreaseAllowance(_yieldSource, type(uint256).max.sub(_allowance));\n\n    return true;\n  }\n\n  /// @notice Calculates the number of shares that should be minted or burned when a user deposit or withdraw.\n  /// @param tokens Amount of tokens.\n  /// @return Number of shares.\n  function _tokenToShares(uint256 tokens) internal returns (uint256) {\n    uint256 shares;\n    uint256 _totalSupply = totalSupply();\n\n    if (_totalSupply == 0) {\n      shares = tokens;\n    } else {\n      // rate = tokens / shares\n      // shares = tokens * (totalShares / swappableYieldSourceTotalSupply)\n      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));\n      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);\n    }\n\n    return shares;\n  }\n\n  /// @notice Calculates the number of tokens a user has in the yield source.\n  /// @param shares Amount of shares.\n  /// @return Number of tokens.\n  function _sharesToToken(uint256 shares) internal returns (uint256) {\n    uint256 tokens;\n    uint256 _totalSupply = totalSupply();\n\n    if (_totalSupply == 0) {\n      tokens = shares;\n    } else {\n      // tokens = shares * (yieldSourceTotalSupply / totalShares)\n      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);\n      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);\n    }\n\n    return tokens;\n  }\n\n  /// @notice Mint tokens to the user.\n  /// @dev Shares corresponding to the number of tokens supplied are minted to user's balance.\n  /// @param mintAmount Amount of asset tokens to be minted.\n  /// @param to User whose balance will receive the tokens.\n  function _mintShares(uint256 mintAmount, address to) internal {\n    uint256 shares = _tokenToShares(mintAmount);\n\n    require(shares > 0, \"SwappableYieldSource/shares-gt-zero\");\n\n    _mint(to, shares);\n  }\n\n  /// @notice Burn shares from user's balance.\n  /// @dev Shares corresponding to the number of tokens withdrawn are burnt from user's balance.\n  /// @param burnAmount Amount of asset tokens to be burnt.\n  function _burnShares(uint256 burnAmount) internal {\n    uint256 shares = _tokenToShares(burnAmount);\n    _burn(msg.sender, shares);\n  }\n\n  /// @notice Supplies tokens to the current yield source.  Allows assets to be supplied on other user's behalf using the `to` param.\n  /// @dev Asset tokens are supplied to the yield source, then deposited into the underlying yield source (eg: Aave, Compound, etc...).\n  /// @dev Shares from the yield source are minted to the swappable yield source address (this contract).\n  /// @dev Shares from the swappable yield source are minted to the `to` address.\n  /// @param amount Amount of `depositToken()` to be supplied.\n  /// @param to User whose balance will receive the tokens.\n  function supplyTokenTo(uint256 amount, address to) external override nonReentrant {\n    IERC20Upgradeable(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n    yieldSource.supplyTokenTo(amount, address(this));\n\n    _mintShares(amount, to);\n  }\n\n  /// @notice Returns the total balance in swappable tokens (eg: swsDAI).\n  /// @return Underlying balance of swappable tokens.\n  function balanceOfToken(address addr) external override returns (uint256) {\n    return _sharesToToken(balanceOf(addr));\n  }\n\n  /// @notice Redeems tokens from the current yield source.\n  /// @dev Shares of the swappable yield source address (this contract) are burnt from the yield source.\n  /// @dev Shares of the `msg.sender` address are burnt from the swappable yield source.\n  /// @param _amount Amount of `depositToken()` to withdraw.\n  /// @return Actual amount of tokens that were redeemed.\n  function redeemToken(uint256 _amount) external override nonReentrant returns (uint256) {\n    _burnShares(_amount);\n\n    uint256 _redeemAmount = yieldSource.redeemToken(_amount);\n    IERC20Upgradeable(depositToken).safeTransfer(msg.sender, _redeemAmount);\n\n    return _redeemAmount;\n  }\n\n  /// @notice Set new yield source.\n  /// @dev After setting the new yield source, we need to approve it to spend maxUint256 amount of depositToken (eg: DAI).\n  /// @param _oldYieldSource Previous yield source address to replace with `_newYieldSource`.\n  /// @param _newYieldSource New yield source address to set.\n  function _setYieldSource(IYieldSource _oldYieldSource, IYieldSource _newYieldSource) internal {\n    require(address(_newYieldSource) != address(_oldYieldSource), \"SwappableYieldSource/same-yield-source\");\n\n    address _depositTokenAddress = _newYieldSource.depositToken();\n    require(_depositTokenAddress == depositToken, \"SwappableYieldSource/different-deposit-token\");\n\n    yieldSource = _newYieldSource;\n\n    IERC20Upgradeable _depositToken = IERC20Upgradeable(_depositTokenAddress);\n    _depositToken.safeApprove(address(_newYieldSource), type(uint256).max);\n\n    uint256 _allowance = _depositToken.allowance(address(this), address(_oldYieldSource));\n    _depositToken.safeDecreaseAllowance(address(_oldYieldSource), _allowance);\n\n    emit SwappableYieldSourceSet(_newYieldSource);\n  }\n\n  /// @notice Transfer funds from old yield source to new yield source.\n  /// @dev We check that the `currentBalance` transferred is at least equal or superior to the `amountRedeemed` requested.\n  /// @dev `amountRedeemed` can be inferior to `redeemAmount` if funds were deposited into a yield source that applies a fee on withdrawals.\n  /// @dev `currentBalance` can be superior to `amountRedeemed` if yield has been accruing between redeeming and checking for a mathematical error.\n  /// @param _oldYieldSource Previous yield source address to transfer funds from.\n  /// @param _newYieldSource New yield source address to transfer funds to.\n  function _transferFunds(IYieldSource _oldYieldSource, IYieldSource _newYieldSource) internal {\n    uint256 _redeemAmount = _oldYieldSource.balanceOfToken(address(this));\n    uint256 _amountRedeemed = _oldYieldSource.redeemToken(_redeemAmount);\n\n    uint256 _currentBalance = IERC20Upgradeable(depositToken).balanceOf(address(this));\n\n    require(_amountRedeemed <= _currentBalance, \"SwappableYieldSource/transfer-amount-different\");\n\n    _newYieldSource.supplyTokenTo(_currentBalance, address(this));\n\n    emit FundsTransferred(_oldYieldSource, _newYieldSource, _currentBalance);\n  }\n\n  /// @notice Swap current yield source for new yield source.\n  /// @dev This function is only callable by the owner.\n  /// @dev We set a new yield source and then transfer funds from the now previous yield source to the new current yield source.\n  /// @param _newYieldSource New yield source address to set and transfer funds to.\n  /// @return true if operation is successful.\n  function swapYieldSource(IYieldSource _newYieldSource) external onlyOwner nonReentrant returns (bool) {\n    require(address(_newYieldSource) != address(0), \"SwappableYieldSource/yield-source-not-zero-address\");\n\n    IYieldSource _oldYieldSource = yieldSource;\n\n    _setYieldSource(_oldYieldSource, _newYieldSource);\n    _transferFunds(_oldYieldSource, _newYieldSource);\n\n    return true;\n  }\n\n  /// @notice Transfer ERC20 tokens other than the yield source's tokens held by this contract to the recipient address.\n  /// @dev This function is only callable by the owner or asset manager.\n  /// @param erc20Token ERC20 token to transfer.\n  /// @param to Recipient of the tokens.\n  /// @param amount Amount of tokens to transfer.\n  /// @return true if operation is successful.\n  function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {\n    require(address(erc20Token) != address(yieldSource), \"SwappableYieldSource/yield-source-token-transfer-not-allowed\");\n    erc20Token.safeTransfer(to, amount);\n    emit TransferredERC20(msg.sender, to, amount, erc20Token);\n    return true;\n  }\n}"
    }
  ]
}