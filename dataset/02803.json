{
  "Title": "H-8: Yield, Swivel, Element, APWine and Sense lend() are subject to reentracy resulting in Illuminate PT over-mint",
  "Content": "# Issue H-8: Yield, Swivel, Element, APWine and Sense lend() are subject to reentracy resulting in Illuminate PT over-mint \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/179 \n\n## Found by \nJeiwan, cryptphi, minhtrng, windowhan\\_kalosec, HonorLt, hyh, kenzo, Holmgren\n\n## Summary\n\nLender's lend() versions for Yield, Swivel, Element, APWine and Sense use balance difference for the net result calculation, i.e. how much Illuminate PTs to mint for the caller, and call user-provided contract to perform the swapping. The functions aren't protected from reentrancy.\n\nThis opens up an attack surface when the functions are being called repetitively, and, while the first call result is accounted once, nested calls, dealing with the same type of PTs, are accounted multiple times, leading to severe Illuminate PT over-mint.\n\n## Vulnerability Detail\n\nTaking Yield version as an example, Bob the attacker can provide custom-made contract `y` instead of Yield Space Pool. `y` do call the real pool, but before that it calls the same lend() with the same parameters (apart from amount), so `y` got called again.\n\nLet's say it happens 2 extra times. Let's say the first call is done with `10 DAI`, the second with `100 DAI`, the third with `10^6 DAI`, i.e. Bob needs to provide `10^6 + 10^2 + 10^1 DAI`. Let's say it is done right before maturity and there is no discounting remaining, i.e. `1 DAI = 1 PT`.\n\nThe result of the first yield() call will be accounted once, as designed. The result of the second, nested, call, will be accounted twice as it mints to the user according to the yield() call performed and increases the Yield PT balance, which is counted in the first lend(). The result of the third call will be accounted in all lend() functions.\n\nThis way first lend() will mint `1 * 10^6 + 1 * 10^2 + 1 * 10^1` as it will be the total Yield PT balance difference from the three yield() calls it performed directly and nested, i.e. the balance will be counted before the swapping started, the second time it will be counted when all three swaps be completed. The second lend() will mint `1 * 10^6 + 1 * 10^2` as it be finished before first yield() do its swap. The third lend() will mint `1 * 10^6`, having no further calls nested.\n\nBob will get `3 * 10^6 + 2 * 10^2 + 1 * 10^1` Illuminate PT minted for the `10^6 + 10^2 + 10^1` DAI provided.\n\n## Impact\n\nThe impact is massive Illuminate PTs over-mint that result in attacker being able to steal the funds of all other users by redeeming first the whole underlying amount due to the type of Illuminate PTs he obtained.\n\nAs there are no low probability prerequisites, setting the severity to be high.\n\n## Code Snippet\n\nSimilar in all: Bob creates a wrapper that calls the same version of lend() with the same parameters, then calls the correct pool. In each version of lend() there are a user-provided contract that is called to perform the operation, allowing for reentracy.\n\nYield lend() calls yield() with user-provided contract `y`, that is called in-between balance recording:\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L290-L347\n\n```solidity\n    /// @notice lend method for the Illuminate and Yield protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y Yield Space Pool for the principal token\n    /// @param minimum slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y,\n        uint256 minimum\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Check that the principal is Illuminate or Yield\n        if (\n            p != uint8(MarketPlace.Principals.Illuminate) &&\n            p != uint8(MarketPlace.Principals.Yield)\n        ) {\n            revert Exception(6, 0, 0, address(0), address(0));\n        }\n\n        // Get principal token for this market\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Extract fee\n        fees[u] = fees[u] + a / feenominator;\n\n        // Transfer underlying from user to the lender contract\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Make sure the Yield Space Pool matches principal token\n            address fyToken = IYield(y).fyToken();\n            if (IYield(y).fyToken() != principal) {\n                revert Exception(12, 0, 0, fyToken, principal);\n            }\n        }\n\n        // Swap underlying for PTs to lender\n        uint256 returned = yield(\n            u,\n            y,\n            a - a / feenominator,\n            address(this),\n            principal,\n            minimum\n        );\n\n        // Mint Illuminate PTs to msg.sender\n        IERC5095(principalToken(u, m)).authMint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned, a, msg.sender);\n\n        return returned;\n    }\n```\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L919-L957\n\n```solidity\n    /// @notice swaps underlying premium via a Yield Space Pool\n    /// @dev this method is only used by the Yield, Illuminate and Swivel protocols\n    /// @param u address of an underlying asset\n    /// @param y Yield Space Pool for the principal token\n    /// @param a amount of underlying tokens to lend\n    /// @param r the receiving address for PTs\n    /// @param p the principal token in the Yield Space Pool\n    /// @param m the minimum amount to purchase\n    /// @return uint256 the amount of tokens sent to the Yield Space Pool\n    function yield(\n        address u,\n        address y,\n        uint256 a,\n        address r,\n        address p,\n        uint256 m\n    ) internal returns (uint256) {\n        // Get the starting balance (to verify receipt of tokens)\n        uint256 starting = IERC20(p).balanceOf(r);\n\n        // Get the amount of tokens received for swapping underlying\n        uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));\n\n        // Send the remaining amount to the Yield pool\n        Safe.transfer(IERC20(u), y, a);\n\n        // Lend out the remaining tokens in the Yield pool\n        IYield(y).sellBase(r, returned);\n\n        // Get the ending balance of principal tokens (must be at least starting + returned)\n        uint256 received = IERC20(p).balanceOf(r) - starting;\n\n        // Verify receipt of PTs from Yield Space Pool\n        if (received <= m) {\n            revert Exception(11, received, m, address(0), address(0));\n        }\n\n        return received;\n    }\n```\n\nSimilarly, Swivel lend() calls yield() with user-supplied Yield Space Pool `y` via swivelLendPremium():\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L349-L449\n\n```solidity\n    /// @notice lend method signature for Swivel\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a array of amounts of underlying tokens lent to each order in the orders array\n    /// @param y Yield Space Pool for the Illuminate PT in this market\n    /// @param o array of Swivel orders being filled\n    /// @param s array of signatures for each order in the orders array\n    /// @param e flag to indicate if returned funds should be swapped in Yield Space Pool\n    /// @param premiumSlippage slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] memory a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s,\n        bool e,\n        uint256 premiumSlippage\n    ) external unpaused(u, m, p) returns (uint256) {\n        {\n            // Check that the principal is Swivel\n            if (p != uint8(MarketPlace.Principals.Swivel)) {\n \t\t\t\t...\n            }\n\n            // Lent represents the total amount of underlying to be lent\n            uint256 lent = swivelAmount(a);\n\n            // Transfer underlying token from user to Illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n\n            // Get the underlying balance prior to calling initiate\n            uint256 starting = IERC20(u).balanceOf(address(this));\n\n            // Verify and collect the fee\n            {\n            \t...\n            }\n\n            uint256 received;\n            {\n                // Get the starting amount of principal tokens\n                uint256 startingZcTokens = IERC20(\n                    IMarketPlace(marketPlace).token(u, m, p)\n                ).balanceOf(address(this));\n\n                // Fill the given orders on Swivel\n                ISwivel(swivelAddr).initiate(o, a, s);\n\n                if (e) {\n                    // Calculate the premium\n                    uint256 premium = IERC20(u).balanceOf(address(this)) -\n                        starting;\n\n                    // Swap the premium for Illuminate principal tokens\n                    swivelLendPremium(u, m, y, premium, premiumSlippage);\n                }\n\n                // Compute how many principal tokens were received\n                received =\n                    IERC20(IMarketPlace(marketPlace).token(u, m, p)).balanceOf(\n                        address(this)\n                    ) -\n                    startingZcTokens;\n            }\n\n            // Mint Illuminate principal tokens to the user\n            IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n            {\n                emit Lend(\n                \t...\n                );\n            }\n            return received;\n        }\n    }\n```\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L959-L979\n\n```solidity\n    /// @notice lends the leftover underlying premium to the Illuminate PT's Yield Space Pool\n    function swivelLendPremium(\n        address u,\n        uint256 m,\n        address y,\n        uint256 p,\n        uint256 slippageTolerance\n    ) internal {\n        // Lend remaining funds to Illuminate's Yield Space Pool\n        uint256 swapped = yield(\n            u,\n            y,\n            p,\n            address(this),\n            IMarketPlace(marketPlace).token(u, m, 0),\n            slippageTolerance\n        );\n\n        // Mint the remaining tokens\n        IERC5095(principalToken(u, m)).authMint(msg.sender, swapped);\n    }\n```\n\nThis way both Yield and Swivel call yield() with user-supplied pool `y` and mint the difference obtained with the `y` call to a user.\n\nElement lend calls elementSwap() with user-supplied pool `e` and mints the balance difference:\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L451-L511\n\n```solidity\n    /// @notice lend method signature for Element\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param e Element pool that is lent to\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address e,\n        bytes32 i\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Get the principal token for this market for Element\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer underlying token from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Track the accumulated fees\n        fees[u] = fees[u] + a / feenominator;\n\n        uint256 purchased;\n        {\n        \t...\n\n            // Conduct the swap on Element\n            purchased = elementSwap(e, swap, fund, r, d);\n        }\n\n        // Mint tokens to the user\n        IERC5095(principalToken(u, m)).authMint(msg.sender, purchased);\n\n        emit Lend(p, u, m, purchased, a, msg.sender);\n        return purchased;\n    }\n```\n\nelementSwap() similarly calls user-supplied `e` to perform the swapping and mints the balance difference:\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L1000-L1028\n\n```solidity\n    /// @notice executes a swap for and verifies receipt of Element PTs\n    function elementSwap(\n        address e,\n        Element.SingleSwap memory s,\n        Element.FundManagement memory f,\n        uint256 r,\n        uint256 d\n    ) internal returns (uint256) {\n        // Get the principal token\n        address principal = address(s.assetOut);\n\n        // Get the intial balance\n        uint256 starting = IERC20(principal).balanceOf(address(this));\n\n        // Conduct the swap on Element\n        IElementVault(e).swap(s, f, r, d);\n\n        // Get how many PTs were purchased by the swap call\n        uint256 purchased = IERC20(principal).balanceOf(address(this)) -\n            starting;\n\n        // Verify that a minimum amount was received\n        if (purchased < r) {\n            revert Exception(11, 0, 0, address(0), address(0));\n        }\n\n        // Return the net amount of principal tokens acquired after the swap\n        return purchased;\n    }\n```\n\nAPWine lend() in the same manner calls user-supplied pool `x` and mints the balance difference `received`:\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L562-L621\n\n```solidity\n    /// @notice lend method signature for APWine\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param x APWine router that executes the swap\n    /// @param pool the AMM pool used by APWine to execute the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address x,\n        address pool\n    ) external unpaused(u, m, p) returns (uint256) {\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            // Calculate amount to be lent out\n            lent = a - fee;\n        }\n\n        // Get the starting APWine token balance\n        uint256 starting = IERC20(principal).balanceOf(address(this));\n\n        // Swap on the APWine Pool using the provided market and params\n        IAPWineRouter(x).swapExactAmountIn(\n            pool,\n            apwinePairPath(),\n            apwineTokenPath(),\n            lent,\n            r,\n            address(this),\n            d,\n            address(0)\n        );\n\n        // Calculate the amount of APWine principal tokens received after the swap\n        uint256 received = IERC20(principal).balanceOf(address(this)) -\n            starting;\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n```\n\nSense lend() also directly calls user-supplied AMM `x` and mints the balance difference to a caller:\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L681-L741\n\n```solidity\n    /// @notice lend method signature for Sense\n    /// @dev this method can be called before maturity to lend to Sense while minting Illuminate tokens\n    /// @dev Sense provides a [divider] contract that splits [target] assets (underlying) into PTs and YTs. Each [target] asset has a [series] of contracts, each identifiable by their [maturity].\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param x AMM that is used to conduct the swap\n    /// @param s Sense's maturity for the given market\n    /// @param adapter Sense's adapter necessary to facilitate the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint128 a,\n        uint256 r,\n        address x,\n        uint256 s,\n        address adapter\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Retrieve the principal token for this market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).token(u, m, p));\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Determine the fee\n        uint256 fee = a / feenominator;\n\n        // Add the accumulated fees to the total\n        fees[u] = fees[u] + fee;\n\n        // Determine lent amount after fees\n        uint256 lent = a - fee;\n\n        // Stores the amount of principal tokens received in swap for underlying\n        uint256 received;\n        {\n            // Get the starting balance of the principal token\n            uint256 starting = token.balanceOf(address(this));\n\n            // Swap those tokens for the principal tokens\n            ISensePeriphery(x).swapUnderlyingForPTs(adapter, s, lent, r);\n\n            // Calculate number of principal tokens received in the swap\n            received = token.balanceOf(address(this)) - starting;\n\n            // Verify that we received the principal tokens\n            if (received < r) {\n                revert Exception(11, 0, 0, address(0), address(0));\n            }\n        }\n\n        // Mint the Illuminate tokens based on the returned amount\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n``` \n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding reentracy guard modifier to Yield, Swivel, Element, APWine and Sense lend() functions of the Lender.\n\nNotice that although Pendle, Tempus and Notional versions of lend() look to be resilient to the attack as they use either internal address (Pendle and Notional) or verify the supplied address (Tempus, https://github.com/tempus-finance/fixed-income-protocol/blob/master/contracts/TempusController.sol#L63) the same reentracy guard modifier can be used there as well as a general approach as these functions still mint the recorded balance difference to a user and there might exist yet unnoticed possibility to game it.\n\nIn all these cases either direct removal of the attack surface or precautious control for it do justify the reentracy guard gas cost.\n\n## Discussion\n\n**Minh-Trng**\n\nEscalate for 1 USDC\nI would like to request reevaluation of the duplication grouping. Currently, all issues that mention reentrancy are grouped together and count as 1 issue. As you can see in the list of duplicates, most wardens have submitted 2 issues, one for the affected lending functions and one for the single redeem function that is affected. Grouping them as a single issue would effectively punish those that put in the effort to identify both the affected lending and redeem parts, as well as describing the vulnerability details and impact (which are different), compared to those who only submitted the issue for the lending related code.\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> I would like to request reevaluation of the duplication grouping. Currently, all issues that mention reentrancy are grouped together and count as 1 issue. As you can see in the list of duplicates, most wardens have submitted 2 issues, one for the affected lending functions and one for the single redeem function that is affected. Grouping them as a single issue would effectively punish those that put in the effort to identify both the affected lending and redeem parts, as well as describing the vulnerability details and impact (which are different), compared to those who only submitted the issue for the lending related code.\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**SheldonHolmgren**\n\nEscalate for 100 USDC\n\nI just want to add more weight to the issue raised by @Minh-Trng above. They wrote it better than I could so I quote:\n> I would like to request reevaluation of the duplication grouping. Currently, all issues that mention reentrancy are grouped together and count as 1 issue. As you can see in the list of duplicates, most wardens have submitted 2 issues, one for the affected lending functions and one for the single redeem function that is affected. Grouping them as a single issue would effectively punish those that put in the effort to identify both the affected lending and redeem parts, as well as describing the vulnerability details and impact (which are different), compared to those who only submitted the issue for the lending related code.\n\n**sherlock-admin**\n\n > Escalate for 100 USDC\n> \n> I just want to add more weight to the issue raised by @Minh-Trng above. They wrote it better than I could so I quote:\n> > I would like to request reevaluation of the duplication grouping. Currently, all issues that mention reentrancy are grouped together and count as 1 issue. As you can see in the list of duplicates, most wardens have submitted 2 issues, one for the affected lending functions and one for the single redeem function that is affected. Grouping them as a single issue would effectively punish those that put in the effort to identify both the affected lending and redeem parts, as well as describing the vulnerability details and impact (which are different), compared to those who only submitted the issue for the lending related code.\n\nYou've created a valid escalation for 100 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "src/Lender.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol'; // library of MarketPlace specific constructs\nimport 'src/lib/Swivel.sol'; // library of Swivel specific constructs\nimport 'src/lib/Element.sol'; // library of Element specific constructs\nimport 'src/lib/Safe.sol';\nimport 'src/lib/Cast.sol';\nimport 'src/lib/RevertMsgExtractor.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusAMM.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/ISensePeriphery.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IElementVault.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/IAPWineRouter.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleToken.sol';\n\n/// @title Lender\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users\n/// @notice The contract holds the principal tokens and mints an ERC-5095 tokens to users to represent their loans\ncontract Lender {\n    /// @notice minimum wait before the admin may withdraw funds or change the fee rate\n    uint256 public constant HOLD = 3 days;\n\n    /// @notice address that is allowed to set and withdraw fees, disable principals, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal token has been paused by the admin\n    mapping(address => mapping(uint256 => bool[9])) public paused;\n\n    /// @notice contract used to execute swaps on Swivel's exchange\n    address public immutable swivelAddr;\n    /// @notice a SushiSwap router used by Pendle to execute swaps\n    address public immutable pendleAddr;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public constant MIN_FEENOMINATOR = 500;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping(address => uint256) public withdrawals;\n\n    /// @notice emitted upon lending to a protocol\n    event Lend(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 returned,\n        uint256 spent,\n        address sender\n    );\n    /// @notice emitted upon minting Illuminate principal tokens\n    event Mint(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount\n    );\n    /// @notice emitted upon scheduling a withdrawal\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted upon blocking a scheduled withdrawal\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n    /// @notice emitted upon scheduling a fee change\n    event ScheduleFeeChange(uint256 when);\n    /// @notice emitted upon blocking a scheduled fee change\n    event BlockFeeChange();\n    /// @notice emitted upon pausing or unpausing of a principal token\n    event PauseMarket(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        address token,\n        bool indexed state\n    );\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    modifier unpaused(\n        address u,\n        uint256 m,\n        uint8 p\n    ) {\n        if (paused[u][m][p]) {\n            revert Exception(1, p, 0, address(0), address(0));\n        }\n        _;\n    }\n\n    /// @notice initializes the Lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    constructor(address s, address p) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // approve the underlying for max per given principal\n        for (uint8 i; i != 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).token(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, type(uint256).max);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses.\n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        for (uint256 i; i != u.length; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], type(uint256).max);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice approves market contracts that require lender approval\n    /// @param u address of an underlying asset\n    /// @param a APWine's router contract\n    /// @param e Element's vault contract\n    /// @param n Notional's token contract\n    function approve(\n        address u,\n        address a,\n        address e,\n        address n\n    ) external authorized(marketPlace) {\n        uint256 max = type(uint256).max;\n        IERC20 uToken = IERC20(u);\n        if (a != address(0)) {\n            Safe.approve(uToken, a, max);\n        }\n        if (e != address(0)) {\n            Safe.approve(uToken, e, max);\n        }\n        if (n != address(0)) {\n            Safe.approve(uToken, n, max);\n        }\n        if (IERC20(u).allowance(address(this), swivelAddr) == 0) {\n            Safe.approve(uToken, swivelAddr, max);\n        }\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (block.timestamp < feeTime) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for Illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on Illuminate\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) external unpaused(u, m, p) returns (bool) {\n        // Fetch the desired principal token\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer the users principal tokens to the lender contract\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n\n        // Mint the tokens received from the user\n        IERC5095(principalToken(u, m)).authMint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n\n    /// @notice lend method for the Illuminate and Yield protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y Yield Space Pool for the principal token\n    /// @param minimum slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y,\n        uint256 minimum\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Check that the principal is Illuminate or Yield\n        if (\n            p != uint8(MarketPlace.Principals.Illuminate) &&\n            p != uint8(MarketPlace.Principals.Yield)\n        ) {\n            revert Exception(6, 0, 0, address(0), address(0));\n        }\n\n        // Get principal token for this market\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Extract fee\n        fees[u] = fees[u] + a / feenominator;\n\n        // Transfer underlying from user to the lender contract\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Make sure the Yield Space Pool matches principal token\n            address fyToken = IYield(y).fyToken();\n            if (IYield(y).fyToken() != principal) {\n                revert Exception(12, 0, 0, fyToken, principal);\n            }\n        }\n\n        // Swap underlying for PTs to lender\n        uint256 returned = yield(\n            u,\n            y,\n            a - a / feenominator,\n            address(this),\n            principal,\n            minimum\n        );\n\n        // Mint Illuminate PTs to msg.sender\n        IERC5095(principalToken(u, m)).authMint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned, a, msg.sender);\n\n        return returned;\n    }\n\n    /// @notice lend method signature for Swivel\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a array of amounts of underlying tokens lent to each order in the orders array\n    /// @param y Yield Space Pool for the Illuminate PT in this market\n    /// @param o array of Swivel orders being filled\n    /// @param s array of signatures for each order in the orders array\n    /// @param e flag to indicate if returned funds should be swapped in Yield Space Pool\n    /// @param premiumSlippage slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] memory a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s,\n        bool e,\n        uint256 premiumSlippage\n    ) external unpaused(u, m, p) returns (uint256) {\n        {\n            // Check that the principal is Swivel\n            if (p != uint8(MarketPlace.Principals.Swivel)) {\n                revert Exception(\n                    6,\n                    p,\n                    uint8(MarketPlace.Principals.Swivel),\n                    address(0),\n                    address(0)\n                );\n            }\n\n            // Lent represents the total amount of underlying to be lent\n            uint256 lent = swivelAmount(a);\n\n            // Transfer underlying token from user to Illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n\n            // Get the underlying balance prior to calling initiate\n            uint256 starting = IERC20(u).balanceOf(address(this));\n\n            // Verify and collect the fee\n            {\n                // Calculate fee for the total amount to be lent\n                uint256 fee = lent / feenominator;\n\n                // Get last order to be processed's index\n                uint256 lastIndex = a.length - 1;\n\n                // Add the accumulated fees to the total\n                a[lastIndex] = a[lastIndex] - fee; // Revert here if fee not paid\n\n                // Extract fee\n                fees[u] += fee;\n            }\n\n            uint256 received;\n            {\n                // Get the starting amount of principal tokens\n                uint256 startingZcTokens = IERC20(\n                    IMarketPlace(marketPlace).token(u, m, p)\n                ).balanceOf(address(this));\n\n                // Fill the given orders on Swivel\n                ISwivel(swivelAddr).initiate(o, a, s);\n\n                if (e) {\n                    // Calculate the premium\n                    uint256 premium = IERC20(u).balanceOf(address(this)) -\n                        starting;\n\n                    // Swap the premium for Illuminate principal tokens\n                    swivelLendPremium(u, m, y, premium, premiumSlippage);\n                }\n\n                // Compute how many principal tokens were received\n                received =\n                    IERC20(IMarketPlace(marketPlace).token(u, m, p)).balanceOf(\n                        address(this)\n                    ) -\n                    startingZcTokens;\n            }\n\n            // Mint Illuminate principal tokens to the user\n            IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n            {\n                emit Lend(\n                    uint8(MarketPlace.Principals.Swivel),\n                    u,\n                    m,\n                    received,\n                    lent,\n                    msg.sender\n                );\n            }\n            return received;\n        }\n    }\n\n    /// @notice lend method signature for Element\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param e Element pool that is lent to\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address e,\n        bytes32 i\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Get the principal token for this market for Element\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer underlying token from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Track the accumulated fees\n        fees[u] = fees[u] + a / feenominator;\n\n        uint256 purchased;\n        {\n            // Calculate the amount to be lent\n            uint256 lent = a - a / feenominator;\n\n            // Create the variables needed to execute an Element swap\n            Element.FundManagement memory fund = Element.FundManagement({\n                sender: address(this),\n                recipient: payable(address(this)),\n                fromInternalBalance: false,\n                toInternalBalance: false\n            });\n\n            Element.SingleSwap memory swap = Element.SingleSwap({\n                poolId: i,\n                amount: lent,\n                kind: Element.SwapKind.GIVEN_IN,\n                assetIn: IAny(u),\n                assetOut: IAny(principal),\n                userData: '0x00000000000000000000000000000000000000000000000000000000000000'\n            });\n\n            // Conduct the swap on Element\n            purchased = elementSwap(e, swap, fund, r, d);\n        }\n\n        // Mint tokens to the user\n        IERC5095(principalToken(u, m)).authMint(msg.sender, purchased);\n\n        emit Lend(p, u, m, purchased, a, msg.sender);\n        return purchased;\n    }\n\n    /// @notice lend method signature for Pendle\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 returned;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            address[] memory path = new address[](2);\n            path[0] = u;\n            path[1] = principal;\n\n            // Swap on the Pendle Router using the provided market and params\n            returned = IPendle(pendleAddr).swapExactTokensForTokens(\n                a - fee,\n                r,\n                path,\n                address(this),\n                d\n            )[1];\n        }\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned, a, msg.sender);\n        return returned;\n    }\n\n    /// @notice lend method signature for APWine\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param x APWine router that executes the swap\n    /// @param pool the AMM pool used by APWine to execute the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address x,\n        address pool\n    ) external unpaused(u, m, p) returns (uint256) {\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            // Calculate amount to be lent out\n            lent = a - fee;\n        }\n\n        // Get the starting APWine token balance\n        uint256 starting = IERC20(principal).balanceOf(address(this));\n\n        // Swap on the APWine Pool using the provided market and params\n        IAPWineRouter(x).swapExactAmountIn(\n            pool,\n            apwinePairPath(),\n            apwineTokenPath(),\n            lent,\n            r,\n            address(this),\n            d,\n            address(0)\n        );\n\n        // Calculate the amount of APWine principal tokens received after the swap\n        uint256 received = IERC20(principal).balanceOf(address(this)) -\n            starting;\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice lend method signature for Tempus\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return when executing the swap (sets a limit to slippage)\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param x Tempus AMM that executes the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address x\n    ) external unpaused(u, m, p) returns (uint256) {\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            // Calculate amount to be lent out\n            lent = a - fee;\n        }\n\n        // Get the starting balance of the principal token\n        uint256 start = IERC20(principal).balanceOf(address(this));\n\n        // Get the Tempus Router from the principal token\n        address controller = ITempusPool(ITempusToken(principal).pool())\n            .controller();\n\n        // Swap on the Tempus Router using the provided market and params\n        ITempus(controller).depositAndFix(x, lent, true, r, d);\n\n        // Calculate the amount of Tempus principal tokens received after the deposit\n        uint256 received = IERC20(principal).balanceOf(address(this)) - start;\n\n        // Verify that a minimum number of principal tokens were received\n        if (received < r) {\n            revert Exception(11, received, r, address(0), address(0));\n        }\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice lend method signature for Sense\n    /// @dev this method can be called before maturity to lend to Sense while minting Illuminate tokens\n    /// @dev Sense provides a [divider] contract that splits [target] assets (underlying) into PTs and YTs. Each [target] asset has a [series] of contracts, each identifiable by their [maturity].\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param x AMM that is used to conduct the swap\n    /// @param s Sense's maturity for the given market\n    /// @param adapter Sense's adapter necessary to facilitate the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint128 a,\n        uint256 r,\n        address x,\n        uint256 s,\n        address adapter\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Retrieve the principal token for this market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).token(u, m, p));\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Determine the fee\n        uint256 fee = a / feenominator;\n\n        // Add the accumulated fees to the total\n        fees[u] = fees[u] + fee;\n\n        // Determine lent amount after fees\n        uint256 lent = a - fee;\n\n        // Stores the amount of principal tokens received in swap for underlying\n        uint256 received;\n        {\n            // Get the starting balance of the principal token\n            uint256 starting = token.balanceOf(address(this));\n\n            // Swap those tokens for the principal tokens\n            ISensePeriphery(x).swapUnderlyingForPTs(adapter, s, lent, r);\n\n            // Calculate number of principal tokens received in the swap\n            received = token.balanceOf(address(this)) - starting;\n\n            // Verify that we received the principal tokens\n            if (received < r) {\n                revert Exception(11, 0, 0, address(0), address(0));\n            }\n        }\n\n        // Mint the Illuminate tokens based on the returned amount\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n\n    /// @dev lend method signature for Notional\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Instantiate Notional princpal token\n        address token = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Add the accumulated fees to the total\n        uint256 fee = a / feenominator;\n        fees[u] = fees[u] + fee;\n\n        // Swap on the Notional Token wrapper\n        uint256 received = INotional(token).deposit(a - fee, address(this));\n\n        // Verify that we received the principal tokens\n        if (received < r) {\n            revert Exception(16, received, r, address(0), address(0));\n        }\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice allows the admin to schedule the withdrawal of tokens\n    /// @param e address of (erc20) token to withdraw\n    /// @return bool true if successful\n    function scheduleWithdrawal(address e)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        uint256 when = block.timestamp + HOLD;\n\n        withdrawals[e] = when;\n\n        emit ScheduleWithdrawal(e, when);\n        return true;\n    }\n\n    /// @notice emergency function to block unplanned withdrawals\n    /// @param e address of token withdrawal to block\n    /// @return bool true if successful\n    function blockWithdrawal(address e)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        delete withdrawals[e];\n\n        emit BlockWithdrawal(e);\n        return true;\n    }\n\n    /// @notice allows the admin to schedule a change to the fee denominators\n    function scheduleFeeChange() external authorized(admin) returns (bool) {\n        uint256 when = block.timestamp + HOLD;\n        feeChange = when;\n\n        emit ScheduleFeeChange(when);\n\n        return true;\n    }\n\n    /// @notice Emergency function to block unplanned changes to fee structure\n    function blockFeeChange() external authorized(admin) returns (bool) {\n        delete feeChange;\n\n        emit BlockFeeChange();\n\n        return true;\n    }\n\n    /// @notice allows the admin to withdraw the given token, provided the holding period has been observed\n    /// @param e Address of token to withdraw\n    /// @return bool true if successful\n    function withdraw(address e) external authorized(admin) returns (bool) {\n        uint256 when = withdrawals[e];\n        if (when == 0) {\n            revert Exception(18, 0, 0, address(0), address(0));\n        }\n\n        if (block.timestamp < when) {\n            revert Exception(19, 0, 0, address(0), address(0));\n        }\n\n        delete withdrawals[e];\n\n        delete fees[e];\n\n        IERC20 token = IERC20(e);\n        Safe.transfer(token, admin, token.balanceOf(address(this)));\n\n        return true;\n    }\n\n    /// @notice withdraws accumulated lending fees of the underlying token\n    /// @param e address of the underlying token to withdraw\n    /// @return bool true if successful\n    function withdrawFee(address e) external authorized(admin) returns (bool) {\n        // Get the token to be withdrawn\n        IERC20 token = IERC20(e);\n\n        // Get the balance to be transferred\n        uint256 balance = fees[e];\n\n        // Reset accumulated fees of the token to 0\n        fees[e] = 0;\n\n        // Transfer the accumulated fees to the admin\n        Safe.transfer(token, admin, balance);\n\n        return true;\n    }\n\n    /// @notice pauses a market and prevents execution of all lending for that principal\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param b bool representing whether to pause or unpause\n    /// @return bool true if successful\n    function pause(\n        address u,\n        uint256 m,\n        uint8 p,\n        bool b\n    ) external authorized(admin) returns (bool) {\n        paused[u][m][p] = b;\n        emit PauseMarket(p, u, m, IMarketPlace(marketPlace).token(u, m, p), b);\n        return true;\n    }\n\n    /// @notice Tranfers FYTs for APWine redemptions\n    /// @param f FYT contract address\n    /// @param a amount of tokens to send to the redeemer\n    function transferFYTs(address f, uint256 a)\n        external\n        authorized(IMarketPlace(marketPlace).redeemer())\n    {\n        Safe.transfer(IERC20(f), IMarketPlace(marketPlace).redeemer(), a);\n    }\n\n    /// @notice Allows batched call to self (this contract).\n    /// @param c An array of inputs for each call.\n    function batch(bytes[] calldata c)\n        external\n        payable\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](c.length);\n\n        for (uint256 i; i < c.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                c[i]\n            );\n\n            if (!success) revert(RevertMsgE"
    }
  ]
}