{
  "Title": "M-2: Mint limit is not reduced when the Vault is burning TAU",
  "Content": "# Issue M-2: Mint limit is not reduced when the Vault is burning TAU \n\nSource: https://github.com/sherlock-audit/2023-03-taurus-judging/issues/149 \n\n## Found by \nSunSec, GimelSec, chaduke, shaka, tvdung94, Ruhum, cducrest-brainbot, nobody2018, Chinmay, duc, LethL, y1cunhui, mstpr-brainbot, HonorLt, 8olidity, bytes032\n\n## Summary\n\nUpon burning TAU, it incorrectly updates the `currentMinted` when Vault is acting on behalf of users.\n\n## Vulnerability Detail\n\nWhen the burn of `TAU` is performed, it calls `_decreaseCurrentMinted` to reduce the limit of tokens minted by the Vault:\n```solidity\n    function _decreaseCurrentMinted(address account, uint256 amount) internal virtual {\n        // If the burner is a vault, subtract burnt TAU from its currentMinted.\n        // This has a few highly unimportant edge cases which can generally be rectified by increasing the relevant vault's mintLimit.\n        uint256 accountMinted = currentMinted[account];\n        if (accountMinted >= amount) {\n            currentMinted[msg.sender] = accountMinted - amount;\n        }\n    }\n```\n\nThe issue is that it subtracts `accountMinted` (which is `currentMinted[account]`) from `currentMinted[msg.sender]`. When the vault is burning tokens on behalf of the user, the `account` != `msg.sender` meaning the `currentMinted[account]` is 0, and thus the `currentMinted` of Vault will be reduced by 0 making it pretty useless.\n\nAnother issue is that users can transfer their `TAU` between accounts, and then `amount > accountMinted` will not be triggered.\n\n## Impact\n\n`currentMinted` is incorrectly decreased upon burning so vaults do not get more space to mint new tokens.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/TAU.sol#L76-L83\n\n## Tool used\n\nManual Review\n\n## Recommendation\nA simple solution would be to:\n```solidity\n     uint256 accountMinted = currentMinted[msg.sender];\n```\nBut I suggest revisiting and rethinking this function altogether.\n\n## Discussion\n\n**Sierraescape**\n\nhttps://github.com/protokol/taurus-contracts/pull/85\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/45",
  "Code": [
    {
      "filename": "taurus-contracts/contracts/TAU.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC20Burnable } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\nerror notGovernance();\nerror mintLimitExceeded(uint256 newAmount, uint256 maxMintAmount);\n\ncontract TAU is ERC20, ERC20Burnable {\n    address public governance;\n\n    // Max amount of tokens which a given vault can mint. Since this is set to zero by default, there is no need to register vaults.\n    mapping(address => uint256) public mintLimit;\n    mapping(address => uint256) public currentMinted;\n\n    constructor(address _governance) ERC20(\"TAU\", \"TAU\") {\n        governance = _governance;\n    }\n\n    /**\n     * @dev Set new mint limit for a given vault. Only governance can call this function.\n     * note if the new limit is lower than the vault's current amount minted, this will disable future mints for that vault,\n        but will do nothing to its existing minted amount.\n     * @param vault The address of the vault whose mintLimit will be updated\n     * @param newLimit The new mint limit for the target vault\n     */\n    function setMintLimit(address vault, uint256 newLimit) external {\n        if (msg.sender != governance) {\n            revert notGovernance();\n        }\n        mintLimit[vault] = newLimit;\n    }\n\n    function mint(address recipient, uint256 amount) external {\n        // Check whether mint amount exceeds mintLimit for msg.sender\n        uint256 newMinted = currentMinted[msg.sender] + amount;\n        if (newMinted > mintLimit[msg.sender]) {\n            revert mintLimitExceeded(newMinted, mintLimit[msg.sender]);\n        }\n\n        // Update vault currentMinted\n        currentMinted[msg.sender] = newMinted;\n\n        // Mint TAU to recipient\n        _mint(recipient, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual override {\n        address account = _msgSender();\n        _burn(account, amount);\n        _decreaseCurrentMinted(account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance. Also decreases the burner's currentMinted amount if the burner is a vault.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual override {\n        super.burnFrom(account, amount);\n        _decreaseCurrentMinted(account, amount);\n    }\n\n    function _decreaseCurrentMinted(address account, uint256 amount) internal virtual {\n        // If the burner is a vault, subtract burnt TAU from its currentMinted.\n        // This has a few highly unimportant edge cases which can generally be rectified by increasing the relevant vault's mintLimit.\n        uint256 accountMinted = currentMinted[account];\n        if (accountMinted >= amount) {\n            currentMinted[msg.sender] = accountMinted - amount;\n        }\n    }\n}"
    }
  ]
}