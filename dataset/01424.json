{
  "Title": "M-13: Vault cannot be added back into the vault registry",
  "Content": "# Issue M-13: Vault cannot be added back into the vault registry \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/674 \n\n## Found by \n0x70C9, AuditorPraise, Aymen0909, KingNFT, Phantasmagoria, ast3ros, carrotsmuggler, dipp, techOptimizor, xiaoming90\n\nThe vault registry does not clear the vault type mapping when removing a vault, which prevents the same vault from being added back later.\n\n## Vulnerability Detail\n\nWhen removing a vault from the registry, all states related to the vaults such as the `_vaults`, `_assets`, `_vaultsByAsset` are cleared except the `_vaultsByType` state.\n\n        function removeVault(address vaultAddress) external onlyUpdater {\n            Errors.verifyNotZero(vaultAddress, \"vaultAddress\");\n\n            // remove from vaults list\n            if (!_vaults.remove(vaultAddress)) revert VaultNotFound(vaultAddress);\n\n            address asset = ILMPVault(vaultAddress).asset();\n\n            // remove from assets list if this was the last vault for that asset\n            if (_vaultsByAsset[asset].length() == 1) {\n                //slither-disable-next-line unused-return\n                _assets.remove(asset);\n            }\n\n            // remove from vaultsByAsset mapping\n            if (!_vaultsByAsset[asset].remove(vaultAddress)) revert VaultNotFound(vaultAddress);\n\n            emit VaultRemoved(asset, vaultAddress);\n        }\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/LMPVaultRegistry.sol#L64-L82\n\nThe uncleared `_vaultsByType` state will cause the `addVault` function to revert when trying to add the vault back into the registry even though the vault does not exist in the registry anymore.\n\n        if (!_vaultsByType[vaultType].add(vaultAddress)) revert VaultAlreadyExists(vaultAddress);\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/LMPVaultRegistry.sol#L59\n\n## Impact\n\nThe `addVault` function is broken in the edge case when the updater tries to add the vault back into the registry after removing it. It affects all the operations of the protocol that rely on the vault registry.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/LMPVaultRegistry.sol#L64-L82\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nClear the `_vaultsByType` state when removing the vault from the registry.\n\n```diff\n\n        function removeVault(address vaultAddress) external onlyUpdater {\n            Errors.verifyNotZero(vaultAddress, \"vaultAddress\");\n+            ILMPVault vault = ILMPVault(vaultAddress);\n+            bytes32 vaultType = vault.vaultType();\n\n            // remove from vaults list\n            if (!_vaults.remove(vaultAddress)) revert VaultNotFound(vaultAddress);\n\n            address asset = ILMPVault(vaultAddress).asset();\n\n            // remove from assets list if this was the last vault for that asset\n            if (_vaultsByAsset[asset].length() == 1) {\n                //slither-disable-next-line unused-return\n                _assets.remove(asset);\n            }\n\n            // remove from vaultsByAsset mapping\n            if (!_vaultsByAsset[asset].remove(vaultAddress)) revert VaultNotFound(vaultAddress);\n+           if (!_vaultsByType[vaultType].remove(vaultAddress)) revert VaultNotFound(vaultAddress);\n\n            emit VaultRemoved(asset, vaultAddress);\n        }\n\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/LMPVaultRegistry.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { AccessControl } from \"openzeppelin-contracts/access/AccessControl.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\n\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { VaultTypes } from \"src/vault/VaultTypes.sol\";\n\nimport { ILMPVaultRegistry } from \"src/interfaces/vault/ILMPVaultRegistry.sol\";\nimport { ILMPVault } from \"src/interfaces/vault/ILMPVault.sol\";\n\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\n\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\n\ncontract LMPVaultRegistry is SystemComponent, ILMPVaultRegistry, SecurityBase {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    EnumerableSet.AddressSet private _vaults;\n    EnumerableSet.AddressSet private _assets;\n\n    // registry of vaults for a given asset\n    mapping(address => EnumerableSet.AddressSet) private _vaultsByAsset;\n    // registry of vaults for a given type\n    mapping(bytes32 => EnumerableSet.AddressSet) private _vaultsByType;\n\n    constructor(ISystemRegistry _systemRegistry)\n        SystemComponent(_systemRegistry)\n        SecurityBase(address(_systemRegistry.accessController()))\n    { }\n\n    modifier onlyUpdater() {\n        if (!_hasRole(Roles.REGISTRY_UPDATER, msg.sender)) revert Errors.AccessDenied();\n        _;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n    //\n    //                        Update Methods\n    //\n    ///////////////////////////////////////////////////////////////////\n\n    function addVault(address vaultAddress) external onlyUpdater {\n        Errors.verifyNotZero(vaultAddress, \"vaultAddress\");\n\n        ILMPVault vault = ILMPVault(vaultAddress);\n\n        address asset = vault.asset();\n        bytes32 vaultType = vault.vaultType();\n\n        if (!_vaults.add(vaultAddress)) revert VaultAlreadyExists(vaultAddress);\n        //slither-disable-next-line unused-return\n        if (!_assets.contains(asset)) _assets.add(asset);\n\n        if (!_vaultsByAsset[asset].add(vaultAddress)) revert VaultAlreadyExists(vaultAddress);\n        if (!_vaultsByType[vaultType].add(vaultAddress)) revert VaultAlreadyExists(vaultAddress);\n\n        emit VaultAdded(asset, vaultAddress);\n    }\n\n    function removeVault(address vaultAddress) external onlyUpdater {\n        Errors.verifyNotZero(vaultAddress, \"vaultAddress\");\n\n        // remove from vaults list\n        if (!_vaults.remove(vaultAddress)) revert VaultNotFound(vaultAddress);\n\n        address asset = ILMPVault(vaultAddress).asset();\n\n        // remove from assets list if this was the last vault for that asset\n        if (_vaultsByAsset[asset].length() == 1) {\n            //slither-disable-next-line unused-return\n            _assets.remove(asset);\n        }\n\n        // remove from vaultsByAsset mapping\n        if (!_vaultsByAsset[asset].remove(vaultAddress)) revert VaultNotFound(vaultAddress);\n\n        emit VaultRemoved(asset, vaultAddress);\n    }\n\n    ///////////////////////////////////////////////////////////////////\n    //\n    //                        Enumeration Methods\n    //\n    ///////////////////////////////////////////////////////////////////\n\n    function isVault(address vaultAddress) external view override returns (bool) {\n        return _vaults.contains(vaultAddress);\n    }\n\n    function listVaults() external view returns (address[] memory) {\n        return _vaults.values();\n    }\n\n    function listVaultsForAsset(address asset) external view returns (address[] memory) {\n        return _vaultsByAsset[asset].values();\n    }\n\n    function listVaultsForType(bytes32 _vaultType) external view returns (address[] memory) {\n        return _vaultsByType[_vaultType].values();\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/LMPVaultRegistry.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { AccessControl } from \"openzeppelin-contracts/access/AccessControl.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\n\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { VaultTypes } from \"src/vault/VaultTypes.sol\";\n\nimport { ILMPVaultRegistry } from \"src/interfaces/vault/ILMPVaultRegistry.sol\";\nimport { ILMPVault } from \"src/interfaces/vault/ILMPVault.sol\";\n\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\n\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\n\ncontract LMPVaultRegistry is SystemComponent, ILMPVaultRegistry, SecurityBase {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    EnumerableSet.AddressSet private _vaults;\n    EnumerableSet.AddressSet private _assets;\n\n    // registry of vaults for a given asset\n    mapping(address => EnumerableSet.AddressSet) private _vaultsByAsset;\n    // registry of vaults for a given type\n    mapping(bytes32 => EnumerableSet.AddressSet) private _vaultsByType;\n\n    constructor(ISystemRegistry _systemRegistry)\n        SystemComponent(_systemRegistry)\n        SecurityBase(address(_systemRegistry.accessController()))\n    { }\n\n    modifier onlyUpdater() {\n        if (!_hasRole(Roles.REGISTRY_UPDATER, msg.sender)) revert Errors.AccessDenied();\n        _;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n    //\n    //                        Update Methods\n    //\n    ///////////////////////////////////////////////////////////////////\n\n    function addVault(address vaultAddress) external onlyUpdater {\n        Errors.verifyNotZero(vaultAddress, \"vaultAddress\");\n\n        ILMPVault vault = ILMPVault(vaultAddress);\n\n        address asset = vault.asset();\n        bytes32 vaultType = vault.vaultType();\n\n        if (!_vaults.add(vaultAddress)) revert VaultAlreadyExists(vaultAddress);\n        //slither-disable-next-line unused-return\n        if (!_assets.contains(asset)) _assets.add(asset);\n\n        if (!_vaultsByAsset[asset].add(vaultAddress)) revert VaultAlreadyExists(vaultAddress);\n        if (!_vaultsByType[vaultType].add(vaultAddress)) revert VaultAlreadyExists(vaultAddress);\n\n        emit VaultAdded(asset, vaultAddress);\n    }\n\n    function removeVault(address vaultAddress) external onlyUpdater {\n        Errors.verifyNotZero(vaultAddress, \"vaultAddress\");\n\n        // remove from vaults list\n        if (!_vaults.remove(vaultAddress)) revert VaultNotFound(vaultAddress);\n\n        address asset = ILMPVault(vaultAddress).asset();\n\n        // remove from assets list if this was the last vault for that asset\n        if (_vaultsByAsset[asset].length() == 1) {\n            //slither-disable-next-line unused-return\n            _assets.remove(asset);\n        }\n\n        // remove from vaultsByAsset mapping\n        if (!_vaultsByAsset[asset].remove(vaultAddress)) revert VaultNotFound(vaultAddress);\n\n        emit VaultRemoved(asset, vaultAddress);\n    }\n\n    ///////////////////////////////////////////////////////////////////\n    //\n    //                        Enumeration Methods\n    //\n    ///////////////////////////////////////////////////////////////////\n\n    function isVault(address vaultAddress) external view override returns (bool) {\n        return _vaults.contains(vaultAddress);\n    }\n\n    function listVaults() external view returns (address[] memory) {\n        return _vaults.values();\n    }\n\n    function listVaultsForAsset(address asset) external view returns (address[] memory) {\n        return _vaultsByAsset[asset].values();\n    }\n\n    function listVaultsForType(bytes32 _vaultType) external view returns (address[] memory) {\n        return _vaultsByType[_vaultType].values();\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/LMPVaultRegistry.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { AccessControl } from \"openzeppelin-contracts/access/AccessControl.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\n\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { VaultTypes } from \"src/vault/VaultTypes.sol\";\n\nimport { ILMPVaultRegistry } from \"src/interfaces/vault/ILMPVaultRegistry.sol\";\nimport { ILMPVault } from \"src/interfaces/vault/ILMPVault.sol\";\n\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\n\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\n\ncontract LMPVaultRegistry is SystemComponent, ILMPVaultRegistry, SecurityBase {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    EnumerableSet.AddressSet private _vaults;\n    EnumerableSet.AddressSet private _assets;\n\n    // registry of vaults for a given asset\n    mapping(address => EnumerableSet.AddressSet) private _vaultsByAsset;\n    // registry of vaults for a given type\n    mapping(bytes32 => EnumerableSet.AddressSet) private _vaultsByType;\n\n    constructor(ISystemRegistry _systemRegistry)\n        SystemComponent(_systemRegistry)\n        SecurityBase(address(_systemRegistry.accessController()))\n    { }\n\n    modifier onlyUpdater() {\n        if (!_hasRole(Roles.REGISTRY_UPDATER, msg.sender)) revert Errors.AccessDenied();\n        _;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n    //\n    //                        Update Methods\n    //\n    ///////////////////////////////////////////////////////////////////\n\n    function addVault(address vaultAddress) external onlyUpdater {\n        Errors.verifyNotZero(vaultAddress, \"vaultAddress\");\n\n        ILMPVault vault = ILMPVault(vaultAddress);\n\n        address asset = vault.asset();\n        bytes32 vaultType = vault.vaultType();\n\n        if (!_vaults.add(vaultAddress)) revert VaultAlreadyExists(vaultAddress);\n        //slither-disable-next-line unused-return\n        if (!_assets.contains(asset)) _assets.add(asset);\n\n        if (!_vaultsByAsset[asset].add(vaultAddress)) revert VaultAlreadyExists(vaultAddress);\n        if (!_vaultsByType[vaultType].add(vaultAddress)) revert VaultAlreadyExists(vaultAddress);\n\n        emit VaultAdded(asset, vaultAddress);\n    }\n\n    function removeVault(address vaultAddress) external onlyUpdater {\n        Errors.verifyNotZero(vaultAddress, \"vaultAddress\");\n\n        // remove from vaults list\n        if (!_vaults.remove(vaultAddress)) revert VaultNotFound(vaultAddress);\n\n        address asset = ILMPVault(vaultAddress).asset();\n\n        // remove from assets list if this was the last vault for that asset\n        if (_vaultsByAsset[asset].length() == 1) {\n            //slither-disable-next-line unused-return\n            _assets.remove(asset);\n        }\n\n        // remove from vaultsByAsset mapping\n        if (!_vaultsByAsset[asset].remove(vaultAddress)) revert VaultNotFound(vaultAddress);\n\n        emit VaultRemoved(asset, vaultAddress);\n    }\n\n    ///////////////////////////////////////////////////////////////////\n    //\n    //                        Enumeration Methods\n    //\n    ///////////////////////////////////////////////////////////////////\n\n    function isVault(address vaultAddress) external view override returns (bool) {\n        return _vaults.contains(vaultAddress);\n    }\n\n    function listVaults() external view returns (address[] memory) {\n        return _vaults.values();\n    }\n\n    function listVaultsForAsset(address asset) external view returns (address[] memory) {\n        return _vaultsByAsset[asset].values();\n    }\n\n    function listVaultsForType(bytes32 _vaultType) external view returns (address[] memory) {\n        return _vaultsByType[_vaultType].values();\n    }\n}"
    }
  ]
}