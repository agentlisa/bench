{
  "Title": "[L-02] `RedeemEvent` emits wrong `to` address",
  "Content": "<h2 id=\"l-02-redeemevent-emits-wrong-to-address\" style=\"position:relative;\"><a href=\"#l-02-redeemevent-emits-wrong-to-address\" aria-label=\"l 02 redeemevent emits wrong to address permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-02] <code>RedeemEvent</code> emits wrong <code>to</code> address</h2>\n<p>In the <code>dMute.RedeemTo</code> function the <code>RedeemEvent</code> is emitted (<a href=\"https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/dao/dMute.sol#L128\">Link</a>).  </p>\n<p>It is defined as:<br>\n<a href=\"https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/dao/dMute.sol#L25\">Link</a>  </p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"33\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">event</span><span class=\"mtk1\"> </span><span class=\"mtk11\">RedeemEvent</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">to</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">unlockedAmount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">burnAmount</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>So the first parameter should be the <code>to</code> address.  </p>\n<p>When the event is emitted the first parameter is <code>msg.sender</code>. The issue is that the <code>to</code> address and <code>msg.sender</code> can be different. So the event in some cases contains wrong information.  </p>\n<p>Fix:  </p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"diff\" data-index=\"34\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">diff --git a/contracts/dao/dMute.sol b/contracts/dao/dMute.sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">index 59f95b7..98a65d5 100644</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">--- a/contracts/dao/dMute.sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">+++ b/contracts/dao/dMute.sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">@@ -125,7 +125,7 @@ contract dMute is dSoulBound {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">         _burn(msg.sender, total_to_burn);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\"> </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\"> </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-        emit RedeemEvent(msg.sender, total_to_redeem, total_to_burn);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+        emit RedeemEvent(to, total_to_redeem, total_to_burn);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">     }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\"> </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">     function GetUserLockLength(address account) public view returns (uint256 amount) {</span></span></span></code></pre>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2023-03-mute-switch-versus-contest",
  "Code": [
    {
      "filename": "contracts/dao/dMute.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../interfaces/IERC20.sol';\nimport '../libraries/SafeMath.sol';\nimport './dSoulBound.sol';\n\n/// @notice Mute DAO token, untransferrable\ncontract dMute is dSoulBound {\n    using SafeMath for uint;\n\n    address public MuteToken;\n\n    struct UserLockInfo {\n      uint256 amount;\n      uint256 time;\n      uint256 tokens_minted;\n    }\n\n    mapping(address => UserLockInfo[]) public _userLocks;\n\n    uint private unlocked = 1;\n\n    event LockEvent(address to, uint256 lockAmount, uint256 mintedAmount, uint256 totalTime);\n    event RedeemEvent(address to, uint256 unlockedAmount, uint256 burnAmount);\n\n    modifier nonReentrant() {\n        require(unlocked == 1, 'dMute::ReentrancyGuard: REENTRANT_CALL');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    /// @dev Expects a LP token address & the base reward muteToken address\n    constructor (address _muteToken) {\n        require(_muteToken != address(0), \"MuteAmplifier: invalid muteToken\");\n        MuteToken = _muteToken;\n    }\n\n    /*\n    function lockBonus(uint256 lock_time) internal view returns (uint256){\n        uint256 week_time = 60 * 60 * 24 * 7;\n        uint256 max_lock = week_time.mul(52 * 2); // 2 years\n\n        return lock_time.mul(10**18).div(max_lock).mul(10);\n    }\n    */\n\n    function timeToTokens(uint256 _amount, uint256 _lock_time) internal pure returns (uint256){\n        uint256 week_time = 1 weeks;\n        uint256 max_lock = 52 weeks;\n\n        require(_lock_time >= week_time, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n        require(_lock_time <= max_lock, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n\n        // amount * % of time locked up from min to max\n        uint256 base_tokens = _amount.mul(_lock_time.mul(10**18).div(max_lock)).div(10**18);\n        // apply % min max bonus\n        //uint256 boosted_tokens = base_tokens.mul(lockBonus(lock_time)).div(10**18);\n\n        return base_tokens;\n    }\n\n    function Lock(uint256 _amount, uint256 _lock_time) public {\n        LockTo(_amount, _lock_time, msg.sender);\n    }\n\n    function LockTo(uint256 _amount, uint256 _lock_time, address to) public nonReentrant {\n        require(IERC20(MuteToken).balanceOf(msg.sender) >= _amount, \"dMute::Lock: INSUFFICIENT_BALANCE\");\n\n        //transfer tokens to this contract\n        IERC20(MuteToken).transferFrom(msg.sender, address(this), _amount);\n\n        // calculate dTokens to mint\n        uint256 tokens_to_mint = timeToTokens(_amount, _lock_time);\n\n        require(tokens_to_mint > 0, 'dMute::Lock: INSUFFICIENT_TOKENS_MINTED');\n\n        _mint(to, tokens_to_mint);\n\n        _userLocks[to].push(UserLockInfo(_amount, block.timestamp.add(_lock_time), tokens_to_mint));\n\n        emit LockEvent(to, _amount, tokens_to_mint, _lock_time);\n    }\n\n    function Redeem(uint256[] memory lock_index) public {\n        RedeemTo(lock_index, msg.sender);\n    }\n\n    function RedeemTo(uint256[] memory lock_index, address to) public nonReentrant {\n        uint256 total_to_redeem = 0;\n        uint256 total_to_burn = 0;\n\n        for(uint256 i; i < lock_index.length; i++){\n          uint256 index = lock_index[i];\n          UserLockInfo memory lock_info = _userLocks[msg.sender][index];\n\n          require(block.timestamp >= lock_info.time, \"dMute::Redeem: INSUFFICIENT_LOCK_TIME\");\n          require(lock_info.amount >= 0 , \"dMute::Redeem: INSUFFICIENT_AMOUNT\");\n          require(lock_info.tokens_minted >= 0 , \"dMute::Redeem: INSUFFICIENT_MINT_AMOUNT\");\n\n          total_to_redeem = total_to_redeem.add(lock_info.amount);\n          total_to_burn = total_to_burn.add(lock_info.tokens_minted);\n\n          _userLocks[msg.sender][index] = UserLockInfo(0,0,0);\n        }\n\n        require(total_to_redeem > 0, \"dMute::Lock: INSUFFICIENT_REDEEM_AMOUNT\");\n        require(total_to_burn > 0, \"dMute::Lock: INSUFFICIENT_BURN_AMOUNT\");\n\n\n        for(uint256 i = _userLocks[msg.sender].length; i > 0; i--){\n          UserLockInfo memory lock_info = _userLocks[msg.sender][i - 1];\n\n          // recently redeemed lock, destroy it\n          if(lock_info.time == 0){\n            _userLocks[msg.sender][i - 1] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1];\n            _userLocks[msg.sender].pop();\n          }\n        }\n\n        //redeem tokens to user\n        IERC20(MuteToken).transfer(to, total_to_redeem);\n        //burn dMute\n        _burn(msg.sender, total_to_burn);\n\n\n        emit RedeemEvent(msg.sender, total_to_redeem, total_to_burn);\n    }\n\n    function GetUserLockLength(address account) public view returns (uint256 amount) {\n        amount = _userLocks[account].length;\n    }\n\n    function GetUnderlyingTokens(address account) public view returns(uint256 amount) {\n        for(uint256 i; i < _userLocks[account].length; i++){\n          amount = amount.add(_userLocks[account][i].amount);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/dao/dMute.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../interfaces/IERC20.sol';\nimport '../libraries/SafeMath.sol';\nimport './dSoulBound.sol';\n\n/// @notice Mute DAO token, untransferrable\ncontract dMute is dSoulBound {\n    using SafeMath for uint;\n\n    address public MuteToken;\n\n    struct UserLockInfo {\n      uint256 amount;\n      uint256 time;\n      uint256 tokens_minted;\n    }\n\n    mapping(address => UserLockInfo[]) public _userLocks;\n\n    uint private unlocked = 1;\n\n    event LockEvent(address to, uint256 lockAmount, uint256 mintedAmount, uint256 totalTime);\n    event RedeemEvent(address to, uint256 unlockedAmount, uint256 burnAmount);\n\n    modifier nonReentrant() {\n        require(unlocked == 1, 'dMute::ReentrancyGuard: REENTRANT_CALL');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    /// @dev Expects a LP token address & the base reward muteToken address\n    constructor (address _muteToken) {\n        require(_muteToken != address(0), \"MuteAmplifier: invalid muteToken\");\n        MuteToken = _muteToken;\n    }\n\n    /*\n    function lockBonus(uint256 lock_time) internal view returns (uint256){\n        uint256 week_time = 60 * 60 * 24 * 7;\n        uint256 max_lock = week_time.mul(52 * 2); // 2 years\n\n        return lock_time.mul(10**18).div(max_lock).mul(10);\n    }\n    */\n\n    function timeToTokens(uint256 _amount, uint256 _lock_time) internal pure returns (uint256){\n        uint256 week_time = 1 weeks;\n        uint256 max_lock = 52 weeks;\n\n        require(_lock_time >= week_time, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n        require(_lock_time <= max_lock, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n\n        // amount * % of time locked up from min to max\n        uint256 base_tokens = _amount.mul(_lock_time.mul(10**18).div(max_lock)).div(10**18);\n        // apply % min max bonus\n        //uint256 boosted_tokens = base_tokens.mul(lockBonus(lock_time)).div(10**18);\n\n        return base_tokens;\n    }\n\n    function Lock(uint256 _amount, uint256 _lock_time) public {\n        LockTo(_amount, _lock_time, msg.sender);\n    }\n\n    function LockTo(uint256 _amount, uint256 _lock_time, address to) public nonReentrant {\n        require(IERC20(MuteToken).balanceOf(msg.sender) >= _amount, \"dMute::Lock: INSUFFICIENT_BALANCE\");\n\n        //transfer tokens to this contract\n        IERC20(MuteToken).transferFrom(msg.sender, address(this), _amount);\n\n        // calculate dTokens to mint\n        uint256 tokens_to_mint = timeToTokens(_amount, _lock_time);\n\n        require(tokens_to_mint > 0, 'dMute::Lock: INSUFFICIENT_TOKENS_MINTED');\n\n        _mint(to, tokens_to_mint);\n\n        _userLocks[to].push(UserLockInfo(_amount, block.timestamp.add(_lock_time), tokens_to_mint));\n\n        emit LockEvent(to, _amount, tokens_to_mint, _lock_time);\n    }\n\n    function Redeem(uint256[] memory lock_index) public {\n        RedeemTo(lock_index, msg.sender);\n    }\n\n    function RedeemTo(uint256[] memory lock_index, address to) public nonReentrant {\n        uint256 total_to_redeem = 0;\n        uint256 total_to_burn = 0;\n\n        for(uint256 i; i < lock_index.length; i++){\n          uint256 index = lock_index[i];\n          UserLockInfo memory lock_info = _userLocks[msg.sender][index];\n\n          require(block.timestamp >= lock_info.time, \"dMute::Redeem: INSUFFICIENT_LOCK_TIME\");\n          require(lock_info.amount >= 0 , \"dMute::Redeem: INSUFFICIENT_AMOUNT\");\n          require(lock_info.tokens_minted >= 0 , \"dMute::Redeem: INSUFFICIENT_MINT_AMOUNT\");\n\n          total_to_redeem = total_to_redeem.add(lock_info.amount);\n          total_to_burn = total_to_burn.add(lock_info.tokens_minted);\n\n          _userLocks[msg.sender][index] = UserLockInfo(0,0,0);\n        }\n\n        require(total_to_redeem > 0, \"dMute::Lock: INSUFFICIENT_REDEEM_AMOUNT\");\n        require(total_to_burn > 0, \"dMute::Lock: INSUFFICIENT_BURN_AMOUNT\");\n\n\n        for(uint256 i = _userLocks[msg.sender].length; i > 0; i--){\n          UserLockInfo memory lock_info = _userLocks[msg.sender][i - 1];\n\n          // recently redeemed lock, destroy it\n          if(lock_info.time == 0){\n            _userLocks[msg.sender][i - 1] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1];\n            _userLocks[msg.sender].pop();\n          }\n        }\n\n        //redeem tokens to user\n        IERC20(MuteToken).transfer(to, total_to_redeem);\n        //burn dMute\n        _burn(msg.sender, total_to_burn);\n\n\n        emit RedeemEvent(msg.sender, total_to_redeem, total_to_burn);\n    }\n\n    function GetUserLockLength(address account) public view returns (uint256 amount) {\n        amount = _userLocks[account].length;\n    }\n\n    function GetUnderlyingTokens(address account) public view returns(uint256 amount) {\n        for(uint256 i; i < _userLocks[account].length; i++){\n          amount = amount.add(_userLocks[account][i].amount);\n        }\n    }\n}"
    }
  ]
}