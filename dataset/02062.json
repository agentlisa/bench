{
  "Title": "M-3: Adversary can utilize a large number of their own loans to cheat other lenders out of interest",
  "Content": "# Issue M-3: Adversary can utilize a large number of their own loans to cheat other lenders out of interest \n\nSource: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/24 \n\n## Found by \n0x52, GimelSec\n\n## Summary\n\nThe minimal interest paid by a loan is scaled by the number of provisions that make up the loan. By inflating the number of provisions with their own provisions then can cause legitimate lenders to receive a much lower interest rate than intended.\n\n## Vulnerability Detail\n\n[ClaimFacet.sol#L94-L106](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L94-L106)\n\n    function sendInterests(Loan storage loan, Provision storage provision) internal returns (uint256 sent) {\n        uint256 interests = loan.payment.paid - loan.lent;\n        if (interests == loan.payment.minInterestsToRepay) {\n            // this is the case if the loan is repaid shortly after issuance\n            // each lender gets its minimal interest, as an anti ddos measure to spam offer\n            sent = provision.amount + (interests / loan.nbOfPositions);\n        } else {\n            /* provision.amount / lent = share of the interests belonging to the lender. The parenthesis make the\n            calculus in the order that maximizes precison */\n            sent = provision.amount + (interests * (provision.amount)) / loan.lent;\n        }\n        loan.assetLent.checkedTransfer(msg.sender, sent);\n    }\n\nIf a loan is paid back before the minimal interest rate has been reached then each provision will receive the unweighted minimal interest amount. This can be abused to take loans that pay legitimate lenders a lower APR than expected, cheating them of their yield.\n\nExample:\nA user wishes to borrow 1000 USDC at 10% APR. Assume the minimal interest per provision is 10 USDC and minimum borrow amount is 20 USDC. After 1 year the user would owe 100 USDC in interest. A user can abuse the minimum to pay legitimate lenders much lower than 10% APR. The attacker will find a legitimate offer to claim 820 USDC. This will create an offer for themselves and borrow 20 USDC from it 9 times. This creates a total of 10 provisions each owed a minimum of 10 USDC or 100 USDC total. Now after 1 year they owe 100 USDC on their loan and the repay the loan. Since 100 USDC is the minimum, each of the 10 provisions will get their minimal interest. 90 USDC will go to their provisions and 10 will go to the legitimate user who loaned them a majority of the USDC. Their APR is ~1.2% which is ~1/9th of what they specified.\n\n## Impact\n\nLegitimate users can be cheated out of interest owed\n\n## Code Snippet\n\n[ClaimFacet.sol#L94-L106](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L94-L106)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe relative size of the provisions should be enforced so that one is not much larger than any other one\n\n\n\n## Discussion\n\n**npasquie**\n\nsimilar to #66\n\n**npasquie**\n\nfixed by https://github.com/kairos-loan/kairos-contracts/pull/51\nthe fix restricts the nb of offer/provision per loan to 1 eliminating the vulnerability\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/56",
  "Code": [
    {
      "filename": "kairos-contracts/src/ClaimFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IClaimFacet} from \"./interface/IClaimFacet.sol\";\nimport {BorrowerAlreadyClaimed, LoanNotRepaidOrLiquidatedYet, NotBorrowerOfTheLoan} from \"./DataStructure/Errors.sol\";\nimport {ERC721CallerIsNotOwnerNorApproved} from \"./DataStructure/ERC721Errors.sol\";\nimport {Loan, Protocol, Provision, SupplyPosition} from \"./DataStructure/Storage.sol\";\nimport {ONE, protocolStorage, supplyPositionStorage} from \"./DataStructure/Global.sol\";\nimport {Ray} from \"./DataStructure/Objects.sol\";\nimport {RayMath} from \"./utils/RayMath.sol\";\nimport {Erc20CheckedTransfer} from \"./utils/Erc20CheckedTransfer.sol\";\nimport {SafeMint} from \"./SupplyPositionLogic/SafeMint.sol\";\n\n/// @notice claims supplier and borrower rights on loans or supply positions\ncontract ClaimFacet is IClaimFacet, SafeMint {\n    using RayMath for Ray;\n    using RayMath for uint256;\n    using Erc20CheckedTransfer for IERC20;\n\n    /// @notice claims principal plus interests or liquidation share due as a supplier\n    /// @param positionIds identifiers of one or multiple supply position to burn\n    /// @return sent amount sent\n    function claim(uint256[] calldata positionIds) external returns (uint256 sent) {\n        Protocol storage proto = protocolStorage();\n        SupplyPosition storage sp = supplyPositionStorage();\n        Loan storage loan;\n        Provision storage provision;\n        uint256 loanId;\n        uint256 sentTemp;\n\n        for (uint256 i = 0; i < positionIds.length; i++) {\n            if (!_isApprovedOrOwner(msg.sender, positionIds[i])) {\n                revert ERC721CallerIsNotOwnerNorApproved();\n            }\n            _burn(positionIds[i]);\n            provision = sp.provision[positionIds[i]];\n            loanId = provision.loanId;\n            loan = proto.loan[loanId];\n\n            if (loan.payment.liquidated) {\n                sentTemp = sendShareOfSaleAsSupplier(loan, provision);\n            } else {\n                if (loan.payment.paid == 0) {\n                    revert LoanNotRepaidOrLiquidatedYet(loanId);\n                }\n                sentTemp = sendInterests(loan, provision);\n            }\n            emit Claim(msg.sender, sentTemp, loanId);\n            sent += sentTemp;\n        }\n    }\n\n    /// @notice claims share of liquidation due to a borrower who's collateral has been sold\n    /// @param loanIds loan identifiers of one or multiple loans where the borrower wants to claim liquidation share\n    /// @return sent amount sent\n    function claimAsBorrower(uint256[] calldata loanIds) external returns (uint256 sent) {\n        Protocol storage proto = protocolStorage();\n        Loan storage loan;\n        uint256 sentTemp;\n        uint256 loanId;\n\n        for (uint256 i = 0; i < loanIds.length; i++) {\n            loanId = loanIds[i];\n            loan = proto.loan[loanId];\n            if (loan.borrower != msg.sender) {\n                revert NotBorrowerOfTheLoan(loanId);\n            }\n            if (loan.payment.borrowerClaimed) {\n                revert BorrowerAlreadyClaimed(loanId);\n            }\n            if (loan.payment.liquidated) {\n                loan.payment.borrowerClaimed = true;\n                // 1 - shareLent = share belonging to the borrower (not used as collateral)\n                sentTemp = loan.payment.paid.mul(ONE.sub(loan.shareLent));\n            } else {\n                revert LoanNotRepaidOrLiquidatedYet(loanId);\n            }\n            if (sentTemp > 0) {\n                /* the function may be called to store that the borrower claimed its due, but if this due is of 0 there\n                is no point in emitting a transfer and claim event */\n                loan.assetLent.checkedTransfer(msg.sender, sentTemp);\n                sent += sentTemp;\n                emit Claim(msg.sender, sentTemp, loanId);\n            }\n        }\n    }\n\n    /// @notice sends principal plus interests of the loan to `msg.sender`\n    /// @param loan - to calculate amount from\n    /// @param provision liquidity provision for this loan\n    /// @return sent amount sent\n    function sendInterests(Loan storage loan, Provision storage provision) internal returns (uint256 sent) {\n        uint256 interests = loan.payment.paid - loan.lent;\n        if (interests == loan.payment.minInterestsToRepay) {\n            // this is the case if the loan is repaid shortly after issuance\n            // each lender gets its minimal interest, as an anti ddos measure to spam offer\n            sent = provision.amount + (interests / loan.nbOfPositions);\n        } else {\n            /* provision.amount / lent = share of the interests belonging to the lender. The parenthesis make the\n            calculus in the order that maximizes precison */\n            sent = provision.amount + (interests * (provision.amount)) / loan.lent;\n        }\n        loan.assetLent.checkedTransfer(msg.sender, sent);\n    }\n\n    /// @notice sends liquidation share due to `msg.sender` as a supplier\n    /// @param loan - from which the collateral were liquidated\n    /// @param provision liquidity provisioned by this loan by the supplier\n    /// @return sent amount sent\n    function sendShareOfSaleAsSupplier(\n        Loan storage loan,\n        Provision storage provision\n    ) internal returns (uint256 sent) {\n        // in the case of a liqudidation, provision.share is considered the share of the NFT acquired by the lender\n        sent = loan.payment.paid.mul(provision.share);\n        loan.assetLent.checkedTransfer(msg.sender, sent);\n    }\n}"
    },
    {
      "filename": "kairos-contracts/src/ClaimFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IClaimFacet} from \"./interface/IClaimFacet.sol\";\nimport {BorrowerAlreadyClaimed, LoanNotRepaidOrLiquidatedYet, NotBorrowerOfTheLoan} from \"./DataStructure/Errors.sol\";\nimport {ERC721CallerIsNotOwnerNorApproved} from \"./DataStructure/ERC721Errors.sol\";\nimport {Loan, Protocol, Provision, SupplyPosition} from \"./DataStructure/Storage.sol\";\nimport {ONE, protocolStorage, supplyPositionStorage} from \"./DataStructure/Global.sol\";\nimport {Ray} from \"./DataStructure/Objects.sol\";\nimport {RayMath} from \"./utils/RayMath.sol\";\nimport {Erc20CheckedTransfer} from \"./utils/Erc20CheckedTransfer.sol\";\nimport {SafeMint} from \"./SupplyPositionLogic/SafeMint.sol\";\n\n/// @notice claims supplier and borrower rights on loans or supply positions\ncontract ClaimFacet is IClaimFacet, SafeMint {\n    using RayMath for Ray;\n    using RayMath for uint256;\n    using Erc20CheckedTransfer for IERC20;\n\n    /// @notice claims principal plus interests or liquidation share due as a supplier\n    /// @param positionIds identifiers of one or multiple supply position to burn\n    /// @return sent amount sent\n    function claim(uint256[] calldata positionIds) external returns (uint256 sent) {\n        Protocol storage proto = protocolStorage();\n        SupplyPosition storage sp = supplyPositionStorage();\n        Loan storage loan;\n        Provision storage provision;\n        uint256 loanId;\n        uint256 sentTemp;\n\n        for (uint256 i = 0; i < positionIds.length; i++) {\n            if (!_isApprovedOrOwner(msg.sender, positionIds[i])) {\n                revert ERC721CallerIsNotOwnerNorApproved();\n            }\n            _burn(positionIds[i]);\n            provision = sp.provision[positionIds[i]];\n            loanId = provision.loanId;\n            loan = proto.loan[loanId];\n\n            if (loan.payment.liquidated) {\n                sentTemp = sendShareOfSaleAsSupplier(loan, provision);\n            } else {\n                if (loan.payment.paid == 0) {\n                    revert LoanNotRepaidOrLiquidatedYet(loanId);\n                }\n                sentTemp = sendInterests(loan, provision);\n            }\n            emit Claim(msg.sender, sentTemp, loanId);\n            sent += sentTemp;\n        }\n    }\n\n    /// @notice claims share of liquidation due to a borrower who's collateral has been sold\n    /// @param loanIds loan identifiers of one or multiple loans where the borrower wants to claim liquidation share\n    /// @return sent amount sent\n    function claimAsBorrower(uint256[] calldata loanIds) external returns (uint256 sent) {\n        Protocol storage proto = protocolStorage();\n        Loan storage loan;\n        uint256 sentTemp;\n        uint256 loanId;\n\n        for (uint256 i = 0; i < loanIds.length; i++) {\n            loanId = loanIds[i];\n            loan = proto.loan[loanId];\n            if (loan.borrower != msg.sender) {\n                revert NotBorrowerOfTheLoan(loanId);\n            }\n            if (loan.payment.borrowerClaimed) {\n                revert BorrowerAlreadyClaimed(loanId);\n            }\n            if (loan.payment.liquidated) {\n                loan.payment.borrowerClaimed = true;\n                // 1 - shareLent = share belonging to the borrower (not used as collateral)\n                sentTemp = loan.payment.paid.mul(ONE.sub(loan.shareLent));\n            } else {\n                revert LoanNotRepaidOrLiquidatedYet(loanId);\n            }\n            if (sentTemp > 0) {\n                /* the function may be called to store that the borrower claimed its due, but if this due is of 0 there\n                is no point in emitting a transfer and claim event */\n                loan.assetLent.checkedTransfer(msg.sender, sentTemp);\n                sent += sentTemp;\n                emit Claim(msg.sender, sentTemp, loanId);\n            }\n        }\n    }\n\n    /// @notice sends principal plus interests of the loan to `msg.sender`\n    /// @param loan - to calculate amount from\n    /// @param provision liquidity provision for this loan\n    /// @return sent amount sent\n    function sendInterests(Loan storage loan, Provision storage provision) internal returns (uint256 sent) {\n        uint256 interests = loan.payment.paid - loan.lent;\n        if (interests == loan.payment.minInterestsToRepay) {\n            // this is the case if the loan is repaid shortly after issuance\n            // each lender gets its minimal interest, as an anti ddos measure to spam offer\n            sent = provision.amount + (interests / loan.nbOfPositions);\n        } else {\n            /* provision.amount / lent = share of the interests belonging to the lender. The parenthesis make the\n            calculus in the order that maximizes precison */\n            sent = provision.amount + (interests * (provision.amount)) / loan.lent;\n        }\n        loan.assetLent.checkedTransfer(msg.sender, sent);\n    }\n\n    /// @notice sends liquidation share due to `msg.sender` as a supplier\n    /// @param loan - from which the collateral were liquidated\n    /// @param provision liquidity provisioned by this loan by the supplier\n    /// @return sent amount sent\n    function sendShareOfSaleAsSupplier(\n        Loan storage loan,\n        Provision storage provision\n    ) internal returns (uint256 sent) {\n        // in the case of a liqudidation, provision.share is considered the share of the NFT acquired by the lender\n        sent = loan.payment.paid.mul(provision.share);\n        loan.assetLent.checkedTransfer(msg.sender, sent);\n    }\n}"
    }
  ]
}