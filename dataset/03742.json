{
  "Title": "Wrong logic in `withdrawAll`",
  "Content": "##### Description\nAt the moment `withdrawAll` counts balance as: `balanceOfPool(_gauge)` (https://github.com/convex-eth/platform/blob/754d9e700693246275b613e895b4044b63ce9ed5/contracts/contracts/VoterProxy.sol#L92)\n\nCorrect logic should be: `balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)))`.\n\nThe `withdrawAll` method is used by `shutdownSystem` so potentially some tokens could remain in the contract.\n\n##### Recommendation\nIt is recommended to count amount of tokens as `balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)))`.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/VoterProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\n\ncontract CurveVoterProxy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public constant mintr = address(0xd061D61a4d941c39E5453435B6345Dc261C2fcE0);\n    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n\n    address public constant escrow = address(0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2);\n    address public constant gaugeController = address(0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB);\n    \n    address public owner;\n    address public operator;\n    address public depositor;\n    \n    mapping (address => bool) private stashPool;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"CurveVoterProxy\";\n    }\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n    }\n\n    function setOperator(address _operator) external {\n        require(msg.sender == owner, \"!auth\");\n        require(operator == address(0) || IDeposit(operator).isShutdown() == true, \"needs shutdown\");\n        \n        operator = _operator;\n    }\n\n    function setDepositor(address _depositor) external {\n        require(msg.sender == owner, \"!auth\");\n\n        depositor = _depositor;\n    }\n\n    function setStashAccess(address _stash, bool _status) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        stashPool[_stash] = _status;\n        return true;\n    }\n\n    function deposit(address _token, address _gauge) external returns(bool){\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        if (balance > 0) {\n            IERC20(_token).safeApprove(_gauge, 0);\n            IERC20(_token).safeApprove(_gauge, balance);\n            ICurveGauge(_gauge).deposit(balance);\n        }\n        return true;\n    }\n\n    //stash only function for pulling extra incentive reward tokens out\n    function withdraw(IERC20 _asset) external returns (uint256 balance) {\n        require(stashPool[msg.sender] == true, \"!auth\");\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(msg.sender, balance);\n        return balance;\n    }\n\n    // Withdraw partial funds\n    function withdraw(address _token, address _gauge, uint256 _amount) public returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_gauge, _amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n        return true;\n    }\n\n     function withdrawAll(address _token, address _gauge) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        uint256 amount = balanceOfPool(_gauge);\n        withdraw(_token, _gauge, amount);\n        return true;\n    }\n\n    function _withdrawSome(address _gauge, uint256 _amount) internal returns (uint256) {\n        ICurveGauge(_gauge).withdraw(_amount);\n        return _amount;\n    }\n\n    function createLock(uint256 _value, uint256 _unlockTime) external returns(bool){\n        require(msg.sender == depositor, \"!auth\");\n        IERC20(crv).safeApprove(escrow, 0);\n        IERC20(crv).safeApprove(escrow, _value);\n        ICurveVoteEscrow(escrow).create_lock(_value, _unlockTime);\n        return true;\n    }\n\n    function increaseAmount(uint256 _value) external returns(bool){\n        require(msg.sender == depositor, \"!auth\");\n        IERC20(crv).safeApprove(escrow, 0);\n        IERC20(crv).safeApprove(escrow, _value);\n        ICurveVoteEscrow(escrow).increase_amount(_value);\n        return true;\n    }\n\n    function increaseTime(uint256 _value) external returns(bool){\n        require(msg.sender == depositor, \"!auth\");\n        ICurveVoteEscrow(escrow).increase_unlock_time(_value);\n        return true;\n    }\n\n    function release() external returns(bool){\n        require(msg.sender == depositor, \"!auth\");\n        ICurveVoteEscrow(escrow).withdraw();\n        return true;\n    }\n\n    function vote(uint256 _voteId, address _votingAddress, bool _support) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        IVoting(_votingAddress).vote(_voteId,_support,false);\n        return true;\n    }\n\n    function voteGaugeWeight(address _gauge, uint256 _weight) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n\n        //vote\n        IVoting(gaugeController).vote_for_gauge_weights(_gauge, _weight);\n        return true;\n    }\n\n    function claimCrv(address _gauge) external returns (uint256){\n        require(msg.sender == operator, \"!auth\");\n        IMinter(mintr).mint(_gauge);\n        uint256 _balance = IERC20(crv).balanceOf(address(this));\n        IERC20(crv).safeTransfer(operator, _balance);\n        return _balance;\n    }\n\n    function claimRewards(address _gauge) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        ICurveGauge(_gauge).claim_rewards();\n        return true;\n    }\n\n    function claimFees(address _distroContract, address _token) external returns (uint256){\n        require(msg.sender == operator, \"!auth\");\n        IFeeDistro(_distroContract).claim();\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(operator, _balance);\n        return _balance;\n    }    \n\n    function balanceOfPool(address _gauge) public view returns (uint256) {\n        return ICurveGauge(_gauge).balanceOf(address(this));\n    }\n\n}"
    }
  ]
}