{
  "Title": "[M-10] Blocking of the VUSD withdrawals is possible if the reserve token doesn’t support zero value transfers",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L62\n\n\n# Vulnerability details\n\n## Impact\n\nVUSD withdraw queue will be blocked and user funds frozen simply by requesting a zero value withdraw, if the reserve token doesn't support zero value transfers.\n\nPutting it medium only on an assumption that reserve will be USDC and the probability is low, but VUSD do allow any reserve token and the impact here is both funds freeze and stopping of the operations\n\n## Proof of Concept\n\nIt is possible to burn zero amount in OZ implementation:\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC20/ERC20Upgradeable.sol#L285-L300\n\nSo, withdraw will burn zero amount and put it to the queue:\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L48\n\nUSDC does support zero value transfers, but not all the tokens do:\n\nhttps://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers\n\nCurrently VUSD can use any reserve token:\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L33\n\nWithdraw queue position can be modified in the `processWithdrawals` function only.\n\nBut it will fail every time on the zero amount entry, as there is no way to skip it (and mint VUSD back, for example), so anything else after this zero entry will not be processed:\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L62\n\nThis way the withdrawal functionality and the corresponding user funds will be frozen within VUSD contract, which will become inoperable\n\n## Recommended Mitigation Steps\n\nConsider adding a zero amount check, as it doesn’t cost much, while zero transfer doesn't make sense anyway.\n\nNow:\n```\nreserveToken.safeTransfer(withdrawal.usr, withdrawal.amount);\nreserve -= withdrawal.amount;\n```\n\nTo be:\n```\nif (withdrawal.amount > 0) {\n\treserveToken.safeTransfer(withdrawal.usr, withdrawal.amount);\n\treserve -= withdrawal.amount;\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-hubble-contest",
  "Code": [
    {
      "filename": "contracts/VUSD.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC20PresetMinterPauserUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\n\ncontract VUSD is VanillaGovernable, ERC20PresetMinterPauserUpgradeable {\n    using SafeERC20 for IERC20;\n\n    struct Withdrawal {\n        address usr;\n        uint amount;\n    }\n\n    /// @notice vUSD is backed 1:1 with reserveToken (USDC)\n    IERC20 public immutable reserveToken;\n\n    Withdrawal[] public withdrawals;\n\n    /// @dev withdrawals will start processing at withdrawals[start]\n    uint public start;\n\n    /// @dev Constrained by block gas limit\n    uint public maxWithdrawalProcesses;\n\n    uint256[50] private __gap;\n\n    constructor(address _reserveToken) {\n        require(_reserveToken != address(0), \"vUSD: null _reserveToken\");\n        reserveToken = IERC20(_reserveToken);\n    }\n\n    function init(address _governance) external {\n        super.initialize(\"Hubble USD\", \"hUSD\"); // has initializer modifier\n        _setGovernace(_governance);\n        maxWithdrawalProcesses = 100;\n    }\n\n    function mintWithReserve(address to, uint amount) external {\n        reserveToken.safeTransferFrom(msg.sender, address(this), amount);\n        _mint(to, amount);\n    }\n\n    function withdraw(uint amount) external {\n        burn(amount);\n        withdrawals.push(Withdrawal(msg.sender, amount));\n    }\n\n    function processWithdrawals() external {\n        uint reserve = reserveToken.balanceOf(address(this));\n        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');\n        uint i = start;\n        while (i < withdrawals.length && (i - start) <= maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n            reserveToken.safeTransfer(withdrawal.usr, withdrawal.amount);\n            reserve -= withdrawal.amount;\n            i += 1;\n        }\n        start = i;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    function setMaxWithdrawalProcesses(uint _maxWithdrawalProcesses) external onlyGovernance {\n        maxWithdrawalProcesses = _maxWithdrawalProcesses;\n    }\n}"
    }
  ]
}