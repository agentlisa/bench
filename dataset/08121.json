{
  "Title": "[M-12] Griefing/DOS of withdrawals by EOAs from treasury (TRSRY) possible",
  "Content": "_Submitted by minhtrng_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/TreasuryCustodian.sol#L53-L67><br>\n\nAny withdrawals from the treasury by an approved EOA can be denied by a malicious actor that watches the mempool.\n\n### Proof of Concept\n\nThe function TreasuryCustodian.revokePolicyApprovals() doesnt provide sufficient checks for its intended purpose of \"revoking a deactivated policy's approvals\". As can be seen by the TODO labels, the issue has already been acknowledged by the team (regardless it is still an issue present in an in-scope contract). The only check performed is trying to call the isActive()-function on an address and interpret the returned value as boolean. Attempting to call this function on an EOA will not fail and return 0 (=false). Hence the condition to revert is not fulfilled and the amounts approved to withdraw will be set to 0.\n\n### Tools Used\n\nIDE (Remix, VSCode)\n\n### Recommended Mitigation Steps\n\nA partial but insufficient fix would be to check if the address passed to the function contains code and hence is not an EOA. A better approach might be to add a mapping(address => bool) of all addresses that have been active policies some time in the past to the kernel, something like this:\n\nAs a public variable in Kernel.sol\n`mapping(address => bool) public isRegisteredPolicy;`\n\nin Kernel.activatePolicy():\n`isRegisteredPolicy[address(policy_)] ) = true;`\n\nand finally in TreasuryCustodian.revokePolicyApprovals():\n`if(!kernel.isRegisteredPolicy(policy_) revert NotARegisteredPolicy`\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/317#issuecomment-1241262776):**\n > TODOs are outdated, I forgot to clear them ;(. But the points are taken. Code will be adjusted, but probably not the way from the recommendation. Instead will gate the function behind custodian role.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/policies/TreasuryCustodian.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {OlympusTreasury} from \"src/modules/TRSRY.sol\";\nimport \"src/Kernel.sol\";\n\n// ERRORS\nerror PolicyStillActive();\nerror PolicyNotFound();\n\n// Generic contract to allow authorized contracts to interact with treasury\n// Use cases include setting and removing approvals, as well as allocating assets for yield\ncontract TreasuryCustodian is Policy {\n    /* ========== STATE VARIABLES ========== */\n    event ApprovalRevoked(address indexed policy_, ERC20[] tokens_);\n\n    // Modules\n    OlympusTreasury internal TRSRY;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /* ========== FRAMEWORK CONFIGURATION ========== */\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"TRSRY\");\n\n        TRSRY = OlympusTreasury(getModuleAddress(dependencies[0]));\n    }\n\n    function requestPermissions() external view override returns (Permissions[] memory requests) {\n        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n\n        requests = new Permissions[](2);\n        requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n        requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.setDebt.selector);\n    }\n\n    function grantApproval(\n        address for_,\n        ERC20 token_,\n        uint256 amount_\n    ) external onlyRole(\"custodian\") {\n        TRSRY.setApprovalFor(for_, token_, amount_);\n    }\n\n    // Anyone can call to revoke a deactivated policy's approvals.\n    // TODO Currently allows anyone to revoke any approval EXCEPT activated policies.\n    // TODO must reorg policy storage to be able to check for deactivated policies.\n    function revokePolicyApprovals(address policy_, ERC20[] memory tokens_) external {\n        if (Policy(policy_).isActive()) revert PolicyStillActive();\n\n        // TODO Make sure `policy_` is an actual policy and not a random address.\n\n        uint256 len = tokens_.length;\n        for (uint256 j; j < len; ) {\n            TRSRY.setApprovalFor(policy_, tokens_[j], 0);\n            unchecked {\n                ++j;\n            }\n        }\n\n        emit ApprovalRevoked(policy_, tokens_);\n    }\n\n    // Debt admin functions for authorized addresses to manipulate debt in special cases\n\n    function increaseDebt(\n        ERC20 token_,\n        address debtor_,\n        uint256 amount_\n    ) external onlyRole(\"custodian\") {\n        uint256 debt = TRSRY.reserveDebt(token_, debtor_);\n        TRSRY.setDebt(token_, debtor_, debt + amount_);\n    }\n\n    function decreaseDebt(\n        ERC20 token_,\n        address debtor_,\n        uint256 amount_\n    ) external onlyRole(\"custodian\") {\n        uint256 debt = TRSRY.reserveDebt(token_, debtor_);\n        TRSRY.setDebt(token_, debtor_, debt - amount_);\n    }\n}"
    }
  ]
}