{
  "Title": "[N-01] Use `JBTokenAmount::decimals` instead of hardcoding it in `payParams`",
  "Content": "In `payParams` the number of tokens to mint is determined by multiplying value with weight and dividing by *1e18*.\n\n```Solidity\n        // Find the total number of tokens to mint, as a fixed point number with 18 decimals\n        uint256 _tokenCount = PRBMath.mulDiv(_data.amount.value, _data.weight, 10 ** 18);\n```\n\nAs the token to be used by the project has 18 decimals this is not an issue for now. Any other project token to be added will require this modified in order to keep the premise that the total number of tokens to mint is a fixed point number with 18 decimals.\n\nOut of the formula, `_data.weight` has 18 decimals:\n\nhttps://github.com/jbx-protocol/juice-contracts-v3/blob/12d852f28d372dd44987586f8009c56b0fe247a9/contracts/JBSingleTokenPaymentTerminalStore3_1.sol#L351-L352\n\n```Solidity\n    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.\n    uint256 _weight;\n```\n\nSo the 1e18 must be the decimal count of the `JBTokenAmount` in order to be fully safe.\n\n### Instances (1)\n\nhttps://github.com/code-423n4/2023-05-juicebox/blob/main/juice-buyback/contracts/JBXBuybackDelegate.sol#L149-L150\n\n### Recommendation\n\nUse the decimals propriety of `JBTokenAmount` instead of a hardcoded *1e18*:\n```Solidity\n        uint256 _tokenCount = PRBMath.mulDiv(_data.amount.value, _data.weight, 10 ** _data.amount.decimals);\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-juicebox",
  "Code": [
    {
      "filename": "contracts/JBSingleTokenPaymentTerminalStore3_1.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './interfaces/IJBController3_1.sol';\nimport './interfaces/IJBFundingCycleDataSource.sol';\nimport './interfaces/IJBSingleTokenPaymentTerminalStore.sol';\nimport './libraries/JBConstants.sol';\nimport './libraries/JBCurrencies.sol';\nimport './libraries/JBFixedPointNumber.sol';\nimport './libraries/JBFundingCycleMetadataResolver.sol';\nimport './structs/JBPayDelegateAllocation.sol';\nimport './structs/JBPayParamsData.sol';\n\n/**\n  @notice\n  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.\n\n  @dev\n  Adheres to:\n  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n\n  @dev\n  This Store expects a project's controller to be an IJBController3_1. This is the only difference between this version and the original.\n*/\ncontract JBSingleTokenPaymentTerminalStore3_1 is\n  ReentrancyGuard,\n  IJBSingleTokenPaymentTerminalStore\n{\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n  error INVALID_AMOUNT_TO_SEND_DELEGATE();\n  error CURRENCY_MISMATCH();\n  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n  error FUNDING_CYCLE_PAYMENT_PAUSED();\n  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n  error FUNDING_CYCLE_REDEEM_PAUSED();\n  error INADEQUATE_CONTROLLER_ALLOWANCE();\n  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n  error INSUFFICIENT_TOKENS();\n  error INVALID_FUNDING_CYCLE();\n  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n  //*********************************************************************//\n  // -------------------------- private constants ---------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. \n  */\n  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;\n\n  //*********************************************************************//\n  // ---------------- public immutable stored properties --------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The directory of terminals and controllers for projects.\n  */\n  IJBDirectory public immutable override directory;\n\n  /**\n    @notice\n    The contract storing all funding cycle configurations.\n  */\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /**\n    @notice\n    The contract that exposes price feeds.\n  */\n  IJBPrices public immutable override prices;\n\n  //*********************************************************************//\n  // --------------------- public stored properties -------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The amount of tokens that each project has for each terminal, in terms of the terminal's token.\n\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the balance applies.\n    _projectId The ID of the project to get the balance of.\n  */\n  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;\n\n  /**\n    @notice\n    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.\n\n    @dev\n    Increases as projects use their preconfigured distribution limits.\n\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the used distribution limit applies.\n    _projectId The ID of the project to get the used distribution limit of.\n    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.\n  */\n  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))\n    public\n    override usedDistributionLimitOf;\n\n  /**\n    @notice\n    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.\n\n    @dev\n    Increases as projects use their allowance.\n\n    @dev\n    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the overflow allowance applies.\n    _projectId The ID of the project to get the used overflow allowance of.\n    _configuration The configuration of the during which the allowance was used.\n  */\n  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))\n    public\n    override usedOverflowAllowanceOf;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Gets the current overflowed amount in a terminal for a specified project.\n\n    @dev\n    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n\n    @return The current amount of overflow that project has in the specified terminal.\n  */\n  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Return the overflow during the project's current funding cycle.\n    return\n      _overflowDuring(\n        _terminal,\n        _projectId,\n        fundingCycleStore.currentOf(_projectId),\n        _terminal.currency()\n      );\n  }\n\n  /**\n    @notice\n    Gets the current overflowed amount for a specified project across all terminals.\n\n    @param _projectId The ID of the project to get total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the total overflow should be in terms of.\n\n    @return The current total amount of overflow that project has across all terminals.\n  */\n  function currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) external view override returns (uint256) {\n    return _currentTotalOverflowOf(_projectId, _decimals, _currency);\n  }\n\n  /**\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @dev\n    The current reclaimable overflow is returned in terms of the specified terminal's currency.\n\n    @dev\n    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n\n    @param _terminal The terminal from which the reclaimable amount would come.\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.\n\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.\n  */\n  function currentReclaimableOverflowOf(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    bool _useTotalOverflow\n  ) external view override returns (uint256) {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get the amount of current overflow.\n    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.\n    uint256 _currentOverflow = _useTotalOverflow\n      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())\n      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());\n\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_currentOverflow == 0) return 0;\n\n    // Get the number of outstanding tokens the project has.\n    uint256 _totalSupply = IJBController3_1(directory.controllerOf(_projectId))\n      .totalOutstandingTokensOf(_projectId);\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount > _totalSupply) return 0;\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(\n        _projectId,\n        _fundingCycle,\n        _tokenCount,\n        _totalSupply,\n        _currentOverflow\n      );\n  }\n\n  /**\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.\n\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.\n  */\n  function currentReclaimableOverflowOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) external view override returns (uint256) {\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_overflow == 0) return 0;\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount > _totalSupply) return 0;\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);\n  }\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  /**\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _prices A contract that exposes price feeds.\n  */\n  constructor(\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBPrices _prices\n  ) {\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    prices = _prices;\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Records newly contributed tokens to a project.\n\n    @dev\n    Mints the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.\n\n    @param _payer The original address that sent the payment to the terminal.\n    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.\n    @param _projectId The ID of the project being paid.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.\n    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n\n    @return fundingCycle The project's funding cycle during which payment was made.\n    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.\n    @return delegateAllocations The amount to send to delegates instead of adding to the local balance.\n    @return memo A memo that should be passed along to the emitted event.\n  */\n  function recordPaymentFrom(\n    address _payer,\n    JBTokenAmount calldata _amount,\n    uint256 _projectId,\n    uint256 _baseWeightCurrency,\n    address _beneficiary,\n    string calldata _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 tokenCount,\n      JBPayDelegateAllocation[] memory delegateAllocations,\n      string memory memo\n    )\n  {\n    // Get a reference to the current funding cycle for the project.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The project must have a funding cycle configured.\n    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();\n\n    // Must not be paused.\n    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();\n\n    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.\n    uint256 _weight;\n\n    // If the funding cycle has configured a data source, use it to derive a weight and memo.\n    if (fundingCycle.useDataSourceForPay() && fundingCycle.dataSource() != address(0)) {\n      // Create the params that'll be sent to the data source.\n      JBPayParamsData memory _data = JBPayParamsData(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _payer,\n        _amount,\n        _projectId,\n        fundingCycle.configuration,\n        _beneficiary,\n        fundingCycle.weight,\n        fundingCycle.reservedRate(),\n        _memo,\n        _metadata\n      );\n      (_weight, memo, delegateAllocations) = IJBFundingCycleDataSource(fundingCycle.dataSource())\n        .payParams(_data);\n    }\n    // Otherwise use the funding cycle's weight\n    else {\n      _weight = fundingCycle.weight;\n      memo = _memo;\n    }\n\n    // Scoped section prevents stack too deep. `_balanceDiff` only used within scope.\n    {\n      // Keep a reference to the amount that should be added to the project's balance.\n      uint256 _balanceDiff = _amount.value;\n\n      // Validate all delegated amounts. This needs to be done before returning the delegate allocations to ensure valid delegated amounts.\n      if (delegateAllocations.length != 0) {\n        for (uint256 _i; _i < delegateAllocations.length; ) {\n          // Get a reference to the amount to be delegated.\n          uint256 _delegatedAmount = delegateAllocations[_i].amount;\n\n          // Validate if non-zero.\n          if (_delegatedAmount != 0) {\n            // Can't delegate more than was paid.\n            if (_delegatedAmount > _balanceDiff) revert INVALID_AMOUNT_TO_SEND_DELEGATE();\n\n            // Decrement the total amount being added to the balance.\n            _balanceDiff = _balanceDiff - _delegatedAmount;\n          }\n\n          unchecked {\n            ++_i;\n          }\n        }\n      }\n\n      // If there's no amount being recorded, there's nothing left to do.\n      if (_amount.value == 0) return (fundingCycle, 0, delegateAllocations, memo);\n\n      // Add the correct balance difference to the token balance of the project.\n      if (_balanceDiff != 0)\n        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n          balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n          _balanceDiff;\n    }\n\n    // If there's no weight, token count must be 0 so there's nothing left to do.\n    if (_weight == 0) return (fundingCycle, 0, delegateAllocations, memo);\n\n    // Get a reference to the number of decimals in the amount. (prevents stack too deep).\n    uint256 _decimals = _amount.decimals;\n\n    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.\n    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.\n    uint256 _weightRatio = _amount.currency == _baseWeightCurrency\n      ? 10**_decimals\n      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);\n\n    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.\n    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);\n  }\n\n  /**\n    @notice\n    Records newly redeemed tokens of a project.\n\n    @dev\n    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.\n\n    @param _holder The account that is having its tokens redeemed.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n\n    @return fundingCycle The funding cycle during which the redemption was made.\n    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.\n    @return delegateAllocations The amount to send to delegates instead of sending to the beneficiary.\n    @return memo A memo that should be passed along to the emitted event.\n  */\n  function recordRedemptionFor(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 reclaimAmount,\n      JBRedemptionDelegateAllocation[] memory delegateAllocations,\n      string memory memo\n    )\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();\n\n    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.\n    {\n      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.\n      JBTokenAmount memory _reclaimedTokenAmount;\n      uint256 _currentOverflow;\n      uint256 _totalSupply;\n\n      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.\n      {\n        // Get a reference to the terminal's tokens.\n        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();\n\n        // Get a reference to the terminal's decimals.\n        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();\n\n        // Get areference to the terminal's currency.\n        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n        // Get the amount of current overflow.\n        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.\n        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()\n          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)\n          : _overflowDuring(\n            IJBSingleTokenPaymentTerminal(msg.sender),\n            _projectId,\n            fundingCycle,\n            _currency\n          );\n\n        // Get the number of outstanding tokens the project has.\n        _totalSupply = IJBController3_1(directory.controllerOf(_projectId))\n          .totalOutstandingTokensOf(_projectId);\n\n        // Can't redeem more tokens that is in the supply.\n        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();\n\n        if (_currentOverflow != 0)\n          // Calculate reclaim amount using the current overflow amount.\n          reclaimAmount = _reclaimableOverflowDuring(\n            _projectId,\n            fundingCycle,\n            _tokenCount,\n            _totalSupply,\n            _currentOverflow\n          );\n\n        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);\n      }\n\n      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.\n      if (fundingCycle.useDataSourceForRedeem() && fundingCycle.dataSource() != address(0)) {\n        // Yet another scoped section prevents stack too deep. `_state`  only used within scope.\n        {\n          // Get a reference to the ballot state.\n          JBBallotState _state = fundingCycleStore.currentBallotStateOf(_projectId);\n\n          // Create the params that'll be sent to the data source.\n          JBRedeemParamsData memory _data = JBRedeemParamsData(\n            IJBSingleTokenPaymentTerminal(msg.sender),\n            _holder,\n            _projectId,\n            fundingCycle.configuration,\n            _tokenCount,\n            _totalSupply,\n            _currentOverflow,\n            _reclaimedTokenAmount,\n            fundingCycle.useTotalOverflowForRedemptions(),\n            _state == JBBallotState.Active\n              ? fundingCycle.ballotRedemptionRate()\n              : fundingCycle.redemptionRate(),\n            _memo,\n            _metadata\n          );\n          (reclaimAmount, memo, delegateAllocations) = IJBFundingCycleDataSource(\n            fundingCycle.dataSource()\n          ).redeemParams(_data);\n        }\n      } else {\n        memo = _memo;\n      }\n    }\n\n    // Keep a reference to the amount that should be subtracted from the project's balance.\n    uint256 _balanceDiff = reclaimAmount;\n\n    if (delegateAllocations.length != 0) {\n      // Validate all delegated amounts.\n      for (uint256 _i; _i < delegateAllocations.length; ) {\n        // Get a reference to the amount to be delegated.\n        uint256 _delegatedAmount = delegateAllocations[_i].amount;\n\n        // Validate if non-zero.\n        if (_delegatedAmount != 0)\n          // Increment the total amount being subtracted from the balance.\n          _balanceDiff = _balanceDiff + _delegatedAmount;\n\n        unchecked {\n          ++_i;\n        }\n      }\n    }\n\n    // The amount being reclaimed must be within the project's balance.\n    if (_balanceDiff > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Remove the reclaimed funds from the project's balance.\n    if (_balanceDiff != 0) {\n      unchecked {\n        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n          balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n          _balanceDiff;\n      }\n    }\n  }\n\n  /**\n    @notice\n    Records newly distributed funds for a project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project that is having funds distributed.\n    @param _amount The amount to use from the distribution limit, as a fixed point number.\n    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.\n\n    @return fundingCycle The funding cycle during which the distribution was made.\n    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordDistributionFor(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The funding cycle must not be configured to have distributions paused.\n    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n\n    // The new total amount that has been distributed during this funding cycle.\n    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.number] + _amount;\n\n    // Amount must be within what is still distributable.\n    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController3_1(\n      directory.controllerOf(_projectId)\n    ).fundAccessConstraintsStore().distributionLimitOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n\n    // Make sure the new used amount is within the distribution limit.\n    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)\n      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n\n    // Make sure the currencies match.\n    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();\n\n    // Get a reference to the terminal's currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n    // Convert the amount to the balance's currency.\n    distributedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // The amount being distributed must be available.\n    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Store the new amount.\n    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.number\n    ] = _newUsedDistributionLimitOf;\n\n    // Removed the distributed funds from the project's token balance.\n    unchecked {\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n        distributedAmount;\n    }\n  }\n\n  /**\n    @notice\n    Records newly used allowance funds of a project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount to use from the allowance, as a fixed point number. \n    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.\n\n    @return fundingCycle The funding cycle during which the overflow allowance is being used.\n    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordUsedAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to the new used overflow allowance for this funding cycle configuration.\n    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.configuration] + _amount;\n\n    // There must be sufficient allowance available.\n    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController3_1(\n      directory.controllerOf(_projectId)\n    ).fundAccessConstraintsStore().overflowAllowanceOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n\n    // Make sure the new used amount is within the allowance.\n    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)\n      revert INADEQUATE_CONTROLLER_ALLOWANCE();\n\n    // Make sure the currencies match.\n    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();\n\n    // Get a reference to the terminal's currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n    // Convert the amount to this store's terminal's token.\n    usedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // The amount being distributed must be available in the overflow.\n    if (\n      usedAmount >\n      _overflowDuring(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _projectId,\n        fundingCycle,\n        _balanceCurrency\n      )\n    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Store the incremented value.\n    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.configuration\n    ] = _newUsedOverflowAllowanceOf;\n\n    // Update the project's balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      usedAmount;\n  }\n\n  /**\n    @notice\n    Records newly added funds for the project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project to which the funds being added belong.\n    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {\n    // Increment the balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount;\n  }\n\n  /**\n    @notice\n    Records the migration of funds from this store.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.\n\n    @param _projectId The ID of the project being migrated.\n\n    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordMigration(uint256 _projectId)\n    external\n    override\n    nonReentrant\n    returns (uint256 balance)\n  {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n    // Return the current balance.\n    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];\n\n    // Set the balance to 0.\n    balanceOf[IJBSingle"
    }
  ]
}