{
  "Title": "[M-01] Semi-erroneous Median Value",
  "Content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/NFTFloorOracle.sol#L429>\n\nIn `NFTFloorOracle.sol`, `_combine()` returns a validated `medianPrice` on line 429 after having `validPriceList` sorted in ascending order.\n\nIt will return a correct median as along as the array entails an odd number of valid prices. However, if there were an even number of valid prices, the median was supposed to be the average of the two middle values according to the median formula below:\n\n#### Median Formula\n\n![median formula](https://www.gstatic.com/education/formulas2/472522532/en/median_formula.svg)\n\n![x](https://www.gstatic.com/education/formulas2/472522532/en/median_formula_median_formula_var\\_1.svg)   =\tordered list of values in data set<br>\n![n](https://www.gstatic.com/education/formulas2/472522532/en/median_formula_median_formula_var\\_2.svg)    =\t number of values in data set\n\nThe impact could be significant in edge cases and affect all function calls dependent on the finalized `twap`.\n\n### Proof of Concept\n\nLet's assume there are four valid ether prices each of which is 1.5 times more than the previous one:\n\n`validPriceList = [1000, 1500, 2250, 3375]`\n\nInstead of returning `(1500 + 2250) / 2 = 1875`, 2250 is returned, incurring a 20% increment or 120 price deviation.\n\n### Recommended Mitigation Steps\n\nConsider having line 429 refactored as follows:\n\n            if (validNum % 2 != 0) {\n                return (true, validPriceList[validNum / 2]);\n            }\n            else\n                return (true, (validPriceList[validNum / 2] + validPriceList[(validNum / 2) - 1]) / 2); \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/misc/NFTFloorOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../dependencies/openzeppelin/contracts/AccessControl.sol\";\nimport \"../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"./interfaces/INFTFloorOracle.sol\";\n\n//we need to deploy 3 oracles at least\nuint8 constant MIN_ORACLES_NUM = 3;\n//expirationPeriod at least the interval of client to feed data(currently 6h=21600s/12=1800 in mainnet)\n//we do not accept price lags behind to much\nuint128 constant EXPIRATION_PERIOD = 1800;\n//reject when price increase/decrease 1.5 times more than original value\nuint128 constant MAX_DEVIATION_RATE = 150;\n\nstruct OracleConfig {\n    // Expiration Period for each feed price\n    uint128 expirationPeriod;\n    // Maximum deviation allowed between two consecutive oracle prices\n    uint128 maxPriceDeviation;\n}\n\nstruct PriceInformation {\n    // last reported floor price(offchain twap)\n    uint256 twap;\n    // last updated blocknumber\n    uint256 updatedAt;\n    // last updated timestamp\n    uint256 updatedTimestamp;\n}\n\nstruct FeederRegistrar {\n    // if asset registered or not\n    bool registered;\n    // index in asset list\n    uint8 index;\n    // if asset paused,reject the price\n    bool paused;\n    // feeder -> PriceInformation\n    mapping(address => PriceInformation) feederPrice;\n}\n\nstruct FeederPosition {\n    // if feeder registered or not\n    bool registered;\n    // index in feeder list\n    uint8 index;\n}\n\n/// @title A simple on-chain price oracle mechanism\n/// @author github.com/drbh,github.com/yrong\n/// @notice Offchain clients can update the prices in this contract. The public can read prices\n/// aggeregate prices which are not expired from different feeders, if number of valid/unexpired prices\n/// not enough, we do not aggeregate and just use previous price\ncontract NFTFloorOracle is Initializable, AccessControl, INFTFloorOracle {\n    event AssetAdded(address indexed asset);\n    event AssetRemoved(address indexed asset);\n    event AssetPaused(address indexed asset, bool paused);\n\n    event FeederAdded(address indexed feeder);\n    event FeederRemoved(address indexed feeder);\n\n    event OracleConfigSet(uint128 expirationPeriod, uint128 maxPriceDeviation);\n    event AssetDataSet(\n        address indexed asset,\n        uint256 twap,\n        uint256 lastUpdatedBlock\n    );\n\n    bytes32 public constant UPDATER_ROLE = keccak256(\"UPDATER_ROLE\");\n\n    /// @dev Aggregated price with address\n    // the NFT contract -> latest price information\n    mapping(address => PriceInformation) public assetPriceMap;\n\n    /// @dev All feeders\n    address[] public feeders;\n\n    /// @dev feeder map\n    // feeder address -> index in feeder list\n    mapping(address => FeederPosition) private feederPositionMap;\n\n    /// @dev All asset list\n    address[] public assets;\n\n    /// @dev Original raw value to aggregate with\n    // the NFT contract address -> FeederRegistrar which contains price from each feeder\n    mapping(address => FeederRegistrar) public assetFeederMap;\n\n    /// @dev storage for oracle configurations\n    OracleConfig public config;\n\n    /// @notice Allow contract creator to set admin and updaters\n    /// @param _admin The admin who can change roles\n    /// @param _feeders The initial updaters\n    /// @param _assets The initial nft assets\n    function initialize(\n        address _admin,\n        address[] memory _feeders,\n        address[] memory _assets\n    ) public initializer {\n        _addAssets(_assets);\n        _addFeeders(_feeders);\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        //still need to grant update_role to admin for emergency call\n        _setupRole(UPDATER_ROLE, _admin);\n        _setConfig(EXPIRATION_PERIOD, MAX_DEVIATION_RATE);\n    }\n\n    modifier whenNotPaused(address _asset) {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            _whenNotPaused(_asset);\n        }\n        _;\n    }\n\n    modifier onlyWhenAssetExisted(address _asset) {\n        require(_isAssetExisted(_asset), \"NFTOracle: asset not existed\");\n        _;\n    }\n\n    modifier onlyWhenAssetNotExisted(address _asset) {\n        require(!_isAssetExisted(_asset), \"NFTOracle: asset existed\");\n        _;\n    }\n\n    modifier onlyWhenFeederExisted(address _feeder) {\n        require(_isFeederExisted(_feeder), \"NFTOracle: feeder not existed\");\n        _;\n    }\n\n    modifier onlyWhenFeederNotExisted(address _feeder) {\n        require(!_isFeederExisted(_feeder), \"NFTOracle: feeder existed\");\n        _;\n    }\n\n    /// @notice Allows owner to add assets.\n    /// @param _assets assets to add\n    function addAssets(address[] calldata _assets)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _addAssets(_assets);\n    }\n\n    /// @notice Allows owner to remove asset.\n    /// @param _asset asset to remove\n    function removeAsset(address _asset)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        onlyWhenAssetExisted(_asset)\n    {\n        _removeAsset(_asset);\n    }\n\n    /// @notice Allows owner to add feeders.\n    /// @param _feeders feeders to add\n    function addFeeders(address[] calldata _feeders)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _addFeeders(_feeders);\n    }\n\n    /// @notice Allows owner to remove feeder.\n    /// @param _feeder feeder to remove\n    function removeFeeder(address _feeder)\n        external\n        onlyWhenFeederExisted(_feeder)\n    {\n        _removeFeeder(_feeder);\n    }\n\n    /// @notice Allows owner to update oracle configs\n    function setConfig(uint128 expirationPeriod, uint128 maxPriceDeviation)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _setConfig(expirationPeriod, maxPriceDeviation);\n    }\n\n    /// @notice Allows owner to pause asset\n    function setPause(address _asset, bool _flag)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        assetFeederMap[_asset].paused = _flag;\n        emit AssetPaused(_asset, _flag);\n    }\n\n    /// @notice Allows updater to set new price on PriceInformation and updates the\n    /// internal Median cumulativePrice.\n    /// @param _asset The nft contract to set a floor price for\n    /// @param _twap The last floor twap\n    function setPrice(address _asset, uint256 _twap)\n        public\n        onlyRole(UPDATER_ROLE)\n        onlyWhenAssetExisted(_asset)\n        whenNotPaused(_asset)\n    {\n        bool dataValidity = false;\n        if (hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            _finalizePrice(_asset, _twap);\n            return;\n        }\n        dataValidity = _checkValidity(_asset, _twap);\n        require(dataValidity, \"NFTOracle: invalid price data\");\n        // add price to raw feeder storage\n        _addRawValue(_asset, _twap);\n        uint256 medianPrice;\n        // set twap price only when median value is valid\n        (dataValidity, medianPrice) = _combine(_asset, _twap);\n        if (dataValidity) {\n            _finalizePrice(_asset, medianPrice);\n        }\n    }\n\n    /// @notice Allows owner to set new price on PriceInformation and updates the\n    /// internal Median cumulativePrice.\n    /// @param _assets The nft contract to set a floor price for\n    function setMultiplePrices(\n        address[] calldata _assets,\n        uint256[] calldata _twaps\n    ) external onlyRole(UPDATER_ROLE) {\n        require(\n            _assets.length == _twaps.length,\n            \"NFTOracle: Tokens and price length differ\"\n        );\n        for (uint256 i = 0; i < _assets.length; i++) {\n            setPrice(_assets[i], _twaps[i]);\n        }\n    }\n\n    /// @param _asset The nft contract\n    /// @return price The most recent price on chain\n    function getPrice(address _asset)\n        external\n        view\n        override\n        returns (uint256 price)\n    {\n        uint256 updatedAt = assetPriceMap[_asset].updatedAt;\n        require(\n            (block.number - updatedAt) <= config.expirationPeriod,\n            \"NFTOracle: asset price expired\"\n        );\n        return assetPriceMap[_asset].twap;\n    }\n\n    /// @param _asset The nft contract\n    /// @return timestamp The timestamp of the last update for an asset\n    function getLastUpdateTime(address _asset)\n        external\n        view\n        override\n        returns (uint256 timestamp)\n    {\n        return assetPriceMap[_asset].updatedTimestamp;\n    }\n\n    function getFeederSize() public view returns (uint256) {\n        return feeders.length;\n    }\n\n    function _whenNotPaused(address _asset) internal view {\n        bool _paused = assetFeederMap[_asset].paused;\n        require(!_paused, \"NFTOracle: nft price feed paused\");\n    }\n\n    function _isAssetExisted(address _asset) internal view returns (bool) {\n        return assetFeederMap[_asset].registered;\n    }\n\n    function _isFeederExisted(address _feeder) internal view returns (bool) {\n        return feederPositionMap[_feeder].registered;\n    }\n\n    function _addAsset(address _asset)\n        internal\n        onlyWhenAssetNotExisted(_asset)\n    {\n        assetFeederMap[_asset].registered = true;\n        assets.push(_asset);\n        assetFeederMap[_asset].index = uint8(assets.length - 1);\n        emit AssetAdded(_asset);\n    }\n\n    /// @notice add nft assets.\n    /// @param _assets assets to add\n    function _addAssets(address[] memory _assets) internal {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            _addAsset(_assets[i]);\n        }\n    }\n\n    function _removeAsset(address _asset)\n        internal\n        onlyWhenAssetExisted(_asset)\n    {\n        uint8 assetIndex = assetFeederMap[_asset].index;\n        delete assets[assetIndex];\n        delete assetPriceMap[_asset];\n        delete assetFeederMap[_asset];\n        emit AssetRemoved(_asset);\n    }\n\n    function _addFeeder(address _feeder)\n        internal\n        onlyWhenFeederNotExisted(_feeder)\n    {\n        feeders.push(_feeder);\n        feederPositionMap[_feeder].index = uint8(feeders.length - 1);\n        feederPositionMap[_feeder].registered = true;\n        _setupRole(UPDATER_ROLE, _feeder);\n        emit FeederAdded(_feeder);\n    }\n\n    /// @notice set feeders.\n    /// @param _feeders feeders to set\n    function _addFeeders(address[] memory _feeders) internal {\n        for (uint256 i = 0; i < _feeders.length; i++) {\n            _addFeeder(_feeders[i]);\n        }\n    }\n\n    function _removeFeeder(address _feeder)\n        internal\n        onlyWhenFeederExisted(_feeder)\n    {\n        uint8 feederIndex = feederPositionMap[_feeder].index;\n        if (feederIndex >= 0 && feeders[feederIndex] == _feeder) {\n            feeders[feederIndex] = feeders[feeders.length - 1];\n            feeders.pop();\n        }\n        delete feederPositionMap[_feeder];\n        revokeRole(UPDATER_ROLE, _feeder);\n        emit FeederRemoved(_feeder);\n    }\n\n    /// @notice set oracle configs\n    /// @param _expirationPeriod only prices not expired will be aggregated with\n    /// @param _maxPriceDeviation use to reject when price increase/decrease rate more than this value\n    function _setConfig(uint128 _expirationPeriod, uint128 _maxPriceDeviation)\n        internal\n    {\n        config.expirationPeriod = _expirationPeriod;\n        config.maxPriceDeviation = _maxPriceDeviation;\n        emit OracleConfigSet(_expirationPeriod, _maxPriceDeviation);\n    }\n\n    function _checkValidity(address _asset, uint256 _twap)\n        internal\n        view\n        returns (bool)\n    {\n        require(_twap > 0, \"NFTOracle: price should be more than 0\");\n        PriceInformation memory assetPriceMapEntry = assetPriceMap[_asset];\n        uint256 _priorTwap = assetPriceMapEntry.twap;\n        uint256 _updatedAt = assetPriceMapEntry.updatedAt;\n        uint256 priceDeviation;\n        //first price is always valid\n        if (_priorTwap == 0 || _updatedAt == 0) {\n            return true;\n        }\n        priceDeviation = _twap > _priorTwap\n            ? (_twap * 100) / _priorTwap\n            : (_priorTwap * 100) / _twap;\n\n        // config maxPriceDeviation as multiple directly(not percent) for simplicity\n        if (priceDeviation >= config.maxPriceDeviation) {\n            return false;\n        }\n        return true;\n    }\n\n    function _finalizePrice(address _asset, uint256 _twap) internal {\n        PriceInformation storage assetPriceMapEntry = assetPriceMap[_asset];\n        assetPriceMapEntry.twap = _twap;\n        assetPriceMapEntry.updatedAt = block.number;\n        assetPriceMapEntry.updatedTimestamp = block.timestamp;\n        emit AssetDataSet(\n            _asset,\n            assetPriceMapEntry.twap,\n            assetPriceMapEntry.updatedAt\n        );\n    }\n\n    function _addRawValue(address _asset, uint256 _twap) internal {\n        FeederRegistrar storage feederRegistrar = assetFeederMap[_asset];\n        PriceInformation storage priceInfo = feederRegistrar.feederPrice[\n            msg.sender\n        ];\n        priceInfo.twap = _twap;\n        priceInfo.updatedAt = block.number;\n    }\n\n    function _combine(address _asset, uint256 _twap)\n        internal\n        view\n        returns (bool, uint256)\n    {\n        FeederRegistrar storage feederRegistrar = assetFeederMap[_asset];\n        uint256 currentBlock = block.number;\n        //first time just use the feeding value\n        if (assetPriceMap[_asset].twap == 0) {\n            return (true, _twap);\n        }\n        //use memory here so allocate with maximum length\n        uint256 feederSize = feeders.length;\n        uint256[] memory validPriceList = new uint256[](feederSize);\n        uint256 validNum = 0;\n        //aggeregate with price from all feeders\n        for (uint256 i = 0; i < feederSize; i++) {\n            PriceInformation memory priceInfo = feederRegistrar.feederPrice[\n                feeders[i]\n            ];\n            if (priceInfo.updatedAt > 0) {\n                uint256 diffBlock = currentBlock - priceInfo.updatedAt;\n                if (diffBlock <= config.expirationPeriod) {\n                    validPriceList[validNum] = priceInfo.twap;\n                    validNum++;\n                }\n            }\n        }\n        if (validNum < MIN_ORACLES_NUM) {\n            return (false, assetPriceMap[_asset].twap);\n        }\n        _quickSort(validPriceList, 0, int256(validNum - 1));\n        return (true, validPriceList[validNum / 2]);\n    }\n\n    function _quickSort(\n        uint256[] memory arr,\n        int256 left,\n        int256 right\n    ) internal pure {\n        int256 i = left;\n        int256 j = right;\n        if (i == j) return;\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\n        while (i <= j) {\n            while (arr[uint256(i)] < pivot) i++;\n            while (pivot < arr[uint256(j)]) j--;\n            if (i <= j) {\n                (arr[uint256(i)], arr[uint256(j)]) = (\n                    arr[uint256(j)],\n                    arr[uint256(i)]\n                );\n                i++;\n                j--;\n            }\n        }\n        if (left < j) _quickSort(arr, left, j);\n        if (i < right) _quickSort(arr, i, right);\n    }\n}"
    }
  ]
}