{
  "Title": "[M-02] LP rewards in `liquidity_lockbox` can be arbitraged",
  "Content": "\nThe [`liquidity_lockbox`](https://github.com/code-423n4/2023-12-autonolas/blob/main/lockbox-solana/solidity/liquidity_lockbox.sol) contract is designed to handle liquidity positions in a specific Orca LP pool. Users can deposit their LP NFTs into the contract, receiving in exchange tokens according to their position size. These tokens are minted with the goal of allowing users to bridge them to Ethereum later on and exchange them for OLAS at a discount.\n\nHowever, a potential vulnerability arises from the unrestricted nature of the deposit and withdrawal functions. Specifically, a user can deposit a large amount of assets and immediately withdraw all existing positions using the tokens they just received. This sequence of actions can be repeated to continuously exploit the LP rewards system, leading to an unfair distribution of rewards.\n\nThe root cause of this issue lies in the `withdraw()` function, which does not have any restrictions or checks that prevent immediate withdrawal after a deposit and pays all accrued LP rewards [to the caller](https://github.com/code-423n4/2023-12-autonolas/blob/main/lockbox-solana/solidity/liquidity_lockbox.sol#L295-L307).\n\n### Proof of Concept\n\nConsider the following scenario:\n\n1.  Alice obtains a large amount of tokens either through a [flashloan](https://github.com/solendprotocol/solana-program-library/blob/master/token-lending/program/src/processor.rs#L102) or by buying them.\n2.  Alice uses these tokens to open a large position in the Orca pool.\n3.  Alice deposits the position NFT into the `liquidity_lockbox` contract, receiving a large amount of bridge tokens.\n4.  Alice withdraws all existing positions using the tokens she just received and receives the LP rewards.\n5.  Alice closes the received positions in the Orca pool, repays the flashloan (if used) and pockets the rewards.\n\nThis sequence of actions can be repeated by Alice to continuously exploit the LP rewards system.\n\n### Recommended Mitigation Steps\n\nTo mitigate this issue, a possible solution could be to implement a lock-up period for deposited positions. This would prevent users from immediately withdrawing their positions after depositing. Additionally, consider not distributing rewards to the withdrawing user (which will never be fair) and instead collecting them for the protocol.\n\n**[kupermind (Olas) confirmed](https://github.com/code-423n4/2023-12-autonolas-findings/issues/444#issuecomment-1892657650)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "lockbox-solana/solidity/liquidity_lockbox.sol",
      "content": "import \"./library/spl_token.sol\";\nimport \"./interfaces/whirlpool.sol\";\n\n// Position struct\nstruct Position {\n    // Whirlpool (LP pool) address, 32 bytes\n    address whirlpool;\n    // Position mint (liquidity NFT) address, 32 bytes\n    address positionMint;\n    // Position liquidity, 16 bytes\n    uint128 liquidity;\n    // Tick lower index, 4 bytes\n    int32 tickLowerIndex;\n    /// Tick upper index, 4 bytes\n    int32 tickUpperIndex;\n}\n\n/// @dev The liquidity in the position cannot be practically bigger than the max of uint64 since\n///      spl token functions are limited by the uint64 value.\n\n@program_id(\"GUGGHzwC8wEKY3g7QS38YmoS8t5Q2faWAGAfxDK2bXbb\")\ncontract liquidity_lockbox {\n    // Orca whirlpool program address\n    address public constant orca = address\"whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc\";\n    // Whirlpool (LP) pool address\n    address public pool;\n    // Current program owned PDA account address\n    address public pdaProgram;\n    // Bridged token mint address\n    address public bridgedTokenMint;\n    // PDA bridged token account address\n    address public pdaBridgedTokenAccount;\n    // PDA header for position account\n    uint64 public pdaHeader = 0xd0f7407ae48fbcaa;\n    // Program PDA seed\n    bytes public constant pdaProgramSeed = \"pdaProgram\";\n    // Program PDA bump\n    bytes1 public pdaBump;\n    int32 public constant minTickLowerIndex = -443632;\n    int32 public constant maxTickLowerIndex = 443632;\n\n    // Total number of token accounts (even those that hold no positions anymore)\n    uint32 public numPositionAccounts;\n    // First available account index in the set of accounts;\n    uint32 public firstAvailablePositionAccountIndex;\n    // Total liquidity in a lockbox\n    uint64 public totalLiquidity;\n\n    //\n    mapping(address => uint64) public mapPositionAccountLiquidity;\n    mapping(address => address) public mapPositionAccountPdaAta;\n    address[type(uint32).max] public positionAccounts;\n\n    @space(10000)\n    @payer(payer)\n    @seed(\"pdaProgram\")\n    constructor(\n        address _pool,\n        address _bridgedTokenMint,\n        address _pdaBridgedTokenAccount,\n        @bump bytes1 _bump\n    ) {\n        pool = _pool;\n        bridgedTokenMint = _bridgedTokenMint;\n        pdaBridgedTokenAccount = _pdaBridgedTokenAccount;\n\n        // Independently derive the PDA address from the seeds, bump, and programId\n        (address pda, bytes1 bump) = try_find_program_address([\"pdaProgram\"], type(liquidity_lockbox).program_id);\n\n        // Verify that the bump passed to the constructor matches the bump derived from the seeds and programId\n        if (bump != _bump) {\n            revert(\"Invalid bump\");\n        }\n\n        // Assign pda and bump\n        pdaProgram = pda;\n        pdaBump = bump;\n    }\n\n    /// @dev Gets the position data.\n    /// @param position Position account.\n    /// @param positionMint Position mint (NFT).\n    /// @return positionData Position data.\n    function _getPositionData(AccountInfo position, address positionMint) internal view returns (Position positionData) {\n        // Extract the position data\n        positionData = Position({\n            whirlpool: position.data.readAddress(8),\n            positionMint: position.data.readAddress(40),\n            liquidity: position.data.readUint128LE(72),\n            tickLowerIndex: position.data.readInt32LE(88),\n            tickUpperIndex: position.data.readInt32LE(92)\n        });\n\n        // Check that the liquidity is within uint64 bounds\n        if (positionData.liquidity > type(uint64).max) {\n            revert(\"Liquidity overflow\");\n        }\n\n        // Check the whirlpool\n        if (positionData.whirlpool != pool) {\n            revert(\"Wrong pool address\");\n        }\n\n        // Check the NFT address\n        if (positionData.positionMint != positionMint) {\n            revert(\"Wrong NFT address\");\n        }\n\n        // Check tick values\n        if (positionData.tickLowerIndex != minTickLowerIndex || positionData.tickUpperIndex != maxTickLowerIndex) {\n            revert(\"Wrong ticks\");\n        }\n\n        // Check the PDA ownership\n        if (position.owner != orca) {\n            revert(\"Wrong PDA owner\");\n        }\n\n        // Check the PDA header data\n        uint64 header = position.data.readUint64LE(0);\n        if (header != pdaHeader) {\n            revert(\"Wrong PDA header\");\n        }\n\n        // Check the PDA address correctness\n        (address pdaPosition, ) = try_find_program_address([\"position\", positionData.positionMint], orca);\n        if (pdaPosition != position.key) {\n            revert(\"Wrong position PDA\");\n        }\n    }\n\n    /// @dev Deposits the position mint (NFT) in order to get a corresponding liquidity amount of bridged tokens\n    @mutableAccount(userPositionAccount)\n    @mutableAccount(pdaPositionAccount)\n    @mutableAccount(userBridgedTokenAccount)\n    @mutableAccount(bridgedTokenMint)\n    @account(position)\n    @account(positionMint)\n    @signer(userWallet)\n    function deposit() external {\n        // Get the position data based on provided accounts\n        Position positionData = _getPositionData(tx.accounts.position, tx.accounts.positionMint.key);\n\n        uint64 positionLiquidity = uint64(positionData.liquidity);\n\n        // Check that the mint of the user position ATA matches the position mint\n        address positionMint = tx.accounts.userPositionAccount.data.readAddress(0);\n        if (positionMint != tx.accounts.positionMint.key) {\n            revert(\"Wrong user position ATA\");\n        }\n\n        // Check that the bridged token mint account is correct\n        if (tx.accounts.bridgedTokenMint.key != bridgedTokenMint) {\n            revert(\"Wrong bridged token mint account\");\n        }\n\n        // PDA position account owner must be the PDA program account\n        address pdaPositionOwner = tx.accounts.pdaPositionAccount.data.readAddress(32);\n        if (pdaPositionOwner != pdaProgram) {\n            revert(\"Wrong PDA position owner\");\n        }\n\n        // Transfer the position NFT to the pdaPositionAccount address of this program\n        SplToken.transfer(\n            tx.accounts.userPositionAccount.key,\n            tx.accounts.pdaPositionAccount.key,\n            tx.accounts.userWallet.key,\n            1);\n\n        // Mint bridged tokens to the user\n        SplToken.pda_mint_to(\n            bridgedTokenMint,\n            tx.accounts.userBridgedTokenAccount.key,\n            pdaProgram,\n            positionLiquidity,\n            pdaProgramSeed,\n            pdaBump);\n\n        // Record position liquidity amount and its correspondent account address\n        address positionAddress = tx.accounts.position.key;\n        mapPositionAccountLiquidity[positionAddress] = positionLiquidity;\n        address pdaPositionAta = tx.accounts.pdaPositionAccount.key;\n        mapPositionAccountPdaAta[positionAddress] = pdaPositionAta;\n        positionAccounts[numPositionAccounts] = positionAddress;\n\n        // Increase the total number of positions\n        numPositionAccounts++;\n        // Increase the amount of total liquidity\n        totalLiquidity += positionLiquidity;\n    }\n\n    /// @dev Withdraws LP tokens separately to each token ATA and burns provided bridge tokens.\n    /// @param amount Bridged token amount.\n    @mutableAccount(pool)\n    @account(tokenProgramId)\n    @mutableAccount(position)\n    @mutableAccount(userBridgedTokenAccount)\n    @mutableAccount(pdaBridgedTokenAccount)\n    @mutableAccount(userWallet)\n    @mutableAccount(bridgedTokenMint)\n    @mutableAccount(pdaPositionAccount)\n    @mutableAccount(userTokenAccountA)\n    @mutableAccount(userTokenAccountB)\n    @mutableAccount(tokenVaultA)\n    @mutableAccount(tokenVaultB)\n    @mutableAccount(tickArrayLower)\n    @mutableAccount(tickArrayUpper)\n    @mutableAccount(positionMint)\n    @signer(sig)\n    function withdraw(uint64 amount) external {\n        address positionAddress = positionAccounts[firstAvailablePositionAccountIndex];\n        if (positionAddress != tx.accounts.position.key) {\n            revert(\"Wrong liquidity token account\");\n        }\n\n        address pdaPositionAta = tx.accounts.pdaPositionAccount.key;\n        if (mapPositionAccountPdaAta[positionAddress] != pdaPositionAta) {\n            revert(\"Wrong position ATA\");\n        }\n\n        uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];\n        // Check that the token account exists\n        if (positionLiquidity == 0) {\n            revert(\"No liquidity on a provided token account\");\n        }\n\n        // Check the requested amount to be smaller or equal than the position liquidity\n        if (amount > positionLiquidity) {\n            revert(\"Amount exceeds a position liquidity\");\n        }\n\n        // Check the pdaBridgedTokenAccount address\n        if (tx.accounts.pdaBridgedTokenAccount.key != pdaBridgedTokenAccount) {\n            revert(\"Wrong PDA bridged token ATA\");\n        }\n\n        // Check that the pool is correct\n        if (tx.accounts.pool.key != pool) {\n            revert(\"Pool address is incorrect\");\n        }\n\n        // Check that the bridged token mint account is correct\n        if (tx.accounts.bridgedTokenMint.key != bridgedTokenMint) {\n            revert(\"Wrong bridged token mint account\");\n        }\n\n        // Transfer bridged tokens to the pdaBridgedTokenAccount address of this program\n        SplToken.transfer(\n            tx.accounts.userBridgedTokenAccount.key,\n            pdaBridgedTokenAccount,\n            tx.accounts.userWallet.key,\n            amount);\n\n        // Decrease the total liquidity amount\n        totalLiquidity -= amount;\n\n        // Burn acquired bridged tokens\n        SplToken.pda_burn(pdaBridgedTokenAccount, bridgedTokenMint, pdaProgram, amount, pdaProgramSeed, pdaBump);\n\n        // Decrease the position liquidity\n        AccountMeta[11] metasDecreaseLiquidity = [\n            AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false}),\n            AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n            AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: pdaPositionAta, is_writable: false, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.userTokenAccountA.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.userTokenAccountB.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tokenVaultA.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tokenVaultB.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: true, is_signer: false})\n        ];\n        // a026d06f685b2c01 - decreaseLiquidity, eff0ae00000000000000000000000000 - amount, aaf1950200000000 - minA, b8522d0000000000 - minB\n        // bytes bincode = \"0xa026d06f685b2c01eff0ae00000000000000000000000000aaf1950200000000b8522d0000000000\";\n        // orca.call{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(bincode);\n        whirlpool.decreaseLiquidity{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(amount, 0, 0);\n\n        // Update the token remainder\n        uint64 remainder = positionLiquidity - amount;\n        // Update liquidity and its associated position account\n        mapPositionAccountLiquidity[positionAddress] = remainder;\n\n        // If requested amount can be fully covered by the current position liquidity, close the position\n        if (remainder == 0) {\n            // Update fees for the position\n            AccountMeta[4] metasUpdateFees = [\n                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: false, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: false, is_signer: false})\n            ];\n            whirlpool.updateFeesAndRewards{accounts: metasUpdateFees, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Collect fees from the position\n            AccountMeta[9] metasCollectFees = [\n                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaPositionAta, is_writable: false, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.userTokenAccountA.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tokenVaultA.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.userTokenAccountB.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tokenVaultB.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false})\n            ];\n            whirlpool.collectFees{accounts: metasCollectFees, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Close the position\n            AccountMeta[6] metasClosePosition = [\n                AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n                AccountMeta({pubkey: tx.accounts.userWallet.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.positionMint.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaPositionAta, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false})\n            ];\n            whirlpool.closePosition{accounts: metasClosePosition, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Increase the first available position account index\n            firstAvailablePositionAccountIndex++;\n        }\n    }\n\n    /// @dev Gets the position data.\n    /// @return Position data.\n    @account(position)\n    @account(positionMint)\n    function getPositionData() external view returns (Position) {\n        return _getPositionData(tx.accounts.position, tx.accounts.positionMint.key);\n    }\n\n    /// @dev Gets liquidity amounts and position accounts in order to correctly withdraw a specified liquidity amount.\n    /// @param amount Liquidity amount to withdraw.\n    /// @return positionAmounts Position amounts.\n    /// @return positionAddresses Position mint addresses.\n    /// @return positionPdaAtas Position PDA ATA-s controlled by the program.\n    function getLiquidityAmountsAndPositions(uint64 amount)\n        external view returns (uint64[] positionAmounts, address[] positionAddresses, address[] positionPdaAtas)\n    {\n        if (amount > totalLiquidity) {\n            revert (\"Requested amount is too big for the total available liquidity\");\n        }\n\n        uint64 liquiditySum = 0;\n        uint32 numPositions = 0;\n        uint64 amountLeft = 0;\n\n        // Get the number of allocated positions\n        for (uint32 i = firstAvailablePositionAccountIndex; i < numPositionAccounts; ++i) {\n            address positionAddress = positionAccounts[i];\n            uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];\n\n            // Increase a total calculated liquidity and a number of positions to return\n            liquiditySum += positionLiquidity;\n            numPositions++;\n\n            // Check if the accumulated liquidity is enough to cover the requested amount\n            if (liquiditySum >= amount) {\n                amountLeft = liquiditySum - amount;\n                break;\n            }\n        }\n\n        // Allocate the necessary arrays and fill the values\n        positionAddresses = new address[](numPositions);\n        positionAmounts = new uint64[](numPositions);\n        positionPdaAtas = new address[](numPositions);\n        for (uint32 i = 0; i < numPositions; ++i) {\n            positionAddresses[i] = positionAccounts[firstAvailablePositionAccountIndex + i];\n            positionAmounts[i] = mapPositionAccountLiquidity[positionAddresses[i]];\n            positionPdaAtas[i] = mapPositionAccountPdaAta[positionAddresses[i]];\n        }\n\n        // Adjust the last position, if it was not fully allocated\n        if (numPositions > 0 && amountLeft > 0) {\n            positionAmounts[numPositions - 1] = amountLeft;\n        }\n    }\n\n    /// @dev Gets token account balance.\n    @account(account)\n    function getBalance() external view returns (uint64) {\n        return SplToken.get_balance(tx.accounts.account);\n    }\n\n    /// @dev Gets total supply of a provided token account.\n    @account(account)\n    function totalSupply() external view returns (uint64) {\n        return SplToken.total_supply(tx.accounts.account);\n    }\n}"
    },
    {
      "filename": "token-lending/program/src/processor.rs",
      "content": "//! Program state processor\n\nuse crate::{\n    self as spl_token_lending,\n    error::LendingError,\n    instruction::LendingInstruction,\n    math::{Decimal, Rate, TryAdd, TryDiv, TryMul, TrySub, WAD},\n    pyth,\n    state::{\n        CalculateBorrowResult, CalculateLiquidationResult, CalculateRepayResult,\n        InitLendingMarketParams, InitObligationParams, InitReserveParams, LendingMarket,\n        NewReserveCollateralParams, NewReserveLiquidityParams, Obligation, Reserve,\n        ReserveCollateral, ReserveConfig, ReserveLiquidity,\n    },\n};\nuse num_traits::FromPrimitive;\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    decode_error::DecodeError,\n    entrypoint::ProgramResult,\n    instruction::Instruction,\n    msg,\n    program::{invoke, invoke_signed},\n    program_error::{PrintProgramError, ProgramError},\n    program_pack::{IsInitialized, Pack},\n    pubkey::Pubkey,\n    sysvar::{clock::Clock, rent::Rent, Sysvar},\n};\nuse spl_token::solana_program::instruction::AccountMeta;\nuse spl_token::state::{Account, Mint};\nuse std::{convert::TryInto, result::Result};\nuse switchboard_program::{\n    get_aggregator, get_aggregator_result, AggregatorState, RoundResult, SwitchboardAccountType,\n};\n\n/// Processes an instruction\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    input: &[u8],\n) -> ProgramResult {\n    let instruction = LendingInstruction::unpack(input)?;\n    match instruction {\n        LendingInstruction::InitLendingMarket {\n            owner,\n            quote_currency,\n        } => {\n            msg!(\"Instruction: Init Lending Market\");\n            process_init_lending_market(program_id, owner, quote_currency, accounts)\n        }\n        LendingInstruction::SetLendingMarketOwner { new_owner } => {\n            msg!(\"Instruction: Set Lending Market Owner\");\n            process_set_lending_market_owner(program_id, new_owner, accounts)\n        }\n        LendingInstruction::InitReserve {\n            liquidity_amount,\n            config,\n        } => {\n            msg!(\"Instruction: Init Reserve\");\n            process_init_reserve(program_id, liquidity_amount, config, accounts)\n        }\n        LendingInstruction::RefreshReserve => {\n            msg!(\"Instruction: Refresh Reserve\");\n            process_refresh_reserve(program_id, accounts)\n        }\n        LendingInstruction::DepositReserveLiquidity { liquidity_amount } => {\n            msg!(\"Instruction: Deposit Reserve Liquidity\");\n            process_deposit_reserve_liquidity(program_id, liquidity_amount, accounts)\n        }\n        LendingInstruction::RedeemReserveCollateral { collateral_amount } => {\n            msg!(\"Instruction: Redeem Reserve Collateral\");\n            process_redeem_reserve_collateral(program_id, collateral_amount, accounts)\n        }\n        LendingInstruction::InitObligation => {\n            msg!(\"Instruction: Init Obligation\");\n            process_init_obligation(program_id, accounts)\n        }\n        LendingInstruction::RefreshObligation => {\n            msg!(\"Instruction: Refresh Obligation\");\n            process_refresh_obligation(program_id, accounts)\n        }\n        LendingInstruction::DepositObligationCollateral { collateral_amount } => {\n            msg!(\"Instruction: Deposit Obligation Collateral\");\n            process_deposit_obligation_collateral(program_id, collateral_amount, accounts)\n        }\n        LendingInstruction::WithdrawObligationCollateral { collateral_amount } => {\n            msg!(\"Instruction: Withdraw Obligation Collateral\");\n            process_withdraw_obligation_collateral(program_id, collateral_amount, accounts)\n        }\n        LendingInstruction::BorrowObligationLiquidity { liquidity_amount } => {\n            msg!(\"Instruction: Borrow Obligation Liquidity\");\n            process_borrow_obligation_liquidity(program_id, liquidity_amount, accounts)\n        }\n        LendingInstruction::RepayObligationLiquidity { liquidity_amount } => {\n            msg!(\"Instruction: Repay Obligation Liquidity\");\n            process_repay_obligation_liquidity(program_id, liquidity_amount, accounts)\n        }\n        LendingInstruction::LiquidateObligation { liquidity_amount } => {\n            msg!(\"Instruction: Liquidate Obligation\");\n            process_liquidate_obligation(program_id, liquidity_amount, accounts)\n        }\n        LendingInstruction::FlashLoan { amount } => {\n            msg!(\"Instruction: Flash Loan\");\n            process_flash_loan(program_id, amount, accounts)\n        }\n        LendingInstruction::DepositReserveLiquidityAndObligationCollateral { liquidity_amount } => {\n            msg!(\"Instruction: Deposit Reserve Liquidity and Obligation Collateral\");\n            process_deposit_reserve_liquidity_and_obligation_collateral(\n                program_id,\n                liquidity_amount,\n                accounts,\n            )\n        }\n        LendingInstruction::WithdrawObligationCollateralAndRedeemReserveCollateral {\n            collateral_amount,\n        } => {\n            msg!(\"Instruction: Withdraw Obligation Collateral and Redeem Reserve Collateral\");\n            process_withdraw_obligation_collateral_and_redeem_reserve_liquidity(\n                program_id,\n                collateral_amount,\n                accounts,\n            )\n        }\n        LendingInstruction::UpdateReserveConfig { config } => {\n            msg!(\"Instruction: UpdateReserveConfig\");\n            process_update_reserve_config(program_id, config, accounts)\n        }\n    }\n}\n\nfn process_init_lending_market(\n    program_id: &Pubkey,\n    owner: Pubkey,\n    quote_currency: [u8; 32],\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let lending_market_info = next_account_info(account_info_iter)?;\n    let rent = &Rent::from_account_info(next_account_info(account_info_iter)?)?;\n    let token_program_id = next_account_info(account_info_iter)?;\n    let oracle_program_id = next_account_info(account_info_iter)?;\n    let switchboard_oracle_program_id = next_account_info(account_info_iter)?;\n\n    assert_rent_exempt(rent, lending_market_info)?;\n    let mut lending_market = assert_uninitialized::<LendingMarket>(lending_market_info)?;\n    if lending_market_info.owner != program_id {\n        msg!(\"Lending market provided is not owned by the lending program\");\n        return Err(LendingError::InvalidAccountOwner.into());\n    }\n\n    lending_market.init(InitLendingMarketParams {\n        bump_seed: Pubkey::find_program_address(&[lending_market_info.key.as_ref()], program_id).1,\n        owner,\n        quote_currency,\n        token_program_id: *token_program_id.key,\n        oracle_program_id: *oracle_program_id.key,\n        switchboard_oracle_program_id: *switchboard_oracle_program_id.key,\n    });\n    LendingMarket::pack(lending_market, &mut lending_market_info.data.borrow_mut())?;\n\n    Ok(())\n}\n\n#[inline(never)] // avoid stack frame limit\nfn process_set_lending_market_owner(\n    program_id: &Pubkey,\n    new_owner: Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let lending_market_info = next_account_info(account_info_iter)?;\n    let lending_market_owner_info = next_account_info(account_info_iter)?;\n\n    let mut lending_market = LendingMarket::unpack(&lending_market_info.data.borrow())?;\n    if lending_market_info.owner != program_id {\n        msg!(\"Lending market provided is not owned by the lending program\");\n        return Err(LendingError::InvalidAccountOwner.into());\n    }\n    if &lending_market.owner != lending_market_owner_info.key {\n        msg!(\"Lending market owner does not match the lending market owner provided\");\n        return Err(LendingError::InvalidMarketOwner.into());\n    }\n    if !lending_market_owner_info.is_signer {\n        msg!(\"Lending market owner provided must be a signer\");\n        return Err(LendingError::InvalidSigner.into());\n    }\n\n    lending_market.owner = new_owner;\n    LendingMarket::pack(lending_market, &mut lending_market_info.data.borrow_mut())?;\n\n    Ok(())\n}\n\nfn process_init_reserve(\n    program_id: &Pubkey,\n    liquidity_amount: u64,\n    config: ReserveConfig,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    if liquidity_amount == 0 {\n        msg!(\"Reserve must be initialized with liquidity\");\n        return Err(LendingError::InvalidAmount.into());\n    }\n    validate_reserve_config(config)?;\n    let account_info_iter = &mut accounts.iter().peekable();\n    let source_liquidity_info = next_account_info(account_info_iter)?;\n    let destination_collateral_info = next_account_info(account_info_iter)?;\n    let reserve_info = next_account_info(account_info_iter)?;\n    let reserve_liquidity_mint_info = next_account_info(account_info_iter)?;\n    let reserve_liquidity_supply_info = next_account_info(account_info_iter)?;\n    let reserve_liquidity_fee_receiver_info = next_account_info(account_info_iter)?;\n    let reserve_collateral_mint_info = next_account_info(account_info_iter)?;\n    let reserve_collateral_supply_info = next_account_info(account_info_iter)?;\n    let pyth_product_info = next_account_info(account_info_iter)?;\n    let pyth_price_info = next_account_info(account_info_iter)?;\n    let switchboard_feed_info = next_account_info(account_info_iter)?;\n    let lending_market_info = next_account_info(account_info_iter)?;\n    let lending_market_authority_info = next_account_info(account_info_iter)?;\n    let lending_market_owner_info = next_account_info(account_info_iter)?;\n    let user_transfer_authority_info = next_account_info(account_info_iter)?;\n    let clock = &Clock::from_account_info(next_account_info(account_info_iter)?)?;\n    let rent_info = next_account_info(account_info_iter)?;\n    let rent = &Rent::from_account_info(rent_info)?;\n    let token_program_id = next_account_info(account_info_iter)?;\n\n    assert_rent_exempt(rent, reserve_info)?;\n    let mut reserve = assert_uninitialized::<Reserve>(reserve_info)?;\n    if reserve_info.owner != program_id {\n        msg!(\n            \"Reserve provided is not owned by the lending program {} != {}\",\n            &reserve_info.owner.to_string(),\n            &program_id.to_string(),\n        );\n        return Err(LendingError::InvalidAccountOwner.into());\n    }\n\n    if reserve_liquidity_supply_info.key == source_liquidity_info.key {\n        msg!(\"Reserve liquidity supply cannot be used as the source liquidity provided\");\n        return Err(LendingError::InvalidAccountInput.into());\n    }\n\n    let lending_market = LendingMarket::unpack(&lending_market_info.data.borrow())?;\n    if lending_market_info.owner != program_id {\n        msg!(\n            \"Lending market provided is not owned by the lending program  {} != {}\",\n            &lending_market_info.owner.to_string(),\n            &program_id.to_string(),\n        );\n        return Err(LendingError::InvalidAccountOwner.into());\n    }\n    if &lending_market.token_program_id != token_program_id.key {\n        msg!(\"Lending market token program does not match the token program provided\");\n        return Err(LendingError::InvalidTokenProgram.into());\n    }\n    if &lending_market.owner != lending_market_owner_info.key {\n        msg!(\"Lending market owner does not match the lending market owner provided\");\n        return Err(LendingError::InvalidMarketOwner.into());\n    }\n    if !lending_market_owner_info.is_signer {\n        msg!(\"Lending market owner provided must be a signer\");\n        return Err(LendingError::InvalidSigner.into());\n    }\n    if *switchboard_feed_info.key == spl_token_lending::NULL_PUBKEY\n        && (*pyth_price_info.key == spl_token_lending::NULL_PUBKEY\n            || *pyth_product_info.key == spl_token_lending::NULL_PUBKEY)\n    {\n        msg!(\"Both price oracles are null. At least one must be non-null\");\n        return Err(LendingError::InvalidOracleConfig.into());\n    }\n    validate_pyth_keys(&lending_market, pyth_product_info, pyth_price_info)?;\n    validate_switchboard_keys(&lending_market, switchboard_feed_info)?;\n\n    let market_price = get_price(switchboard_feed_info, pyth_price_info, clock)?;\n\n    let authority_signer_seeds = &[\n        lending_market_info.key.as_ref(),\n        &[lending_market.bump_seed],\n    ];\n    let lending_market_authority_pubkey =\n        Pubkey::create_program_address(authority_signer_seeds, program_id)?;\n    if &lending_market_authority_pubkey != lending_market_authority_info.key {\n        msg!(\n            \"Derived lending market authority does not match the lending market authority provided\"\n        );\n        return Err(LendingError::InvalidMarketAuthority.into());\n    }\n\n    let reserve_liquidity_mint = unpack_mint(&reserve_liquidity_mint_info.data.borrow())?;\n    if reserve_liquidity_mint_info.owner != token_program_id.key {\n        msg!(\"Reserve liquidity mint is not owned by the token program provided\");\n        return Err(LendingError::InvalidTokenOwner.into());\n    }\n\n    reserve.init(InitReserveParams {\n        current_slot: clock.slot,\n        lending_market: *lending_market_info.key,\n        liquidity: ReserveLiquidity::new(NewReserveLiquidityParams {\n            mint_pubkey: *reserve_liquidity_mint_info.key,\n            mint_decimals: reserve_liquidity_mint.decimals,\n            supply_pubkey: *reserve_liquidity_supply_info.key,\n            pyth_oracle_pubkey: *pyth_price_info.key,\n            switchboard_oracle_pubkey: *switchboard_feed_info.key,\n            market_price,\n        }),\n        collateral: ReserveCollateral::new(NewReserveCollateralParams {\n            mint_pubkey: *reserve_collateral_mint_info.key,\n            supply_pubkey: *reserve_collateral_supply_info.key,\n        }),\n        config,\n    });\n\n    let collateral_amount = reserve.deposit_liquidity(liquidity_amount)?;\n    Reserve::pack(reserve, &mut reserve_info.data.borrow_mut())?;\n\n    spl_token_init_account(TokenInitializeAccountParams {\n        account: reserve_liquidity_supply_info.clone(),\n        mint: reserve_liquidity_mint_info.clone(),\n        owner: lending_market_authority_info.clone(),\n        rent: rent_info.clone(),\n        token_program: token_program_id.clone(),\n    })?;\n\n    spl_token_init_account(TokenInitializeAccountParams {\n        account: reserve_liquidity_fee_receiver_info.clone(),\n        mint: reserve_liquidity_mint_info.clone(),\n        owner: lending_market_authority_info.clone(),\n        rent: rent_info.clone(),\n        token_program: token_program_id.clone(),\n    })?;\n\n    spl_token_init_mint(TokenInitializeMintParams {\n        mint: reserve_collateral_mint_info.clone(),\n        authority: lending_market_authority_info.key,\n        rent: rent_info.clone(),\n        decimals: reserve_liquidity_mint.decimals,\n        token_program: token_program_id.clone(),\n    })?;\n\n    spl_token_init_account(TokenInitializeAccountParams {\n        account: reserve_collateral_supply_info.clone(),\n        mint: reserve_collateral_mint_info.clone(),\n        owner: lending_market_authority_info.clone(),\n        rent: rent_info.clone(),\n        token_program: token_program_id.clone(),\n    })?;\n\n    spl_token_init_account(TokenInitializeAccountParams {\n        account: destination_collateral_info.clone(),\n        mint: reserve_collateral_mint_info.clone(),\n        owner: user_transfer_authority_info.clone(),\n        rent: rent_info.clone(),\n        token_program: token_program_id.clone(),\n    })?;\n\n    spl_token_transfer(TokenTrans"
    }
  ]
}