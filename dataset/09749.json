{
  "Title": "[N-01] Missing zero-address check in constructors and the setter functions",
  "Content": "\nMissing checks for zero-addresses may lead to infunctional protocol, if the variable addresses are updated incorrectly.\n\n### Proof of Concept\n\n1.  Navigate to the following all contract functions: [PrePOMarket.sol#L44](https://github.com/code-423n4/2022-03-prepo/blob/d62d7146b27fd39a5f1358ffde08766724886cf5/contracts/core/PrePOMarket.sol#L44).\n\n### Recommended Mitigation Steps\n\nConsider adding zero-address checks in the discussed constructors:\nrequire(newAddr != address(0));.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-03-prepo",
  "Code": [
    {
      "filename": "contracts/core/PrePOMarket.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/ILongShortToken.sol\";\nimport \"./interfaces/IPrePOMarket.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract PrePOMarket is IPrePOMarket, Ownable, ReentrancyGuard {\n    address private _treasury;\n\n    IERC20 private immutable _collateral;\n    ILongShortToken private immutable _longToken;\n    ILongShortToken private immutable _shortToken;\n\n    uint256 private immutable _floorLongPrice;\n    uint256 private immutable _ceilingLongPrice;\n    uint256 private _finalLongPrice;\n\n    uint256 private immutable _floorValuation;\n    uint256 private immutable _ceilingValuation;\n\n    uint256 private _mintingFee;\n    uint256 private _redemptionFee;\n\n    uint256 private immutable _expiryTime;\n\n    bool private _publicMinting;\n\n    uint256 private constant MAX_PRICE = 1e18;\n    uint256 private constant FEE_DENOMINATOR = 1000000;\n    uint256 private constant FEE_LIMIT = 50000;\n\n    /**\n     * Assumes `_newCollateral`, `_newLongToken`, and `_newShortToken` are\n     * valid, since they will be handled by the PrePOMarketFactory. The\n     * treasury is initialized to governance due to stack limitations.\n     *\n     * Assumes that ownership of `_longToken` and `_shortToken` has been\n     * transferred to this contract via `createMarket()` in\n     * `PrePOMarketFactory.sol`.\n     */\n    constructor(\n        address _governance,\n        address _newCollateral,\n        ILongShortToken _newLongToken,\n        ILongShortToken _newShortToken,\n        uint256 _newFloorLongPrice,\n        uint256 _newCeilingLongPrice,\n        uint256 _newFloorValuation,\n        uint256 _newCeilingValuation,\n        uint256 _newMintingFee,\n        uint256 _newRedemptionFee,\n        uint256 _newExpiryTime,\n        bool _allowed\n    ) {\n        require(\n            _newCeilingLongPrice > _newFloorLongPrice,\n            \"Ceiling must exceed floor\"\n        );\n        require(_newExpiryTime > block.timestamp, \"Invalid expiry\");\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        require(_newCeilingLongPrice <= MAX_PRICE, \"Ceiling cannot exceed 1\");\n\n        transferOwnership(_governance);\n        _treasury = _governance;\n\n        _collateral = IERC20(_newCollateral);\n        _longToken = _newLongToken;\n        _shortToken = _newShortToken;\n\n        _floorLongPrice = _newFloorLongPrice;\n        _ceilingLongPrice = _newCeilingLongPrice;\n        _finalLongPrice = MAX_PRICE + 1;\n\n        _floorValuation = _newFloorValuation;\n        _ceilingValuation = _newCeilingValuation;\n\n        _mintingFee = _newMintingFee;\n        _redemptionFee = _newRedemptionFee;\n\n        _expiryTime = _newExpiryTime;\n\n        _publicMinting = _allowed;\n\n        emit MarketCreated(\n            address(_newLongToken),\n            address(_newShortToken),\n            _newFloorLongPrice,\n            _newCeilingLongPrice,\n            _newFloorValuation,\n            _newCeilingValuation,\n            _newMintingFee,\n            _newRedemptionFee,\n            _newExpiryTime\n        );\n    }\n\n    function mintLongShortTokens(uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        if (msg.sender != owner()) {\n            require(_publicMinting, \"Public minting disabled\");\n        }\n        require(_finalLongPrice > MAX_PRICE, \"Market ended\");\n        require(\n            _collateral.balanceOf(msg.sender) >= _amount,\n            \"Insufficient collateral\"\n        );\n        /**\n         * Add 1 to avoid rounding to zero, only process if user is minting\n         * an amount large enough to pay a fee\n         */\n        uint256 _fee = (_amount * _mintingFee) / FEE_DENOMINATOR + 1;\n        require(_amount > _fee, \"Minting amount too small\");\n        _collateral.transferFrom(msg.sender, _treasury, _fee);\n        _amount -= _fee;\n        _collateral.transferFrom(msg.sender, address(this), _amount);\n        _longToken.mint(msg.sender, _amount);\n        _shortToken.mint(msg.sender, _amount);\n        emit Mint(msg.sender, _amount);\n        return _amount;\n    }\n\n    function redeem(uint256 _longAmount, uint256 _shortAmount)\n        external\n        override\n        nonReentrant\n    {\n        require(\n            _longToken.balanceOf(msg.sender) >= _longAmount,\n            \"Insufficient long tokens\"\n        );\n        require(\n            _shortToken.balanceOf(msg.sender) >= _shortAmount,\n            \"Insufficient short tokens\"\n        );\n\n        uint256 _collateralOwed;\n        if (_finalLongPrice <= MAX_PRICE) {\n            uint256 _shortPrice = MAX_PRICE - _finalLongPrice;\n            _collateralOwed =\n                (_finalLongPrice * _longAmount + _shortPrice * _shortAmount) /\n                MAX_PRICE;\n        } else {\n            require(\n                _longAmount == _shortAmount,\n                \"Long and Short must be equal\"\n            );\n            _collateralOwed = _longAmount;\n        }\n\n        _longToken.burnFrom(msg.sender, _longAmount);\n        _shortToken.burnFrom(msg.sender, _shortAmount);\n        /**\n         * Add 1 to avoid rounding to zero, only process if user is redeeming\n         * an amount large enough to pay a fee\n         */\n        uint256 _fee = (_collateralOwed * _redemptionFee) /\n            FEE_DENOMINATOR +\n            1;\n        require(_collateralOwed > _fee, \"Redemption amount too small\");\n        _collateral.transfer(_treasury, _fee);\n        _collateralOwed -= _fee;\n        _collateral.transfer(msg.sender, _collateralOwed);\n\n        emit Redemption(msg.sender, _collateralOwed);\n    }\n\n    function setTreasury(address _newTreasury) external override onlyOwner {\n        _treasury = _newTreasury;\n        emit TreasuryChanged(_newTreasury);\n    }\n\n    function setFinalLongPrice(uint256 _newFinalLongPrice)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            _newFinalLongPrice >= _floorLongPrice,\n            \"Price cannot be below floor\"\n        );\n        require(\n            _newFinalLongPrice <= _ceilingLongPrice,\n            \"Price cannot exceed ceiling\"\n        );\n        _finalLongPrice = _newFinalLongPrice;\n        emit FinalLongPriceSet(_newFinalLongPrice);\n    }\n\n    function setMintingFee(uint256 _newMintingFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _mintingFee = _newMintingFee;\n        emit MintingFeeChanged(_newMintingFee);\n    }\n\n    function setRedemptionFee(uint256 _newRedemptionFee)\n        external\n        override\n        onlyOwner\n    {\n        require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n        _redemptionFee = _newRedemptionFee;\n        emit RedemptionFeeChanged(_newRedemptionFee);\n    }\n\n    function setPublicMinting(bool _allowed) external override onlyOwner {\n        _publicMinting = _allowed;\n        emit PublicMintingChanged(_allowed);\n    }\n\n    function getTreasury() external view override returns (address) {\n        return _treasury;\n    }\n\n    function getCollateral() external view override returns (IERC20) {\n        return _collateral;\n    }\n\n    function getLongToken() external view override returns (ILongShortToken) {\n        return _longToken;\n    }\n\n    function getShortToken() external view override returns (ILongShortToken) {\n        return _shortToken;\n    }\n\n    function getFloorLongPrice() external view override returns (uint256) {\n        return _floorLongPrice;\n    }\n\n    function getCeilingLongPrice() external view override returns (uint256) {\n        return _ceilingLongPrice;\n    }\n\n    function getFinalLongPrice() external view override returns (uint256) {\n        return _finalLongPrice;\n    }\n\n    function getFloorValuation() external view override returns (uint256) {\n        return _floorValuation;\n    }\n\n    function getCeilingValuation() external view override returns (uint256) {\n        return _ceilingValuation;\n    }\n\n    function getMintingFee() external view override returns (uint256) {\n        return _mintingFee;\n    }\n\n    function getRedemptionFee() external view override returns (uint256) {\n        return _redemptionFee;\n    }\n\n    function getExpiryTime() external view override returns (uint256) {\n        return _expiryTime;\n    }\n\n    function isPublicMintingAllowed() external view override returns (bool) {\n        return _publicMinting;\n    }\n\n    function getMaxPrice() external pure override returns (uint256) {\n        return MAX_PRICE;\n    }\n\n    function getFeeDenominator() external pure override returns (uint256) {\n        return FEE_DENOMINATOR;\n    }\n\n    function getFeeLimit() external pure override returns (uint256) {\n        return FEE_LIMIT;\n    }\n}"
    }
  ]
}