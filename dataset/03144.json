{
  "Title": "No validation of the address parameter value in the contract constructor",
  "Content": "##### Description\nThe variable is assigned the value of the constructor input parameter. But this parameter is not checked before this. If the value turns out to be zero, then it will be necessary to redeploy the contract, since there is no other functionality to set this variable.\nAt line \nhttps://github.com/lidofinance/lido-dao/blob/801d3e854efb33ff33a59fe51187e187047a6be2/contracts/0.8.9/LidoMevTxFeeVault.sol#L72 \nthe `TREASURY` variable is set to the value of the `_treasury` input parameter.\n##### Recommendation\nIt is necessary to add a check of the input parameter to zero before initializing the variable.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/0.8.9/LidoMevTxFeeVault.sol",
      "content": "// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-v4.4/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-v4.4/token/ERC721/IERC721.sol\";\n\n\ninterface ILido {\n    /**\n    * @notice A payable function supposed to be funded only by LidoMevTxFeeVault contract\n    * @dev We need a separate function because funds received by default payable function\n    * will go through entire deposit algorithm\n    */\n    function receiveMevTxFee() external payable;\n}\n\n\n/**\n* @title A vault for temporary storage of MEV and transaction fees\n*\n* This contract has no payable functions because it's balance is supposed to be\n* increased directly by ethereum protocol when transaction priority fees and extracted MEV\n* rewards are earned by a validator.\n* These vault replenishments happen continuously throught a day, while withdrawals\n* happen much less often, only on LidoOracle beacon balance reports\n*/\ncontract LidoMevTxFeeVault {\n    address public immutable LIDO;\n    address public immutable TREASURY;\n\n    /**\n     * Total amount of rewards received via transactions\n     * Rewards received on this contract set as coinbase (fee receipient)\n     * are not counted\n     */\n    uint256 public totalRewardsReceivedViaTransactions;\n\n    /**\n      * Emitted when the ERC20 `token` recovered (e.g. transferred)\n      * to the Lido treasure address by `requestedBy` sender.\n      */\n    event ERC20Recovered(\n        address indexed requestedBy,\n        address indexed token,\n        uint256 amount\n    );\n\n    /**\n      * Emitted when the ERC721-compatible `token` (NFT) recovered (e.g. transferred)\n      * to the Lido treasure address by `requestedBy` sender.\n      */\n    event ERC721Recovered(\n        address indexed requestedBy,\n        address indexed token,\n        uint256 tokenId\n    );\n\n    /**\n      * Ctor\n      *\n      * @param _lido the Lido token (stETH) address\n      * @param _treasury the Lido treasury address (see ERC20/ERC721-recovery interfaces)\n      */\n    constructor(address _lido, address _treasury) {\n        require(_lido != address(0), \"LIDO_ZERO_ADDRESS\");\n\n        LIDO = _lido;\n        TREASURY = _treasury;\n    }\n\n    /**\n    * @notice Allows the contract to receive ETH\n    * @dev MEV rewards may be sent as plain ETH transfers\n    */\n    receive() external payable {\n        totalRewardsReceivedViaTransactions = totalRewardsReceivedViaTransactions + msg.value;\n    }\n\n    /**\n    * @notice Withdraw all accumulated rewards to Lido contract\n    * @dev Can be called only by the Lido contract\n    * @return amount uint256 of funds received as MEV and transaction fees in wei\n    */\n    function withdrawRewards() external returns (uint256 amount) {\n        require(msg.sender == LIDO, \"ONLY_LIDO_CAN_WITHDRAW\");\n\n        amount = address(this).balance;\n        if (amount > 0) {\n            ILido(LIDO).receiveMevTxFee{value: amount}();\n        }\n        return amount;\n    }\n\n    /**\n      * Transfers a given `_amount` of an ERC20-token (defined by the `_token` contract address)\n      * currently belonging to the burner contract address to the Lido treasury address.\n      *\n      * @param _token an ERC20-compatible token\n      * @param _amount token amount\n      */\n    function recoverERC20(address _token, uint256 _amount) external {\n        require(_amount > 0, \"ZERO_RECOVERY_AMOUNT\");\n\n        emit ERC20Recovered(msg.sender, _token, _amount);\n\n        require(IERC20(_token).transfer(TREASURY, _amount));\n    }\n\n    /**\n      * Transfers a given token_id of an ERC721-compatible NFT (defined by the token contract address)\n      * currently belonging to the burner contract address to the Lido treasury address.\n      *\n      * @param _token an ERC721-compatible token\n      * @param _tokenId minted token id\n      */\n    function recoverERC721(address _token, uint256 _tokenId) external {\n        emit ERC721Recovered(msg.sender, _token, _tokenId);\n\n        IERC721(_token).transferFrom(address(this), TREASURY, _tokenId);\n    }\n}"
    }
  ]
}