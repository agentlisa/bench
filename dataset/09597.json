{
  "Title": "[M-04] `OracleRef` assumes backup oracle uses the same normalizer as main oracle",
  "Content": "_Submitted by cmichel_\n\n[OracleRef.sol#L104](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/refs/OracleRef.sol#L104)<br>\n\nThe `OracleRef` assumes that the backup oracle uses the same normalizer as the main oracle.<br>\nThis generally isn't the case as it could be a completely different oracle, not even operated by Chainlink.<br>\n\nIf the main oracle fails, the backup oracle could be scaled by a wrong amount and return a wrong price which could lead to users being able to mint volt cheap or redeem volt for inflated underlying amounts.\n\n### Recommended Mitigation Steps\n\nShould there be two scaling factors, one for each oracle?\n\n**[ElliotFriedman (Volt) confirmed and commented](https://github.com/code-423n4/2022-03-volt-findings/issues/26#issuecomment-1092201320):**\n > This is a good catch as it exposes some underlying assumptions made about backup oracles; however, we can assume that both oracles will use the same scaling factor and thus we will not need a second value for the backup oracle.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-volt-protocol-contest",
  "Code": [
    {
      "filename": "contracts/refs/OracleRef.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./IOracleRef.sol\";\nimport \"./CoreRef.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/// @title Reference to an Oracle\n/// @author Fei Protocol\n/// @notice defines some utilities around interacting with the referenced oracle\nabstract contract OracleRef is IOracleRef, CoreRef {\n    using Decimal for Decimal.D256;\n    using SafeCast for int256;\n\n    /// @notice the oracle reference by the contract\n    IOracle public override oracle;\n\n    /// @notice the backup oracle reference by the contract\n    IOracle public override backupOracle;\n\n    /// @notice number of decimals to scale oracle price by, i.e. multiplying by 10^(decimalsNormalizer)\n    int256 public override decimalsNormalizer;\n\n    bool public override doInvert;\n\n    /// @notice OracleRef constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle oracle to reference\n    /// @param _backupOracle backup oracle to reference\n    /// @param _decimalsNormalizer number of decimals to normalize the oracle feed if necessary\n    /// @param _doInvert invert the oracle price if this flag is on\n    constructor(\n        address _core,\n        address _oracle,\n        address _backupOracle,\n        int256 _decimalsNormalizer,\n        bool _doInvert\n    ) CoreRef(_core) {\n        _setOracle(_oracle);\n        if (_backupOracle != address(0) && _backupOracle != _oracle) {\n            _setBackupOracle(_backupOracle);\n        }\n        _setDoInvert(_doInvert);\n        _setDecimalsNormalizer(_decimalsNormalizer);\n    }\n\n    /// @notice sets the referenced oracle\n    /// @param newOracle the new oracle to reference\n    function setOracle(address newOracle) external override onlyGovernor {\n        _setOracle(newOracle);\n    }\n\n    /// @notice sets the flag for whether to invert or not\n    /// @param newDoInvert the new flag for whether to invert\n    function setDoInvert(bool newDoInvert) external override onlyGovernor {\n        _setDoInvert(newDoInvert);\n    }\n\n    /// @notice sets the new decimalsNormalizer\n    /// @param newDecimalsNormalizer the new decimalsNormalizer\n    function setDecimalsNormalizer(int256 newDecimalsNormalizer)\n        external\n        override\n        onlyGovernor\n    {\n        _setDecimalsNormalizer(newDecimalsNormalizer);\n    }\n\n    /// @notice sets the referenced backup oracle\n    /// @param newBackupOracle the new backup oracle to reference\n    function setBackupOracle(address newBackupOracle)\n        external\n        override\n        onlyGovernorOrAdmin\n    {\n        _setBackupOracle(newBackupOracle);\n    }\n\n    /// @notice invert a peg price\n    /// @param price the peg price to invert\n    /// @return the inverted peg as a Decimal\n    /// @dev the inverted peg would be X per FEI\n    function invert(Decimal.D256 memory price)\n        public\n        pure\n        override\n        returns (Decimal.D256 memory)\n    {\n        return Decimal.one().div(price);\n    }\n\n    /// @notice updates the referenced oracle\n    function updateOracle() public override {\n        oracle.update();\n    }\n\n    /// @notice the peg price of the referenced oracle\n    /// @return the peg as a Decimal\n    /// @dev the peg is defined as FEI per X with X being ETH, dollars, etc\n    function readOracle() public view override returns (Decimal.D256 memory) {\n        (Decimal.D256 memory _peg, bool valid) = oracle.read();\n        if (!valid && address(backupOracle) != address(0)) {\n            (_peg, valid) = backupOracle.read();\n        }\n        require(valid, \"OracleRef: oracle invalid\");\n\n        // Scale the oracle price by token decimals delta if necessary\n        uint256 scalingFactor;\n        if (decimalsNormalizer < 0) {\n            scalingFactor = 10**(-1 * decimalsNormalizer).toUint256();\n            _peg = _peg.div(scalingFactor);\n        } else {\n            scalingFactor = 10**decimalsNormalizer.toUint256();\n            _peg = _peg.mul(scalingFactor);\n        }\n\n        // Invert the oracle price if necessary\n        if (doInvert) {\n            _peg = invert(_peg);\n        }\n        return _peg;\n    }\n\n    function _setOracle(address newOracle) internal {\n        require(newOracle != address(0), \"OracleRef: zero address\");\n        address oldOracle = address(oracle);\n        oracle = IOracle(newOracle);\n        emit OracleUpdate(oldOracle, newOracle);\n    }\n\n    // Supports zero address if no backup\n    function _setBackupOracle(address newBackupOracle) internal {\n        address oldBackupOracle = address(backupOracle);\n        backupOracle = IOracle(newBackupOracle);\n        emit BackupOracleUpdate(oldBackupOracle, newBackupOracle);\n    }\n\n    function _setDoInvert(bool newDoInvert) internal {\n        bool oldDoInvert = doInvert;\n        doInvert = newDoInvert;\n\n        if (oldDoInvert != newDoInvert) {\n            _setDecimalsNormalizer(-1 * decimalsNormalizer);\n        }\n\n        emit InvertUpdate(oldDoInvert, newDoInvert);\n    }\n\n    function _setDecimalsNormalizer(int256 newDecimalsNormalizer) internal {\n        int256 oldDecimalsNormalizer = decimalsNormalizer;\n        decimalsNormalizer = newDecimalsNormalizer;\n        emit DecimalsNormalizerUpdate(\n            oldDecimalsNormalizer,\n            newDecimalsNormalizer\n        );\n    }\n\n    function _setDecimalsNormalizerFromToken(address token) internal {\n        int256 feiDecimals = 18;\n        int256 _decimalsNormalizer = feiDecimals -\n            int256(uint256(IERC20Metadata(token).decimals()));\n\n        if (doInvert) {\n            _decimalsNormalizer = -1 * _decimalsNormalizer;\n        }\n\n        _setDecimalsNormalizer(_decimalsNormalizer);\n    }\n}"
    }
  ]
}