{
  "Title": "Contract does not conform to the ERC1820 specification",
  "Content": "The [ERC1820](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1820.md) standard defines a universal registry where addresses can register the interfaces they support. The specification requires that compliant contracts have a `canImplementInterfaceForAddress(bytes32 interfaceHash, address addr)` function that returns the `ERC1820_ACCEPT_MAGIC` constant *if and only if* the contract implements the interface (`interfaceHash`) for a given address (`addr`).\n\n\nImportantly, EIP1820 [specifies](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1820.md#interface-implementation-erc1820implementerinterface):\n\n\n\n> If [the contract] does not implement the `interfaceHash` for a given address (`addr`), [the `canImplementInterfaceForAddress` function] MUST NOT return `ERC1820_ACCEPT_MAGIC`.\n> \n> \n\n\nOn [line 12 of](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L12) [recoverable-wallet.sol](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L12) the `Erc777TokensRecipient` contract implements a `canImplementInterfaceForAddress` function which returns the `ERC1820_ACCEPT_MAGIC` constant on all inputs. This would indicate to an external caller that the contract implements all interfaces for all addresses.\n\n\nConsider modifying this function so that it returns `ERC1820_ACCEPT_MAGIC` only when `interfaceHash` is `keccak256(abi.encodePacked(“ERC777TokensRecipient”)` and `addr` is `address(this)`.\n\n\nAdditionally, the ERC1820 standard defines the `canImplementInterfaceForAddress(bytes32 interfaceHash, address addr)` function with `bytes32 interfaceHash` as the first parameter and `address addr` as the second parameter. However, the implementation on [line 12 of recoverable-wallet.sol](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L12) has these parameters reversed. We recommend changing the order of these parameters so the `canImplementInterfaceForAddress` function complies with the ERC1820 specification.\n\n\n***Update:*** *The**`canImplementInterfaceForAddress`* *function has been modified to conform with the ERC1820 standard. Note that the comments in lines 18 and 21 are still using* *`addr`**, yet the variable has been renamed to* *`_implementer`**.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "EIPS/eip-1820.md",
      "content": "---\neip: 1820\ncategory: ERC\nstatus: Moved\n---\n\nThis file was moved to https://github.com/ethereum/ercs/blob/master/ERCS/erc-1820.md"
    },
    {
      "filename": "contracts/source/recoverable-wallet.sol",
      "content": "pragma solidity 0.5.8;\n\ninterface Erc1820Registry {\n\tfunction setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract Erc777TokensRecipient {\n\tconstructor() public {\n\t\tErc1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24).setInterfaceImplementer(address(this), keccak256(abi.encodePacked(\"ERC777TokensRecipient\")), address(this));\n\t}\n\tfunction tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external { }\n\tfunction canImplementInterfaceForAddress(address, bytes32) external pure returns(bytes32) { return keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\")); }\n}\n\ncontract Ownable {\n\tevent ownership_transfer_started(address indexed owner, address indexed pending_owner);\n\tevent ownership_transfer_cancelled(address indexed owner, address indexed pending_owner);\n\tevent ownership_transfer_finished(address indexed old_owner, address indexed new_owner);\n\n\taddress public owner;\n\taddress public pending_owner;\n\n\tconstructor(address _owner) public {\n\t\trequire(_owner != address(0), \"Contract must have an owner.\");\n\t\towner = _owner;\n\t}\n\n\tmodifier only_owner() {\n\t\trequire(msg.sender == owner, \"Only the owner may call this method.\");\n\t\t_;\n\t}\n\n\tmodifier only_pending_owner() {\n\t\trequire(msg.sender == pending_owner, \"Only the pending owner can call this method.\");\n\t\t_;\n\t}\n\n\tfunction start_ownership_transfer(address _pending_owner) external only_owner {\n\t\trequire(_pending_owner != address(0), \"Contract must have an owner.\");\n\t\tpending_owner = _pending_owner;\n\t\temit ownership_transfer_started(owner, pending_owner);\n\t}\n\n\tfunction cancel_ownership_transfer() external only_owner {\n\t\taddress _pending_owner = pending_owner;\n\t\tpending_owner = address(0);\n\t\temit ownership_transfer_cancelled(owner, _pending_owner);\n\t}\n\n\tfunction accept_ownership() external only_pending_owner {\n\t\taddress _old_owner = owner;\n\t\towner = pending_owner;\n\t\tpending_owner = address(0);\n\t\temit ownership_transfer_finished(_old_owner, owner);\n\t}\n}\n\ncontract RecoverableWallet is Ownable, Erc777TokensRecipient {\n\tevent recovery_address_added(address indexed new_recoverer, uint256 recovery_delay_in_days);\n\tevent recovery_address_removed(address indexed old_recoverer);\n\tevent recovery_started(address indexed new_owner);\n\tevent recovery_cancelled();\n\tevent recovery_finished(address indexed new_pending_owner);\n\n\tmapping(address => uint16) public recovery_delays;\n\taddress public active_recovery_address;\n\tuint256 public active_recovery_end_time = uint256(-1);\n\n\tmodifier only_during_recovery() {\n\t\trequire(active_recovery_address != address(0), \"This method can only be called during a recovery.\");\n\t\t_;\n\t}\n\n\tmodifier only_outside_recovery() {\n\t\trequire(active_recovery_address == address(0), \"This method cannot be called during a recovery.\");\n\t\t_;\n\t}\n\n\tconstructor(address _initial_owner) Ownable(_initial_owner) public {\n\t\treset_recovery();\n\t}\n\n\t// accept ETH into this contract\n\tfunction () external payable { }\n\n\tfunction add_recovery_address(address _new_recovery_address, uint16 _recovery_delay_in_days) external only_owner only_outside_recovery {\n\t\trequire(_recovery_delay_in_days > 0, \"Recovery delay must be at least 1 day.\");\n\t\trecovery_delays[_new_recovery_address] = _recovery_delay_in_days;\n\t\temit recovery_address_added(_new_recovery_address, _recovery_delay_in_days);\n\t}\n\n\tfunction remove_recovery_address(address _old_recovery_address) external only_owner only_outside_recovery {\n\t\trecovery_delays[_old_recovery_address] = 0;\n\t\temit recovery_address_removed(_old_recovery_address);\n\t}\n\n\tfunction start_recovery() external {\n\t\tuint16 _proposed_recovery_delay = recovery_delays[msg.sender];\n\t\trequire(_proposed_recovery_delay != 0, \"Only designated recovery addresseses can initiate the recovery process.\");\n\n\t\tbool _in_recovery = active_recovery_address != address(0);\n\t\tif (_in_recovery) {\n\t\t\t// NOTE: the recovery address cannot change during recovery, so we can rely on this being != 0\n\t\t\tuint16 _active_recovery_delay = recovery_delays[active_recovery_address];\n\t\t\trequire(_proposed_recovery_delay < _active_recovery_delay, \"Recovery is already under way and new recovery doesn't have a higher priority.\");\n\t\t}\n\n\t\tactive_recovery_address = msg.sender;\n\t\tactive_recovery_end_time = block.timestamp + _proposed_recovery_delay * 1 days;\n\t\temit recovery_started(msg.sender);\n\t}\n\n\tfunction cancel_recovery() external only_owner only_during_recovery {\n\t\treset_recovery();\n\t\temit recovery_cancelled();\n\t}\n\n\tfunction finish_recovery() external only_during_recovery {\n\t\trequire(active_recovery_address != address(0), \"No recovery in progress.\");\n\t\trequire(block.timestamp > active_recovery_end_time, \"You must wait until the recovery delay is over before finishing the recovery.\");\n\n\t\tpending_owner = active_recovery_address;\n\t\treset_recovery();\n\t\temit recovery_finished(pending_owner);\n\t}\n\n\tfunction deploy(uint256 _value, bytes calldata _data, uint256 _salt) external payable only_owner only_outside_recovery returns (address) {\n\t\tbytes memory _data2 = _data;\n\t\taddress new_contract;\n\t\t/* solium-disable-next-line */\n\t\tassembly {\n\t\t\tnew_contract := create2(_value, add(_data2, 32), mload(_data2), _salt)\n\t\t}\n\t\trequire(new_contract != address(0), \"Contract creation failed.\");\n\t\treturn new_contract;\n\t}\n\n\tfunction execute(address payable _to, uint256 _value, bytes calldata _data) external payable only_owner only_outside_recovery returns (bytes memory) {\n\t\t(bool _success, bytes memory _result) = _to.call.value(_value)(_data);\n\t\trequire(_success, \"Contract execution failed.\");\n\t\treturn _result;\n\t}\n\n\tfunction reset_recovery() private {\n\t\tactive_recovery_address = address(0);\n\t\tactive_recovery_end_time = uint256(-1);\n\t}\n}\n\ncontract RecoverableWalletFactory {\n\tevent wallet_created(address indexed owner, RecoverableWallet indexed wallet);\n\n\tfunction create_wallet() external returns (RecoverableWallet) {\n\t\tRecoverableWallet wallet = new RecoverableWallet(msg.sender);\n\t\temit wallet_created(msg.sender, wallet);\n\t\treturn wallet;\n\t}\n\n\tfunction exists() external pure returns (bytes32) {\n\t\treturn 0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef;\n\t}\n}"
    },
    {
      "filename": "contracts/source/recoverable-wallet.sol",
      "content": "pragma solidity 0.5.8;\n\ninterface Erc1820Registry {\n\tfunction setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract Erc777TokensRecipient {\n\tconstructor() public {\n\t\tErc1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24).setInterfaceImplementer(address(this), keccak256(abi.encodePacked(\"ERC777TokensRecipient\")), address(this));\n\t}\n\tfunction tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external { }\n\tfunction canImplementInterfaceForAddress(address, bytes32) external pure returns(bytes32) { return keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\")); }\n}\n\ncontract Ownable {\n\tevent ownership_transfer_started(address indexed owner, address indexed pending_owner);\n\tevent ownership_transfer_cancelled(address indexed owner, address indexed pending_owner);\n\tevent ownership_transfer_finished(address indexed old_owner, address indexed new_owner);\n\n\taddress public owner;\n\taddress public pending_owner;\n\n\tconstructor(address _owner) public {\n\t\trequire(_owner != address(0), \"Contract must have an owner.\");\n\t\towner = _owner;\n\t}\n\n\tmodifier only_owner() {\n\t\trequire(msg.sender == owner, \"Only the owner may call this method.\");\n\t\t_;\n\t}\n\n\tmodifier only_pending_owner() {\n\t\trequire(msg.sender == pending_owner, \"Only the pending owner can call this method.\");\n\t\t_;\n\t}\n\n\tfunction start_ownership_transfer(address _pending_owner) external only_owner {\n\t\trequire(_pending_owner != address(0), \"Contract must have an owner.\");\n\t\tpending_owner = _pending_owner;\n\t\temit ownership_transfer_started(owner, pending_owner);\n\t}\n\n\tfunction cancel_ownership_transfer() external only_owner {\n\t\taddress _pending_owner = pending_owner;\n\t\tpending_owner = address(0);\n\t\temit ownership_transfer_cancelled(owner, _pending_owner);\n\t}\n\n\tfunction accept_ownership() external only_pending_owner {\n\t\taddress _old_owner = owner;\n\t\towner = pending_owner;\n\t\tpending_owner = address(0);\n\t\temit ownership_transfer_finished(_old_owner, owner);\n\t}\n}\n\ncontract RecoverableWallet is Ownable, Erc777TokensRecipient {\n\tevent recovery_address_added(address indexed new_recoverer, uint256 recovery_delay_in_days);\n\tevent recovery_address_removed(address indexed old_recoverer);\n\tevent recovery_started(address indexed new_owner);\n\tevent recovery_cancelled();\n\tevent recovery_finished(address indexed new_pending_owner);\n\n\tmapping(address => uint16) public recovery_delays;\n\taddress public active_recovery_address;\n\tuint256 public active_recovery_end_time = uint256(-1);\n\n\tmodifier only_during_recovery() {\n\t\trequire(active_recovery_address != address(0), \"This method can only be called during a recovery.\");\n\t\t_;\n\t}\n\n\tmodifier only_outside_recovery() {\n\t\trequire(active_recovery_address == address(0), \"This method cannot be called during a recovery.\");\n\t\t_;\n\t}\n\n\tconstructor(address _initial_owner) Ownable(_initial_owner) public {\n\t\treset_recovery();\n\t}\n\n\t// accept ETH into this contract\n\tfunction () external payable { }\n\n\tfunction add_recovery_address(address _new_recovery_address, uint16 _recovery_delay_in_days) external only_owner only_outside_recovery {\n\t\trequire(_recovery_delay_in_days > 0, \"Recovery delay must be at least 1 day.\");\n\t\trecovery_delays[_new_recovery_address] = _recovery_delay_in_days;\n\t\temit recovery_address_added(_new_recovery_address, _recovery_delay_in_days);\n\t}\n\n\tfunction remove_recovery_address(address _old_recovery_address) external only_owner only_outside_recovery {\n\t\trecovery_delays[_old_recovery_address] = 0;\n\t\temit recovery_address_removed(_old_recovery_address);\n\t}\n\n\tfunction start_recovery() external {\n\t\tuint16 _proposed_recovery_delay = recovery_delays[msg.sender];\n\t\trequire(_proposed_recovery_delay != 0, \"Only designated recovery addresseses can initiate the recovery process.\");\n\n\t\tbool _in_recovery = active_recovery_address != address(0);\n\t\tif (_in_recovery) {\n\t\t\t// NOTE: the recovery address cannot change during recovery, so we can rely on this being != 0\n\t\t\tuint16 _active_recovery_delay = recovery_delays[active_recovery_address];\n\t\t\trequire(_proposed_recovery_delay < _active_recovery_delay, \"Recovery is already under way and new recovery doesn't have a higher priority.\");\n\t\t}\n\n\t\tactive_recovery_address = msg.sender;\n\t\tactive_recovery_end_time = block.timestamp + _proposed_recovery_delay * 1 days;\n\t\temit recovery_started(msg.sender);\n\t}\n\n\tfunction cancel_recovery() external only_owner only_during_recovery {\n\t\treset_recovery();\n\t\temit recovery_cancelled();\n\t}\n\n\tfunction finish_recovery() external only_during_recovery {\n\t\trequire(active_recovery_address != address(0), \"No recovery in progress.\");\n\t\trequire(block.timestamp > active_recovery_end_time, \"You must wait until the recovery delay is over before finishing the recovery.\");\n\n\t\tpending_owner = active_recovery_address;\n\t\treset_recovery();\n\t\temit recovery_finished(pending_owner);\n\t}\n\n\tfunction deploy(uint256 _value, bytes calldata _data, uint256 _salt) external payable only_owner only_outside_recovery returns (address) {\n\t\tbytes memory _data2 = _data;\n\t\taddress new_contract;\n\t\t/* solium-disable-next-line */\n\t\tassembly {\n\t\t\tnew_contract := create2(_value, add(_data2, 32), mload(_data2), _salt)\n\t\t}\n\t\trequire(new_contract != address(0), \"Contract creation failed.\");\n\t\treturn new_contract;\n\t}\n\n\tfunction execute(address payable _to, uint256 _value, bytes calldata _data) external payable only_owner only_outside_recovery returns (bytes memory) {\n\t\t(bool _success, bytes memory _result) = _to.call.value(_value)(_data);\n\t\trequire(_success, \"Contract execution failed.\");\n\t\treturn _result;\n\t}\n\n\tfunction reset_recovery() private {\n\t\tactive_recovery_address = address(0);\n\t\tactive_recovery_end_time = uint256(-1);\n\t}\n}\n\ncontract RecoverableWalletFactory {\n\tevent wallet_created(address indexed owner, RecoverableWallet indexed wallet);\n\n\tfunction create_wallet() external returns (RecoverableWallet) {\n\t\tRecoverableWallet wallet = new RecoverableWallet(msg.sender);\n\t\temit wallet_created(msg.sender, wallet);\n\t\treturn wallet;\n\t}\n\n\tfunction exists() external pure returns (bytes32) {\n\t\treturn 0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef;\n\t}\n}"
    }
  ]
}