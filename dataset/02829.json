{
  "Title": "Implicit balances",
  "Content": "There are several instances throughout the code base where the strategies use their token balance without validating it matches the expected value. This has two implications:\n\n\n* It does not account for tokens that could be sent to the contract directly.\n* It assumes the contract has received the expected number of tokens.\n\n\nThe most important example is [both](https://github.com/OriginProtocol/origin-dollar/blob/bfe0ac8e5d7c05b9bf1021fafb25e0aed8a6ed45/contracts/contracts/strategies/ConvexOUSDMetaStrategy.sol#L154) [instances](https://github.com/OriginProtocol/origin-dollar/blob/bfe0ac8e5d7c05b9bf1021fafb25e0aed8a6ed45/contracts/contracts/strategies/ConvexOUSDMetaStrategy.sol#L176) when the `ConvexOUSDMetaStrategy` attempts to burn all its OUSD tokens. This would [fail](https://github.com/OriginProtocol/origin-dollar/blob/bfe0ac8e5d7c05b9bf1021fafb25e0aed8a6ed45/contracts/contracts/vault/VaultCore.sol#L254) if its balance exceeds the acceptable range, which could occur if someone sends OUSD directly to the strategy.\n\n\nAdditionally, in the interest of predictability:\n\n\n* When the [amount of tokens to deposit](https://github.com/OriginProtocol/origin-dollar/blob/bfe0ac8e5d7c05b9bf1021fafb25e0aed8a6ed45/contracts/contracts/strategies/ConvexOUSDMetaStrategy.sol#L55) is already known, that value can be used instead of the [contract’s balance](https://github.com/OriginProtocol/origin-dollar/blob/bfe0ac8e5d7c05b9bf1021fafb25e0aed8a6ed45/contracts/contracts/strategies/ConvexOUSDMetaStrategy.sol#L69). Alternatively, only the difference [needs to be minted](https://github.com/OriginProtocol/origin-dollar/blob/bfe0ac8e5d7c05b9bf1021fafb25e0aed8a6ed45/contracts/contracts/strategies/ConvexOUSDMetaStrategy.sol#L65) in the first place.\n* When the [amount of tokens to receive](https://github.com/OriginProtocol/origin-dollar/blob/bfe0ac8e5d7c05b9bf1021fafb25e0aed8a6ed45/contracts/contracts/strategies/ConvexOUSDMetaStrategy.sol#L98) is already known, it can be used as [the minimum withdrawal amount](https://github.com/OriginProtocol/origin-dollar/blob/bfe0ac8e5d7c05b9bf1021fafb25e0aed8a6ed45/contracts/contracts/strategies/ConvexOUSDMetaStrategy.sol#L151).\n\n\nLastly, in the interest of local reasoning and robustness, consider explicitly confirming that the Curve protocol returns the expected number of tokens, rather than assuming it respects the stated minimum thresholds.\n\n\n**Update:** *Fixed in [commit `290c68fd25a1f2967324948398227684ec834597`](https://github.com/OriginProtocol/origin-dollar/commit/ea5154feaa97b64a36bd49d83d38be6b9d526524). The Curve system is still assumed to return the expected number of tokens.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/strategies/ConvexOUSDMetaStrategy.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IERC20 } from \"./BaseCurveStrategy.sol\";\nimport { BaseConvexMetaStrategy } from \"./BaseConvexMetaStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract ConvexOUSDMetaStrategy is BaseConvexMetaStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /* Take 3pool LP and mint the corresponding amount of ousd. Deposit and stake that to\n     * ousd Curve Metapool. Take the LP from metapool and deposit them to Convex.\n     */\n    function _lpDepositAll() internal override {\n        IERC20 metapoolErc20 = IERC20(address(metapool));\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 threePoolLpBalance = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n        uint256 curve3PoolVirtualPrice = curvePool.get_virtual_price();\n        uint256 threePoolLpDollarValue = threePoolLpBalance.mulTruncate(\n            curve3PoolVirtualPrice\n        );\n\n        uint256 ousdToAdd = toPositive(\n            int256(\n                metapool.balances(crvCoinIndex).mulTruncate(\n                    curve3PoolVirtualPrice\n                )\n            ) -\n                int256(metapool.balances(mainCoinIndex)) +\n                int256(threePoolLpDollarValue)\n        );\n\n        /* Add so much OUSD so that the pool ends up being balanced. And at minimum\n         * add twice as much OUSD as 3poolLP and at maximum at twice as\n         * much OUSD.\n         */\n        ousdToAdd = Math.max(ousdToAdd, threePoolLpDollarValue);\n        ousdToAdd = Math.min(ousdToAdd, threePoolLpDollarValue * 2);\n\n        /* Mint so much ousd that the dollar value of 3CRVLP in the pool and OUSD will be equal after\n         * deployment of liquidity. In cases where pool is heavier in OUSD before the deposit strategy mints\n         * less OUSD and gets less metapoolLP and less rewards. And when pool is heavier in 3CRV strategy mints\n         * more OUSD and gets more metapoolLP and more rewards.\n         *\n         * In both cases metapool ends up being balanced and there should be no incentive to execute arbitrage trade.\n         */\n        if (ousdToAdd > 0) {\n            IVault(vaultAddress).mintForStrategy(ousdToAdd);\n        }\n\n        uint256 ousdBalance = metapoolMainToken.balanceOf(address(this));\n        uint256[2] memory _amounts = [ousdBalance, threePoolLpBalance];\n\n        uint256 metapoolVirtualPrice = metapool.get_virtual_price();\n        /**\n         * First convert all the deposited tokens to dollar values,\n         * then divide by virtual price to convert to metapool LP tokens\n         * and apply the max slippage\n         */\n        uint256 minReceived = (ousdBalance + threePoolLpDollarValue)\n            .divPrecisely(metapoolVirtualPrice)\n            .mulTruncate(uint256(1e18) - maxSlippage);\n\n        // slither-disable-next-line unused-return\n        metapool.add_liquidity(_amounts, minReceived);\n\n        uint256 metapoolLp = metapoolErc20.balanceOf(address(this));\n\n        bool success = IConvexDeposits(cvxDepositorAddress).deposit(\n            cvxDepositorPTokenId,\n            metapoolLp,\n            true // Deposit with staking\n        );\n\n        require(success, \"Failed to deposit to Convex\");\n    }\n\n    /**\n     * Withdraw the specified amount of tokens from the gauge. And use all the resulting tokens\n     * to remove liquidity from metapool\n     * @param num3CrvTokens Number of Convex LP tokens to remove from gauge\n     */\n    function _lpWithdraw(uint256 num3CrvTokens) internal override {\n        /* The rate between coins in the metapool determines the rate at which metapool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much 3crvLp\n         * we want we can determine how much of OUSD we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 crvPoolBalance = metapool.balances(crvCoinIndex);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * metapool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it. \n         */\n        uint256 k = (1e36 * metapoolLPToken.totalSupply()) / crvPoolBalance;\n        // simplifying below to: `uint256 diff = (num3CrvTokens - 1) * k` causes loss of precision\n        uint256 diff = crvPoolBalance * k - (crvPoolBalance - num3CrvTokens - 1) * k;\n        uint256 lpToBurn = diff / 1e36;\n\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n\n        require(\n            lpToBurn <= gaugeTokens,\n            string(\n                bytes.concat(\n                    bytes(\"Attempting to withdraw \"),\n                    bytes(Strings.toString(lpToBurn)),\n                    bytes(\", metapoolLP but only \"),\n                    bytes(Strings.toString(gaugeTokens)),\n                    bytes(\" available.\")\n                )\n            )\n        );\n\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards for deposit\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            lpToBurn,\n            true\n        );\n\n        // always withdraw all of the available metapool LP tokens (similar to how we always deposit all)\n        metapool.remove_liquidity(\n            lpToBurn,\n            [uint256(0), uint256(0)]\n        );\n        IVault(vaultAddress).burnForStrategy(\n            metapoolMainToken.balanceOf(address(this))\n        );\n    }\n\n    function _lpWithdrawAll() internal override {\n        IERC20 metapoolErc20 = IERC20(address(metapool));\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            gaugeTokens,\n            true\n        );\n\n        uint256[2] memory _minAmounts = [uint256(0), uint256(0)];\n        // slither-disable-next-line unused-return\n        metapool.remove_liquidity(\n            metapoolErc20.balanceOf(address(this)),\n            _minAmounts\n        );\n\n        IVault(vaultAddress).burnForStrategy(\n            metapoolMainToken.balanceOf(address(this))\n        );\n    }\n}"
    },
    {
      "filename": "contracts/contracts/strategies/ConvexOUSDMetaStrategy.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IERC20 } from \"./BaseCurveStrategy.sol\";\nimport { BaseConvexMetaStrategy } from \"./BaseConvexMetaStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract ConvexOUSDMetaStrategy is BaseConvexMetaStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /* Take 3pool LP and mint the corresponding amount of ousd. Deposit and stake that to\n     * ousd Curve Metapool. Take the LP from metapool and deposit them to Convex.\n     */\n    function _lpDepositAll() internal override {\n        IERC20 metapoolErc20 = IERC20(address(metapool));\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 threePoolLpBalance = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n        uint256 curve3PoolVirtualPrice = curvePool.get_virtual_price();\n        uint256 threePoolLpDollarValue = threePoolLpBalance.mulTruncate(\n            curve3PoolVirtualPrice\n        );\n\n        uint256 ousdToAdd = toPositive(\n            int256(\n                metapool.balances(crvCoinIndex).mulTruncate(\n                    curve3PoolVirtualPrice\n                )\n            ) -\n                int256(metapool.balances(mainCoinIndex)) +\n                int256(threePoolLpDollarValue)\n        );\n\n        /* Add so much OUSD so that the pool ends up being balanced. And at minimum\n         * add twice as much OUSD as 3poolLP and at maximum at twice as\n         * much OUSD.\n         */\n        ousdToAdd = Math.max(ousdToAdd, threePoolLpDollarValue);\n        ousdToAdd = Math.min(ousdToAdd, threePoolLpDollarValue * 2);\n\n        /* Mint so much ousd that the dollar value of 3CRVLP in the pool and OUSD will be equal after\n         * deployment of liquidity. In cases where pool is heavier in OUSD before the deposit strategy mints\n         * less OUSD and gets less metapoolLP and less rewards. And when pool is heavier in 3CRV strategy mints\n         * more OUSD and gets more metapoolLP and more rewards.\n         *\n         * In both cases metapool ends up being balanced and there should be no incentive to execute arbitrage trade.\n         */\n        if (ousdToAdd > 0) {\n            IVault(vaultAddress).mintForStrategy(ousdToAdd);\n        }\n\n        uint256 ousdBalance = metapoolMainToken.balanceOf(address(this));\n        uint256[2] memory _amounts = [ousdBalance, threePoolLpBalance];\n\n        uint256 metapoolVirtualPrice = metapool.get_virtual_price();\n        /**\n         * First convert all the deposited tokens to dollar values,\n         * then divide by virtual price to convert to metapool LP tokens\n         * and apply the max slippage\n         */\n        uint256 minReceived = (ousdBalance + threePoolLpDollarValue)\n            .divPrecisely(metapoolVirtualPrice)\n            .mulTruncate(uint256(1e18) - maxSlippage);\n\n        // slither-disable-next-line unused-return\n        metapool.add_liquidity(_amounts, minReceived);\n\n        uint256 metapoolLp = metapoolErc20.balanceOf(address(this));\n\n        bool success = IConvexDeposits(cvxDepositorAddress).deposit(\n            cvxDepositorPTokenId,\n            metapoolLp,\n            true // Deposit with staking\n        );\n\n        require(success, \"Failed to deposit to Convex\");\n    }\n\n    /**\n     * Withdraw the specified amount of tokens from the gauge. And use all the resulting tokens\n     * to remove liquidity from metapool\n     * @param num3CrvTokens Number of Convex LP tokens to remove from gauge\n     */\n    function _lpWithdraw(uint256 num3CrvTokens) internal override {\n        /* The rate between coins in the metapool determines the rate at which metapool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much 3crvLp\n         * we want we can determine how much of OUSD we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 crvPoolBalance = metapool.balances(crvCoinIndex);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * metapool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it. \n         */\n        uint256 k = (1e36 * metapoolLPToken.totalSupply()) / crvPoolBalance;\n        // simplifying below to: `uint256 diff = (num3CrvTokens - 1) * k` causes loss of precision\n        uint256 diff = crvPoolBalance * k - (crvPoolBalance - num3CrvTokens - 1) * k;\n        uint256 lpToBurn = diff / 1e36;\n\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n\n        require(\n            lpToBurn <= gaugeTokens,\n            string(\n                bytes.concat(\n                    bytes(\"Attempting to withdraw \"),\n                    bytes(Strings.toString(lpToBurn)),\n                    bytes(\", metapoolLP but only \"),\n                    bytes(Strings.toString(gaugeTokens)),\n                    bytes(\" available.\")\n                )\n            )\n        );\n\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards for deposit\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            lpToBurn,\n            true\n        );\n\n        // always withdraw all of the available metapool LP tokens (similar to how we always deposit all)\n        metapool.remove_liquidity(\n            lpToBurn,\n            [uint256(0), uint256(0)]\n        );\n        IVault(vaultAddress).burnForStrategy(\n            metapoolMainToken.balanceOf(address(this))\n        );\n    }\n\n    function _lpWithdrawAll() internal override {\n        IERC20 metapoolErc20 = IERC20(address(metapool));\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            gaugeTokens,\n            true\n        );\n\n        uint256[2] memory _minAmounts = [uint256(0), uint256(0)];\n        // slither-disable-next-line unused-return\n        metapool.remove_liquidity(\n            metapoolErc20.balanceOf(address(this)),\n            _minAmounts\n        );\n\n        IVault(vaultAddress).burnForStrategy(\n            metapoolMainToken.balanceOf(address(this))\n        );\n    }\n}"
    },
    {
      "filename": "contracts/contracts/strategies/ConvexOUSDMetaStrategy.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IERC20 } from \"./BaseCurveStrategy.sol\";\nimport { BaseConvexMetaStrategy } from \"./BaseConvexMetaStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract ConvexOUSDMetaStrategy is BaseConvexMetaStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /* Take 3pool LP and mint the corresponding amount of ousd. Deposit and stake that to\n     * ousd Curve Metapool. Take the LP from metapool and deposit them to Convex.\n     */\n    function _lpDepositAll() internal override {\n        IERC20 metapoolErc20 = IERC20(address(metapool));\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 threePoolLpBalance = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n        uint256 curve3PoolVirtualPrice = curvePool.get_virtual_price();\n        uint256 threePoolLpDollarValue = threePoolLpBalance.mulTruncate(\n            curve3PoolVirtualPrice\n        );\n\n        uint256 ousdToAdd = toPositive(\n            int256(\n                metapool.balances(crvCoinIndex).mulTruncate(\n                    curve3PoolVirtualPrice\n                )\n            ) -\n                int256(metapool.balances(mainCoinIndex)) +\n                int256(threePoolLpDollarValue)\n        );\n\n        /* Add so much OUSD so that the pool ends up being balanced. And at minimum\n         * add twice as much OUSD as 3poolLP and at maximum at twice as\n         * much OUSD.\n         */\n        ousdToAdd = Math.max(ousdToAdd, threePoolLpDollarValue);\n        ousdToAdd = Math.min(ousdToAdd, threePoolLpDollarValue * 2);\n\n        /* Mint so much ousd that the dollar value of 3CRVLP in the pool and OUSD will be equal after\n         * deployment of liquidity. In cases where pool is heavier in OUSD before the deposit strategy mints\n         * less OUSD and gets less metapoolLP and less rewards. And when pool is heavier in 3CRV strategy mints\n         * more OUSD and gets more metapoolLP and more rewards.\n         *\n         * In both cases metapool ends up being balanced and there should be no incentive to execute arbitrage trade.\n         */\n        if (ousdToAdd > 0) {\n            IVault(vaultAddress).mintForStrategy(ousdToAdd);\n        }\n\n        uint256 ousdBalance = metapoolMainToken.balanceOf(address(this));\n        uint256[2] memory _amounts = [ousdBalance, threePoolLpBalance];\n\n        uint256 metapoolVirtualPrice = metapool.get_virtual_price();\n        /**\n         * First convert all the deposited tokens to dollar values,\n         * then divide by virtual price to convert to metapool LP tokens\n         * and apply the max slippage\n         */\n        uint256 minReceived = (ousdBalance + threePoolLpDollarValue)\n            .divPrecisely(metapoolVirtualPrice)\n            .mulTruncate(uint256(1e18) - maxSlippage);\n\n        // slither-disable-next-line unused-return\n        metapool.add_liquidity(_amounts, minReceived);\n\n        uint256 metapoolLp = metapoolErc20.balanceOf(address(this));\n\n        bool success = IConvexDeposits(cvxDepositorAddress).deposit(\n            cvxDepositorPTokenId,\n            metapoolLp,\n            true // Deposit with staking\n        );\n\n        require(success, \"Failed to deposit to Convex\");\n    }\n\n    /**\n     * Withdraw the specified amount of tokens from the gauge. And use all the resulting tokens\n     * to remove liquidity from metapool\n     * @param num3CrvTokens Number of Convex LP tokens to remove from gauge\n     */\n    function _lpWithdraw(uint256 num3CrvTokens) internal override {\n        /* The rate between coins in the metapool determines the rate at which metapool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much 3crvLp\n         * we want we can determine how much of OUSD we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 crvPoolBalance = metapool.balances(crvCoinIndex);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * metapool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it. \n         */\n        uint256 k = (1e36 * metapoolLPToken.totalSupply()) / crvPoolBalance;\n        // simplifying below to: `uint256 diff = (num3CrvTokens - 1) * k` causes loss of precision\n        uint256 diff = crvPoolBalance * k - (crvPoolBalance - num3CrvTokens - 1) * k;\n        uint256 lpToBurn = diff / 1e36;\n\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n\n        require(\n            lpToBurn <= gaugeTokens,\n            string(\n                bytes.concat(\n                    bytes(\"Attempting to withdraw \"),\n                    bytes(Strings.toString(lpToBurn)),\n                    bytes(\", metapoolLP but only \"),\n                    bytes(Strings.toString(gaugeTokens)),\n                    bytes(\" available.\")\n                )\n            )\n        );\n\n        // withdraw and unwrap with claim takes back the lpTokens and also collects the rewards for deposit\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            lpToBurn,\n            true\n        );\n\n        // always withdraw all of the available metapool LP tokens (similar to how we always deposit all)\n        metapool.remove_liquidity(\n            lpToBurn,\n            [uint256(0), uint256(0)]\n        );\n        IVault(vaultAddress).burnForStrategy(\n            metapoolMainToken.balanceOf(address(this))\n        );\n    }\n\n    function _lpWithdrawAll() internal override {\n        IERC20 metapoolErc20 = IERC20(address(metapool));\n        uint256 gaugeTokens = IRewardStaking(cvxRewardStakerAddress).balanceOf(\n            address(this)\n        );\n        IRewardStaking(cvxRewardStakerAddress).withdrawAndUnwrap(\n            gaugeTokens,\n            true\n        );\n\n        uint256[2] memory _minAmounts = [uint256(0), uint256(0)];\n        // slither-disable-next-line unused-return\n        metapool.remove_liquidity(\n            metapoolErc20.balanceOf(address(this)),\n            _minAmounts\n        );\n\n        IVault(vaultAddress).burnForStrategy(\n            metapoolMainToken.balanceOf(address(this))\n        );\n    }\n}"
    }
  ]
}