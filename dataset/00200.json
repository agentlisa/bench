{
  "Title": "M-6: Rewards are calculated as distributed even if there are no stakers, locking the rewards forever",
  "Content": "# Issue M-6: Rewards are calculated as distributed even if there are no stakers, locking the rewards forever \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/113 \n\nThe protocol has acknowledged this issue.\n\n## Found by \n0x73696d616f, BoRonGod, Ironsidesec, SUPERMAN\\_I4G, Tendency, dimulski, marchev, rbserver\n## Summary\nThe ``ZivoeRewards.sol`` and the ``ZivoeRewardsVesting.sol`` contracts are a fork of the Synthetix rewards distribution contract, with slight modifications. The contract logic keeps track of the total time passed, as well as the cumulative rate of rewards that have been generated for each token used for rewards, so that for every user, it just has to keep track of the last timestamp and last rate at the time of the last reward withdrawal, stake, or unstake in order to calculate the rewards owed since the user began staking. The code special-cases the scenario where there are no users, by not updating the cumulative rate when the _totalSupply is zero, but it does not include such a condition for the tracking of the timestamp. Because of this, even when there are no users staking, the accounting logic still thinks funds were being dispersed during that timeframe (because the starting timestamp is updated), which means the funds effectively are distributed to nobody, rather than being saved for when there is someone to receive them. And will be locked in the contract forever. One of the modifications is this line in the [depositReward()](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeRewards.sol#L228-L243) function. \n```solidity\n      IERC20(_rewardsToken).safeTransferFrom(_msgSender(), address(this), reward);\n```\nContrary to the Synthetix implementation, Zivo requires each time reward is deposited to the contact, the reward amount to be transferred in the same transaction. However if a reward is deposited but there are no stakers, the reward that should have been distributed for the period until the first user stakes, will be locked in the contract forever, and won't be able to be added to the rewards for the next reward period because of the above code snippet. \n\n## Vulnerability Detail\n[Gist](https://gist.github.com/AtanasDimulski/e2edba2c03e4dd1325b9e73c8fd58ddb)\nAfter following the steps in the above linked [gist](https://gist.github.com/AtanasDimulski/e2edba2c03e4dd1325b9e73c8fd58ddb) add the following test to the ``AuditorTests.t.sol`` contract:\n\n```solidity\n    function test_LockedRewards() public {\n        vm.startPrank(ZVL);\n        zivoeToken.transfer(alice, 5_000_000e18);\n        uint256 duration = 30 days;\n        stZVE.addReward(address(mockUSDC), duration);\n        vm.stopPrank();\n\n        vm.startPrank(simulateYLD);\n        mockUSDC.mint(simulateYLD, 50_000e6); // this represent 50_000 USDC tokens to be distributed in the next 30 days\n        mockUSDC.approve(address(stZVE), type(uint256).max);\n        stZVE.depositReward(address(mockUSDC), 50_000e6);\n        skip(172_800); /// @notice two days pass, before anybody stakes in the contract\n        vm.stopPrank();\n\n        vm.startPrank(alice);\n        console2.log(\"USDC balance of alice before staking: \", mockUSDC.balanceOf(alice));\n        console2.log(\"USDC balance of stZVE contract: \", mockUSDC.balanceOf(address(stZVE)));\n        zivoeToken.approve(address(stZVE), type(uint256).max);\n        stZVE.stake(5_000_000e18);\n        skip(duration);\n        stZVE.fullWithdraw();\n        console2.log(\"USDC balance of alice after staking for 30 days: \", mockUSDC.balanceOf(alice));\n        console2.log(\"USDC balance of stZVE contract, when users have withdrawn everything for the first period: \", mockUSDC.balanceOf(address(stZVE)));\n        console2.log(\"USDC balance of stZVE contract, when users have withdrawn everything for the first period normalized: \", mockUSDC.balanceOf(address(stZVE)) / 1e6);\n        console2.log(\"zivoToken balance of alice after unstaking: \", zivoeToken.balanceOf(alice));\n        vm.stopPrank();\n    }\n```\n\n```solidity\nLogs:\n  USDC balance of alice before staking:  0\n  USDC balance of stZVE contract:  50000000000\n  USDC balance of alice after staking for 30 days:  46665000000\n  USDC balance of stZVE contract, when users have withdrawn everything for the first period:  3335000000\n  USDC balance of stZVE contract, when users have withdrawn everything for the first period normalized:  3335\n  zivoToken balance of alice after unstaking:  5000000000000000000000000\n```\nAs can be seen from the above logs **3335 USDC tokens** will be locked forever. \n\nTo run the test use: ``forge test -vvv --mt test_LockedRewards``\n## Impact\nIf the [depositReward()](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeRewards.sol#L228-L243) function is called prior to there being any users staking, the funds that should have gone to the first stakers will instead accrue to nobody, and be locked in the contract forever. \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeRewards.sol#L228-L243\n\n## Tool used\nManual Review & Foundry\n\n## Recommendation\nRemove the ``safeTransfer()`` from the [depositReward()](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeRewards.sol#L228-L243) function, and instead check if there are enough reward tokens already in the contract. Something similar to the [Synthetix implementation](https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol#L113-L132).\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> borderline medium/low. If there are no stakers and depositReward is called, the deposit amount might be lost since it isn't distributed to anybody.\n\n\n\n**panprog**\n\nKeeping this medium as the loss of funds can happen, although the probability of this is very low, but still possible.\n\n**spacegliderrrr**\n\nEscalate\n\nIt would be an admin/ user mistake to deposit rewards when there are no stakers. Issue should be low.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> It would be an admin/ user mistake to deposit rewards when there are no stakers. Issue should be low.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**panprog**\n\nThe rewards are sent from the lockers into ZivoeYDL, which then calls `depositReward` in the `distributeYield` function, which can be called by any user, thus the rewards might be lost without any admin interaction, only from (any) user interaction. And it's not user depositing rewards, it's user forcing accumulated reward to be deposited.\n\n**WangSecurity**\n\nNeed clarification how it can distribute rewards if there are no stakers. As I know the users deposit into tranches and their funds are used for either loans or investing in other protocols, correct? For depositing into tranches, the users receive ZVE token and then can stake it.\n\nBut in the edge case, no one staked their ZVE token, but the funds from tranches were invested in some protocol and accrued yield. That yield will be distributed among users, but since no one staked their ZVE, the funds are stuck inside the contract and cannot be withdraw by anyone?\n\n**panprog**\n\n@WangSecurity \nThe following are `ZivoeRewards` contracts (from `ZivoeGlobals`):\n```solidity\n    address public stJTT;       /// @dev The ZivoeRewards ($stJTT) contract.\n    address public stSTT;       /// @dev The ZivoeRewards ($stSTT) contract.\n    address public stZVE;       /// @dev The ZivoeRewards ($stZVE) contract.\n```\n\nWhen user deposits into tranche, he's given tranche tokens (STT or JTT). But in order to get the rewards, user will have to stake his token into stSTT/stJTT, which are ZivoeRewards. When the `ZivoeYDL` distributes yield via `distributeYield`, it deposits this yield as reward into stSTT/stJTT based on emaSTT/emaJTT, which are averages of the adjusted balances (not staked tokens). So if for whatever reason all users unstake their stSTT or stJTT tokens, it is possible that there is some distribution accumulated, which is deposited into stSTT or stJTT, but there are no stakers.\n\nThis is not a concern with stZVE, because it splits the yield between stZVE / vestZVE based on staked tokens total supply, so if stZVE total supply == 0, it will receive 0 reward.\n\n**WangSecurity**\n\nIn that case, the likelihood of that scenario is extremely low, but no guarantee that it doesn't happen, leading to a loss of funds if the issue occurs.\n\nPlanning to reject the escalations and leave the issue as it is.\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [spacegliderrrr](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/113/#issuecomment-2105745683): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/ZivoeRewards.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./libraries/ZivoeVotes.sol\";\n\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\";\n\ninterface IZivoeGlobals_ZivoeRewards {\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n}\n\n\n\n/// @notice This contract facilitates staking and yield distribution.\n///         This contract has the following responsibilities:\n///           - Allows staking and unstaking of modular \"stakingToken\".\n///           - Allows claiming yield distributed / \"deposited\" to this contract.\n///           - Allows multiple assets to be added as \"rewardToken\" for distributions.\n///           - Vests rewardTokens linearly overtime to stakers.\ncontract ZivoeRewards is ReentrancyGuard, Context, ZivoeVotes {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    struct Reward {\n        uint256 rewardsDuration;        /// @dev How long rewards take to vest, e.g. 30 days.\n        uint256 periodFinish;           /// @dev When current rewards will finish vesting.\n        uint256 rewardRate;             /// @dev Rewards emitted per second.\n        uint256 lastUpdateTime;         /// @dev Last time this data struct was updated.\n        uint256 rewardPerTokenStored;   /// @dev Last snapshot of rewardPerToken taken.\n    }\n\n    address public immutable GBL;       /// @dev The ZivoeGlobals contract.\n\n    address[] public rewardTokens;      /// @dev Array of ERC20 tokens distributed as rewards (if present).\n\n    uint256 private _totalSupply;       /// @dev Total supply of (non-transferrable) LP tokens for reards contract.\n\n    /// @dev Contains rewards information for each rewardToken.\n    mapping(address => Reward) public rewardData;\n\n    /// @dev The order is account -> rewardAsset -> amount.\n    mapping(address => mapping(address => uint256)) public accountRewardPerTokenPaid;\n\n    /// @dev The order is account -> rewardAsset -> amount.\n    mapping(address => mapping(address => uint256)) public rewards;\n\n     /// @dev Contains LP token balance of each account (is 1:1 ratio with amount deposited).\n    mapping(address => uint256) private _balances;\n\n    IERC20 public stakingToken;         /// @dev IERC20 wrapper for the stakingToken (deposited to receive LP tokens).\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the ZivoeRewards contract.\n    /// @param _stakingToken The ERC20 asset deposited to mint LP tokens (and returned when burning LP tokens).\n    /// @param _GBL The ZivoeGlobals contract.\n    constructor(address _stakingToken, address _GBL) {\n        stakingToken = IERC20(_stakingToken);\n        GBL = _GBL;\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during addReward().\n    /// @param  reward The asset that's being distributed.\n    event RewardAdded(address indexed reward);\n\n    /// @notice Emitted during depositReward().\n    /// @param  reward The asset that's being deposited.\n    /// @param  amount The amout deposited.\n    /// @param  depositor The _msgSender() who deposited said reward.\n    event RewardDeposited(address indexed reward, uint256 amount, address indexed depositor);\n\n    /// @notice Emitted during _getRewardAt().\n    /// @param  account The account receiving a reward.\n    /// @param  rewardsToken The ERC20 asset distributed as a reward.\n    /// @param  reward The amount of \"rewardsToken\" distributed.\n    event RewardDistributed(address indexed account, address indexed rewardsToken, uint256 reward);\n\n    /// @notice Emitted during stake().\n    /// @param  account The account staking \"stakingToken\".\n    /// @param  amount The amount of \"stakingToken\" staked.\n    event Staked(address indexed account, uint256 amount);\n\n    /// @notice Emitted during stakeFor().\n    /// @param  account The account receiveing the staked position of \"stakingToken\".\n    /// @param  amount The amount of \"stakingToken\" staked.\n    /// @param  by The account facilitating the staking.\n    event StakedFor(address indexed account, uint256 amount, address indexed by);\n\n    /// @notice Emitted during withdraw().\n    /// @param  account The account withdrawing \"stakingToken\".\n    /// @param  amount The amount of \"stakingToken\" withdrawn.\n    event Withdrawn(address indexed account, uint256 amount);\n\n\n\n    // ---------------\n    //    Modifiers\n    // ---------------\n\n    /// @notice This modifier ensures account rewards information is updated BEFORE mutative actions.\n    /// @param account The account to update personal rewards information if account != address(0).\n    modifier updateReward(address account) {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address token = rewardTokens[i];\n            rewardData[token].rewardPerTokenStored = rewardPerToken(token);\n            rewardData[token].lastUpdateTime = lastTimeRewardApplicable(token);\n            if (account != address(0)) {\n                rewards[account][token] = earned(account, token);\n                accountRewardPerTokenPaid[account][token] = rewardData[token].rewardPerTokenStored;\n            }\n        }\n        _;\n    }\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Returns the amount of tokens owned by \"account\", received when depositing via stake().\n    /// @param account The account to view information of.\n    /// @return amount The amount of tokens owned by \"account\".\n    function balanceOf(address account) external view returns (uint256 amount) { return _balances[account]; }\n    \n    /// @notice Returns the total amount of rewards being distributed to everyone for current rewardsDuration.\n    /// @param  _rewardsToken The asset that's being distributed.\n    /// @return amount The amount of rewards being distributed.\n    function getRewardForDuration(address _rewardsToken) external view returns (uint256 amount) {\n        return rewardData[_rewardsToken].rewardRate.mul(rewardData[_rewardsToken].rewardsDuration);\n    }\n\n    /// @notice Returns the amount of tokens in existence; these are minted and burned when depositing or withdrawing.\n    /// @return amount The amount of tokens in existence.\n    function totalSupply() external view returns (uint256 amount) { return _totalSupply; }\n\n    /// @notice Returns the last snapshot of rewardPerTokenStored taken for a reward asset.\n    /// @param account The account to view information of.\n    /// @param rewardAsset The reward token for which we want to return the rewardPerTokenstored.\n    /// @return amount The latest up-to-date value of rewardPerTokenStored.\n    function viewAccountRewardPerTokenPaid(\n        address account, address rewardAsset\n    ) external view returns (uint256 amount) {\n        return accountRewardPerTokenPaid[account][rewardAsset];\n    }\n\n    /// @notice Returns the rewards earned of a specific rewardToken for an address.\n    /// @param account The account to view information of.\n    /// @param rewardAsset The asset earned as a reward.\n    /// @return amount The amount of rewards earned.\n    function viewRewards(address account, address rewardAsset) external view returns (uint256 amount) {\n        return rewards[account][rewardAsset];\n    }\n\n    /// @notice Provides information on the rewards available for claim.\n    /// @param account The account to view information of.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return amount The amount of rewards earned.\n    function earned(address account, address _rewardsToken) public view returns (uint256 amount) {\n        return _balances[account].mul(\n            rewardPerToken(_rewardsToken).sub(accountRewardPerTokenPaid[account][_rewardsToken])\n        ).div(1e18).add(rewards[account][_rewardsToken]);\n    }\n\n    /// @notice Helper function for assessing distribution timelines.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return timestamp The most recent time (in UNIX format) at which rewards are available for distribution.\n    function lastTimeRewardApplicable(address _rewardsToken) public view returns (uint256 timestamp) {\n        return Math.min(block.timestamp, rewardData[_rewardsToken].periodFinish);\n    }\n\n    /// @notice Cumulative amount of rewards distributed per LP token.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return amount The cumulative amount of rewards distributed per LP token.\n    function rewardPerToken(address _rewardsToken) public view returns (uint256 amount) {\n        if (_totalSupply == 0) { return rewardData[_rewardsToken].rewardPerTokenStored; }\n        return rewardData[_rewardsToken].rewardPerTokenStored.add(\n            lastTimeRewardApplicable(_rewardsToken).sub(\n                rewardData[_rewardsToken].lastUpdateTime\n            ).mul(rewardData[_rewardsToken].rewardRate).mul(1e18).div(_totalSupply)\n        );\n    }\n\n    /// @notice Adds a new asset as a reward to this contract.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @param _rewardsDuration How long rewards take to vest, e.g. 30 days (denoted in seconds).\n    function addReward(address _rewardsToken, uint256 _rewardsDuration) external {\n        require(\n            _msgSender() == IZivoeGlobals_ZivoeRewards(GBL).ZVL(), \n            \"_msgSender() != IZivoeGlobals_ZivoeRewards(GBL).ZVL()\")\n        ;\n        require(_rewardsDuration > 0, \"ZivoeRewards::addReward() _rewardsDuration == 0\");\n        require(\n            rewardData[_rewardsToken].rewardsDuration == 0, \n            \"ZivoeRewards::addReward() rewardData[_rewardsToken].rewardsDuration != 0\"\n        );\n        require(rewardTokens.length < 10, \"ZivoeRewards::addReward() rewardTokens.length >= 10\");\n\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].rewardsDuration = _rewardsDuration;\n        emit RewardAdded(_rewardsToken);\n    }\n\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @param reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external updateReward(address(0)) nonReentrant {\n        IERC20(_rewardsToken).safeTransferFrom(_msgSender(), address(this), reward);\n\n        // Update vesting accounting for reward (if existing rewards being distributed, increase proportionally).\n        if (block.timestamp >= rewardData[_rewardsToken].periodFinish) {\n            rewardData[_rewardsToken].rewardRate = reward.div(rewardData[_rewardsToken].rewardsDuration);\n        } else {\n            uint256 remaining = rewardData[_rewardsToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardData[_rewardsToken].rewardRate);\n            rewardData[_rewardsToken].rewardRate = reward.add(leftover).div(rewardData[_rewardsToken].rewardsDuration);\n        }\n\n        rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\n        rewardData[_rewardsToken].periodFinish = block.timestamp.add(rewardData[_rewardsToken].rewardsDuration);\n        emit RewardDeposited(_rewardsToken, reward, _msgSender());\n    }\n\n    /// @notice Simultaneously calls withdraw() and getRewards() for convenience.\n    function fullWithdraw() external {\n        withdraw(_balances[_msgSender()]);\n        getRewards();\n    }\n\n    /// @notice Stakes the specified amount of stakingToken to this contract.\n    /// @param amount The amount of the _rewardsToken to deposit.\n    function stake(uint256 amount) external nonReentrant updateReward(_msgSender()) {\n        require(amount > 0, \"ZivoeRewards::stake() amount == 0\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n        _writeCheckpoint(_checkpoints[_msgSender()], _add, amount);\n        _balances[_msgSender()] = _balances[_msgSender()].add(amount);\n        stakingToken.safeTransferFrom(_msgSender(), address(this), amount);\n        emit Staked(_msgSender(), amount);\n    }\n\n    /// @notice Stakes the specified amount of stakingToken to this contract, awarded to someone else.\n    /// @dev    This takes stakingToken from _msgSender() and awards stake to \"account\".\n    /// @param amount The amount of the _rewardsToken to deposit.\n    /// @param account The account to stake for (that ultimately receives the stake).\n    function stakeFor(uint256 amount, address account) external nonReentrant updateReward(account) {\n        require(amount > 0, \"ZivoeRewards::stakeFor() amount == 0\");\n        require(account != address(0), \"ZivoeRewards::stakeFor() account == address(0)\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n        _writeCheckpoint(_checkpoints[account], _add, amount);\n        _balances[account] = _balances[account].add(amount);\n        stakingToken.safeTransferFrom(_msgSender(), address(this), amount);\n        emit StakedFor(account, amount, _msgSender());\n    }\n    \n    /// @notice Claim rewards for all possible _rewardTokens.\n    function getRewards() public updateReward(_msgSender()) {\n        for (uint256 i = 0; i < rewardTokens.length; i++) { _getRewardAt(i); }\n    }\n    \n    /// @notice Claim rewards for a specific _rewardToken.\n    /// @param index The index to claim, corresponds to a given index of rewardToken[].\n    function _getRewardAt(uint256 index) internal nonReentrant {\n        address _rewardsToken = rewardTokens[index];\n        uint256 reward = rewards[_msgSender()][_rewardsToken];\n        if (reward > 0) {\n            rewards[_msgSender()][_rewardsToken] = 0;\n            IERC20(_rewardsToken).safeTransfer(_msgSender(), reward);\n            emit RewardDistributed(_msgSender(), _rewardsToken, reward);\n        }\n    }\n\n    /// @notice Withdraws the specified amount of stakingToken from this contract.\n    /// @param amount The amount of the _rewardsToken to withdraw.\n    function withdraw(uint256 amount) public nonReentrant updateReward(_msgSender()) {\n        require(amount > 0, \"ZivoeRewards::withdraw() amount == 0\");\n\n        _totalSupply = _totalSupply.sub(amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n        _writeCheckpoint(_checkpoints[_msgSender()], _subtract, amount);\n        _balances[_msgSender()] = _balances[_msgSender()].sub(amount);\n        stakingToken.safeTransfer(_msgSender(), amount);\n        emit Withdrawn(_msgSender(), amount);\n    }\n\n}"
    },
    {
      "filename": "zivoe-core-foundry/src/ZivoeRewards.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./libraries/ZivoeVotes.sol\";\n\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\";\n\ninterface IZivoeGlobals_ZivoeRewards {\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n}\n\n\n\n/// @notice This contract facilitates staking and yield distribution.\n///         This contract has the following responsibilities:\n///           - Allows staking and unstaking of modular \"stakingToken\".\n///           - Allows claiming yield distributed / \"deposited\" to this contract.\n///           - Allows multiple assets to be added as \"rewardToken\" for distributions.\n///           - Vests rewardTokens linearly overtime to stakers.\ncontract ZivoeRewards is ReentrancyGuard, Context, ZivoeVotes {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    struct Reward {\n        uint256 rewardsDuration;        /// @dev How long rewards take to vest, e.g. 30 days.\n        uint256 periodFinish;           /// @dev When current rewards will finish vesting.\n        uint256 rewardRate;             /// @dev Rewards emitted per second.\n        uint256 lastUpdateTime;         /// @dev Last time this data struct was updated.\n        uint256 rewardPerTokenStored;   /// @dev Last snapshot of rewardPerToken taken.\n    }\n\n    address public immutable GBL;       /// @dev The ZivoeGlobals contract.\n\n    address[] public rewardTokens;      /// @dev Array of ERC20 tokens distributed as rewards (if present).\n\n    uint256 private _totalSupply;       /// @dev Total supply of (non-transferrable) LP tokens for reards contract.\n\n    /// @dev Contains rewards information for each rewardToken.\n    mapping(address => Reward) public rewardData;\n\n    /// @dev The order is account -> rewardAsset -> amount.\n    mapping(address => mapping(address => uint256)) public accountRewardPerTokenPaid;\n\n    /// @dev The order is account -> rewardAsset -> amount.\n    mapping(address => mapping(address => uint256)) public rewards;\n\n     /// @dev Contains LP token balance of each account (is 1:1 ratio with amount deposited).\n    mapping(address => uint256) private _balances;\n\n    IERC20 public stakingToken;         /// @dev IERC20 wrapper for the stakingToken (deposited to receive LP tokens).\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the ZivoeRewards contract.\n    /// @param _stakingToken The ERC20 asset deposited to mint LP tokens (and returned when burning LP tokens).\n    /// @param _GBL The ZivoeGlobals contract.\n    constructor(address _stakingToken, address _GBL) {\n        stakingToken = IERC20(_stakingToken);\n        GBL = _GBL;\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during addReward().\n    /// @param  reward The asset that's being distributed.\n    event RewardAdded(address indexed reward);\n\n    /// @notice Emitted during depositReward().\n    /// @param  reward The asset that's being deposited.\n    /// @param  amount The amout deposited.\n    /// @param  depositor The _msgSender() who deposited said reward.\n    event RewardDeposited(address indexed reward, uint256 amount, address indexed depositor);\n\n    /// @notice Emitted during _getRewardAt().\n    /// @param  account The account receiving a reward.\n    /// @param  rewardsToken The ERC20 asset distributed as a reward.\n    /// @param  reward The amount of \"rewardsToken\" distributed.\n    event RewardDistributed(address indexed account, address indexed rewardsToken, uint256 reward);\n\n    /// @notice Emitted during stake().\n    /// @param  account The account staking \"stakingToken\".\n    /// @param  amount The amount of \"stakingToken\" staked.\n    event Staked(address indexed account, uint256 amount);\n\n    /// @notice Emitted during stakeFor().\n    /// @param  account The account receiveing the staked position of \"stakingToken\".\n    /// @param  amount The amount of \"stakingToken\" staked.\n    /// @param  by The account facilitating the staking.\n    event StakedFor(address indexed account, uint256 amount, address indexed by);\n\n    /// @notice Emitted during withdraw().\n    /// @param  account The account withdrawing \"stakingToken\".\n    /// @param  amount The amount of \"stakingToken\" withdrawn.\n    event Withdrawn(address indexed account, uint256 amount);\n\n\n\n    // ---------------\n    //    Modifiers\n    // ---------------\n\n    /// @notice This modifier ensures account rewards information is updated BEFORE mutative actions.\n    /// @param account The account to update personal rewards information if account != address(0).\n    modifier updateReward(address account) {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address token = rewardTokens[i];\n            rewardData[token].rewardPerTokenStored = rewardPerToken(token);\n            rewardData[token].lastUpdateTime = lastTimeRewardApplicable(token);\n            if (account != address(0)) {\n                rewards[account][token] = earned(account, token);\n                accountRewardPerTokenPaid[account][token] = rewardData[token].rewardPerTokenStored;\n            }\n        }\n        _;\n    }\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Returns the amount of tokens owned by \"account\", received when depositing via stake().\n    /// @param account The account to view information of.\n    /// @return amount The amount of tokens owned by \"account\".\n    function balanceOf(address account) external view returns (uint256 amount) { return _balances[account]; }\n    \n    /// @notice Returns the total amount of rewards being distributed to everyone for current rewardsDuration.\n    /// @param  _rewardsToken The asset that's being distributed.\n    /// @return amount The amount of rewards being distributed.\n    function getRewardForDuration(address _rewardsToken) external view returns (uint256 amount) {\n        return rewardData[_rewardsToken].rewardRate.mul(rewardData[_rewardsToken].rewardsDuration);\n    }\n\n    /// @notice Returns the amount of tokens in existence; these are minted and burned when depositing or withdrawing.\n    /// @return amount The amount of tokens in existence.\n    function totalSupply() external view returns (uint256 amount) { return _totalSupply; }\n\n    /// @notice Returns the last snapshot of rewardPerTokenStored taken for a reward asset.\n    /// @param account The account to view information of.\n    /// @param rewardAsset The reward token for which we want to return the rewardPerTokenstored.\n    /// @return amount The latest up-to-date value of rewardPerTokenStored.\n    function viewAccountRewardPerTokenPaid(\n        address account, address rewardAsset\n    ) external view returns (uint256 amount) {\n        return accountRewardPerTokenPaid[account][rewardAsset];\n    }\n\n    /// @notice Returns the rewards earned of a specific rewardToken for an address.\n    /// @param account The account to view information of.\n    /// @param rewardAsset The asset earned as a reward.\n    /// @return amount The amount of rewards earned.\n    function viewRewards(address account, address rewardAsset) external view returns (uint256 amount) {\n        return rewards[account][rewardAsset];\n    }\n\n    /// @notice Provides information on the rewards available for claim.\n    /// @param account The account to view information of.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return amount The amount of rewards earned.\n    function earned(address account, address _rewardsToken) public view returns (uint256 amount) {\n        return _balances[account].mul(\n            rewardPerToken(_rewardsToken).sub(accountRewardPerTokenPaid[account][_rewardsToken])\n        ).div(1e18).add(rewards[account][_rewardsToken]);\n    }\n\n    /// @notice Helper function for assessing distribution timelines.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return timestamp The most recent time (in UNIX format) at which rewards are available for distribution.\n    function lastTimeRewardApplicable(address _rewardsToken) public view returns (uint256 timestamp) {\n        return Math.min(block.timestamp, rewardData[_rewardsToken].periodFinish);\n    }\n\n    /// @notice Cumulative amount of rewards distributed per LP token.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return amount The cumulative amount of rewards distributed per LP token.\n    function rewardPerToken(address _rewardsToken) public view returns (uint256 amount) {\n        if (_totalSupply == 0) { return rewardData[_rewardsToken].rewardPerTokenStored; }\n        return rewardData[_rewardsToken].rewardPerTokenStored.add(\n            lastTimeRewardApplicable(_rewardsToken).sub(\n                rewardData[_rewardsToken].lastUpdateTime\n            ).mul(rewardData[_rewardsToken].rewardRate).mul(1e18).div(_totalSupply)\n        );\n    }\n\n    /// @notice Adds a new asset as a reward to this contract.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @param _rewardsDuration How long rewards take to vest, e.g. 30 days (denoted in seconds).\n    function addReward(address _rewardsToken, uint256 _rewardsDuration) external {\n        require(\n            _msgSender() == IZivoeGlobals_ZivoeRewards(GBL).ZVL(), \n            \"_msgSender() != IZivoeGlobals_ZivoeRewards(GBL).ZVL()\")\n        ;\n        require(_rewardsDuration > 0, \"ZivoeRewards::addReward() _rewardsDuration == 0\");\n        require(\n            rewardData[_rewardsToken].rewardsDuration == 0, \n            \"ZivoeRewards::addReward() rewardData[_rewardsToken].rewardsDuration != 0\"\n        );\n        require(rewardTokens.length < 10, \"ZivoeRewards::addReward() rewardTokens.length >= 10\");\n\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].rewardsDuration = _rewardsDuration;\n        emit RewardAdded(_rewardsToken);\n    }\n\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @param reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external updateReward(address(0)) nonReentrant {\n        IERC20(_rewardsToken).safeTransferFrom(_msgSender(), address(this), reward);\n\n        // Update vesting accounting for reward (if existing rewards being distributed, increase proportionally).\n        if (block.timestamp >= rewardData[_rewardsToken].periodFinish) {\n            rewardData[_rewardsToken].rewardRate = reward.div(rewardData[_rewardsToken].rewardsDuration);\n        } else {\n            uint256 remaining = rewardData[_rewardsToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardData[_rewardsToken].rewardRate);\n            rewardData[_rewardsToken].rewardRate = reward.add(leftover).div(rewardData[_rewardsToken].rewardsDuration);\n        }\n\n        rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\n        rewardData[_rewardsToken].periodFinish = block.timestamp.add(rewardData[_rewardsToken].rewardsDuration);\n        emit RewardDeposited(_rewardsToken, reward, _msgSender());\n    }\n\n    /// @notice Simultaneously calls withdraw() and getRewards() for convenience.\n    function fullWithdraw() external {\n        withdraw(_balances[_msgSender()]);\n        getRewards();\n    }\n\n    /// @notice Stakes the specified amount of stakingToken to this contract.\n    /// @param amount The amount of the _rewardsToken to deposit.\n    function stake(uint256 amount) external nonReentrant updateReward(_msgSender()) {\n        require(amount > 0, \"ZivoeRewards::stake() amount == 0\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n        _writeCheckpoint(_checkpoints[_msgSender()], _add, amount);\n        _balances[_msgSender()] = _balances[_msgSender()].add(amount);\n        stakingToken.safeTransferFrom(_msgSender(), address(this), amount);\n        emit Staked(_msgSender(), amount);\n    }\n\n    /// @notice Stakes the specified amount of stakingToken to this contract, awarded to someone else.\n    /// @dev    This takes stakingToken from _msgSender() and awards stake to \"account\".\n    /// @param amount The amount of the _rewardsToken to deposit.\n    /// @param account The account to stake for (that ultimately receives the stake).\n    function stakeFor(uint256 amount, address account) external nonReentrant updateReward(account) {\n        require(amount > 0, \"ZivoeRewards::stakeFor() amount == 0\");\n        require(account != address(0), \"ZivoeRewards::stakeFor() account == address(0)\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n        _writeCheckpoint(_checkpoints[account], _add, amount);\n        _balances[account] = _balances[account].add(amount);\n        stakingToken.safeTransferFrom(_msgSender(), address(this), amount);\n        emit StakedFor(account, amount, _msgSender());\n    }\n    \n    /// @notice Claim rewards for all possible _rewardTokens.\n    function getRewards() public updateReward(_msgSender()) {\n        for (uint256 i = 0; i < rewardTokens.length; i++) { _getRewardAt(i); }\n    }\n    \n    /// @notice Claim rewards for a specific _rewardToken.\n    /// @param index The index to claim, corresponds to a given index of rewardToken[].\n    function _getRewardAt(uint256 index) internal nonReentrant {\n        address _rewardsToken = rewardTokens[index];\n        uint256 reward = rewards[_msgSender()][_rewardsToken];\n        if (reward > 0) {\n            rewards[_msgSender()][_rewardsToken] = 0;\n            IERC20(_rewardsToken).safeTransfer(_msgSender(), reward);\n            emit RewardDistributed(_msgSender(), _rewardsToken, reward);\n        }\n    }\n\n    /// @notice Withdraws the specified amount of stakingToken from this contract.\n    /// @param amount The amount of the _rewardsToken to withdraw.\n    function withdraw(uint256 amount) public nonReentrant updateReward(_msgSender()) {\n        require(amount > 0, \"ZivoeRewards::withdraw() amount == 0\");\n\n        _totalSupply = _totalSupply.sub(amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n        _writeCheckpoint(_checkpoints[_msgSender()], _subtract, amount);\n        _balances[_msgSender()] = _balances[_msgSender()].sub(amount);\n        stakingToken.safeTransfer(_msgSender(), amount);\n        emit Withdrawn(_msgSender(), amount);\n    }\n\n}"
    },
    {
      "filename": "zivoe-core-foundry/src/ZivoeRewards.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./libraries/ZivoeVotes.sol\";\n\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\";\n\ninterface IZivoeGlobals_ZivoeRewards {\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n}\n\n\n\n/// @notice This contract facilitates staking and yield distribution.\n///         This contract has the following responsibilities:\n///           - Allows staking and unstaking of modular \"stakingToken\".\n///           - Allows claiming yield distributed / \"deposited\" to this contract.\n///           - Allows multiple assets to be added as \"rewardToken\" for distributions.\n///           - Vests rewardTokens linearly overtime to stakers.\ncontract ZivoeRewards is ReentrancyGuard, Context, ZivoeVotes {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    struct Reward {\n        uint256 rewardsDuration;        /// @dev How long rewards take to vest, e.g. 30 days.\n        uint256 periodFinish;           /// @dev When current rewards will finish vesting.\n        uint256 rewardRate;             /// @dev Rewards emitted per second.\n        uint256 lastUpdateTime;         /// @dev Last time this data struct was updated.\n        uint256 rewardPerTokenStored;   /// @dev Last snapshot of rewardPerToken taken.\n    }\n\n    address public immutable GBL;       /// @dev The ZivoeGlobals contract.\n\n    address[] public rewardTokens;      /// @dev Array of ERC20 tokens distributed as rewards (if present).\n\n    uint256 private _totalSupply;       /// @dev Total supply of (non-transferrable) LP tokens for reards contract.\n\n    /// @dev Contains rewards information for each rewardToken.\n    mapping(address => Reward) public rewardData;\n\n    /// @dev The order is account -> rewardAsset -> amount.\n    mapping(address => mapping(address => uint256)) public accountRewardPerTokenPaid;\n\n    /// @dev The order is account -> rewardAsset -> amount.\n    mapping(address => mapping(address => uint256)) public rewards;\n\n     /// @dev Contains LP token balance of each account (is 1:1 ratio with amount deposited).\n    mapp"
    }
  ]
}