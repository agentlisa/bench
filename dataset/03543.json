{
  "Title": "[M02] Not enforcing a default strategy for new assets",
  "Content": "The [`supportAsset` function](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultAdmin.sol#L139) allows the governor to add a new asset to the `VaultCore` contract, but it does not enforce a default strategy for it [by calling the `setAssetDefaultStrategy`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultAdmin.sol#L119).\n\n\nThis can potentially cause a misbehavior when allocating assets from the vault to the strategies. The new asset can still be deposited through the [`mint`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultCore.sol#L43) or [`mintMultiple`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultCore.sol#L95) functions, and it will contribute to the [utilization of the vault buffer](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultCore.sol#L282), but it will [not be deposited to any strategy](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultCore.sol#L310-L321). This skews the investment ratio so a higher percentage of *all the other assets* will be moved to the strategies, draining the buffer that should be used for future redemptions.\n\n\nConsider enforcing configuration of the asset’s default strategy in the `supportAsset` function.\n\n\n**Update:** *Not fixed. The Origin team states:*\n\n\n\n> We’ll keep this the way it is. This won’t lose any funds if it’s not set. The vault still operates without a default strategy (both places it is used, allocating and redeeming check if this is set and skip it if it is not). It is possible that there may be temporary times in DeFi when the Origin Dollar doesn’t trust any lending protocol/strategy, and goes to purely holding assets to increase stability until things settle down.\n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/vault/VaultAdmin.sol",
      "content": "pragma solidity 0.5.11;\n\n/**\n * @title OUSD Vault Admin Contract\n * @notice The VaultAdmin contract makes configuration and admin calls on the vault.\n * @author Origin Protocol Inc\n */\n\nimport \"./VaultStorage.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IUniswapV2Router } from \"../interfaces/uniswap/IUniswapV2Router02.sol\";\n\ncontract VaultAdmin is VaultStorage {\n    /**\n     * @dev Verifies that the caller is the Vault, Governor, or Strategist.\n     */\n    modifier onlyVaultOrGovernorOrStrategist() {\n        require(\n            msg.sender == address(this) ||\n                msg.sender == strategistAddr ||\n                isGovernor(),\n            \"Caller is not the Vault, Governor, or Strategist\"\n        );\n        _;\n    }\n\n    modifier onlyGovernorOrStrategist() {\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /***************************************\n                 Configuration\n    ****************************************/\n\n    /**\n     * @dev Set address of price provider.\n     * @param _priceProvider Address of price provider\n     */\n    function setPriceProvider(address _priceProvider) external onlyGovernor {\n        priceProvider = _priceProvider;\n        emit PriceProviderUpdated(_priceProvider);\n    }\n\n    /**\n     * @dev Set a fee in basis points to be charged for a redeem.\n     * @param _redeemFeeBps Basis point fee to be charged\n     */\n    function setRedeemFeeBps(uint256 _redeemFeeBps) external onlyGovernor {\n        redeemFeeBps = _redeemFeeBps;\n        emit RedeemFeeUpdated(_redeemFeeBps);\n    }\n\n    /**\n     * @dev Set a buffer of assets to keep in the Vault to handle most\n     * redemptions without needing to spend gas unwinding assets from a Strategy.\n     * @param _vaultBuffer Percentage using 18 decimals. 100% = 1e18.\n     */\n    function setVaultBuffer(uint256 _vaultBuffer)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(_vaultBuffer <= 1e18, \"Invalid value\");\n        vaultBuffer = _vaultBuffer;\n        emit VaultBufferUpdated(_vaultBuffer);\n    }\n\n    /**\n     * @dev Sets the minimum amount of OUSD in a mint to trigger an\n     * automatic allocation of funds afterwords.\n     * @param _threshold OUSD amount with 18 fixed decimals.\n     */\n    function setAutoAllocateThreshold(uint256 _threshold)\n        external\n        onlyGovernor\n    {\n        autoAllocateThreshold = _threshold;\n        emit AllocateThresholdUpdated(_threshold);\n    }\n\n    /**\n     * @dev Set a minimum amount of OUSD in a mint or redeem that triggers a\n     * rebase\n     * @param _threshold OUSD amount with 18 fixed decimals.\n     */\n    function setRebaseThreshold(uint256 _threshold) external onlyGovernor {\n        rebaseThreshold = _threshold;\n        emit RebaseThresholdUpdated(_threshold);\n    }\n\n    /**\n     * @dev Set address of Uniswap for performing liquidation of strategy reward\n     * tokens\n     * @param _address Address of Uniswap\n     */\n    function setUniswapAddr(address _address) external onlyGovernor {\n        uniswapAddr = _address;\n        emit UniswapUpdated(_address);\n    }\n\n    /**\n     * @dev Set address of Strategist\n     * @param _address Address of Strategist\n     */\n    function setStrategistAddr(address _address) external onlyGovernor {\n        strategistAddr = _address;\n        emit StrategistUpdated(_address);\n    }\n\n    /**\n     * @dev Set the default Strategy for an asset, i.e. the one which the asset\n            will be automatically allocated to and withdrawn from\n     * @param _asset Address of the asset\n     * @param _strategy Address of the Strategy\n     */\n    function setAssetDefaultStrategy(address _asset, address _strategy)\n        external\n        onlyGovernorOrStrategist\n    {\n        emit AssetDefaultStrategyUpdated(_asset, _strategy);\n        require(strategies[_strategy].isSupported, \"Strategy not approved\");\n        IStrategy strategy = IStrategy(_strategy);\n        require(assets[_asset].isSupported, \"Asset is not supported\");\n        require(\n            strategy.supportsAsset(_asset),\n            \"Asset not supported by Strategy\"\n        );\n        assetDefaultStrategies[_asset] = _strategy;\n    }\n\n    /**\n     * @dev Add a supported asset to the contract, i.e. one that can be\n     *         to mint OUSD.\n     * @param _asset Address of asset\n     */\n    function supportAsset(address _asset) external onlyGovernor {\n        require(!assets[_asset].isSupported, \"Asset already supported\");\n\n        assets[_asset] = Asset({ isSupported: true });\n        allAssets.push(_asset);\n\n        // Verify that our oracle supports the asset\n        // slither-disable-next-line unused-return\n        IOracle(priceProvider).price(_asset);\n\n        emit AssetSupported(_asset);\n    }\n\n    /**\n     * @dev Add a strategy to the Vault.\n     * @param _addr Address of the strategy to add\n     */\n    function approveStrategy(address _addr) external onlyGovernor {\n        require(!strategies[_addr].isSupported, \"Strategy already approved\");\n        strategies[_addr] = Strategy({ isSupported: true, _deprecated: 0 });\n        allStrategies.push(_addr);\n        emit StrategyApproved(_addr);\n    }\n\n    /**\n     * @dev Remove a strategy from the Vault. Removes all invested assets and\n     * returns them to the Vault.\n     * @param _addr Address of the strategy to remove\n     */\n\n    function removeStrategy(address _addr) external onlyGovernor {\n        require(strategies[_addr].isSupported, \"Strategy not approved\");\n\n        // Initialize strategyIndex with out of bounds result so function will\n        // revert if no valid index found\n        uint256 strategyIndex = allStrategies.length;\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            if (allStrategies[i] == _addr) {\n                strategyIndex = i;\n                break;\n            }\n        }\n\n        if (strategyIndex < allStrategies.length) {\n            allStrategies[strategyIndex] = allStrategies[allStrategies.length -\n                1];\n            allStrategies.pop();\n\n            // Withdraw all assets\n            IStrategy strategy = IStrategy(_addr);\n            strategy.withdrawAll();\n            // Call harvest after withdraw in case withdraw triggers\n            // distribution of additional reward tokens (true for Compound)\n            _harvest(_addr);\n            emit StrategyRemoved(_addr);\n        }\n\n        // Clean up struct in mapping, this can be removed later\n        // See https://github.com/OriginProtocol/origin-dollar/issues/324\n        strategies[_addr].isSupported = false;\n    }\n\n    /**\n     * @notice Move assets from one Strategy to another\n     * @param _strategyFromAddress Address of Strategy to move assets from.\n     * @param _strategyToAddress Address of Strategy to move assets to.\n     * @param _assets Array of asset address that will be moved\n     * @param _amounts Array of amounts of each corresponding asset to move.\n     */\n    function reallocate(\n        address _strategyFromAddress,\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external onlyGovernorOrStrategist {\n        require(\n            strategies[_strategyFromAddress].isSupported,\n            \"Invalid from Strategy\"\n        );\n        require(\n            strategies[_strategyToAddress].isSupported,\n            \"Invalid to Strategy\"\n        );\n        require(_assets.length == _amounts.length, \"Parameter length mismatch\");\n\n        IStrategy strategyFrom = IStrategy(_strategyFromAddress);\n        IStrategy strategyTo = IStrategy(_strategyToAddress);\n\n        for (uint256 i = 0; i < _assets.length; i++) {\n            require(strategyTo.supportsAsset(_assets[i]), \"Asset unsupported\");\n            // Withdraw from Strategy and pass other Strategy as recipient\n            strategyFrom.withdraw(address(strategyTo), _assets[i], _amounts[i]);\n        }\n        // Tell new Strategy to deposit into protocol\n        strategyTo.depositAll();\n    }\n\n    /**\n     * @dev Sets the maximum allowable difference between\n     * total supply and backing assets' value.\n     */\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external onlyGovernor {\n        maxSupplyDiff = _maxSupplyDiff;\n        emit MaxSupplyDiffChanged(_maxSupplyDiff);\n    }\n\n    /**\n     * @dev Sets the trusteeAddress that can receive a portion of yield.\n     *      Setting to the zero address disables this feature.\n     */\n    function setTrusteeAddress(address _address) external onlyGovernor {\n        trusteeAddress = _address;\n        emit TrusteeAddressChanged(_address);\n    }\n\n    /**\n     * @dev Sets the TrusteeFeeBps to the percentage of yield that should be\n     *      received in basis points.\n     */\n    function setTrusteeFeeBps(uint256 _basis) external onlyGovernor {\n        require(_basis <= 5000, \"basis cannot exceed 50%\");\n        trusteeFeeBps = _basis;\n        emit TrusteeFeeBpsChanged(_basis);\n    }\n\n    /***************************************\n                    Pause\n    ****************************************/\n\n    /**\n     * @dev Set the deposit paused flag to true to prevent rebasing.\n     */\n    function pauseRebase() external onlyGovernorOrStrategist {\n        rebasePaused = true;\n        emit RebasePaused();\n    }\n\n    /**\n     * @dev Set the deposit paused flag to true to allow rebasing.\n     */\n    function unpauseRebase() external onlyGovernor {\n        rebasePaused = false;\n        emit RebaseUnpaused();\n    }\n\n    /**\n     * @dev Set the deposit paused flag to true to prevent capital movement.\n     */\n    function pauseCapital() external onlyGovernorOrStrategist {\n        capitalPaused = true;\n        emit CapitalPaused();\n    }\n\n    /**\n     * @dev Set the deposit paused flag to false to enable capital movement.\n     */\n    function unpauseCapital() external onlyGovernorOrStrategist {\n        capitalPaused = false;\n        emit CapitalUnpaused();\n    }\n\n    /***************************************\n                    Rewards\n    ****************************************/\n\n    /**\n     * @dev Transfer token to governor. Intended for recovering tokens stuck in\n     *      contract, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        external\n        onlyGovernor\n    {\n        require(!assets[_asset].isSupported, \"Only unsupported assets\");\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @dev Collect reward tokens from all strategies and swap for supported\n     *      stablecoin via Uniswap\n     */\n    function harvest() external onlyGovernorOrStrategist {\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            _harvest(allStrategies[i]);\n        }\n    }\n\n    /**\n     * @dev Collect reward tokens for a specific strategy and swap for supported\n     *      stablecoin via Uniswap. Called from the vault.\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     */\n    function harvest(address _strategyAddr)\n        external\n        onlyVaultOrGovernorOrStrategist\n        returns (uint256[] memory)\n    {\n        return _harvest(_strategyAddr);\n    }\n\n    /**\n     * @dev Collect reward tokens from a single strategy and swap them for a\n     *      supported stablecoin via Uniswap\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     */\n    function _harvest(address _strategyAddr)\n        internal\n        returns (uint256[] memory)\n    {\n        IStrategy strategy = IStrategy(_strategyAddr);\n        address rewardTokenAddress = strategy.rewardTokenAddress();\n        if (rewardTokenAddress != address(0)) {\n            strategy.collectRewardToken();\n\n            if (uniswapAddr != address(0)) {\n                IERC20 rewardToken = IERC20(strategy.rewardTokenAddress());\n                uint256 rewardTokenAmount = rewardToken.balanceOf(\n                    address(this)\n                );\n                if (rewardTokenAmount > 0) {\n                    // Give Uniswap full amount allowance\n                    rewardToken.safeApprove(uniswapAddr, 0);\n                    rewardToken.safeApprove(uniswapAddr, rewardTokenAmount);\n\n                    // Uniswap redemption path\n                    address[] memory path = new address[](3);\n                    path[0] = strategy.rewardTokenAddress();\n                    path[1] = IUniswapV2Router(uniswapAddr).WETH();\n                    path[2] = allAssets[1]; // USDT\n\n                    return\n                        IUniswapV2Router(uniswapAddr).swapExactTokensForTokens(\n                            rewardTokenAmount,\n                            uint256(0),\n                            path,\n                            address(this),\n                            now.add(1800)\n                        );\n                }\n            }\n        }\n    }\n\n    /***************************************\n                    Pricing\n    ****************************************/\n\n    /**\n     * @dev Returns the total price in 18 digit USD for a given asset.\n     *      Never goes above 1, since that is how we price mints\n     * @param asset address of the asset\n     * @return uint256 USD price of 1 of the asset, in 18 decimal fixed\n     */\n    function priceUSDMint(address asset) external view returns (uint256) {\n        uint256 price = IOracle(priceProvider).price(asset);\n        if (price > 1e8) {\n            price = 1e8;\n        }\n        // Price from Oracle is returned with 8 decimals\n        // scale to 18 so 18-8=10\n        return price.scaleBy(10);\n    }\n\n    /**\n     * @dev Returns the total price in 18 digit USD for a given asset.\n     *      Never goes below 1, since that is how we price redeems\n     * @param asset Addresss of the asset\n     * @return uint256 USD price of 1 of the asset, in 18 decimal fixed\n     */\n    function priceUSDRedeem(address asset) external view returns (uint256) {\n        uint256 price = IOracle(priceProvider).price(asset);\n        if (price < 1e8) {\n            price = 1e8;\n        }\n        // Price from Oracle is returned with 8 decimals\n        // scale to 18 so 18-8=10\n        return price.scaleBy(10);\n    }\n\n    /***************************************\n             Strategies Admin\n    ****************************************/\n\n    /**\n     * @dev Withdraws all assets from the strategy and sends assets to the Vault.\n     * @param _strategyAddr Strategy address.\n     */\n    function withdrawAllFromStrategy(address _strategyAddr)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(\n            strategies[_strategyAddr].isSupported,\n            \"Strategy is not supported\"\n        );\n        IStrategy strategy = IStrategy(_strategyAddr);\n        strategy.withdrawAll();\n    }\n\n    /**\n     * @dev Withdraws all assets from all the strategies and sends assets to the Vault.\n     */\n    function withdrawAllFromStrategies() external onlyGovernorOrStrategist {\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            strategy.withdrawAll();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/contracts/vault/VaultCore.sol",
      "content": "pragma solidity 0.5.11;\n\n/**\n * @title OUSD Vault Contract\n * @notice The Vault contract stores assets. On a deposit, OUSD will be minted\n           and sent to the depositor. On a withdrawal, OUSD will be burned and\n           assets will be sent to the withdrawer. The Vault accepts deposits of\n           interest form yield bearing strategies which will modify the supply\n           of OUSD.\n * @author Origin Protocol Inc\n */\n\nimport \"./VaultStorage.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IBuyback } from \"../interfaces/IBuyback.sol\";\n\ncontract VaultCore is VaultStorage {\n    uint256 constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /**\n     * @dev Verifies that the rebasing is not paused.\n     */\n    modifier whenNotRebasePaused() {\n        require(!rebasePaused, \"Rebasing paused\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the deposits are not paused.\n     */\n    modifier whenNotCapitalPaused() {\n        require(!capitalPaused, \"Capital paused\");\n        _;\n    }\n\n    /**\n     * @dev Deposit a supported asset and mint OUSD.\n     * @param _asset Address of the asset being deposited\n     * @param _amount Amount of the asset being deposited\n     * @param _minimumOusdAmount Minimum OUSD to mint\n     */\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) external whenNotCapitalPaused nonReentrant {\n        require(assets[_asset].isSupported, \"Asset is not supported\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        uint256 price = IOracle(priceProvider).price(_asset);\n        if (price > 1e8) {\n            price = 1e8;\n        }\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        uint256 unitAdjustedDeposit = _amount.scaleBy(int8(18 - assetDecimals));\n        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(\n            price.scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision\n            10**assetDecimals\n        );\n\n        if (_minimumOusdAmount > 0) {\n            require(\n                priceAdjustedDeposit >= _minimumOusdAmount,\n                \"Mint amount lower than minimum\"\n            );\n        }\n\n        emit Mint(msg.sender, priceAdjustedDeposit);\n\n        // Rebase must happen before any transfers occur.\n        if (unitAdjustedDeposit >= rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n\n        // Mint matching OUSD\n        oUSD.mint(msg.sender, priceAdjustedDeposit);\n\n        // Transfer the deposited coins to the vault\n        IERC20 asset = IERC20(_asset);\n        asset.safeTransferFrom(msg.sender, address(this), _amount);\n\n        if (unitAdjustedDeposit >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    /**\n     * @dev Mint for multiple assets in the same call.\n     * @param _assets Addresses of assets being deposited\n     * @param _amounts Amount of each asset at the same index in the _assets\n     *                 to deposit.\n     * @param _minimumOusdAmount Minimum OUSD to mint\n     */\n    function mintMultiple(\n        address[] calldata _assets,\n        uint256[] calldata _amounts,\n        uint256 _minimumOusdAmount\n    ) external whenNotCapitalPaused nonReentrant {\n        require(_assets.length == _amounts.length, \"Parameter length mismatch\");\n\n        uint256 unitAdjustedTotal = 0;\n        uint256 priceAdjustedTotal = 0;\n        uint256[] memory assetPrices = _getAssetPrices(false);\n        for (uint256 j = 0; j < _assets.length; j++) {\n            // In memoriam\n            require(assets[_assets[j]].isSupported, \"Asset is not supported\");\n            require(_amounts[j] > 0, \"Amount must be greater than 0\");\n            for (uint256 i = 0; i < allAssets.length; i++) {\n                if (_assets[j] == allAssets[i]) {\n                    uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);\n                    uint256 price = assetPrices[i];\n                    if (price > 1e18) {\n                        price = 1e18;\n                    }\n                    unitAdjustedTotal = unitAdjustedTotal.add(\n                        _amounts[j].scaleBy(int8(18 - assetDecimals))\n                    );\n                    priceAdjustedTotal = priceAdjustedTotal.add(\n                        _amounts[j].mulTruncateScale(price, 10**assetDecimals)\n                    );\n                }\n            }\n        }\n\n        if (_minimumOusdAmount > 0) {\n            require(\n                priceAdjustedTotal >= _minimumOusdAmount,\n                \"Mint amount lower than minimum\"\n            );\n        }\n\n        emit Mint(msg.sender, priceAdjustedTotal);\n\n        // Rebase must happen before any transfers occur.\n        if (unitAdjustedTotal >= rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n\n        oUSD.mint(msg.sender, priceAdjustedTotal);\n\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20 asset = IERC20(_assets[i]);\n            asset.safeTransferFrom(msg.sender, address(this), _amounts[i]);\n        }\n\n        if (unitAdjustedTotal >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    /**\n     * @dev Withdraw a supported asset and burn OUSD.\n     * @param _amount Amount of OUSD to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        public\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(_amount, _minimumUnitAmount);\n    }\n\n    /**\n     * @dev Withdraw a supported asset and burn OUSD.\n     * @param _amount Amount of OUSD to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount) internal {\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        // Calculate redemption outputs\n        (\n            uint256[] memory outputs,\n            uint256 _backingValue\n        ) = _calculateRedeemOutputs(_amount);\n\n        // Check that OUSD is backed by enough assets\n        uint256 _totalSupply = oUSD.totalSupply();\n        if (maxSupplyDiff > 0) {\n            // Allow a max difference of maxSupplyDiff% between\n            // backing assets value and OUSD total supply\n            uint256 diff = _totalSupply.divPrecisely(_backingValue);\n            require(\n                (diff > 1e18 ? diff.sub(1e18) : uint256(1e18).sub(diff)) <=\n                    maxSupplyDiff,\n                \"Backing supply liquidity error\"\n            );\n        }\n\n        emit Redeem(msg.sender, _amount);\n\n        // Send outputs\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            if (outputs[i] == 0) continue;\n\n            IERC20 asset = IERC20(allAssets[i]);\n\n            if (asset.balanceOf(address(this)) >= outputs[i]) {\n                // Use Vault funds first if sufficient\n                asset.safeTransfer(msg.sender, outputs[i]);\n            } else {\n                address strategyAddr = assetDefaultStrategies[allAssets[i]];\n                if (strategyAddr != address(0)) {\n                    // Nothing in Vault, but something in Strategy, send from there\n                    IStrategy strategy = IStrategy(strategyAddr);\n                    strategy.withdraw(msg.sender, allAssets[i], outputs[i]);\n                } else {\n                    // Cant find funds anywhere\n                    revert(\"Liquidity error\");\n                }\n            }\n        }\n\n        if (_minimumUnitAmount > 0) {\n            uint256 unitTotal = 0;\n            for (uint256 i = 0; i < outputs.length; i++) {\n                uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);\n                unitTotal = unitTotal.add(\n                    outputs[i].scaleBy(int8(18 - assetDecimals))\n                );\n            }\n            require(\n                unitTotal >= _minimumUnitAmount,\n                \"Redeem amount lower than minimum\"\n            );\n        }\n\n        oUSD.burn(msg.sender, _amount);\n\n        // Until we can prove that we won't affect the prices of our assets\n        // by withdrawing them, this should be here.\n        // It's possible that a strategy was off on its asset total, perhaps\n        // a reward token sold for more or for less than anticipated.\n        if (_amount > rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n    }\n\n    /**\n     * @notice Withdraw a supported asset and burn all OUSD.\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeemAll(uint256 _minimumUnitAmount)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(oUSD.balanceOf(msg.sender), _minimumUnitAmount);\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     * @dev Allocate unallocated funds on Vault to strategies.\n     **/\n    function allocate() public whenNotCapitalPaused nonReentrant {\n        _allocate();\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     * @dev Allocate unallocated funds on Vault to strategies.\n     **/\n    function _allocate() internal {\n        uint256 vaultValue = _totalValueInVault();\n        // Nothing in vault to allocate\n        if (vaultValue == 0) return;\n        uint256 strategiesValue = _totalValueInStrategies();\n        // We have a method that does the same as this, gas optimisation\n        uint256 calculatedTotalValue = vaultValue.add(strategiesValue);\n\n        // We want to maintain a buffer on the Vault so calculate a percentage\n        // modifier to multiply each amount being allocated by to enforce the\n        // vault buffer\n        uint256 vaultBufferModifier;\n        if (strategiesValue == 0) {\n            // Nothing in Strategies, allocate 100% minus the vault buffer to\n            // strategies\n            vaultBufferModifier = uint256(1e18).sub(vaultBuffer);\n        } else {\n            vaultBufferModifier = vaultBuffer.mul(calculatedTotalValue).div(\n                vaultValue\n            );\n            if (1e18 > vaultBufferModifier) {\n                // E.g. 1e18 - (1e17 * 10e18)/5e18 = 8e17\n                // (5e18 * 8e17) / 1e18 = 4e18 allocated from Vault\n                vaultBufferModifier = uint256(1e18).sub(vaultBufferModifier);\n            } else {\n                // We need to let the buffer fill\n                return;\n            }\n        }\n        if (vaultBufferModifier == 0) return;\n\n        // Iterate over all assets in the Vault and allocate the the appropriate\n        // strategy\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            IERC20 asset = IERC20(allAssets[i]);\n            uint256 assetBalance = asset.balanceOf(address(this));\n            // No balance, nothing to do here\n            if (assetBalance == 0) continue;\n\n            // Multiply the balance by the vault buffer modifier and truncate\n            // to the scale of the asset decimals\n            uint256 allocateAmount = assetBalance.mulTruncate(\n                vaultBufferModifier\n            );\n\n            address depositStrategyAddr = assetDefaultStrategies[address(\n                asset\n            )];\n\n            if (depositStrategyAddr != address(0) && allocateAmount > 0) {\n                IStrategy strategy = IStrategy(depositStrategyAddr);\n                // Transfer asset to Strategy and call deposit method to\n                // mint or take required action\n                asset.safeTransfer(address(strategy), allocateAmount);\n                strategy.deposit(address(asset), allocateAmount);\n            }\n        }\n\n        // Harvest for all reward tokens above reward liquidation threshold\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            address rewardTokenAddress = strategy.rewardTokenAddress();\n            if (rewardTokenAddress != address(0)) {\n                uint256 liquidationThreshold = strategy\n                    .rewardLiquidationThreshold();\n                if (liquidationThreshold == 0) {\n                    // No threshold set, always harvest from strategy\n                    IVault(address(this)).harvest(allStrategies[i]);\n                } else {\n                    // Check balance against liquidation threshold\n                    // Note some strategies don't hold the reward token balance\n                    // on their contract so the liquidation threshold should be\n                    // set to 0\n                    IERC20 rewardToken = IERC20(rewardTokenAddress);\n                    uint256 rewardTokenAmount = rewardToken.balanceOf(\n                        allStrategies[i]\n                    );\n                    if (rewardTokenAmount >= liquidationThreshold) {\n                        IVault(address(this)).harvest(allStrategies[i]);\n                    }\n                }\n            }\n        }\n\n        // Trigger OGN Buyback\n        IBuyback(trusteeAddress).swap();\n    }\n\n    /**\n     * @dev Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of OUSD.\n     */\n    function rebase() public whenNotRebasePaused nonReentrant {\n        _rebase();\n    }\n\n    /**\n     * @dev Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of OUSD, optionaly sending a\n     *      portion of the yield to the trustee.\n     */\n    function _rebase() internal whenNotRebasePaused {\n        uint256 ousdSupply = oUSD.totalSupply();\n        if (ousdSupply == 0) {\n            return;\n        }\n        uint256 vaultValue = _totalValue();\n\n        // Yield fee collection\n        address _trusteeAddress = trusteeAddress; // gas savings\n        if (_trusteeAddress != address(0) && (vaultValue > ousdSupply)) {\n            uint256 yield = vaultValue.sub(ousdSupply);\n            uint256 fee = yield.mul(trusteeFeeBps).div(10000);\n            require(yield > fee, \"Fee must not be greater than yield\");\n            if (fee > 0) {\n                oUSD.mint(_trusteeAddress, fee);\n            }\n            emit YieldDistribution(_trusteeAddress, yield, fee);\n        }\n\n        // Only rachet OUSD supply upwards\n        ousdSupply = oUSD.totalSupply(); // Final check should use latest value\n        if (vaultValue > ousdSupply) {\n            oUSD.changeSupply(vaultValue);\n        }\n    }\n\n    /**\n     * @dev Determine the total value of assets held by the vault and its\n     *         strategies.\n     * @return uint256 value Total value in USD (1e18)\n     */\n    function totalValue() external view returns (uint256 value) {\n        value = _totalValue();\n    }\n\n    /**\n     * @dev Internal Calculate the total value of the assets held by the\n     *         vault and its strategies.\n     * @return uint256 value Total value in USD (1e18)\n     */\n    function _totalValue() internal view returns (uint256 value) {\n        return _totalValueInVault().add(_totalValueInStrategies());\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Vault.\n     * @return uint256 Total value in ETH (1e18)\n     */\n    function _totalValueInVault() internal view returns (uint256 value) {\n        for (uint256 y = 0; y < allAssets.length; y++) {\n            IERC20 asset = IERC20(allAssets[y]);\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);\n            uint256 balance = asset.balanceOf(address(this));\n            if (balance > 0) {\n                value = value.add(balance.scaleBy(int8(18 - assetDecimals)));\n            }\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Strategies.\n     * @return uint256 Total value in ETH (1e18)\n     */\n    function _totalValueInStrategies() internal view returns (uint256 value) {\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            value = value.add(_totalValueInStrategy(allStrategies[i]));\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held by strategy.\n     * @param _strategyAddr Address of the strategy\n     * @return uint256 Total value in ETH (1e18)\n     */\n    function _totalValueInStrategy(address _strategyAddr)\n        internal\n        view\n        returns (uint256 value)\n    {\n        IStrategy strategy = IStrategy(_strategyAddr);\n        for (uint256 y = 0; y < allAssets.length; y++) {\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);\n            if (strategy.supportsAsset(allAssets[y])) {\n                uint256 balance = strategy.checkBalance(allAssets[y]);\n                if (balance > 0) {\n                    value = value.add(\n                        balance.scaleBy(int8(18 - assetDecimals))\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return uint256 Balance of asset in decimals of asset\n     */\n    function checkBalance(address _asset) external view returns (uint256) {\n        return _checkBalance(_asset);\n    }\n\n    /**\n     * @notice Get the balance of an asset held in V"
    }
  ]
}