{
  "Title": "[M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L150\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L225\n\n\n# Vulnerability details\n\n## Impact\nAfter a lock has expired, it doesn't get any rewards distributed to it. But, unreleased locks cause other existing bonds to not receive the full amount of tokens either. The issue is that as long as the bond is not released, the `totalShares` value isn't updated. Everybody receives a smaller cut of the distribution. Thus, bond owners receive less rewards than they should.\n\nA bond can be released after it expired by the owner of it. If the owner doesn't release it for 7 days, anybody else can release it as well. As long as the owner doesn't release it, the issue will be in effect for at least 7 epochs.\n\nSince this causes a loss of funds for every bond holder I rate it as HIGH. It's likely to be an issue since you can't guarantee that bonds will be released the day they expire.\n\n## Proof of Concept\nHere's a test showcasing the issue:\n\n```js\n// 09.Bonds.js\n\n    it.only(\"test\", async function () {\n      await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"100\"));\n      await lock.connect(owner).lock(StableToken.address, ethers.utils.parseEther(\"100\"), 100);\n      await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther(\"1000\"));\n      await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther(\"1000\"), 10);\n      await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"1000\"));\n      await bond.distribute(stabletoken.address, ethers.utils.parseEther(\"1000\"));\n\n      await network.provider.send(\"evm_increaseTime\", [864000]); // Skip 10 days\n      await network.provider.send(\"evm_mine\");\n\n      [,,,,,,,pending,,,] = await bond.idToBond(1);\n      expect(pending).to.be.equals(\"499999999999999999986\");\n      [,,,,,,,pending,,,] = await bond.idToBond(2);\n      expect(pending).to.be.equals(\"499999999999999999986\");\n\n\n      await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"1000\"));\n      await bond.distribute(stabletoken.address, ethers.utils.parseEther(\"1000\"));\n\n      await network.provider.send(\"evm_increaseTime\", [86400 * 3]); // Skip 3 days\n      await network.provider.send(\"evm_mine\");\n\n      // Bond 2 expired, so it doesn't receive any of the new tokens that were distributed\n      [,,,,,,,pending,,,] = await bond.idToBond(2);\n      expect(pending).to.be.equals(\"499999999999999999986\");\n\n      // Thus, Bond 1 should get all the tokens, increasing its pending value to 1499999999999999999960\n      // But, because bond 2 wasn't released (`totalShares` wasn't updated), bond 1 receives less tokens than it should.\n      // Thus, the following check below fails\n      [,,,,,,,pending,,,] = await bond.idToBond(1);\n      expect(pending).to.be.equals(\"1499999999999999999960\");\n\n      await lock.connect(user).release(2);\n\n      expect(await stabletoken.balanceOf(user.address)).to.be.equals(\"1499999999999999999986\");\n\n    });\n```\n\nThe `totalShares` value is only updated after a lock is released:\n\n```sol\n    function release(\n        uint _id,\n        address _releaser\n    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n        Bond memory bond = idToBond(_id);\n        require(bond.expired, \"!expire\");\n        if (_releaser != bond.owner) {\n            unchecked {\n                require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n            }\n        }\n        amount = bond.amount;\n        unchecked {\n            totalShares[bond.asset] -= bond.shares;\n        // ... \n```\n## Tools Used\nnone\n\n## Recommended Mitigation Steps\nOnly shares belonging to an active bond should be used for the distribution logic.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-tigris-trade-contest",
  "Code": [
    {
      "filename": "contracts/BondNFT.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BondNFT is ERC721Enumerable, Ownable {\n    \n    uint constant private DAY = 24 * 60 * 60;\n\n    struct Bond {\n        uint id;\n        address owner;\n        address asset;\n        uint amount;\n        uint mintEpoch;\n        uint mintTime;\n        uint expireEpoch;\n        uint pending;\n        uint shares;\n        uint period;\n        bool expired;\n    }\n\n    mapping(address => uint256) public epoch;\n    uint private totalBonds;\n    string public baseURI;\n    address public manager;\n    address[] public assets;\n\n    mapping(address => bool) public allowedAsset;\n    mapping(address => uint) private assetsIndex;\n    mapping(uint256 => mapping(address => uint256)) private bondPaid;\n    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare\n    mapping(uint => Bond) private _idToBond;\n    mapping(address => uint) public totalShares;\n    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount\n\n    constructor(\n        string memory _setBaseURI,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n    }\n\n    /**\n     * @notice Create a bond\n     * @dev Should only be called by a manager contract\n     * @param _asset tigAsset token to lock\n     * @param _amount tigAsset amount\n     * @param _period time to lock for in days\n     * @param _owner address to receive the bond\n     * @return id ID of the minted bond\n     */\n    function createLock(\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _owner\n    ) external onlyManager() returns(uint id) {\n        require(allowedAsset[_asset], \"!Asset\");\n        unchecked {\n            uint shares = _amount * _period / 365;\n            uint expireEpoch = epoch[_asset] + _period;\n            id = ++totalBonds;\n            totalShares[_asset] += shares;\n            Bond memory _bond = Bond(\n                id,             // id\n                address(0),     // owner\n                _asset,         // tigAsset token\n                _amount,        // tigAsset amount\n                epoch[_asset],  // mint epoch\n                block.timestamp,// mint timestamp\n                expireEpoch,    // expire epoch\n                0,              // pending\n                shares,         // linearly scaling share of rewards\n                _period,        // lock period\n                false           // is expired boolean\n            );\n            _idToBond[id] = _bond;\n            _mint(_owner, _bond);\n        }\n        emit Lock(_asset, _amount, _period, _owner, id);\n    }\n\n    /** \n     * @notice Extend the lock period and/or amount of a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _asset tigAsset token address\n     * @param _amount amount of tigAsset being added\n     * @param _period days being added to the bond\n     * @param _sender address extending the bond\n     */\n    function extendLock(\n        uint _id,\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _sender\n    ) external onlyManager() {\n        Bond memory bond = idToBond(_id);\n        Bond storage _bond = _idToBond[_id];\n        require(bond.owner == _sender, \"!owner\");\n        require(!bond.expired, \"Expired\");\n        require(bond.asset == _asset, \"!BondAsset\");\n        require(bond.pending == 0);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(bond.period+_period <= 365, \"MAX PERIOD\");\n        unchecked {\n            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n            uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n            totalShares[bond.asset] += shares-bond.shares;\n            _bond.shares = shares;\n            _bond.amount += _amount;\n            _bond.expireEpoch = expireEpoch;\n            _bond.period += _period;\n            _bond.mintTime = block.timestamp;\n            _bond.mintEpoch = epoch[bond.asset];\n            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n        }\n        emit ExtendLock(_period, _amount, _sender,  _id);\n    }\n\n    /**\n     * @notice Release a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _releaser address initiating the release of the bond\n     * @return amount amount of tigAsset returned\n     * @return lockAmount amount of tigAsset locked in the bond\n     * @return asset tigAsset token released\n     * @return _owner bond owner\n     */\n    function release(\n        uint _id,\n        address _releaser\n    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n        Bond memory bond = idToBond(_id);\n        require(bond.expired, \"!expire\");\n        if (_releaser != bond.owner) {\n            unchecked {\n                require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n            }\n        }\n        amount = bond.amount;\n        unchecked {\n            totalShares[bond.asset] -= bond.shares;\n            (uint256 _claimAmount,) = claim(_id, bond.owner);\n            amount += _claimAmount;\n        }\n        asset = bond.asset;\n        lockAmount = bond.amount;\n        _owner = bond.owner;\n        _burn(_id);\n        emit Release(asset, lockAmount, _owner, _id);\n    }\n    /**\n     * @notice Claim rewards from a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond to claim rewards from\n     * @param _claimer address claiming rewards\n     * @return amount amount of tigAsset claimed\n     * @return tigAsset tigAsset token address\n     */\n    function claim(\n        uint _id,\n        address _claimer\n    ) public onlyManager() returns(uint amount, address tigAsset) {\n        Bond memory bond = idToBond(_id);\n        require(_claimer == bond.owner, \"!owner\");\n        amount = bond.pending;\n        tigAsset = bond.asset;\n        unchecked {\n            if (bond.expired) {\n                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n                if (totalShares[bond.asset] > 0) {\n                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n                }\n            }\n            bondPaid[_id][bond.asset] += amount;\n        }\n        IERC20(tigAsset).transfer(manager, amount);\n        emit ClaimFees(tigAsset, amount, _claimer, _id);\n    }\n\n    /**\n     * @notice Claim user debt left from bond transfer\n     * @dev Should only be called by a manager contract\n     * @param _user user address\n     * @param _tigAsset tigAsset token address\n     * @return amount amount of tigAsset claimed\n     */\n    function claimDebt(\n        address _user,\n        address _tigAsset\n    ) public onlyManager() returns(uint amount) {\n        amount = userDebt[_user][_tigAsset];\n        userDebt[_user][_tigAsset] = 0;\n        IERC20(_tigAsset).transfer(manager, amount);\n        emit ClaimDebt(_tigAsset, amount, _user);\n    }\n\n    /**\n     * @notice Distribute rewards to bonds\n     * @param _tigAsset tigAsset token address\n     * @param _amount tigAsset amount\n     */\n    function distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n\n    /**\n     * @notice Get all data for a bond\n     * @param _id ID of the bond\n     * @return bond Bond object\n     */\n    function idToBond(uint256 _id) public view returns (Bond memory bond) {\n        bond = _idToBond[_id];\n        bond.owner = ownerOf(_id);\n        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n        unchecked {\n            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n        }\n    }\n\n    /*\n     * @notice Get expired boolean for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function isExpired(uint256 _id) public view returns (bool) {\n        Bond memory bond = _idToBond[_id];\n        return bond.expireEpoch <= epoch[bond.asset] ? true : false;\n    }\n\n    /*\n     * @notice Get pending rewards for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function pending(\n        uint256 _id\n    ) public view returns (uint256) {\n        return idToBond(_id).pending;\n    }\n\n    function totalAssets() public view returns (uint256) {\n        return assets.length;\n    }\n\n    /*\n     * @notice Gets an array of all whitelisted token addresses\n     * @return address array of addresses\n     */\n    function getAssets() public view returns (address[] memory) {\n        return assets;\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function safeTransferMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _transfer(_msgSender(), _to, _ids[i]);\n            }\n        }\n    }\n\n    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                safeTransferFrom(_from, _to, _ids[i]);\n            }\n        }\n    }\n\n    function approveMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                approve(_to, _ids[i]);\n            }\n        }\n    }\n\n    function _mint(\n        address to,\n        Bond memory bond\n    ) internal {\n        unchecked {\n            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;\n        }\n        _mint(to, bond.id);\n    }\n\n    function _burn(\n        uint256 _id\n    ) internal override {\n        delete _idToBond[_id];\n        super._burn(_id);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 _id\n    ) internal override {\n        Bond memory bond = idToBond(_id);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(!bond.expired, \"Expired!\");\n        unchecked {\n            require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n            userDebt[from][bond.asset] += bond.pending;\n            bondPaid[_id][bond.asset] += bond.pending;\n        }\n        super._transfer(from, to, _id);\n    }\n\n    function balanceIds(address _user) public view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _ids[i] = tokenOfOwnerByIndex(_user, i);\n            }\n        }\n        return _ids;\n    }\n\n    function addAsset(address _asset) external onlyOwner {\n        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n        assetsIndex[_asset] = assets.length;\n        assets.push(_asset);\n        allowedAsset[_asset] = true;\n        epoch[_asset] = block.timestamp/DAY;\n    }\n\n    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n        require(assets[assetsIndex[_asset]] == _asset, \"Not added\");\n        allowedAsset[_asset] = _bool;\n    }\n\n    function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function setManager(\n        address _manager\n    ) public onlyOwner() {\n        manager = _manager;\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"!manager\");\n        _;\n    }\n\n    event Distribution(address _tigAsset, uint256 _amount);\n    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);\n    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);\n    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);\n    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);\n    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);\n}"
    },
    {
      "filename": "contracts/BondNFT.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BondNFT is ERC721Enumerable, Ownable {\n    \n    uint constant private DAY = 24 * 60 * 60;\n\n    struct Bond {\n        uint id;\n        address owner;\n        address asset;\n        uint amount;\n        uint mintEpoch;\n        uint mintTime;\n        uint expireEpoch;\n        uint pending;\n        uint shares;\n        uint period;\n        bool expired;\n    }\n\n    mapping(address => uint256) public epoch;\n    uint private totalBonds;\n    string public baseURI;\n    address public manager;\n    address[] public assets;\n\n    mapping(address => bool) public allowedAsset;\n    mapping(address => uint) private assetsIndex;\n    mapping(uint256 => mapping(address => uint256)) private bondPaid;\n    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare\n    mapping(uint => Bond) private _idToBond;\n    mapping(address => uint) public totalShares;\n    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount\n\n    constructor(\n        string memory _setBaseURI,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n    }\n\n    /**\n     * @notice Create a bond\n     * @dev Should only be called by a manager contract\n     * @param _asset tigAsset token to lock\n     * @param _amount tigAsset amount\n     * @param _period time to lock for in days\n     * @param _owner address to receive the bond\n     * @return id ID of the minted bond\n     */\n    function createLock(\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _owner\n    ) external onlyManager() returns(uint id) {\n        require(allowedAsset[_asset], \"!Asset\");\n        unchecked {\n            uint shares = _amount * _period / 365;\n            uint expireEpoch = epoch[_asset] + _period;\n            id = ++totalBonds;\n            totalShares[_asset] += shares;\n            Bond memory _bond = Bond(\n                id,             // id\n                address(0),     // owner\n                _asset,         // tigAsset token\n                _amount,        // tigAsset amount\n                epoch[_asset],  // mint epoch\n                block.timestamp,// mint timestamp\n                expireEpoch,    // expire epoch\n                0,              // pending\n                shares,         // linearly scaling share of rewards\n                _period,        // lock period\n                false           // is expired boolean\n            );\n            _idToBond[id] = _bond;\n            _mint(_owner, _bond);\n        }\n        emit Lock(_asset, _amount, _period, _owner, id);\n    }\n\n    /** \n     * @notice Extend the lock period and/or amount of a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _asset tigAsset token address\n     * @param _amount amount of tigAsset being added\n     * @param _period days being added to the bond\n     * @param _sender address extending the bond\n     */\n    function extendLock(\n        uint _id,\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _sender\n    ) external onlyManager() {\n        Bond memory bond = idToBond(_id);\n        Bond storage _bond = _idToBond[_id];\n        require(bond.owner == _sender, \"!owner\");\n        require(!bond.expired, \"Expired\");\n        require(bond.asset == _asset, \"!BondAsset\");\n        require(bond.pending == 0);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(bond.period+_period <= 365, \"MAX PERIOD\");\n        unchecked {\n            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n            uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n            totalShares[bond.asset] += shares-bond.shares;\n            _bond.shares = shares;\n            _bond.amount += _amount;\n            _bond.expireEpoch = expireEpoch;\n            _bond.period += _period;\n            _bond.mintTime = block.timestamp;\n            _bond.mintEpoch = epoch[bond.asset];\n            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n        }\n        emit ExtendLock(_period, _amount, _sender,  _id);\n    }\n\n    /**\n     * @notice Release a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _releaser address initiating the release of the bond\n     * @return amount amount of tigAsset returned\n     * @return lockAmount amount of tigAsset locked in the bond\n     * @return asset tigAsset token released\n     * @return _owner bond owner\n     */\n    function release(\n        uint _id,\n        address _releaser\n    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n        Bond memory bond = idToBond(_id);\n        require(bond.expired, \"!expire\");\n        if (_releaser != bond.owner) {\n            unchecked {\n                require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n            }\n        }\n        amount = bond.amount;\n        unchecked {\n            totalShares[bond.asset] -= bond.shares;\n            (uint256 _claimAmount,) = claim(_id, bond.owner);\n            amount += _claimAmount;\n        }\n        asset = bond.asset;\n        lockAmount = bond.amount;\n        _owner = bond.owner;\n        _burn(_id);\n        emit Release(asset, lockAmount, _owner, _id);\n    }\n    /**\n     * @notice Claim rewards from a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond to claim rewards from\n     * @param _claimer address claiming rewards\n     * @return amount amount of tigAsset claimed\n     * @return tigAsset tigAsset token address\n     */\n    function claim(\n        uint _id,\n        address _claimer\n    ) public onlyManager() returns(uint amount, address tigAsset) {\n        Bond memory bond = idToBond(_id);\n        require(_claimer == bond.owner, \"!owner\");\n        amount = bond.pending;\n        tigAsset = bond.asset;\n        unchecked {\n            if (bond.expired) {\n                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n                if (totalShares[bond.asset] > 0) {\n                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n                }\n            }\n            bondPaid[_id][bond.asset] += amount;\n        }\n        IERC20(tigAsset).transfer(manager, amount);\n        emit ClaimFees(tigAsset, amount, _claimer, _id);\n    }\n\n    /**\n     * @notice Claim user debt left from bond transfer\n     * @dev Should only be called by a manager contract\n     * @param _user user address\n     * @param _tigAsset tigAsset token address\n     * @return amount amount of tigAsset claimed\n     */\n    function claimDebt(\n        address _user,\n        address _tigAsset\n    ) public onlyManager() returns(uint amount) {\n        amount = userDebt[_user][_tigAsset];\n        userDebt[_user][_tigAsset] = 0;\n        IERC20(_tigAsset).transfer(manager, amount);\n        emit ClaimDebt(_tigAsset, amount, _user);\n    }\n\n    /**\n     * @notice Distribute rewards to bonds\n     * @param _tigAsset tigAsset token address\n     * @param _amount tigAsset amount\n     */\n    function distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n\n    /**\n     * @notice Get all data for a bond\n     * @param _id ID of the bond\n     * @return bond Bond object\n     */\n    function idToBond(uint256 _id) public view returns (Bond memory bond) {\n        bond = _idToBond[_id];\n        bond.owner = ownerOf(_id);\n        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n        unchecked {\n            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n        }\n    }\n\n    /*\n     * @notice Get expired boolean for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function isExpired(uint256 _id) public view returns (bool) {\n        Bond memory bond = _idToBond[_id];\n        return bond.expireEpoch <= epoch[bond.asset] ? true : false;\n    }\n\n    /*\n     * @notice Get pending rewards for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function pending(\n        uint256 _id\n    ) public view returns (uint256) {\n        return idToBond(_id).pending;\n    }\n\n    function totalAssets() public view returns (uint256) {\n        return assets.length;\n    }\n\n    /*\n     * @notice Gets an array of all whitelisted token addresses\n     * @return address array of addresses\n     */\n    function getAssets() public view returns (address[] memory) {\n        return assets;\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function safeTransferMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _transfer(_msgSender(), _to, _ids[i]);\n            }\n        }\n    }\n\n    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                safeTransferFrom(_from, _to, _ids[i]);\n            }\n        }\n    }\n\n    function approveMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                approve(_to, _ids[i]);\n            }\n        }\n    }\n\n    function _mint(\n        address to,\n        Bond memory bond\n    ) internal {\n        unchecked {\n            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;\n        }\n        _mint(to, bond.id);\n    }\n\n    function _burn(\n        uint256 _id\n    ) internal override {\n        delete _idToBond[_id];\n        super._burn(_id);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 _id\n    ) internal override {\n        Bond memory bond = idToBond(_id);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(!bond.expired, \"Expired!\");\n        unchecked {\n            require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n            userDebt[from][bond.asset] += bond.pending;\n            bondPaid[_id][bond.asset] += bond.pending;\n        }\n        super._transfer(from, to, _id);\n    }\n\n    function balanceIds(address _user) public view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _ids[i] = tokenOfOwnerByIndex(_user, i);\n            }\n        }\n        return _ids;\n    }\n\n    function addAsset(address _asset) external onlyOwner {\n        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n        assetsIndex[_asset] = assets.length;\n        assets.push(_asset);\n        allowedAsset[_asset] = true;\n        epoch[_asset] = block.timestamp/DAY;\n    }\n\n    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n        require(assets[assetsIndex[_asset]] == _asset, \"Not added\");\n        allowedAsset[_asset] = _bool;\n    }\n\n    function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function setManager(\n        address _manager\n    ) public onlyOwner() {\n        manager = _manager;\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"!manager\");\n        _;\n    }\n\n    event Distribution(address _tigAsset, uint256 _amount);\n    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);\n    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);\n    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);\n    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);\n    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);\n}"
    }
  ]
}