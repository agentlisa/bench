{
  "Title": "[N-04] Missing Visibility",
  "Content": "\n### Context\n[`DataStorageOperator.sol#L15-L16`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/DataStorageOperator.sol#L15-L16)\n\n### Description\nIt's best practice to explicitly mark visibility of state variables.\n\n### Recommendation\nConsider adding the missing visibility to the state variables.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-09-quickswap",
  "Code": [
    {
      "filename": "src/core/contracts/DataStorageOperator.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IDataStorageOperator.sol';\n\nimport './libraries/DataStorage.sol';\nimport './libraries/Sqrt.sol';\nimport './libraries/AdaptiveFee.sol';\n\nimport './libraries/Constants.sol';\n\ncontract DataStorageOperator is IDataStorageOperator {\n  uint256 constant UINT16_MODULO = 65536;\n  uint128 constant MAX_VOLUME_PER_LIQUIDITY = 100000 << 64; // maximum meaningful ratio of volume to liquidity\n\n  using DataStorage for DataStorage.Timepoint[UINT16_MODULO];\n\n  DataStorage.Timepoint[UINT16_MODULO] public override timepoints;\n  AdaptiveFee.Configuration public feeConfig;\n\n  address private immutable pool;\n  address private immutable factory;\n\n  modifier onlyPool() {\n    require(msg.sender == pool, 'only pool can call this');\n    _;\n  }\n\n  constructor(address _pool) {\n    factory = msg.sender;\n    pool = _pool;\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function initialize(uint32 time, int24 tick) external override onlyPool {\n    return timepoints.initialize(time, tick);\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function changeFeeConfiguration(AdaptiveFee.Configuration calldata _feeConfig) external override {\n    require(msg.sender == factory || msg.sender == IAlgebraFactory(factory).owner());\n\n    require(uint256(_feeConfig.alpha1) + uint256(_feeConfig.alpha2) + uint256(_feeConfig.baseFee) <= type(uint16).max, 'Max fee exceeded');\n    require(_feeConfig.gamma1 != 0 && _feeConfig.gamma2 != 0 && _feeConfig.volumeGamma != 0, 'Gammas must be > 0');\n\n    feeConfig = _feeConfig;\n    emit FeeConfiguration(_feeConfig);\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function getSingleTimepoint(\n    uint32 time,\n    uint32 secondsAgo,\n    int24 tick,\n    uint16 index,\n    uint128 liquidity\n  )\n    external\n    view\n    override\n    onlyPool\n    returns (\n      int56 tickCumulative,\n      uint160 secondsPerLiquidityCumulative,\n      uint112 volatilityCumulative,\n      uint256 volumePerAvgLiquidity\n    )\n  {\n    uint16 oldestIndex;\n    // check if we have overflow in the past\n    uint16 nextIndex = index + 1; // considering overflow\n    if (timepoints[nextIndex].initialized) {\n      oldestIndex = nextIndex;\n    }\n\n    DataStorage.Timepoint memory result = timepoints.getSingleTimepoint(time, secondsAgo, tick, index, oldestIndex, liquidity);\n    (tickCumulative, secondsPerLiquidityCumulative, volatilityCumulative, volumePerAvgLiquidity) = (\n      result.tickCumulative,\n      result.secondsPerLiquidityCumulative,\n      result.volatilityCumulative,\n      result.volumePerLiquidityCumulative\n    );\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function getTimepoints(\n    uint32 time,\n    uint32[] memory secondsAgos,\n    int24 tick,\n    uint16 index,\n    uint128 liquidity\n  )\n    external\n    view\n    override\n    onlyPool\n    returns (\n      int56[] memory tickCumulatives,\n      uint160[] memory secondsPerLiquidityCumulatives,\n      uint112[] memory volatilityCumulatives,\n      uint256[] memory volumePerAvgLiquiditys\n    )\n  {\n    return timepoints.getTimepoints(time, secondsAgos, tick, index, liquidity);\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function getAverages(\n    uint32 time,\n    int24 tick,\n    uint16 index,\n    uint128 liquidity\n  ) external view override onlyPool returns (uint112 TWVolatilityAverage, uint256 TWVolumePerLiqAverage) {\n    return timepoints.getAverages(time, tick, index, liquidity);\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function write(\n    uint16 index,\n    uint32 blockTimestamp,\n    int24 tick,\n    uint128 liquidity,\n    uint128 volumePerLiquidity\n  ) external override onlyPool returns (uint16 indexUpdated) {\n    return timepoints.write(index, blockTimestamp, tick, liquidity, volumePerLiquidity);\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function calculateVolumePerLiquidity(\n    uint128 liquidity,\n    int256 amount0,\n    int256 amount1\n  ) external pure override returns (uint128 volumePerLiquidity) {\n    uint256 volume = Sqrt.sqrtAbs(amount0) * Sqrt.sqrtAbs(amount1);\n    uint256 volumeShifted;\n    if (volume >= 2**192) volumeShifted = (type(uint256).max) / (liquidity > 0 ? liquidity : 1);\n    else volumeShifted = (volume << 64) / (liquidity > 0 ? liquidity : 1);\n    if (volumeShifted >= MAX_VOLUME_PER_LIQUIDITY) return MAX_VOLUME_PER_LIQUIDITY;\n    else return uint128(volumeShifted);\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function window() external pure override returns (uint32) {\n    return DataStorage.WINDOW;\n  }\n\n  /// @inheritdoc IDataStorageOperator\n  function getFee(\n    uint32 _time,\n    int24 _tick,\n    uint16 _index,\n    uint128 _liquidity\n  ) external view override onlyPool returns (uint16 fee) {\n    (uint88 volatilityAverage, uint256 volumePerLiqAverage) = timepoints.getAverages(_time, _tick, _index, _liquidity);\n\n    return AdaptiveFee.getFee(volatilityAverage / 15, volumePerLiqAverage, feeConfig);\n  }\n}"
    }
  ]
}