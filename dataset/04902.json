{
  "Title": "[M-06] First block proposer check in the `LibProposing._isProposerPermitted` function is errorneous",
  "Content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L93-L94> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L299-L317>\n\nThe `LibProposing.proposeBlock` function calls the `_isProposerPermitted` private function, to ensure if the `proposer is set`. Only that specific address has the permission to propose the block.\n\nIn the `_isProposerPermitted` function, for the first block after the genesis block only the `proposerOne` is allowed to propose the first block as shown below:\n\n```solidity\n            address proposerOne = _resolver.resolve(\"proposer_one\", true);\n            if (proposerOne != address(0) && msg.sender != proposerOne) {\n                return false;\n            }\n```\n\nBut the issue here is that when the `msg.sender == proposerOne` the function `does not return true` if the following conditions occur.\n\nIf the `proposer != address(0) && msg.sender != proposer`. In which case even though the `msg.sender == proposerOne` is `true` for the first block the `_isProposerPermitted` will still return `false` thus reverting the block proposer for the first block.\n\nHence even though the `proposer_one` is the proposer of the first block the transaction will still revert if the above mentioned conditions occur and the `_isProposerPermitted` returns `false` for the first block after the genesis block.\n\nHence this will break the block proposing logic since the proposal of the first block after the genesis block reverts thus not allowing subsequent blocks to be proposed.\n\n### Proof of Concept\n\n```solidity\n        TaikoData.SlotB memory b = _state.slotB;\n        if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();\n```\n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L93-L94>\n\n```solidity\n    function _isProposerPermitted(\n        TaikoData.SlotB memory _slotB,\n        IAddressResolver _resolver\n    )\n        private\n        view\n        returns (bool)\n    {\n        if (_slotB.numBlocks == 1) {\n            // Only proposer_one can propose the first block after genesis\n            address proposerOne = _resolver.resolve(\"proposer_one\", true);\n            if (proposerOne != address(0) && msg.sender != proposerOne) {\n                return false;\n            }\n        }\n\n        address proposer = _resolver.resolve(\"proposer\", true);\n        return proposer == address(0) || msg.sender == proposer;\n    }\n```\n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L299-L317>\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nIt is recommended to add logic in the `LibProposing._isProposerPermitted` function to `return true` when the `msg.sender == proposerOne`, for proposing the first block after genesis block.\n\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/274#issuecomment-2031595523):**\n > I think this is a valid bug: fixing it [here](https://github.com/taikoxyz/taiko-mono/pull/16605) \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/L1/libs/LibProposing.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../hooks/IHook.sol\";\nimport \"../tiers/ITierProvider.sol\";\nimport \"../TaikoData.sol\";\nimport \"./LibDepositing.sol\";\n\n/// @title LibProposing\n/// @notice A library for handling block proposals in the Taiko protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibProposing {\n    using LibAddress for address;\n\n    /// @notice The maximum number of bytes allowed per blob.\n    /// @dev According to EIP4844, each blob has up to 4096 field elements, and each\n    /// field element has 32 bytes.\n    uint256 public constant MAX_BYTES_PER_BLOB = 4096 * 32;\n\n    // Warning: Any events defined here must also be defined in TaikoEvents.sol.\n    /// @notice Emitted when a block is proposed.\n    /// @param blockId The ID of the proposed block.\n    /// @param assignedProver The address of the assigned prover.\n    /// @param livenessBond The liveness bond of the proposed block.\n    /// @param meta The metadata of the proposed block.\n    /// @param depositsProcessed The EthDeposit array about processed deposits in this proposed\n    /// block.\n    event BlockProposed(\n        uint256 indexed blockId,\n        address indexed assignedProver,\n        uint96 livenessBond,\n        TaikoData.BlockMetadata meta,\n        TaikoData.EthDeposit[] depositsProcessed\n    );\n\n    /// @notice Emitted when a blob is cached.\n    /// @param blobHash The hash of the cached blob.\n    event BlobCached(bytes32 blobHash);\n\n    // Warning: Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_BLOB_FOR_DA_DISABLED();\n    error L1_BLOB_NOT_FOUND();\n    error L1_BLOB_NOT_REUSABLE();\n    error L1_BLOB_REUSE_DISABLED();\n    error L1_INVALID_HOOK();\n    error L1_INVALID_PARAM();\n    error L1_INVALID_PROVER();\n    error L1_LIVENESS_BOND_NOT_RECEIVED();\n    error L1_PROPOSER_NOT_EOA();\n    error L1_TOO_MANY_BLOCKS();\n    error L1_TXLIST_OFFSET();\n    error L1_TXLIST_SIZE();\n    error L1_UNAUTHORIZED();\n    error L1_UNEXPECTED_PARENT();\n\n    /// @dev Proposes a Taiko L2 block.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _data Encoded data bytes containing the block params.\n    /// @param _txList Transaction list bytes (if not blob).\n    /// @return meta_ The constructed block's metadata.\n    /// @return deposits_ The EthDeposit array about processed deposits in this proposed\n    /// block.\n    function proposeBlock(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        bytes calldata _data,\n        bytes calldata _txList\n    )\n        internal\n        returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)\n    {\n        TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams));\n\n        // We need a prover that will submit proofs after the block has been submitted\n        if (params.assignedProver == address(0)) {\n            revert L1_INVALID_PROVER();\n        }\n\n        if (params.coinbase == address(0)) {\n            params.coinbase = msg.sender;\n        }\n\n        // Taiko, as a Based Rollup, enables permissionless block proposals.\n        // However, if the \"proposer\" address is set to a non-zero value, we\n        // ensure that only that specific address has the authority to propose\n        // blocks.\n        TaikoData.SlotB memory b = _state.slotB;\n        if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();\n\n        // It's essential to ensure that the ring buffer for proposed blocks\n        // still has space for at least one more block.\n        if (b.numBlocks >= b.lastVerifiedBlockId + _config.blockMaxProposals + 1) {\n            revert L1_TOO_MANY_BLOCKS();\n        }\n\n        bytes32 parentMetaHash =\n            _state.blocks[(b.numBlocks - 1) % _config.blockRingBufferSize].metaHash;\n\n        // Check if parent block has the right meta hash\n        // This is to allow the proposer to make sure the block builds on the expected latest chain\n        // state\n        if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {\n            revert L1_UNEXPECTED_PARENT();\n        }\n\n        // Each transaction must handle a specific quantity of L1-to-L2\n        // Ether deposits.\n        deposits_ = LibDepositing.processDeposits(_state, _config, params.coinbase);\n\n        // Initialize metadata to compute a metaHash, which forms a part of\n        // the block data to be stored on-chain for future integrity checks.\n        // If we choose to persist all data fields in the metadata, it will\n        // require additional storage slots.\n        unchecked {\n            meta_ = TaikoData.BlockMetadata({\n                l1Hash: blockhash(block.number - 1),\n                difficulty: 0, // to be initialized below\n                blobHash: 0, // to be initialized below\n                extraData: params.extraData,\n                depositsHash: keccak256(abi.encode(deposits_)),\n                coinbase: params.coinbase,\n                id: b.numBlocks,\n                gasLimit: _config.blockMaxGasLimit,\n                timestamp: uint64(block.timestamp),\n                l1Height: uint64(block.number - 1),\n                txListByteOffset: 0, // to be initialized below\n                txListByteSize: 0, // to be initialized below\n                minTier: 0, // to be initialized below\n                blobUsed: _txList.length == 0,\n                parentMetaHash: parentMetaHash\n            });\n        }\n\n        // Update certain meta fields\n        if (meta_.blobUsed) {\n            if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED();\n\n            if (params.blobHash != 0) {\n                if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED();\n\n                // We try to reuse an old blob\n                if (!isBlobReusable(_state, _config, params.blobHash)) {\n                    revert L1_BLOB_NOT_REUSABLE();\n                }\n                meta_.blobHash = params.blobHash;\n            } else {\n                // Always use the first blob in this transaction. If the\n                // proposeBlock functions are called more than once in the same\n                // L1 transaction, these multiple L2 blocks will share the same\n                // blob.\n                meta_.blobHash = blobhash(0);\n\n                if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND();\n\n                // Depends on the blob data price, it may not make sense to\n                // cache the blob which costs 20,000 (sstore) + 631 (event)\n                // extra gas.\n                if (_config.blobReuseEnabled && params.cacheBlobForReuse) {\n                    _state.reusableBlobs[meta_.blobHash] = block.timestamp;\n                    emit BlobCached(meta_.blobHash);\n                }\n            }\n\n            // Check that the txList data range is within the max size of a blob\n            if (uint256(params.txListByteOffset) + params.txListByteSize > MAX_BYTES_PER_BLOB) {\n                revert L1_TXLIST_OFFSET();\n            }\n\n            meta_.txListByteOffset = params.txListByteOffset;\n            meta_.txListByteSize = params.txListByteSize;\n        } else {\n            // The proposer must be an Externally Owned Account (EOA) for\n            // calldata usage. This ensures that the transaction is not an\n            // internal one, making calldata retrieval more straightforward for\n            // Taiko node software.\n            if (!LibAddress.isSenderEOA()) revert L1_PROPOSER_NOT_EOA();\n\n            // The txList is the full byte array without any offset\n            if (params.txListByteOffset != 0) {\n                revert L1_INVALID_PARAM();\n            }\n\n            meta_.blobHash = keccak256(_txList);\n            meta_.txListByteOffset = 0;\n            meta_.txListByteSize = uint24(_txList.length);\n        }\n\n        // Check that the tx length is non-zero and within the supported range\n        if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) {\n            revert L1_TXLIST_SIZE();\n        }\n\n        // Following the Merge, the L1 mixHash incorporates the\n        // prevrandao value from the beacon chain. Given the possibility\n        // of multiple Taiko blocks being proposed within a single\n        // Ethereum block, we choose to introduce a salt to this random\n        // number as the L2 mixHash.\n        meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));\n\n        // Use the difficulty as a random number\n        meta_.minTier = ITierProvider(_resolver.resolve(\"tier_provider\", false)).getMinTier(\n            uint256(meta_.difficulty)\n        );\n\n        // Create the block that will be stored onchain\n        TaikoData.Block memory blk = TaikoData.Block({\n            metaHash: keccak256(abi.encode(meta_)),\n            // Safeguard the liveness bond to ensure its preservation,\n            // particularly in scenarios where it might be altered after the\n            // block's proposal but before it has been proven or verified.\n            livenessBond: _config.livenessBond,\n            blockId: b.numBlocks,\n            proposedAt: meta_.timestamp,\n            proposedIn: uint64(block.number),\n            // For a new block, the next transition ID is always 1, not 0.\n            nextTransitionId: 1,\n            // For unverified block, its verifiedTransitionId is always 0.\n            verifiedTransitionId: 0,\n            assignedProver: params.assignedProver\n        });\n\n        // Store the block in the ring buffer\n        _state.blocks[b.numBlocks % _config.blockRingBufferSize] = blk;\n\n        // Increment the counter (cursor) by 1.\n        unchecked {\n            ++_state.slotB.numBlocks;\n        }\n\n        {\n            IERC20 tko = IERC20(_resolver.resolve(\"taiko_token\", false));\n            uint256 tkoBalance = tko.balanceOf(address(this));\n\n            // Run all hooks.\n            // Note that address(this).balance has been updated with msg.value,\n            // prior to any code in this function has been executed.\n            address prevHook;\n            for (uint256 i; i < params.hookCalls.length; ++i) {\n                if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) {\n                    revert L1_INVALID_HOOK();\n                }\n\n                // When a hook is called, all ether in this contract will be send to the hook.\n                // If the ether sent to the hook is not used entirely, the hook shall send the Ether\n                // back to this contract for the next hook to use.\n                // Proposers shall choose use extra hooks wisely.\n                IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(\n                    blk, meta_, params.hookCalls[i].data\n                );\n\n                prevHook = params.hookCalls[i].hook;\n            }\n            // Refund Ether\n            if (address(this).balance != 0) {\n                msg.sender.sendEther(address(this).balance);\n            }\n\n            // Check that after hooks, the Taiko Token balance of this contract\n            // have increased by the same amount as _config.livenessBond (to prevent)\n            // multiple draining payments by a malicious proposer nesting the same\n            // hook.\n            if (tko.balanceOf(address(this)) != tkoBalance + _config.livenessBond) {\n                revert L1_LIVENESS_BOND_NOT_RECEIVED();\n            }\n        }\n\n        emit BlockProposed({\n            blockId: blk.blockId,\n            assignedProver: blk.assignedProver,\n            livenessBond: _config.livenessBond,\n            meta: meta_,\n            depositsProcessed: deposits_\n        });\n    }\n\n    /// @notice Checks if a blob is reusable.\n    /// @param _state Current TaikoData.State.\n    /// @param _config The TaikoData.Config.\n    /// @param _blobHash The blob hash\n    /// @return true if the blob is reusable, false otherwise.\n    function isBlobReusable(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        bytes32 _blobHash\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return _state.reusableBlobs[_blobHash] + _config.blobExpiry > block.timestamp;\n    }\n\n    function _isProposerPermitted(\n        TaikoData.SlotB memory _slotB,\n        IAddressResolver _resolver\n    )\n        private\n        view\n        returns (bool)\n    {\n        if (_slotB.numBlocks == 1) {\n            // Only proposer_one can propose the first block after genesis\n            address proposerOne = _resolver.resolve(\"proposer_one\", true);\n            if (proposerOne != address(0) && msg.sender != proposerOne) {\n                return false;\n            }\n        }\n\n        address proposer = _resolver.resolve(\"proposer\", true);\n        return proposer == address(0) || msg.sender == proposer;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/libs/LibProposing.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../hooks/IHook.sol\";\nimport \"../tiers/ITierProvider.sol\";\nimport \"../TaikoData.sol\";\nimport \"./LibDepositing.sol\";\n\n/// @title LibProposing\n/// @notice A library for handling block proposals in the Taiko protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibProposing {\n    using LibAddress for address;\n\n    /// @notice The maximum number of bytes allowed per blob.\n    /// @dev According to EIP4844, each blob has up to 4096 field elements, and each\n    /// field element has 32 bytes.\n    uint256 public constant MAX_BYTES_PER_BLOB = 4096 * 32;\n\n    // Warning: Any events defined here must also be defined in TaikoEvents.sol.\n    /// @notice Emitted when a block is proposed.\n    /// @param blockId The ID of the proposed block.\n    /// @param assignedProver The address of the assigned prover.\n    /// @param livenessBond The liveness bond of the proposed block.\n    /// @param meta The metadata of the proposed block.\n    /// @param depositsProcessed The EthDeposit array about processed deposits in this proposed\n    /// block.\n    event BlockProposed(\n        uint256 indexed blockId,\n        address indexed assignedProver,\n        uint96 livenessBond,\n        TaikoData.BlockMetadata meta,\n        TaikoData.EthDeposit[] depositsProcessed\n    );\n\n    /// @notice Emitted when a blob is cached.\n    /// @param blobHash The hash of the cached blob.\n    event BlobCached(bytes32 blobHash);\n\n    // Warning: Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_BLOB_FOR_DA_DISABLED();\n    error L1_BLOB_NOT_FOUND();\n    error L1_BLOB_NOT_REUSABLE();\n    error L1_BLOB_REUSE_DISABLED();\n    error L1_INVALID_HOOK();\n    error L1_INVALID_PARAM();\n    error L1_INVALID_PROVER();\n    error L1_LIVENESS_BOND_NOT_RECEIVED();\n    error L1_PROPOSER_NOT_EOA();\n    error L1_TOO_MANY_BLOCKS();\n    error L1_TXLIST_OFFSET();\n    error L1_TXLIST_SIZE();\n    error L1_UNAUTHORIZED();\n    error L1_UNEXPECTED_PARENT();\n\n    /// @dev Proposes a Taiko L2 block.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _data Encoded data bytes containing the block params.\n    /// @param _txList Transaction list bytes (if not blob).\n    /// @return meta_ The constructed block's metadata.\n    /// @return deposits_ The EthDeposit array about processed deposits in this proposed\n    /// block.\n    function proposeBlock(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        bytes calldata _data,\n        bytes calldata _txList\n    )\n        internal\n        returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)\n    {\n        TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams));\n\n        // We need a prover that will submit proofs after the block has been submitted\n        if (params.assignedProver == address(0)) {\n            revert L1_INVALID_PROVER();\n        }\n\n        if (params.coinbase == address(0)) {\n            params.coinbase = msg.sender;\n        }\n\n        // Taiko, as a Based Rollup, enables permissionless block proposals.\n        // However, if the \"proposer\" address is set to a non-zero value, we\n        // ensure that only that specific address has the authority to propose\n        // blocks.\n        TaikoData.SlotB memory b = _state.slotB;\n        if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();\n\n        // It's essential to ensure that the ring buffer for proposed blocks\n        // still has space for at least one more block.\n        if (b.numBlocks >= b.lastVerifiedBlockId + _config.blockMaxProposals + 1) {\n            revert L1_TOO_MANY_BLOCKS();\n        }\n\n        bytes32 parentMetaHash =\n            _state.blocks[(b.numBlocks - 1) % _config.blockRingBufferSize].metaHash;\n\n        // Check if parent block has the right meta hash\n        // This is to allow the proposer to make sure the block builds on the expected latest chain\n        // state\n        if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {\n            revert L1_UNEXPECTED_PARENT();\n        }\n\n        // Each transaction must handle a specific quantity of L1-to-L2\n        // Ether deposits.\n        deposits_ = LibDepositing.processDeposits(_state, _config, params.coinbase);\n\n        // Initialize metadata to compute a metaHash, which forms a part of\n        // the block data to be stored on-chain for future integrity checks.\n        // If we choose to persist all data fields in the metadata, it will\n        // require additional storage slots.\n        unchecked {\n            meta_ = TaikoData.BlockMetadata({\n                l1Hash: blockhash(block.number - 1),\n                difficulty: 0, // to be initialized below\n                blobHash: 0, // to be initialized below\n                extraData: params.extraData,\n                depositsHash: keccak256(abi.encode(deposits_)),\n                coinbase: params.coinbase,\n                id: b.numBlocks,\n                gasLimit: _config.blockMaxGasLimit,\n                timestamp: uint64(block.timestamp),\n                l1Height: uint64(block.number - 1),\n                txListByteOffset: 0, // to be initialized below\n                txListByteSize: 0, // to be initialized below\n                minTier: 0, // to be initialized below\n                blobUsed: _txList.length == 0,\n                parentMetaHash: parentMetaHash\n            });\n        }\n\n        // Update certain meta fields\n        if (meta_.blobUsed) {\n            if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED();\n\n            if (params.blobHash != 0) {\n                if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED();\n\n                // We try to reuse an old blob\n                if (!isBlobReusable(_state, _config, params.blobHash)) {\n                    revert L1_BLOB_NOT_REUSABLE();\n                }\n                meta_.blobHash = params.blobHash;\n            } else {\n                // Always use the first blob in this transaction. If the\n                // proposeBlock functions are called more than once in the same\n                // L1 transaction, these multiple L2 blocks will share the same\n                // blob.\n                meta_.blobHash = blobhash(0);\n\n                if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND();\n\n                // Depends on the blob data price, it may not make sense to\n                // cache the blob which costs 20,000 (sstore) + 631 (event)\n                // extra gas.\n                if (_config.blobReuseEnabled && params.cacheBlobForReuse) {\n                    _state.reusableBlobs[meta_.blobHash] = block.timestamp;\n                    emit BlobCached(meta_.blobHash);\n                }\n            }\n\n            // Check that the txList data range is within the max size of a blob\n            if (uint256(params.txListByteOffset) + params.txListByteSize > MAX_BYTES_PER_BLOB) {\n                revert L1_TXLIST_OFFSET();\n            }\n\n            meta_.txListByteOffset = params.txListByteOffset;\n            meta_.txListByteSize = params.txListByteSize;\n        } else {\n            // The proposer must be an Externally Owned Account (EOA) for\n            // calldata usage. This ensures that the transaction is not an\n            // internal one, making calldata retrieval more straightforward for\n            // Taiko node software.\n            if (!LibAddress.isSenderEOA()) revert L1_PROPOSER_NOT_EOA();\n\n            // The txList is the full byte array without any offset\n            if (params.txListByteOffset != 0) {\n                revert L1_INVALID_PARAM();\n            }\n\n            meta_.blobHash = keccak256(_txList);\n            meta_.txListByteOffset = 0;\n            meta_.txListByteSize = uint24(_txList.length);\n        }\n\n        // Check that the tx length is non-zero and within the supported range\n        if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) {\n            revert L1_TXLIST_SIZE();\n        }\n\n        // Following the Merge, the L1 mixHash incorporates the\n        // prevrandao value from the beacon chain. Given the possibility\n        // of multiple Taiko blocks being proposed within a single\n        // Ethereum block, we choose to introduce a salt to this random\n        // number as the L2 mixHash.\n        meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));\n\n        // Use the difficulty as a random number\n        meta_.minTier = ITierProvider(_resolver.resolve(\"tier_provider\", false)).getMinTier(\n            uint256(meta_.difficulty)\n        );\n\n        // Create the block that will be stored onchain\n        TaikoData.Block memory blk = TaikoData.Block({\n            metaHash: keccak256(abi.encode(meta_)),\n            // Safeguard the liveness bond to ensure its preservation,\n            // particularly in scenarios where it might be altered after the\n            // block's proposal but before it has been proven or verified.\n            livenessBond: _config.livenessBond,\n            blockId: b.numBlocks,\n            proposedAt: meta_.timestamp,\n            proposedIn: uint64(block.number),\n            // For a new block, the next transition ID is always 1, not 0.\n            nextTransitionId: 1,\n            // For unverified block, its verifiedTransitionId is always 0.\n            verifiedTransitionId: 0,\n            assignedProver: params.assignedProver\n        });\n\n        // Store the block in the ring buffer\n        _state.blocks[b.numBlocks % _config.blockRingBufferSize] = blk;\n\n        // Increment the counter (cursor) by 1.\n        unchecked {\n            ++_state.slotB.numBlocks;\n        }\n\n        {\n            IERC20 tko = IERC20(_resolver.resolve(\"taiko_token\", false));\n            uint256 tkoBalance = tko.balanceOf(address(this));\n\n            // Run all hooks.\n            // Note that address(this).balance has been updated with msg.value,\n            // prior to any code in this function has been executed.\n            address prevHook;\n            for (uint256 i; i < params.hookCalls.length; ++i) {\n                if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) {\n                    revert L1_INVALID_HOOK();\n                }\n\n                // When a hook is called, all ether in this contract will be send to the hook.\n                // If the ether sent to the hook is not used entirely, the hook shall send the Ether\n                // back to this contract for the next hook to use.\n                // Proposers shall choose use extra hooks wisely.\n                IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(\n                    blk, meta_, params.hookCalls[i].data\n                );\n\n                prevHook = params.hookCalls[i].hook;\n            }\n            // Refund Ether\n            if (address(this).balance != 0) {\n                msg.sender.sendEther(address(this).balance);\n            }\n\n            // Check that after hooks, the Taiko Token balance of this contract\n            // have increased by the same amount as _config.livenessBond (to prevent)\n            // multiple draining payments by a malicious proposer nesting the same\n            // hook.\n            if (tko.balanceOf(address(this)) != tkoBalance + _config.livenessBond) {\n                revert L1_LIVENESS_BOND_NOT_RECEIVED();\n            }\n        }\n\n        emit BlockProposed({\n            blockId: blk.blockId,\n            assignedProver: blk.assignedProver,\n            livenessBond: _config.livenessBond,\n            meta: meta_,\n            depositsProcessed: deposits_\n        });\n    }\n\n    /// @notice Checks if a blob is reusable.\n    /// @param _state Current TaikoData.State.\n    /// @param _config The TaikoData.Config.\n    /// @param _blobHash The blob hash\n    /// @return true if the blob is reusable, false otherwise.\n    function isBlobReusable(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        bytes32 _blobHash\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return _state.reusableBlobs[_blobHash] + _config.blobExpiry > block.timestamp;\n    }\n\n    function _isProposerPermitted(\n        TaikoData.SlotB memory _slotB,\n        IAddressResolver _resolver\n    )\n        private\n        view\n        returns (bool)\n    {\n        if (_slotB.numBlocks == 1) {\n            // Only proposer_one can propose the first block after genesis\n            address proposerOne = _resolver.resolve(\"proposer_one\", true);\n            if (proposerOne != address(0) && msg.sender != proposerOne) {\n                return false;\n            }\n        }\n\n        address proposer = _resolver.resolve(\"proposer\", true);\n        return proposer == address(0) || msg.sender == proposer;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/libs/LibProposing.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../hooks/IHook.sol\";\nimport \"../tiers/ITierProvider.sol\";\nimport \"../TaikoData.sol\";\nimport \"./LibDepositing.sol\";\n\n/// @title LibProposing\n/// @notice A library for handling block proposals in the Taiko protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibProposing {\n    using LibAddress for address;\n\n    /// @notice The maximum number of bytes allowed per blob.\n    /// @dev According to EIP4844, each blob has up to 4096 field elements, and each\n    /// field element has 32 bytes.\n    uint256 public constant MAX_BYTES_PER_BLOB = 4096 * 32;\n\n    // Warning: Any events defined here must also be defined in TaikoEvents.sol.\n    /// @notice Emitted when a block is proposed.\n    /// @param blockId The ID of the proposed block.\n    /// @param assignedProver The address of the assigned prover.\n    /// @param livenessBond The liveness bond of the proposed block.\n    /// @param meta The metadata of the proposed block.\n    /// @param depositsProcessed The EthDeposit array about processed deposits in this proposed\n    /// block.\n    event BlockProposed(\n        uint256 indexed blockId,\n        address indexed assignedProver,\n        uint96 livenessBond,\n        TaikoData.BlockMetadata meta,\n        TaikoData.EthDeposit[] depositsProcessed\n    );\n\n    /// @notice Emitted when a blob is cached.\n    /// @param blobHash The hash of the cached blob.\n    event BlobCached(bytes32 blobHash);\n\n    // Warning: Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_BLOB_FOR_DA_DISABLED();\n    error L1_BLOB_NOT_FOUND();\n    error L1_BLOB_NOT_REUSABLE();\n    error L1_BLOB_REUSE_DISABLED();\n    error L1_INVALID_HOOK();\n    error L1_INVALID_PARAM();\n    error L1_INVALID_PROVER();\n    error L1_LIVENESS_BOND_NOT_RECEIVED();\n    error L1_PROPOSER_NOT_EOA();\n    error L1_TOO_MANY_BLOCKS();\n    error L1_TXLIST_OFFSET();\n    error L1_TXLIST_SIZE();\n    error L1_UNAUTHORIZED();\n    error L1_UNEXPECTED_PARENT();\n\n    /// @dev Proposes a Taiko L2 block.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _data Encoded data bytes containing the block params.\n    /// @param _txList Transaction list bytes (if not blob).\n    /// @return meta_ The constructed block's metadata.\n    /// @return deposits_ The EthDeposit array about processed deposits in this proposed\n    /// block.\n    function proposeBlock(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        bytes calldata _data,\n        bytes calldata _txList\n    )\n        internal\n        returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)\n    {\n        TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams));\n\n        // We need a prover that will submit proofs after the block has been submitted\n        if (params.assignedProver == address(0)) {\n            revert L1_INVALID_PROVER();\n        }\n\n        if (params.coinbase == address(0)) {\n            params.coinbase = msg.sender;\n        }\n\n        // Taiko, as a Based Rollup, enables permissionless block proposals.\n        // However, if the \"proposer\" address is set to a non-zero value, we\n        // ensure that only that specific address has the authority to propose\n        // blocks.\n        TaikoData.SlotB memory b = _state.slotB;\n        if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();\n\n        // It's essential to ensure that the ring buffer for proposed blocks\n        // still has space for at least one more block.\n        if (b.numBlocks >= b.lastVerifiedBlockId + _config.blockMaxProposals + 1) {\n            revert L1_TOO_MANY_BLOCKS();\n        }\n\n        bytes32 parentMetaHash =\n            _state.blocks[(b.numBlocks - 1) % _config.blockRingBufferSize].metaHash;\n\n        // Check if parent block has the right meta hash\n        // This is to allow the proposer to make sure the block builds on the expected latest chain\n        // state\n        if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {\n            revert L1_UNEXPECTED_PARENT();\n        }\n\n        // Each transaction must handle a specific quantity of L1-to-L2\n        // Ether deposits.\n        deposits_ = LibDepositing.processDeposits(_state, _config, params.coinbase);\n\n        // Initialize metadata to compute a metaHash, which forms a part of\n        // the block data to be stored on-chain for future integrity checks.\n        // If we choose to persist all data fields in the metadata, it will\n        // require additional storage slots.\n        unchecked {\n            meta_ = TaikoData.BlockMetadata({\n                l1Hash: blockhash(block.number - 1),\n                difficulty: 0, // to be initialized below\n                blobHash: 0, // to be initialized below\n                extraData: params.extraData,\n                depositsHash: keccak256(abi.encode(deposits_)),\n                coinbase: params.coinbase,\n                id: b.numBlocks,\n                gasLimit: _config.blockMaxGasLimit,\n                timestamp: uint64(block.timestamp),\n                l1Height: uint64(block.number - 1),\n                txListByteOffset: 0, // to be initialized below\n                txListByteSize: 0, // to be initialized below\n                minTier: 0, // to be initialized below\n                blobUsed: _txList.length == 0,\n                parentMetaHash: parentMetaHash\n            });\n        }\n\n        // Update certain meta fields\n        if (meta_.blobUsed) {\n            if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED();\n\n            if (params.blobHash != 0) {\n                if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED();\n\n                // We try to reuse an old blob\n                if (!isBlobReusable(_state, _config, params.blobHash)) {\n                    revert L1_BLOB_NOT_REUSABLE();\n                }\n                meta_.blobHash = params.blobHash;\n            } else {"
    }
  ]
}