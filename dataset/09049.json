{
  "Title": "[02] `_revertWithReasonIfOneIsReturned`, `_doesNotMatchMagic` (and `_assertIsValidOrderStaticcallSuccess`) have a fragile dependency on call order",
  "Content": "\nThese helper functions rely on the undisturbed contents returned by `returndatasize`/`returndatacopy`. Should the call sites undergo some changes, they may not function as intended. They are used in numerous functions.\n\nThis is further complicated in `_assertIsValidOrderStaticcallSuccess` which is another layer hiding this assumption.\n\n### Proof of Concept\n**Context:** [LowLevelHelpers.sol#L46](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/LowLevelHelpers.sol#L46), [LowLevelHelpers.sol#L103](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/LowLevelHelpers.sol#L103), [ZoneInteraction.sol#L157](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/ZoneInteraction.sol#L157)\n\nIssues can arise if:\n1. The order of these helpers change and some other call is performed\n2. These helpers become non-internal library functions (because then a call is performed and in the new context the buffer is empty)\n\nAn example use case is below:\n```solidity\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n       // <-- Do something here to disturb the returndata buffer\n\n        // If the call fails...\n        if (!success) {\n            // Revert and pass the revert reason along if one was returned.\n            _revertWithReasonIfOneIsReturned();\n\n            // Otherwise, revert with a generic error message.\n            revert EtherTransferGenericFailure(to, amount);\n        }\n```\n\nSimple way to make this fail:\n```diff\n-    function _revertWithReasonIfOneIsReturned() internal view {\n+    function _revertWithReasonIfOneIsReturned() view {\n```\n\n### Recommended Mitigation Steps\n\nDocument these assumptions as a warning and carefully test these cases.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/lib/LowLevelHelpers.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./ConsiderationConstants.sol\";\n\n/**\n * @title LowLevelHelpers\n * @author 0age\n * @notice LowLevelHelpers contains logic for performing various low-level\n *         operations.\n */\ncontract LowLevelHelpers {\n    /**\n     * @dev Internal view function to staticcall an arbitrary target with given\n     *      calldata. Note that no data is written to memory and no contract\n     *      size check is performed.\n     *\n     * @param target   The account to staticcall.\n     * @param callData The calldata to supply when staticcalling the target.\n     *\n     * @return success The status of the staticcall to the target.\n     */\n    function _staticcall(address target, bytes memory callData)\n        internal\n        view\n        returns (bool success)\n    {\n        assembly {\n            // Perform the staticcall.\n            success := staticcall(\n                gas(),\n                target,\n                add(callData, OneWord),\n                mload(callData),\n                0,\n                0\n            )\n        }\n    }\n\n    /**\n     * @dev Internal view function to revert and pass along the revert reason if\n     *      data was returned by the last call and that the size of that data\n     *      does not exceed the currently allocated memory size.\n     */\n    function _revertWithReasonIfOneIsReturned() internal view {\n        assembly {\n            // If it returned a message, bubble it up as long as sufficient gas\n            // remains to do so:\n            if returndatasize() {\n                // Ensure that sufficient gas is available to copy returndata\n                // while expanding memory where necessary. Start by computing\n                // the word size of returndata and allocated memory.\n                let returnDataWords := div(returndatasize(), OneWord)\n\n                // Note: use the free memory pointer in place of msize() to work\n                // around a Yul warning that prevents accessing msize directly\n                // when the IR pipeline is activated.\n                let msizeWords := div(mload(FreeMemoryPointerSlot), OneWord)\n\n                // Next, compute the cost of the returndatacopy.\n                let cost := mul(CostPerWord, returnDataWords)\n\n                // Then, compute cost of new memory allocation.\n                if gt(returnDataWords, msizeWords) {\n                    cost := add(\n                        cost,\n                        add(\n                            mul(sub(returnDataWords, msizeWords), CostPerWord),\n                            div(\n                                sub(\n                                    mul(returnDataWords, returnDataWords),\n                                    mul(msizeWords, msizeWords)\n                                ),\n                                MemoryExpansionCoefficient\n                            )\n                        )\n                    )\n                }\n\n                // Finally, add a small constant and compare to gas remaining;\n                // bubble up the revert data if enough gas is still available.\n                if lt(add(cost, ExtraGasBuffer), gas()) {\n                    // Copy returndata to memory; overwrite existing memory.\n                    returndatacopy(0, 0, returndatasize())\n\n                    // Revert, specifying memory region with copied returndata.\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to determine if the first word of returndata\n     *      matches an expected magic value.\n     *\n     * @param expected The expected magic value.\n     *\n     * @return A boolean indicating whether the expected value matches the one\n     *         located in the first word of returndata.\n     */\n    function _doesNotMatchMagic(bytes4 expected) internal pure returns (bool) {\n        // Declare a variable for the value held by the return data buffer.\n        bytes4 result;\n\n        // Utilize assembly in order to read directly from returndata buffer.\n        assembly {\n            // Only put result on stack if return data is exactly one word.\n            if eq(returndatasize(), OneWord) {\n                // Copy the word directly from return data into scratch space.\n                returndatacopy(0, 0, OneWord)\n\n                // Take value from scratch space and place it on the stack.\n                result := mload(0)\n            }\n        }\n\n        // Return a boolean indicating whether expected and located value match.\n        return result != expected;\n    }\n}"
    }
  ]
}