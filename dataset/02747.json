{
  "Title": "M-5: Early depositors to DnGmxSeniorVault can manipulate exchange rates to steal funds from later depositors",
  "Content": "# Issue M-5: Early depositors to DnGmxSeniorVault can manipulate exchange rates to steal funds from later depositors \n\nSource: https://github.com/sherlock-audit/2022-10-rage-trade-judging/issues/37 \n\n## Found by \nrvierdiiev, tives, peanuts, joestakey, cccz, ctf\\_sec, \\_\\_141345\\_\\_, 0x52, GimelSec, clems4ever\n\n## Summary\n\nTo calculate the exchange rate for shares in DnGmxSeniorVault it divides the total supply of shares by the totalAssets of the vault. The first deposit can mint a very small number of shares then donate aUSDC to the vault to grossly manipulate the share price. When later depositor deposit into the vault they will lose value due to precision loss and the adversary will profit.\n\n## Vulnerability Detail\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\nShare exchange rate is calculated using the total supply of shares and the totalAsset. This can lead to exchange rate manipulation. As an example, an adversary can mint a single share, then donate 1e8 aUSDC. Minting the first share established a 1:1 ratio but then donating 1e8 changed the ratio to 1:1e8. Now any deposit lower than 1e8 (100 aUSDC) will suffer from precision loss and the attackers share will benefit from it.\n\nThis same vector is present in DnGmxJuniorVault.\n\n## Impact\n\nAdversary can effectively steal funds from later users\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-rage-trade/blob/main/dn-gmx-vaults/contracts/vaults/DnGmxSeniorVault.sol#L211-L221\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInitialize should include a small deposit, such as 1e6 aUSDC that mints the share to a dead address to permanently lock the exchange rate:\n\n        aUsdc.approve(address(pool), type(uint256).max);\n        IERC20(asset).approve(address(pool), type(uint256).max);\n\n    +   deposit(1e6, DEAD_ADDRESS);\n\n## Discussion\n\n**0xDosa**\n\nWe will ensure a guarded launch process that safeguards the first deposit to avoid being manipulated.\n\n**Evert0x**\n\nWe are still considering it a valid issue as the guarded launch process is out of scope.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/16",
  "Code": [
    {
      "filename": "dn-gmx-vaults/contracts/vaults/DnGmxSeniorVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { IAToken } from '@aave/core-v3/contracts/interfaces/IAToken.sol';\nimport { IPool } from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport { IPoolAddressesProvider } from '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\nimport { IPriceOracle } from '@aave/core-v3/contracts/interfaces/IPriceOracle.sol';\n\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { OwnableUpgradeable } from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport { PausableUpgradeable } from '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\n\nimport { FullMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol';\n\nimport { IBorrower } from '../interfaces/IBorrower.sol';\nimport { IDnGmxSeniorVault } from '../interfaces/IDnGmxSeniorVault.sol';\nimport { IERC4626 } from '../interfaces/IERC4626.sol';\n\nimport { ERC4626Upgradeable } from '../ERC4626/ERC4626Upgradeable.sol';\nimport { FeeSplitStrategy } from '../libraries/FeeSplitStrategy.sol';\n\n/**\n * @title Delta Neutral GMX Senior Tranche contract\n * @notice Implements the handling of senior tranche which acts as a lender of aUSDC for junior tranche to\n * borrow and hedge tokens using AAVE\n * @notice It is upgradable contract (via TransparentUpgradeableProxy proxy owned by ProxyAdmin)\n * @author RageTrade\n **/\ncontract DnGmxSeniorVault is IDnGmxSeniorVault, ERC4626Upgradeable, OwnableUpgradeable, PausableUpgradeable {\n    using FullMath for uint256;\n    using FeeSplitStrategy for FeeSplitStrategy.Info;\n\n    uint16 internal constant MAX_BPS = 10_000;\n\n    // maximum assets(usdc) that can be deposited into the vault\n    uint256 public depositCap;\n    // maximum utilizqtion that the vault can go upto due to a withdrawal\n    uint256 public maxUtilizationBps;\n\n    // leverage pool which can take usdc from senior tranche to lend against junior tranche shares\n    IBorrower public leveragePool;\n\n    // junior tranche which can take usdc from senior tranche against the GLP assets deposited to borrow for taking hedges on AAVE\n    IBorrower public dnGmxJuniorVault;\n\n    // fee split vs utilization curve\n    // two sloped curve similar to the one used by AAVE\n    FeeSplitStrategy.Info public feeStrategy;\n\n    // AAVE pool\n    IPool internal pool;\n    // AAVE usdc supply token\n    IAToken internal aUsdc;\n    // AAVE oracle\n    IPriceOracle internal oracle;\n    // AAVE pool address provider\n    IPoolAddressesProvider internal poolAddressProvider;\n    // Borrow caps on leverage pool and junior tranche\n    mapping(address => uint256) public borrowCaps;\n\n    // these gaps are added to allow adding new variables without shifting down inheritance chain\n    uint256[50] private __gaps;\n\n    // ensures caller is valid borrower\n    modifier onlyBorrower() {\n        if (msg.sender != address(dnGmxJuniorVault) && msg.sender != address(leveragePool)) revert CallerNotBorrower();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INIT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice initializer\n    /// @param _name name of vault share token\n    /// @param _symbol symbol of vault share token\n    /// @param _usdc address of usdc token\n    /// @param _poolAddressesProvider add\n    function initialize(\n        address _usdc,\n        string calldata _name,\n        string calldata _symbol,\n        address _poolAddressesProvider\n    ) external initializer {\n        __Ownable_init();\n        __Pausable_init();\n        __ERC4626Upgradeable_init(_usdc, _name, _symbol);\n\n        poolAddressProvider = IPoolAddressesProvider(_poolAddressesProvider);\n\n        pool = IPool(poolAddressProvider.getPool());\n        aUsdc = IAToken(pool.getReserveData(_usdc).aTokenAddress);\n        oracle = IPriceOracle(poolAddressProvider.getPriceOracle());\n\n        aUsdc.approve(address(pool), type(uint256).max);\n        IERC20(asset).approve(address(pool), type(uint256).max);\n    }\n\n    /// @notice grants allowances for tokens to relevant external contracts\n    /// @dev to be called once the vault is deployed\n    function grantAllowances() external onlyOwner {\n        address aavePool = address(pool);\n\n        // allow aave lending pool to spend asset\n        IERC20(asset).approve(aavePool, type(uint256).max);\n        // allow aave lending pool to spend interest bearing token\n        aUsdc.approve(aavePool, type(uint256).max);\n\n        emit AllowancesGranted();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ADMIN SETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice sets deposit cap (6 decimals)\n    /// @param _newDepositCap: updated deposit cap\n    /// @dev depositCap = limit on the asset amount (usdc) that can be deposited into the vault\n    function setDepositCap(uint256 _newDepositCap) external onlyOwner {\n        depositCap = _newDepositCap;\n        emit DepositCapUpdated(_newDepositCap);\n    }\n\n    /// @notice sets leverage pool address\n    /// @param _leveragePool: updated deposit cap\n    function setLeveragePool(IBorrower _leveragePool) external onlyOwner {\n        leveragePool = _leveragePool;\n        emit LeveragePoolUpdated(_leveragePool);\n    }\n\n    /// @notice sets junior tranche address\n    /// @param _dnGmxJuniorVault: updated deposit cap\n    function setDnGmxJuniorVault(IBorrower _dnGmxJuniorVault) external onlyOwner {\n        dnGmxJuniorVault = _dnGmxJuniorVault;\n        emit DnGmxJuniorVaultUpdated(_dnGmxJuniorVault);\n    }\n\n    /// @notice sets max utilization bps\n    /// @dev maximum utilization that vault is allowed to go upto on withdrawals (beyond this withdrawals would fail)\n    /// @param _maxUtilizationBps: updated max utilization bps\n    function setMaxUtilizationBps(uint256 _maxUtilizationBps) external onlyOwner {\n        if (_maxUtilizationBps > MAX_BPS) revert InvalidMaxUtilizationBps();\n        maxUtilizationBps = _maxUtilizationBps;\n        emit MaxUtilizationBpsUpdated(_maxUtilizationBps);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      STRATEGY PARAMETERS SETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice updates borrow cap for junior tranche or leverage pool\n    /// @notice borrowCap = max amount a borrower can take from senior tranche\n    /// @param borrowerAddress: address of borrower for whom cap needs to be updated\n    /// @param cap: new cap for the borrower\n    function updateBorrowCap(address borrowerAddress, uint256 cap) external onlyOwner {\n        if (borrowerAddress != address(dnGmxJuniorVault) && borrowerAddress != address(leveragePool))\n            revert InvalidBorrowerAddress();\n\n        if (IBorrower(borrowerAddress).getUsdcBorrowed() >= cap) revert InvalidCapUpdate();\n\n        borrowCaps[borrowerAddress] = cap;\n        // give allowance to borrower to pull whenever required\n        aUsdc.approve(borrowerAddress, cap);\n\n        emit BorrowCapUpdated(borrowerAddress, cap);\n    }\n\n    /// @notice updates fee split strategy\n    /// @notice this determines how eth rewards should be split between junior and senior tranche\n    /// @notice basis the utilization of senior tranche\n    /// @param _feeStrategy: new fee strategy\n    function updateFeeStrategyParams(FeeSplitStrategy.Info calldata _feeStrategy) external onlyOwner {\n        feeStrategy = _feeStrategy;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PROTOCOL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice borrow aUSDC\n    /// @dev harvests fees from junior tranche since utilization changes\n    /// @param amount amount of aUSDC to transfer from senior tranche to borrower\n    function borrow(uint256 amount) external onlyBorrower {\n        // revert on invalid borrow amount\n        if (amount == 0 || amount > availableBorrow(msg.sender)) revert InvalidBorrowAmount();\n\n        // lazily harvest fees (harvest would return early if not enough rewards accrued)\n        dnGmxJuniorVault.harvestFees();\n\n        // transfers aUsdc to borrower\n        // but doesn't reduce totalAssets of vault since borrwed amounts are factored in\n        aUsdc.transfer(msg.sender, amount);\n    }\n\n    /// @notice repay aUSDC\n    /// @dev harvests fees from junior tranche since utilization changes\n    /// @param amount amount of aUSDC to transfer from borrower to senior tranche\n    function repay(uint256 amount) external onlyBorrower {\n        dnGmxJuniorVault.harvestFees();\n\n        // borrower should have given allowance to spend aUsdc\n        aUsdc.transferFrom(msg.sender, address(this), amount);\n    }\n\n    /// @notice deposit usdc\n    /// @dev harvests fees from junior tranche since utilization changes\n    /// @param amount amount of usdc to be deposited\n    /// @param to receiver of shares\n    /// @return shares minted to receiver\n    function deposit(uint256 amount, address to)\n        public\n        virtual\n        override(IERC4626, ERC4626Upgradeable)\n        whenNotPaused\n        returns (uint256 shares)\n    {\n        // harvesting fees so asset to shares conversion rate is not stale\n        dnGmxJuniorVault.harvestFees();\n        shares = super.deposit(amount, to);\n    }\n\n    /// @notice deposit usdc\n    /// @dev harvests fees from junior tranche since utilization changes\n    /// @param shares amount of shares to be minted\n    /// @param to receiver of shares\n    /// @return amount of asset used to mint shares\n    function mint(uint256 shares, address to)\n        public\n        virtual\n        override(IERC4626, ERC4626Upgradeable)\n        whenNotPaused\n        returns (uint256 amount)\n    {\n        // harvesting fees so asset to shares conversion rate is not stale\n        dnGmxJuniorVault.harvestFees();\n        amount = super.mint(shares, to);\n    }\n\n    /// @notice withdraw usdc\n    /// @dev harvests fees from junior tranche since utilization changes\n    /// @param assets amount of usdc to be transferred\n    /// @param receiver receiver of assets\n    /// @param owner owner of the shares to be burnt\n    /// @return shares amount of shares burned\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override(IERC4626, ERC4626Upgradeable) whenNotPaused returns (uint256 shares) {\n        // harvesting fees so asset to shares conversion rate is not stale\n        dnGmxJuniorVault.harvestFees();\n        shares = super.withdraw(assets, receiver, owner);\n    }\n\n    /// @notice withdraw usdc\n    /// @dev harvests fees from junior tranche since utilization changes\n    /// @param shares amount of shares to be burnt\n    /// @param receiver receiver of assets\n    /// @param owner owner of the shares to be burnt\n    /// @return assets amount of assets received by receiver\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override(IERC4626, ERC4626Upgradeable) whenNotPaused returns (uint256 assets) {\n        // harvesting fees so asset to shares conversion rate is not stale\n        dnGmxJuniorVault.harvestFees();\n        assets = super.redeem(shares, receiver, owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC4626 HOOKS OVERRIDE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice converts aUSDC to USDC before assets are withdrawn to receiver\n    /// @notice also check if the maxUtilization is not being breached (reverts if it does)\n    function beforeWithdraw(\n        uint256 assets,\n        uint256,\n        address\n    ) internal override {\n        /// @dev withdrawal will fail if the utilization goes above maxUtilization value due to a withdrawal\n        // totalUsdcBorrowed will reduce when borrower (junior vault) repays\n        if (totalUsdcBorrowed() > ((totalAssets() - assets) * maxUtilizationBps) / MAX_BPS)\n            revert MaxUtilizationBreached();\n\n        // take out required assets from aave lending pool\n        pool.withdraw(address(asset), assets, address(this));\n    }\n\n    /// @notice converts USDC to aUSDC after assets are taken from depositor\n    /// @notice also check if the depositCap is not being breached (reverts if it does)\n    function afterDeposit(\n        uint256 assets,\n        uint256,\n        address\n    ) internal override {\n        // assets are not counted in 'totalAssets' yet because they are not supplied to aave pool\n        if ((totalAssets() + assets) > depositCap) revert DepositCapExceeded();\n\n        // usdc is direclty supplied to lending pool and earns interest\n        // and hence increasing totalAssets of the vault\n        pool.supply(address(asset), assets, address(this), 0);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice returns price of a single asset token in X128\n    /// @dev only for external / frontend use, not used within contract\n    /// @return Q128 price of asset\n    function getPriceX128() public view returns (uint256) {\n        uint256 price = oracle.getAssetPrice(address(asset));\n\n        // @dev aave returns from same source as chainlink (which is 8 decimals)\n        // usdc decimals - (chainlink decimals + asset decimals) = 6-8-6 = 8\n        return price.mulDiv(1 << 128, 1e8);\n    }\n\n    /// @notice returns overall vault market value for the vault by valueing the underlying assets\n    /// @return Q128 price of asset\n    function getVaultMarketValue() public view returns (uint256) {\n        // use aave's oracle to get price of usdc\n        uint256 price = oracle.getAssetPrice(address(asset));\n\n        // chainlink returns USD denomiated oracles in 1e8\n        return totalAssets().mulDiv(price, 1e8);\n    }\n\n    /// @notice query amount of assset borrwed by all borrowers combined\n    /// @return usdcBorrowed total usdc borrowed\n    function totalUsdcBorrowed() public view returns (uint256 usdcBorrowed) {\n        /// @dev only call getUsdcBorrowed if address is set\n        if (address(leveragePool) != address(0)) usdcBorrowed += leveragePool.getUsdcBorrowed();\n        if (address(dnGmxJuniorVault) != address(0)) usdcBorrowed += dnGmxJuniorVault.getUsdcBorrowed();\n    }\n\n    /// @notice returns eth reward split rate basis utilization in E30\n    /// @return feeSplitRate part that should go to the senior tranche and remaining to junior tranche\n    function getEthRewardsSplitRate() public view returns (uint256 feeSplitRate) {\n        // feeSplitRate would adjust automatically depending upon utilization\n        feeSplitRate = feeStrategy.calculateFeeSplit(aUsdc.balanceOf(address(this)), totalUsdcBorrowed());\n    }\n\n    /// @notice return the available borrow amount for a given borrower address\n    /// @param borrower allowed borrower address\n    /// @return availableAUsdc max aUsdc which given borrower can borrow\n    function availableBorrow(address borrower) public view returns (uint256 availableAUsdc) {\n        uint256 availableBasisCap = borrowCaps[borrower] - IBorrower(borrower).getUsdcBorrowed();\n        uint256 availableBasisBalance = aUsdc.balanceOf(address(this));\n\n        availableAUsdc = availableBasisCap < availableBasisBalance ? availableBasisCap : availableBasisBalance;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       ERC4626 GETTERS OVERRIDES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice decimals of vault shares (= usdc decimals)\n    /// @dev overriding because default decimals are 18\n    /// @return decimals (6)\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    /// @notice derive total assets managed by senior vault\n    /// @return amount total usdc under management\n    function totalAssets() public view override(IERC4626, ERC4626Upgradeable) returns (uint256 amount) {\n        amount = aUsdc.balanceOf(address(this));\n        amount += totalUsdcBorrowed();\n    }\n\n    /// @notice max no. of assets which a user can deposit in single call\n    /// @return max no. of assets\n    function maxDeposit(address) public view override(IERC4626, ERC4626Upgradeable) returns (uint256) {\n        uint256 cap = depositCap;\n        uint256 total = totalAssets();\n\n        // if cap is not reached, user can deposit the difference\n        // otherwise, user can deposit 0 assets\n        return total < cap ? cap - total : 0;\n    }\n\n    /// @notice max no. of shares which a user can mint in single call\n    /// @return max no. of shares\n    function maxMint(address) public view override(IERC4626, ERC4626Upgradeable) returns (uint256) {\n        return convertToShares(maxDeposit(address(0)));\n    }\n\n    /// @notice max no. of assets which a user can withdraw in single call\n    /// @dev checks the max amount basis user balance and maxUtilizationBps and gives the minimum of the two\n    /// @param owner address whose maximum withdrawable assets needs to be computed\n    /// @return max no. of assets\n    function maxWithdraw(address owner) public view override(IERC4626, ERC4626Upgradeable) returns (uint256) {\n        uint256 total = totalAssets();\n        uint256 borrowed = totalUsdcBorrowed();\n\n        // checks the max withdrawable amount until which the vault remains below max utilization\n        uint256 maxAvailable = (total * maxUtilizationBps) / MAX_BPS;\n        maxAvailable = borrowed < maxAvailable ? maxAvailable - borrowed : 0;\n\n        // checks the balance of the user\n        uint256 maxOfUser = convertToAssets(balanceOf(owner));\n\n        // user can withdraw all assets (of owned shares) by if vault has enough\n        // else, user can withdraw whatever is left with vault (non-borrowed)\n        return maxOfUser < maxAvailable ? maxOfUser : maxAvailable;\n    }\n\n    /// @notice max no. of shares which a user can burn in single call\n    /// @param owner address whose maximum redeemable shares needs to be computed\n    /// @return max no. of shares\n    function maxRedeem(address owner) public view override(IERC4626, ERC4626Upgradeable) returns (uint256) {\n        return convertToShares(maxWithdraw(owner));\n    }\n}"
    }
  ]
}