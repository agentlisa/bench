{
  "Title": "[M-02] `PostTxProcessing` can revert user transactions not interacting with Turnstile",
  "Content": "\n<https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L63>\n\n<https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L75>\n\n<https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L81>\n\n<https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L88>\n\n### Impact\n\nAny transaction, even those that don't interact with the Turnstile contract, can be reverted by the `PostTxProcessing` hook if there was a CSR specific error. Thus, the CSR module can impair the behavior of smart contracts not related to the module.\n\n### Proof of Concept\n\nThe `PostTxProcessing` is used by the keeper to register contracts with the CSR module and distribute gas fees to registered contracts ([evm_hooks.go#L41](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L41)). The hook can return an error while handling CSR specific operations:\n\n*   Reading a CSR object from the storage ([evm_hooks.go#L61-L64](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L61-L64));\n*   Sending gas fees to the module ([evm_hooks.go#L73-L76](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L73-L76));\n*   Reading the address of Turnstile ([evm_hooks.go#L79-L82](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L79-L82));\n*   Calling the `distributeFees` function ([evm_hooks.go#L85-L89](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L85-L89)).\n\nIn case any of these operations fails, the whole transaction will be reverted ([state_transition.go#L272-L278](https://github.com/evmos/ethermint/blob/37e394f309808d911b6c7d7eaf1e0c7a9cc1c70b/x/evm/keeper/state_transition.go#L272-L278)):\n\n```go\nif err = k.PostTxProcessing(tmpCtx, msg, receipt); err != nil {\n  // If hooks return error, revert the whole tx.\n  res.VmError = types.ErrPostTxProcessing.Error()\n  k.Logger(ctx).Error(\"tx post processing failed\", \"error\", err)\n```\n\nOne example of when the hook can revert in normal circumstances is when the fees to be distributed are 0, which can be caused by a combination of low gas usage of a transaction, a small CSR share, and rounding (the fees are a share of the gas spent to execute a transaction: [evm_hooks.go#L66-L70](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L66-L70)). In this case, the `distributeFees` call will revert and will cause the whole transaction to be reverted as well ([evm_hooks.go#L86-L89](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L86-L89), [Turnstile.sol#L149](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/CIP-001/src/Turnstile.sol#L149)).\n\n### Recommended Mitigation Steps\n\nIn the `PostTxProcessing` hook, consider always logging errors and returning `nil` to avoid impairing user transactions. Also, consider logging a fatal error and exiting when the module cannot function due to an error.\n\n**[tkkwon1998 (Canto) confirmed and commented](https://github.com/code-423n4/2022-11-canto-findings/issues/94#issuecomment-1356623498):**\n > Error should not be returned, but rather logged and continued to an eventual nil return.\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-11-canto",
  "Code": [
    {
      "filename": "Canto/x/csr/keeper/evm_hooks.go",
      "content": "package keeper\n\nimport (\n\t\"math/big\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v2/contracts\"\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\tevmtypes \"github.com/evmos/ethermint/x/evm/types\"\n)\n\n// Hooks wrapper struct for fees keeper\ntype Hooks struct {\n\tk Keeper\n}\n\nvar (\n\t_                 evmtypes.EvmHooks = Hooks{}\n\tTurnstileContract abi.ABI           = contracts.TurnstileContract.ABI\n)\n\n// Hooks return the wrapper hooks struct for the Keeper\nfunc (k Keeper) Hooks() Hooks {\n\treturn Hooks{k}\n}\n\n// The PostTxProcessing hook implements EvmHooks.PostTxProcessing. The EVM hook allows\n// users to utilize the Turnstile smart contract to register and assign smart contracts\n// to a CSR NFT + distribute transaction fees for contracts that are already registered\n// to some NFT. After each successful EVM transaction, the PostTxProcessing hook will\n// check if any of the events emitted in the tx originate from the Turnstile address.\n// If some event does exist, the event handler will process and update state accordingly.\n// At the very end of the hook, the hook will check if the To address in the tx belongs\n// to any NFT currently in state. If so, the fees will be split and distributed to the\n// Turnstile Address / NFT.\nfunc (h Hooks) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n\t// Check if the csr module has been enabled\n\tparams := h.k.GetParams(ctx)\n\tif !params.EnableCsr {\n\t\treturn nil\n\t}\n\n\t// Check and process turnstile events if applicable\n\th.processEvents(ctx, receipt)\n\n\tcontract := msg.To()\n\tif contract == nil {\n\t\treturn nil\n\t}\n\n\tnftID, foundNFT := h.k.GetNFTByContract(ctx, contract.String())\n\tif !foundNFT {\n\t\treturn nil\n\t}\n\n\tcsr, found := h.k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentCSR, \"EVMHook::PostTxProcessing the NFT ID was found but the CSR was not: %d\", nftID)\n\t}\n\n\t// Calculate fees to be distributed = intFloor(GasUsed * GasPrice * csrShares)\n\tfee := sdk.NewIntFromUint64(receipt.GasUsed).Mul(sdk.NewIntFromBigInt(msg.GasPrice()))\n\tcsrFee := sdk.NewDecFromInt(fee).Mul(params.CsrShares).TruncateInt()\n\tevmDenom := h.k.evmKeeper.GetParams(ctx).EvmDenom\n\tcsrFees := sdk.Coins{{Denom: evmDenom, Amount: csrFee}}\n\n\t// Send fees from fee collector to module account before distribution\n\terr := h.k.bankKeeper.SendCoinsFromModuleToModule(ctx, h.k.FeeCollectorName, types.ModuleName, csrFees)\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from fee collector to module acount, %d\", err)\n\t}\n\n\t// Get the turnstile which will receive funds for tx fees\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\")\n\t}\n\n\t// Distribute fees to turnstile contract by NFT ID distributeFees(amount, nftID)\n\tamount := csrFee.BigInt()\n\t_, err = h.k.CallMethod(ctx, \"distributeFees\", contracts.TurnstileContract, types.ModuleAddress, &turnstileAddress, amount, new(big.Int).SetUint64(nftID))\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from module account to turnstile, %d\", err)\n\t}\n\n\t// Update metrics on the CSR obj\n\tcsr.Txs += 1\n\tcsr.Revenue = csr.Revenue.Add(csrFee)\n\n\t// Store updated CSR\n\th.k.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\nfunc (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {\n\t// Get the turnstile address from which state transition events are emitted\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\tpanic(sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\"))\n\t}\n\n\tfor _, log := range receipt.Logs {\n\t\tif len(log.Topics) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Only process events that originate from the Turnstile contract\n\t\teventID := log.Topics[0]\n\t\tif log.Address == turnstileAddress {\n\t\t\tevent, err := TurnstileContract.EventByID(eventID)\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// switch and process based on the turnstile event type\n\t\t\tswitch event.Name {\n\t\t\tcase types.TurnstileEventRegister:\n\t\t\t\terr = h.k.RegisterEvent(ctx, log.Data)\n\t\t\tcase types.TurnstileEventUpdate:\n\t\t\t\terr = h.k.UpdateEvent(ctx, log.Data)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/evm_hooks.go",
      "content": "package keeper\n\nimport (\n\t\"math/big\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v2/contracts\"\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\tevmtypes \"github.com/evmos/ethermint/x/evm/types\"\n)\n\n// Hooks wrapper struct for fees keeper\ntype Hooks struct {\n\tk Keeper\n}\n\nvar (\n\t_                 evmtypes.EvmHooks = Hooks{}\n\tTurnstileContract abi.ABI           = contracts.TurnstileContract.ABI\n)\n\n// Hooks return the wrapper hooks struct for the Keeper\nfunc (k Keeper) Hooks() Hooks {\n\treturn Hooks{k}\n}\n\n// The PostTxProcessing hook implements EvmHooks.PostTxProcessing. The EVM hook allows\n// users to utilize the Turnstile smart contract to register and assign smart contracts\n// to a CSR NFT + distribute transaction fees for contracts that are already registered\n// to some NFT. After each successful EVM transaction, the PostTxProcessing hook will\n// check if any of the events emitted in the tx originate from the Turnstile address.\n// If some event does exist, the event handler will process and update state accordingly.\n// At the very end of the hook, the hook will check if the To address in the tx belongs\n// to any NFT currently in state. If so, the fees will be split and distributed to the\n// Turnstile Address / NFT.\nfunc (h Hooks) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n\t// Check if the csr module has been enabled\n\tparams := h.k.GetParams(ctx)\n\tif !params.EnableCsr {\n\t\treturn nil\n\t}\n\n\t// Check and process turnstile events if applicable\n\th.processEvents(ctx, receipt)\n\n\tcontract := msg.To()\n\tif contract == nil {\n\t\treturn nil\n\t}\n\n\tnftID, foundNFT := h.k.GetNFTByContract(ctx, contract.String())\n\tif !foundNFT {\n\t\treturn nil\n\t}\n\n\tcsr, found := h.k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentCSR, \"EVMHook::PostTxProcessing the NFT ID was found but the CSR was not: %d\", nftID)\n\t}\n\n\t// Calculate fees to be distributed = intFloor(GasUsed * GasPrice * csrShares)\n\tfee := sdk.NewIntFromUint64(receipt.GasUsed).Mul(sdk.NewIntFromBigInt(msg.GasPrice()))\n\tcsrFee := sdk.NewDecFromInt(fee).Mul(params.CsrShares).TruncateInt()\n\tevmDenom := h.k.evmKeeper.GetParams(ctx).EvmDenom\n\tcsrFees := sdk.Coins{{Denom: evmDenom, Amount: csrFee}}\n\n\t// Send fees from fee collector to module account before distribution\n\terr := h.k.bankKeeper.SendCoinsFromModuleToModule(ctx, h.k.FeeCollectorName, types.ModuleName, csrFees)\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from fee collector to module acount, %d\", err)\n\t}\n\n\t// Get the turnstile which will receive funds for tx fees\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\")\n\t}\n\n\t// Distribute fees to turnstile contract by NFT ID distributeFees(amount, nftID)\n\tamount := csrFee.BigInt()\n\t_, err = h.k.CallMethod(ctx, \"distributeFees\", contracts.TurnstileContract, types.ModuleAddress, &turnstileAddress, amount, new(big.Int).SetUint64(nftID))\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from module account to turnstile, %d\", err)\n\t}\n\n\t// Update metrics on the CSR obj\n\tcsr.Txs += 1\n\tcsr.Revenue = csr.Revenue.Add(csrFee)\n\n\t// Store updated CSR\n\th.k.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\nfunc (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {\n\t// Get the turnstile address from which state transition events are emitted\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\tpanic(sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\"))\n\t}\n\n\tfor _, log := range receipt.Logs {\n\t\tif len(log.Topics) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Only process events that originate from the Turnstile contract\n\t\teventID := log.Topics[0]\n\t\tif log.Address == turnstileAddress {\n\t\t\tevent, err := TurnstileContract.EventByID(eventID)\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// switch and process based on the turnstile event type\n\t\t\tswitch event.Name {\n\t\t\tcase types.TurnstileEventRegister:\n\t\t\t\terr = h.k.RegisterEvent(ctx, log.Data)\n\t\t\tcase types.TurnstileEventUpdate:\n\t\t\t\terr = h.k.UpdateEvent(ctx, log.Data)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/evm_hooks.go",
      "content": "package keeper\n\nimport (\n\t\"math/big\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v2/contracts\"\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\tevmtypes \"github.com/evmos/ethermint/x/evm/types\"\n)\n\n// Hooks wrapper struct for fees keeper\ntype Hooks struct {\n\tk Keeper\n}\n\nvar (\n\t_                 evmtypes.EvmHooks = Hooks{}\n\tTurnstileContract abi.ABI           = contracts.TurnstileContract.ABI\n)\n\n// Hooks return the wrapper hooks struct for the Keeper\nfunc (k Keeper) Hooks() Hooks {\n\treturn Hooks{k}\n}\n\n// The PostTxProcessing hook implements EvmHooks.PostTxProcessing. The EVM hook allows\n// users to utilize the Turnstile smart contract to register and assign smart contracts\n// to a CSR NFT + distribute transaction fees for contracts that are already registered\n// to some NFT. After each successful EVM transaction, the PostTxProcessing hook will\n// check if any of the events emitted in the tx originate from the Turnstile address.\n// If some event does exist, the event handler will process and update state accordingly.\n// At the very end of the hook, the hook will check if the To address in the tx belongs\n// to any NFT currently in state. If so, the fees will be split and distributed to the\n// Turnstile Address / NFT.\nfunc (h Hooks) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n\t// Check if the csr module has been enabled\n\tparams := h.k.GetParams(ctx)\n\tif !params.EnableCsr {\n\t\treturn nil\n\t}\n\n\t// Check and process turnstile events if applicable\n\th.processEvents(ctx, receipt)\n\n\tcontract := msg.To()\n\tif contract == nil {\n\t\treturn nil\n\t}\n\n\tnftID, foundNFT := h.k.GetNFTByContract(ctx, contract.String())\n\tif !foundNFT {\n\t\treturn nil\n\t}\n\n\tcsr, found := h.k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentCSR, \"EVMHook::PostTxProcessing the NFT ID was found but the CSR was not: %d\", nftID)\n\t}\n\n\t// Calculate fees to be distributed = intFloor(GasUsed * GasPrice * csrShares)\n\tfee := sdk.NewIntFromUint64(receipt.GasUsed).Mul(sdk.NewIntFromBigInt(msg.GasPrice()))\n\tcsrFee := sdk.NewDecFromInt(fee).Mul(params.CsrShares).TruncateInt()\n\tevmDenom := h.k.evmKeeper.GetParams(ctx).EvmDenom\n\tcsrFees := sdk.Coins{{Denom: evmDenom, Amount: csrFee}}\n\n\t// Send fees from fee collector to module account before distribution\n\terr := h.k.bankKeeper.SendCoinsFromModuleToModule(ctx, h.k.FeeCollectorName, types.ModuleName, csrFees)\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from fee collector to module acount, %d\", err)\n\t}\n\n\t// Get the turnstile which will receive funds for tx fees\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\")\n\t}\n\n\t// Distribute fees to turnstile contract by NFT ID distributeFees(amount, nftID)\n\tamount := csrFee.BigInt()\n\t_, err = h.k.CallMethod(ctx, \"distributeFees\", contracts.TurnstileContract, types.ModuleAddress, &turnstileAddress, amount, new(big.Int).SetUint64(nftID))\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from module account to turnstile, %d\", err)\n\t}\n\n\t// Update metrics on the CSR obj\n\tcsr.Txs += 1\n\tcsr.Revenue = csr.Revenue.Add(csrFee)\n\n\t// Store updated CSR\n\th.k.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\nfunc (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {\n\t// Get the turnstile address from which state transition events are emitted\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\tpanic(sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\"))\n\t}\n\n\tfor _, log := range receipt.Logs {\n\t\tif len(log.Topics) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Only process events that originate from the Turnstile contract\n\t\teventID := log.Topics[0]\n\t\tif log.Address == turnstileAddress {\n\t\t\tevent, err := TurnstileContract.EventByID(eventID)\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// switch and process based on the turnstile event type\n\t\t\tswitch event.Name {\n\t\t\tcase types.TurnstileEventRegister:\n\t\t\t\terr = h.k.RegisterEvent(ctx, log.Data)\n\t\t\tcase types.TurnstileEventUpdate:\n\t\t\t\terr = h.k.UpdateEvent(ctx, log.Data)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/evm_hooks.go",
      "content": "package keeper\n\nimport (\n\t\"math/big\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v2/contracts\"\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\tevmtypes \"github.com/evmos/ethermint/x/evm/types\"\n)\n\n// Hooks wrapper struct for fees keeper\ntype Hooks struct {\n\tk Keeper\n}\n\nvar (\n\t_                 evmtypes.EvmHooks = Hooks{}\n\tTurnstileContract abi.ABI           = contracts.TurnstileContract.ABI\n)\n\n// Hooks return the wrapper hooks struct for the Keeper\nfunc (k Keeper) Hooks() Hooks {\n\treturn Hooks{k}\n}\n\n// The PostTxProcessing hook implements EvmHooks.PostTxProcessing. The EVM hook allows\n// users to utilize the Turnstile smart contract to register and assign smart contracts\n// to a CSR NFT + distribute transaction fees for contracts that are already registered\n// to some NFT. After each successful EVM transaction, the PostTxProcessing hook will\n// check if any of the events emitted in the tx originate from the Turnstile address.\n// If some event does exist, the event handler will process and update state accordingly.\n// At the very end of the hook, the hook will check if the To address in the tx belongs\n// to any NFT currently in state. If so, the fees will be split and distributed to the\n// Turnstile Address / NFT.\nfunc (h Hooks) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n\t// Check if the csr module has been enabled\n\tparams := h.k.GetParams(ctx)\n\tif !params.EnableCsr {\n\t\treturn nil\n\t}\n\n\t// Check and process turnstile events if applicable\n\th.processEvents(ctx, receipt)\n\n\tcontract := msg.To()\n\tif contract == nil {\n\t\treturn nil\n\t}\n\n\tnftID, foundNFT := h.k.GetNFTByContract(ctx, contract.String())\n\tif !foundNFT {\n\t\treturn nil\n\t}\n\n\tcsr, found := h.k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentCSR, \"EVMHook::PostTxProcessing the NFT ID was found but the CSR was not: %d\", nftID)\n\t}\n\n\t// Calculate fees to be distributed = intFloor(GasUsed * GasPrice * csrShares)\n\tfee := sdk.NewIntFromUint64(receipt.GasUsed).Mul(sdk.NewIntFromBigInt(msg.GasPrice()))\n\tcsrFee := sdk.NewDecFromInt(fee).Mul(params.CsrShares).TruncateInt()\n\tevmDenom := h.k.evmKeeper.GetParams(ctx).EvmDenom\n\tcsrFees := sdk.Coins{{Denom: evmDenom, Amount: csrFee}}\n\n\t// Send fees from fee collector to module account before distribution\n\terr := h.k.bankKeeper.SendCoinsFromModuleToModule(ctx, h.k.FeeCollectorName, types.ModuleName, csrFees)\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from fee collector to module acount, %d\", err)\n\t}\n\n\t// Get the turnstile which will receive funds for tx fees\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\")\n\t}\n\n\t// Distribute fees to turnstile contract by NFT ID distributeFees(amount, nftID)\n\tamount := csrFee.BigInt()\n\t_, err = h.k.CallMethod(ctx, \"distributeFees\", contracts.TurnstileContract, types.ModuleAddress, &turnstileAddress, amount, new(big.Int).SetUint64(nftID))\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from module account to turnstile, %d\", err)\n\t}\n\n\t// Update metrics on the CSR obj\n\tcsr.Txs += 1\n\tcsr.Revenue = csr.Revenue.Add(csrFee)\n\n\t// Store updated CSR\n\th.k.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\nfunc (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {\n\t// Get the turnstile address from which state transition events are emitted\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\tpanic(sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\"))\n\t}\n\n\tfor _, log := range receipt.Logs {\n\t\tif len(log.Topics) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Only process events that originate from the Turnstile contract\n\t\teventID := log.Topics[0]\n\t\tif log.Address == turnstileAddress {\n\t\t\tevent, err := TurnstileContract.EventByID(eventID)\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// switch and process based on the turnstile event type\n\t\t\tswitch event.Name {\n\t\t\tcase types.TurnstileEventRegister:\n\t\t\t\terr = h.k.RegisterEvent(ctx, log.Data)\n\t\t\tcase types.TurnstileEventUpdate:\n\t\t\t\terr = h.k.UpdateEvent(ctx, log.Data)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/evm_hooks.go",
      "content": "package keeper\n\nimport (\n\t\"math/big\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v2/contracts\"\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\tevmtypes \"github.com/evmos/ethermint/x/evm/types\"\n)\n\n// Hooks wrapper struct for fees keeper\ntype Hooks struct {\n\tk Keeper\n}\n\nvar (\n\t_                 evmtypes.EvmHooks = Hooks{}\n\tTurnstileContract abi.ABI           = contracts.TurnstileContract.ABI\n)\n\n// Hooks return the wrapper hooks struct for the Keeper\nfunc (k Keeper) Hooks() Hooks {\n\treturn Hooks{k}\n}\n\n// The PostTxProcessing hook implements EvmHooks.PostTxProcessing. The EVM hook allows\n// users to utilize the Turnstile smart contract to register and assign smart contracts\n// to a CSR NFT + distribute transaction fees for contracts that are already registered\n// to some NFT. After each successful EVM transaction, the PostTxProcessing hook will\n// check if any of the events emitted in the tx originate from the Turnstile address.\n// If some event does exist, the event handler will process and update state accordingly.\n// At the very end of the hook, the hook will check if the To address in the tx belongs\n// to any NFT currently in state. If so, the fees will be split and distributed to the\n// Turnstile Address / NFT.\nfunc (h Hooks) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n\t// Check if the csr module has been enabled\n\tparams := h.k.GetParams(ctx)\n\tif !params.EnableCsr {\n\t\treturn nil\n\t}\n\n\t// Check and process turnstile events if applicable\n\th.processEvents(ctx, receipt)\n\n\tcontract := msg.To()\n\tif contract == nil {\n\t\treturn nil\n\t}\n\n\tnftID, foundNFT := h.k.GetNFTByContract(ctx, contract.String())\n\tif !foundNFT {\n\t\treturn nil\n\t}\n\n\tcsr, found := h.k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentCSR, \"EVMHook::PostTxProcessing the NFT ID was found but the CSR was not: %d\", nftID)\n\t}\n\n\t// Calculate fees to be distributed = intFloor(GasUsed * GasPrice * csrShares)\n\tfee := sdk.NewIntFromUint64(receipt.GasUsed).Mul(sdk.NewIntFromBigInt(msg.GasPrice()))\n\tcsrFee := sdk.NewDecFromInt(fee).Mul(params.CsrShares).TruncateInt()\n\tevmDenom := h.k.evmKeeper.GetParams(ctx).EvmDenom\n\tcsrFees := sdk.Coins{{Denom: evmDenom, Amount: csrFee}}\n\n\t// Send fees from fee collector to module account before distribution\n\terr := h.k.bankKeeper.SendCoinsFromModuleToModule(ctx, h.k.FeeCollectorName, types.ModuleName, csrFees)\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from fee collector to module acount, %d\", err)\n\t}\n\n\t// Get the turnstile which will receive funds for tx fees\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\")\n\t}\n\n\t// Distribute fees to turnstile contract by NFT ID distributeFees(amount, nftID)\n\tamount := csrFee.BigInt()\n\t_, err = h.k.CallMethod(ctx, \"distributeFees\", contracts.TurnstileContract, types.ModuleAddress, &turnstileAddress, amount, new(big.Int).SetUint64(nftID))\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from module account to turnstile, %d\", err)\n\t}\n\n\t// Update metrics on the CSR obj\n\tcsr.Txs += 1\n\tcsr.Revenue = csr.Revenue.Add(csrFee)\n\n\t// Store updated CSR\n\th.k.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\nfunc (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {\n\t// Get the turnstile address from which state transition events are emitted\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\tpanic(sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\"))\n\t}\n\n\tfor _, log := range receipt.Logs {\n\t\tif len(log.Topics) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Only process events that originate from the Turnstile contract\n\t\teventID := log.Topics[0]\n\t\tif log.Address == turnstileAddress {\n\t\t\tevent, err := TurnstileContract.EventByID(eventID)\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// switch and process based on the turnstile event type\n\t\t\tswitch event.Name {\n\t\t\tcase types.TurnstileEventRegister:\n\t\t\t\terr = h.k.RegisterEvent(ctx, log.Data)\n\t\t\tcase types.TurnstileEventUpdate:\n\t\t\t\terr = h.k.UpdateEvent(ctx, log.Data)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/evm_hooks.go",
      "content": "package keeper\n\nimport (\n\t\"math/big\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v2/contracts\"\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\tevmtypes \"github.com/evmos/ethermint/x/evm/types\"\n)\n\n// Hooks wrapper struct for fees keeper\ntype Hooks struct {\n\tk Keeper\n}\n\nvar (\n\t_                 evmtypes.EvmHooks = Hooks{}\n\tTurnstileContract abi.ABI           = contracts.TurnstileContract.ABI\n)\n\n// Hooks return the wrapper hooks struct for the Keeper\nfunc (k Keeper) Hooks() Hooks {\n\treturn Hooks{k}\n}\n\n// The PostTxProcessing hook implements EvmHooks.PostTxProcessing. The EVM hook allows\n// users to utilize the Turnstile smart contract to register and assign smart contracts\n// to a CSR NFT + distribute transaction fees for contracts that are already registered\n// to some NFT. After each successful EVM transaction, the PostTxProcessing hook will\n// check if any of the events emitted in the tx originate from the Turnstile address.\n// If some event does exist, the event handler will process and update state accordingly.\n// At the very end of the hook, the hook will check if the To address in the tx belongs\n// to any NFT currently in state. If so, the fees will be split and distributed to the\n// Turnstile Address / NFT.\nfunc (h Hooks) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n\t// Check if the csr module has been enabled\n\tparams := h.k.GetParams(ctx)\n\tif !params.EnableCsr {\n\t\treturn nil\n\t}\n\n\t// Check and process turnstile events if applicable\n\th.processEvents(ctx, receipt)\n\n\tcontract := msg.To()\n\tif contract == nil {\n\t\treturn nil\n\t}\n\n\tnftID, foundNFT := h.k.GetNFTByContract(ctx, contract.String())\n\tif !foundNFT {\n\t\treturn nil\n\t}\n\n\tcsr, found := h.k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentCSR, \"EVMHook::PostTxProcessing the NFT ID was found but the CSR was not: %d\", nftID)\n\t}\n\n\t// Calculate fees to be distributed = intFloor(GasUsed * GasPrice * csrShares)\n\tfee := sdk.NewIntFromUint64(receipt.GasUsed).Mul(sdk.NewIntFromBigInt(msg.GasPrice()))\n\tcsrFee := sdk.NewDecFromInt(fee).Mul(params.CsrShares).TruncateInt()\n\tevmDenom := h.k.evmKeeper.GetParams(ctx).EvmDenom\n\tcsrFees := sdk.Coins{{Denom: evmDenom, Amount: csrFee}}\n\n\t// Send fees from fee collector to module account before distribution\n\terr := h.k.bankKeeper.SendCoinsFromModuleToModule(ctx, h.k.FeeCollectorName, types.ModuleName, csrFees)\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from fee collector to module acount, %d\", err)\n\t}\n\n\t// Get the turnstile which will receive funds for tx fees\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\")\n\t}\n\n\t// Distribute fees to turnstile contract by NFT ID distributeFees(amount, nftID)\n\tamount := csrFee.BigInt()\n\t_, err = h.k.CallMethod(ctx, \"distributeFees\", contracts.TurnstileContract, types.ModuleAddress, &turnstileAddress, amount, new(big.Int).SetUint64(nftID))\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from module account to turnstile, %d\", err)\n\t}\n\n\t// Update metrics on the CSR obj\n\tcsr.Txs += 1\n\tcsr.Revenue = csr.Revenue.Add(csrFee)\n\n\t// Store updated CSR\n\th.k.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\nfunc (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {\n\t// Get the turnstile address from which state transition events are emitted\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\tpanic(sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\"))\n\t}\n\n\tfor _, log := range receipt.Logs {\n\t\tif len(log.Topics) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Only process events that originate from the Turnstile contract\n\t\teventID := log.Topics[0]\n\t\tif log.Address == turnstileAddress {\n\t\t\tevent, err := TurnstileContract.EventByID(eventID)\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// switch and process based on the turnstile event type\n\t\t\tswitch event.Name {\n\t\t\tcase types.TurnstileEventRegister:\n\t\t\t\terr = h.k.RegisterEvent(ctx, log.Data)\n\t\t\tcase types.TurnstileEventUpdate:\n\t\t\t\terr = h.k.UpdateEvent(ctx, log.Data)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/evm_hooks.go",
      "content": "package keeper\n\nimport (\n\t\"math/big\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v2/contracts\"\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\tevmtypes \"github.com/evmos/ethermint/x/evm/types\"\n)\n\n// Hooks wrapper struct for fees keeper\ntype Hooks struct {\n\tk Keeper\n}\n\nvar (\n\t_                 evmtypes.EvmHooks = Hooks{}\n\tTurnstileContract abi.ABI           = contracts.TurnstileContract.ABI\n)\n\n// Hooks return the wrapper hooks struct for the Keeper\nfunc (k Keeper) Hooks() Hooks {\n\treturn Hooks{k}\n}\n\n// The PostTxProcessing hook implements EvmHooks.PostTxProcessing. The EVM hook allows\n// users to utilize the Turnstile smart contract to register and assign smart contracts\n// to a CSR NFT + distribute transaction fees for contracts that are already registered\n// to some NFT. After each successful EVM transaction, the PostTxProcessing hook will\n// check if any of the events emitted in the tx originate from the Turnstile address.\n// If some event does exist, the event handler will process and update state accordingly.\n// At the very end of the hook, the hook will check if the To address in the tx belongs\n// to any NFT currently in state. If so, the fees will be split and distributed to the\n// Turnstile Address / NFT.\nfunc (h Hooks) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n\t// Check if the csr module has been enabled\n\tparams := h.k.GetParams(ctx)\n\tif !params.EnableCsr {\n\t\treturn nil\n\t}\n\n\t// Check and process turnstile events if applicable\n\th.processEvents(ctx, receipt)\n\n\tcontract := msg.To()\n\tif contract == nil {\n\t\treturn nil\n\t}\n\n\tnftID, foundNFT := h.k.GetNFTByContract(ctx, contract.String())\n\tif !foundNFT {\n\t\treturn nil\n\t}\n\n\tcsr, found := h.k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentCSR, \"EVMHook::PostTxProcessing the NFT ID was found but the CSR was not: %d\", nftID)\n\t}\n\n\t// Calculate fees to be distributed = intFloor(GasUsed * GasPrice * csrShares)\n\tfee := sdk.NewIntFromUint64(receipt.GasUsed).Mul(sdk.NewIntFromBigInt(msg.GasPrice()))\n\tcsrFee := sdk.NewDecFromInt(fee).Mul(params.CsrShares).TruncateInt()\n\tevmDenom := h.k.evmKeeper.GetParams(ctx).EvmDenom\n\tcsrFees := sdk.Coins{{Denom: evmDenom, Amount: csrFee}}\n\n\t// Send fees from fee collector to module account before distribution\n\terr := h.k.bankKeeper.SendCoinsFromModuleToModule(ctx, h.k.FeeCollectorName, types.ModuleName, csrFees)\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from fee collector to module acount, %d\", err)\n\t}\n\n\t// Get the turnstile which will receive funds for tx fees\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\")\n\t}\n\n\t// Distribute fees to turnstile contract by NFT ID distributeFees(amount, nftID)\n\tamount := csrFee.BigInt()\n\t_, err = h.k.CallMethod(ctx, \"distributeFees\", contracts.TurnstileContract, types.ModuleAddress, &turnstileAddress, amount, new(big.Int).SetUint64(nftID))\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from module account to turnstile, %d\", err)\n\t}\n\n\t// Update metrics on the CSR obj\n\tcsr.Txs += 1\n\tcsr.Revenue = csr.Revenue.Add(csrFee)\n\n\t// Store updated CSR\n\th.k.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\nfunc (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {\n\t// Get the turnstile address from which state transition events are emitted\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\tpanic(sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\"))\n\t}\n\n\tfor _, log := range receipt.Logs {\n\t\tif len(log.Topics) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Only process events that originate from the Turnstile contract\n\t\teventID := log.Topics[0]\n\t\tif log.Address == turnstileAddress {\n\t\t\tevent, err := TurnstileContract.EventByID(eventID)\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// switch and process based on the turnstile event type\n\t\t\tswitch event.Name {\n\t\t\tcase types.TurnstileEventRegister:\n\t\t\t\terr = h.k.RegisterEvent(ctx, log.Data)\n\t\t\tcase types.TurnstileEventUpdate:\n\t\t\t\terr = h.k.UpdateEvent(ctx, log.Data)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/evm_hooks.go",
      "content": "package keeper\n\ni"
    }
  ]
}