{
  "Title": "[M-04] You can deposit really small amount for other users to DoS them",
  "Content": "\nDeposit and mint under [**LiquidityPool**](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L141-L152) lack access control, which enables any user to **proceed** the  mint/deposit for another user. Attacker can deposit (this does not require tokens) some wai before users TX to DoS the deposit.\n\n### Proof of Concept\n\n[deposit](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L141-L144) and [mint](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L148-L152) do [processDeposit](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L427-L441)/[processMint](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol#L451-L465) which are the secondary functions to the requests. These function do not take any value in the form of tokens, but only send shares to the receivers. This means they can be called for free.\n\nWith this an attacker who wants to DoS a user, can wait him to make the request to deposit and on the next epoch front run him by calling  [deposit](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L141-L144) with something small like 1 wei. Afterwards when the user calls `deposit`, his TX will inevitable revert, as he will not have enough balance for the full deposit.\n\n### Recommended Mitigation Steps\n\nHave some access control modifiers like [**withApproval**](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L97-L100) used also in [redeem](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol#L200-L208).\n\n```diff\n-    function deposit(uint256 assets, address receiver) public returns (uint256 shares)  {\n+    function deposit(uint256 assets, address receiver) public returns (uint256 shares) withApproval(receiver) {\n        shares = investmentManager.processDeposit(receiver, assets);\n        emit Deposit(address(this), receiver, assets, shares);\n     }\n\n-    function mint(uint256 shares, address receiver) public returns (uint256 assets) {\n+    function mint(uint256 shares, address receiver) public returns (uint256 assets) withApproval(receiver) {\n        assets = investmentManager.processMint(receiver, shares);\n        emit Deposit(address(this), receiver, assets, shares);\n     }\n```\n\n### Assessed type\n\nAccess Control\n\n**[hieronx (Centrifuge) confirmed and commented](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/143#issuecomment-1745028559):**\n > Mitigated in https://github.com/centrifuge/liquidity-pools/pull/136\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-centrifuge",
  "Code": [
    {
      "filename": "src/LiquidityPool.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.21;\n\nimport {Auth} from \"./util/Auth.sol\";\nimport {MathLib} from \"./util/MathLib.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {IERC4626} from \"./interfaces/IERC4626.sol\";\n\ninterface ERC20PermitLike {\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external;\n    function PERMIT_TYPEHASH() external view returns (bytes32);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\ninterface TrancheTokenLike is IERC20, ERC20PermitLike {\n    function checkTransferRestriction(address from, address to, uint256 value) external view returns (bool);\n}\n\ninterface InvestmentManagerLike {\n    function processDeposit(address receiver, uint256 assets) external returns (uint256);\n    function processMint(address receiver, uint256 shares) external returns (uint256);\n    function processWithdraw(uint256 assets, address receiver, address owner) external returns (uint256);\n    function processRedeem(uint256 shares, address receiver, address owner) external returns (uint256);\n    function maxDeposit(address user, address _tranche) external view returns (uint256);\n    function maxMint(address user, address _tranche) external view returns (uint256);\n    function maxWithdraw(address user, address _tranche) external view returns (uint256);\n    function maxRedeem(address user, address _tranche) external view returns (uint256);\n    function totalAssets(uint256 totalSupply, address liquidityPool) external view returns (uint256);\n    function convertToShares(uint256 assets, address liquidityPool) external view returns (uint256);\n    function convertToAssets(uint256 shares, address liquidityPool) external view returns (uint256);\n    function previewDeposit(address user, address liquidityPool, uint256 assets) external view returns (uint256);\n    function previewMint(address user, address liquidityPool, uint256 shares) external view returns (uint256);\n    function previewWithdraw(address user, address liquidityPool, uint256 assets) external view returns (uint256);\n    function previewRedeem(address user, address liquidityPool, uint256 shares) external view returns (uint256);\n    function requestRedeem(uint256 shares, address receiver) external;\n    function requestDeposit(uint256 assets, address receiver) external;\n    function collectDeposit(address receiver) external;\n    function collectRedeem(address receiver) external;\n    function decreaseDepositRequest(uint256 assets, address receiver) external;\n    function decreaseRedeemRequest(uint256 shares, address receiver) external;\n}\n\n/// @title  Liquidity Pool\n/// @notice Liquidity Pool implementation for Centrifuge pools\n///         following the EIP4626 standard, with asynchronous extension methods.\n///\n/// @dev    Each Liquidity Pool is a tokenized vault issuing shares of Centrifuge tranches as restricted ERC20 tokens against currency deposits based on the current share price.\n///         This is extending the EIP4626 standard by 'requestRedeem' & 'requestDeposit' functions, where redeem and deposit orders are submitted to the pools\n///         to be included in the execution of the following epoch. After execution users can use the deposit, mint, redeem and withdraw functions to\n///         get their shares and/or assets from the pools.\ncontract LiquidityPool is Auth, IERC4626 {\n    using MathLib for uint256;\n\n    uint64 public immutable poolId;\n    bytes16 public immutable trancheId;\n\n    /// @notice The investment currency for this Liquidity Pool.\n    ///         Each tranche of a Centrifuge pool can have multiple Liquidity Pools. A Liquidity Pool for each supported asset.\n    ///         Thus tranche shares can be linked to multiple LiquidityPools with different assets.\n    /// @dev    Also known as the investment currency.\n    address public immutable asset;\n\n    /// @notice The restricted ERC-20 Liquidity Pool token. Has a ratio (token price) of underlying assets\n    ///         exchanged on deposit/withdraw/redeem.\n    /// @dev    Also known as tranche tokens.\n    TrancheTokenLike public immutable share;\n\n    InvestmentManagerLike public investmentManager;\n\n    /// @notice Tranche token price, denominated in the asset\n    uint128 public latestPrice;\n\n    /// @notice Timestamp of the last price update\n    uint256 public lastPriceUpdate;\n\n    // --- Events ---\n    event File(bytes32 indexed what, address data);\n    event DepositRequested(address indexed owner, uint256 assets);\n    event RedeemRequested(address indexed owner, uint256 shares);\n    event DepositCollected(address indexed owner);\n    event RedeemCollected(address indexed owner);\n    event UpdatePrice(uint128 price);\n\n    constructor(uint64 poolId_, bytes16 trancheId_, address asset_, address share_, address investmentManager_) {\n        poolId = poolId_;\n        trancheId = trancheId_;\n        asset = asset_;\n        share = TrancheTokenLike(share_);\n        investmentManager = InvestmentManagerLike(investmentManager_);\n\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    /// @dev Either msg.sender is the owner or a ward on the contract\n    modifier withApproval(address owner) {\n        require(msg.sender == owner, \"LiquidityPool/no-approval\");\n        _;\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, address data) public auth {\n        if (what == \"investmentManager\") investmentManager = InvestmentManagerLike(data);\n        else revert(\"LiquidityPool/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- ERC4626 functions ---\n    /// @return Total value of the shares, denominated in the asset of this Liquidity Pools\n    function totalAssets() public view returns (uint256) {\n        return investmentManager.totalAssets(totalSupply(), address(this));\n    }\n\n    /// @notice Calculates the amount of shares that any user would approximately get for the amount of assets provided.\n    ///         The calcultion is based on the token price from the most recent epoch retrieved from Centrifuge.\n    ///         The actual conversion will likely differ as the price changes between order submission and execution.\n    function convertToShares(uint256 assets) public view returns (uint256 shares) {\n        shares = investmentManager.convertToShares(assets, address(this));\n    }\n\n    /// @notice Calculates the asset value for an amount of shares provided.\n    ///         The calculation is based on the token price from the most recent epoch retrieved from Centrifuge.\n    ///         The actual conversion will likely differ as the price changes between order submission and execution.\n    function convertToAssets(uint256 shares) public view returns (uint256 assets) {\n        assets = investmentManager.convertToAssets(shares, address(this));\n    }\n\n    /// @return Maximum amount of assets that can be deposited into the Tranche by the receiver after the epoch had been executed on Centrifuge.\n    function maxDeposit(address receiver) public view returns (uint256) {\n        return investmentManager.maxDeposit(receiver, address(this));\n    }\n\n    /// @return shares that any user would get for an amount of assets provided\n    function previewDeposit(uint256 assets) public view returns (uint256 shares) {\n        shares = investmentManager.previewDeposit(msg.sender, address(this), assets);\n    }\n\n    /// @notice Collect shares for deposited assets after Centrifuge epoch execution.\n    ///         maxDeposit is the max amount of shares that can be collected.\n    function deposit(uint256 assets, address receiver) public returns (uint256 shares) {\n        shares = investmentManager.processDeposit(receiver, assets);\n        emit Deposit(address(this), receiver, assets, shares);\n    }\n\n    /// @notice Collect shares for deposited assets after Centrifuge epoch execution.\n    ///         maxMint is the max amount of shares that can be collected.\n    function mint(uint256 shares, address receiver) public returns (uint256 assets) {\n        // require(receiver == msg.sender, \"LiquidityPool/not-authorized-to-mint\");\n        assets = investmentManager.processMint(receiver, shares);\n        emit Deposit(address(this), receiver, assets, shares);\n    }\n\n    /// @notice Maximum amount of shares that can be claimed by the receiver after the epoch has been executed on the Centrifuge side.\n    function maxMint(address receiver) external view returns (uint256 maxShares) {\n        maxShares = investmentManager.maxMint(receiver, address(this));\n    }\n\n    /// @return assets that any user would get for an amount of shares provided -> convertToAssets\n    function previewMint(uint256 shares) external view returns (uint256 assets) {\n        assets = investmentManager.previewMint(msg.sender, address(this), shares);\n    }\n\n    /// @return maxAssets that the receiver can withdraw\n    function maxWithdraw(address receiver) public view returns (uint256 maxAssets) {\n        return investmentManager.maxWithdraw(receiver, address(this));\n    }\n\n    /// @return shares that a user would need to redeem in order to receive the given amount of assets -> convertToAssets\n    function previewWithdraw(uint256 assets) public view returns (uint256 shares) {\n        shares = investmentManager.previewWithdraw(msg.sender, address(this), assets);\n    }\n\n    /// @notice Withdraw assets after successful epoch execution. Receiver will receive an exact amount of assets for a certain amount of shares that has been redeemed from Owner during epoch execution.\n    /// @return shares that have been redeemed for the exact assets amount\n    function withdraw(uint256 assets, address receiver, address owner)\n        public\n        withApproval(owner)\n        returns (uint256 shares)\n    {\n        uint256 sharesRedeemed = investmentManager.processWithdraw(assets, receiver, owner);\n        emit Withdraw(address(this), receiver, owner, assets, sharesRedeemed);\n        return sharesRedeemed;\n    }\n\n    /// @notice Max amount of shares that can be redeemed by the owner after redemption was requested\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return investmentManager.maxRedeem(owner, address(this));\n    }\n\n    /// @return assets that any user could redeem for a given amount of shares\n    function previewRedeem(uint256 shares) public view returns (uint256 assets) {\n        assets = investmentManager.previewRedeem(msg.sender, address(this), shares);\n    }\n\n    /// @notice Redeem shares after successful epoch execution. Receiver will receive assets for\n    /// @notice Redeem shares can only be called by the Owner or an authorized admin.\n    ///         the exact amount of redeemed shares from Owner after epoch execution.\n    /// @return assets payout for the exact amount of redeemed shares\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        withApproval(owner)\n        returns (uint256 assets)\n    {\n        uint256 currencyPayout = investmentManager.processRedeem(shares, receiver, owner);\n        emit Withdraw(address(this), receiver, owner, currencyPayout, shares);\n        return currencyPayout;\n    }\n\n    // --- Asynchronous 4626 functions ---\n    /// @notice Request asset deposit for a receiver to be included in the next epoch execution.\n    /// @notice Request can only be called by the Owner of the assets or an authorized admin.\n    ///         Asset is locked in the escrow on request submission\n    function requestDeposit(uint256 assets, address owner) public withApproval(owner) {\n        investmentManager.requestDeposit(assets, owner);\n        emit DepositRequested(owner, assets);\n    }\n\n    /// @notice Similar to requestDeposit, but with a permit option.\n    function requestDepositWithPermit(uint256 assets, address owner, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        public\n    {\n        ERC20PermitLike(asset).permit(owner, address(investmentManager), assets, deadline, v, r, s);\n        investmentManager.requestDeposit(assets, owner);\n        emit DepositRequested(owner, assets);\n    }\n\n    /// @notice Request share redemption for a receiver to be included in the next epoch execution.\n    /// @notice Request can only be called by the Owner of the shares or an authorized admin.\n    ///         Shares are locked in the escrow on request submission\n    function requestRedeem(uint256 shares, address owner) public withApproval(owner) {\n        investmentManager.requestRedeem(shares, owner);\n        emit RedeemRequested(owner, shares);\n    }\n\n    /// @notice Similar to requestRedeem, but with a permit option.\n    function requestRedeemWithPermit(uint256 shares, address owner, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        public\n    {\n        share.permit(owner, address(investmentManager), shares, deadline, v, r, s);\n        investmentManager.requestRedeem(shares, owner);\n        emit RedeemRequested(owner, shares);\n    }\n\n    /// @notice Request decreasing the outstanding deposit orders. Will return the assets once the order\n    ///         on Centrifuge is successfully decreased.\n    function decreaseDepositRequest(uint256 assets, address owner) public withApproval(owner) {\n        investmentManager.decreaseDepositRequest(assets, owner);\n    }\n\n    /// @notice Request decreasing the outstanding redemption orders. Will return the shares once the order\n    ///         on Centrifuge is successfully decreased.\n    function decreaseRedeemRequest(uint256 shares, address owner) public withApproval(owner) {\n        investmentManager.decreaseRedeemRequest(shares, owner);\n    }\n\n    // --- Miscellaneous investment functions ---\n    /// @notice Trigger collecting the deposited funds.\n    function collectDeposit(address receiver) public {\n        investmentManager.collectDeposit(receiver);\n        emit DepositCollected(receiver);\n    }\n\n    /// @notice Trigger collecting the deposited tokens.\n    function collectRedeem(address receiver) public {\n        investmentManager.collectRedeem(receiver);\n        emit RedeemCollected(receiver);\n    }\n\n    // --- ERC20 overrides ---\n    function name() public view returns (string memory) {\n        return share.name();\n    }\n\n    function symbol() public view returns (string memory) {\n        return share.symbol();\n    }\n\n    function decimals() public view returns (uint8) {\n        return share.decimals();\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return share.totalSupply();\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return share.balanceOf(owner);\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return share.allowance(owner, spender);\n    }\n\n    function transferFrom(address, address, uint256) public returns (bool) {\n        (bool success, bytes memory data) = address(share).call(bytes.concat(msg.data, bytes20(msg.sender)));\n        _successCheck(success);\n        return abi.decode(data, (bool));\n    }\n\n    function transfer(address, uint256) public returns (bool) {\n        (bool success, bytes memory data) = address(share).call(bytes.concat(msg.data, bytes20(msg.sender)));\n        _successCheck(success);\n        return abi.decode(data, (bool));\n    }\n\n    function approve(address, uint256) public returns (bool) {\n        (bool success, bytes memory data) = address(share).call(bytes.concat(msg.data, bytes20(msg.sender)));\n        _successCheck(success);\n        return abi.decode(data, (bool));\n    }\n\n    function mint(address, uint256) public auth {\n        (bool success,) = address(share).call(bytes.concat(msg.data, bytes20(address(this))));\n        _successCheck(success);\n    }\n\n    function burn(address, uint256) public auth {\n        (bool success,) = address(share).call(bytes.concat(msg.data, bytes20(address(this))));\n        _successCheck(success);\n    }\n\n    // --- Pricing ---\n    function updatePrice(uint128 price) public auth {\n        latestPrice = price;\n        lastPriceUpdate = block.timestamp;\n        emit UpdatePrice(price);\n    }\n\n    // --- Restriction overrides ---\n    /// @notice Check if the shares are allowed to be transferred.\n    function checkTransferRestriction(address from, address to, uint256 value) public view returns (bool) {\n        return share.checkTransferRestriction(from, to, value);\n    }\n\n    // --- Helpers ---\n    /// @dev In case of unsuccessful tx, parse the revert message\n    function _successCheck(bool success) internal pure {\n        if (!success) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/LiquidityPool.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.21;\n\nimport {Auth} from \"./util/Auth.sol\";\nimport {MathLib} from \"./util/MathLib.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {IERC4626} from \"./interfaces/IERC4626.sol\";\n\ninterface ERC20PermitLike {\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external;\n    function PERMIT_TYPEHASH() external view returns (bytes32);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\ninterface TrancheTokenLike is IERC20, ERC20PermitLike {\n    function checkTransferRestriction(address from, address to, uint256 value) external view returns (bool);\n}\n\ninterface InvestmentManagerLike {\n    function processDeposit(address receiver, uint256 assets) external returns (uint256);\n    function processMint(address receiver, uint256 shares) external returns (uint256);\n    function processWithdraw(uint256 assets, address receiver, address owner) external returns (uint256);\n    function processRedeem(uint256 shares, address receiver, address owner) external returns (uint256);\n    function maxDeposit(address user, address _tranche) external view returns (uint256);\n    function maxMint(address user, address _tranche) external view returns (uint256);\n    function maxWithdraw(address user, address _tranche) external view returns (uint256);\n    function maxRedeem(address user, address _tranche) external view returns (uint256);\n    function totalAssets(uint256 totalSupply, address liquidityPool) external view returns (uint256);\n    function convertToShares(uint256 assets, address liquidityPool) external view returns (uint256);\n    function convertToAssets(uint256 shares, address liquidityPool) external view returns (uint256);\n    function previewDeposit(address user, address liquidityPool, uint256 assets) external view returns (uint256);\n    function previewMint(address user, address liquidityPool, uint256 shares) external view returns (uint256);\n    function previewWithdraw(address user, address liquidityPool, uint256 assets) external view returns (uint256);\n    function previewRedeem(address user, address liquidityPool, uint256 shares) external view returns (uint256);\n    function requestRedeem(uint256 shares, address receiver) external;\n    function requestDeposit(uint256 assets, address receiver) external;\n    function collectDeposit(address receiver) external;\n    function collectRedeem(address receiver) external;\n    function decreaseDepositRequest(uint256 assets, address receiver) external;\n    function decreaseRedeemRequest(uint256 shares, address receiver) external;\n}\n\n/// @title  Liquidity Pool\n/// @notice Liquidity Pool implementation for Centrifuge pools\n///         following the EIP4626 standard, with asynchronous extension methods.\n///\n/// @dev    Each Liquidity Pool is a tokenized vault issuing shares of Centrifuge tranches as restricted ERC20 tokens against currency deposits based on the current share price.\n///         This is extending the EIP4626 standard by 'requestRedeem' & 'requestDeposit' functions, where redeem and deposit orders are submitted to the pools\n///         to be included in the execution of the following epoch. After execution users can use the deposit, mint, redeem and withdraw functions to\n///         get their shares and/or assets from the pools.\ncontract LiquidityPool is Auth, IERC4626 {\n    using MathLib for uint256;\n\n    uint64 public immutable poolId;\n    bytes16 public immutable trancheId;\n\n    /// @notice The investment currency for this Liquidity Pool.\n    ///         Each tranche of a Centrifuge pool can have multiple Liquidity Pools. A Liquidity Pool for each supported asset.\n    ///         Thus tranche shares can be linked to multiple LiquidityPools with different assets.\n    /// @dev    Also known as the investment currency.\n    address public immutable asset;\n\n    /// @notice The restricted ERC-20 Liquidity Pool token. Has a ratio (token price) of underlying assets\n    ///         exchanged on deposit/withdraw/redeem.\n    /// @dev    Also known as tranche tokens.\n    TrancheTokenLike public immutable share;\n\n    InvestmentManagerLike public investmentManager;\n\n    /// @notice Tranche token price, denominated in the asset\n    uint128 public latestPrice;\n\n    /// @notice Timestamp of the last price update\n    uint256 public lastPriceUpdate;\n\n    // --- Events ---\n    event File(bytes32 indexed what, address data);\n    event DepositRequested(address indexed owner, uint256 assets);\n    event RedeemRequested(address indexed owner, uint256 shares);\n    event DepositCollected(address indexed owner);\n    event RedeemCollected(address indexed owner);\n    event UpdatePrice(uint128 price);\n\n    constructor(uint64 poolId_, bytes16 trancheId_, address asset_, address share_, address investmentManager_) {\n        poolId = poolId_;\n        trancheId = trancheId_;\n        asset = asset_;\n        share = TrancheTokenLike(share_);\n        investmentManager = InvestmentManagerLike(investmentManager_);\n\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    /// @dev Either msg.sender is the owner or a ward on the contract\n    modifier withApproval(address owner) {\n        require(msg.sender == owner, \"LiquidityPool/no-approval\");\n        _;\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, address data) public auth {\n        if (what == \"investmentManager\") investmentManager = InvestmentManagerLike(data);\n        else revert(\"LiquidityPool/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- ERC4626 functions ---\n    /// @return Total value of the shares, denominated in the asset of this Liquidity Pools\n    function totalAssets() public view returns (uint256) {\n        return investmentManager.totalAssets(totalSupply(), address(this));\n    }\n\n    /// @notice Calculates the amount of shares that any user would approximately get for the amount of assets provided.\n    ///         The calcultion is based on the token price from the most recent epoch retrieved from Centrifuge.\n    ///         The actual conversion will likely differ as the price changes between order submission and execution.\n    function convertToShares(uint256 assets) public view returns (uint256 shares) {\n        shares = investmentManager.convertToShares(assets, address(this));\n    }\n\n    /// @notice Calculates the asset value for an amount of shares provided.\n    ///         The calculation is based on the token price from the most recent epoch retrieved from Centrifuge.\n    ///         The actual conversion will likely differ as the price changes between order submission and execution.\n    function convertToAssets(uint256 shares) public view returns (uint256 assets) {\n        assets = investmentManager.convertToAssets(shares, address(this));\n    }\n\n    /// @return Maximum amount of assets that can be deposited into the Tranche by the receiver after the epoch had been executed on Centrifuge.\n    function maxDeposit(address receiver) public view returns (uint256) {\n        return investmentManager.maxDeposit(receiver, address(this));\n    }\n\n    /// @return shares that any user would get for an amount of assets provided\n    function previewDeposit(uint256 assets) public view returns (uint256 shares) {\n        shares = investmentManager.previewDeposit(msg.sender, address(this), assets);\n    }\n\n    /// @notice Collect shares for deposited assets after Centrifuge epoch execution.\n    ///         maxDeposit is the max amount of shares that can be collected.\n    function deposit(uint256 assets, address receiver) public returns (uint256 shares) {\n        shares = investmentManager.processDeposit(receiver, assets);\n        emit Deposit(address(this), receiver, assets, shares);\n    }\n\n    /// @notice Collect shares for deposited assets after Centrifuge epoch execution.\n    ///         maxMint is the max amount of shares that can be collected.\n    function mint(uint256 shares, address receiver) public returns (uint256 assets) {\n        // require(receiver == msg.sender, \"LiquidityPool/not-authorized-to-mint\");\n        assets = investmentManager.processMint(receiver, shares);\n        emit Deposit(address(this), receiver, assets, shares);\n    }\n\n    /// @notice Maximum amount of shares that can be claimed by the receiver after the epoch has been executed on the Centrifuge side.\n    function maxMint(address receiver) external view returns (uint256 maxShares) {\n        maxShares = investmentManager.maxMint(receiver, address(this));\n    }\n\n    /// @return assets that any user would get for an amount of shares provided -> convertToAssets\n    function previewMint(uint256 shares) external view returns (uint256 assets) {\n        assets = investmentManager.previewMint(msg.sender, address(this), shares);\n    }\n\n    /// @return maxAssets that the receiver can withdraw\n    function maxWithdraw(address receiver) public view returns (uint256 maxAssets) {\n        return investmentManager.maxWithdraw(receiver, address(this));\n    }\n\n    /// @return shares that a user would need to redeem in order to receive the given amount of assets -> convertToAssets\n    function previewWithdraw(uint256 assets) public view returns (uint256 shares) {\n        shares = investmentManager.previewWithdraw(msg.sender, address(this), assets);\n    }\n\n    /// @notice Withdraw assets after successful epoch execution. Receiver will receive an exact amount of assets for a certain amount of shares that has been redeemed from Owner during epoch execution.\n    /// @return shares that have been redeemed for the exact assets amount\n    function withdraw(uint256 assets, address receiver, address owner)\n        public\n        withApproval(owner)\n        returns (uint256 shares)\n    {\n        uint256 sharesRedeemed = investmentManager.processWithdraw(assets, receiver, owner);\n        emit Withdraw(address(this), receiver, owner, assets, sharesRedeemed);\n        return sharesRedeemed;\n    }\n\n    /// @notice Max amount of shares that can be redeemed by the owner after redemption was requested\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return investmentManager.maxRedeem(owner, address(this));\n    }\n\n    /// @return assets that any user could redeem for a given amount of shares\n    function previewRedeem(uint256 shares) public view returns (uint256 assets) {\n        assets = investmentManager.previewRedeem(msg.sender, address(this), shares);\n    }\n\n    /// @notice Redeem shares after successful epoch execution. Receiver will receive assets for\n    /// @notice Redeem shares can only be called by the Owner or an authorized admin.\n    ///         the exact amount of redeemed shares from Owner after epoch execution.\n    /// @return assets payout for the exact amount of redeemed shares\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        withApproval(owner)\n        returns (uint256 assets)\n    {\n        uint256 currencyPayout = investmentManager.processRedeem(shares, receiver, owner);\n        emit Withdraw(address(this), receiver, owner, currencyPayout, shares);\n        return currencyPayout;\n    }\n\n    // --- Asynchronous 4626 functions ---\n    /// @notice Request asset deposit for a receiver to be included in the next epoch execution.\n    /// @notice Request can only be called by the Owner of the assets or an authorized admin.\n    ///         Asset is locked in the escrow on request submission\n    function requestDeposit(uint256 assets, address owner) public withApproval(owner) {\n        investmentManager.requestDeposit(assets, owner);\n        emit DepositRequested(owner, assets);\n    }\n\n    /// @notice Similar to requestDeposit, but with a permit option.\n    function requestDepositWithPermit(uint256 assets, address owner, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        public\n    {\n        ERC20PermitLike(asset).permit(owner, address(investmentManager), assets, deadline, v, r, s);\n        investmentManager.requestDeposit(assets, owner);\n        emit DepositRequested(owner, assets);\n    }\n\n    /// @notice Request share redemption for a receiver to be included in the next epoch execution.\n    /// @notice Request can only be called by the Owner of the shares or an authorized admin.\n    ///         Shares are locked in the escrow on request submission\n    function requestRedeem(uint256 shares, address owner) public withApproval(owner) {\n        investmentManager.requestRedeem(shares, owner);\n        emit RedeemRequested(owner, shares);\n    }\n\n    /// @notice Similar to requestRedeem, but with a permit option.\n    function requestRedeemWithPermit(uint256 shares, address owner, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        public\n    {\n        share.permit(owner, address(investmentManager), shares, deadline, v, r, s);\n        investmentManager.requestRedeem(shares, owner);\n        emit RedeemRequested(owner, shares);\n    }\n\n    /// @notice Request decreasing the outstanding deposit orders. Will return the assets once the order\n    ///         on Centrifuge is successfully decreased.\n    function decreaseDepositRequest(uint256 assets, address owner) public withApproval(owner) {\n        investmentManager.decreaseDepositRequest(assets, owner);\n    }\n\n    /// @notice Request decreasing the outstanding redemption orders. Will return the shares once the order\n    ///         on Centrifuge is successfully decreased.\n    function decreaseRedeemRequest(uint256 shares, address owner) public withApproval(owner) {\n        investmentManager.decreaseRedeemRequest(shares, owner);\n    }\n\n    // --- Miscellaneous investment functions ---\n    /// @notice Trigger collecting the deposited funds.\n    function collectDeposit(address receiver) public {\n        investmentManager.collectDeposit(receiver);\n        emit DepositCollected(receiver);\n    }\n\n    /// @notice Trigger collecting the deposited tokens.\n    function collectRedeem(address receiver) public {\n        investmentManager.collectRedeem(receiver);\n        emit RedeemCollected(receiver);\n    }\n\n    // --- ERC20 overrides ---\n    function name() public view returns (string memory) {\n        return share.name();\n    }\n\n    function symbol() public view returns (string memory) {\n        return share.symbol();\n    }\n\n    function decimals() public view returns (uint8) {\n        return share.decimals();\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return share.totalSupply();\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return share.balanceOf(owner);\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return share.allowance(owner, spender);\n    }\n\n    function transferFrom(address, address, uint256) public returns (bool) {\n        (bool success, bytes memory data) = address(share).call(bytes.concat(msg.data, bytes20(msg.sender)));\n        _successCheck(success);\n        return abi.decode(data, (bool));\n    }\n\n    function transfer(address, uint256) public returns (bool) {\n        (bool success, bytes memory data) = address(share).call(bytes.concat(msg.data, bytes20(msg.sender)));\n        _successCheck(success);\n        return abi.decode(data, (bool));\n    }\n\n    function approve(address, uint256) public returns (bool) {\n        (bool success, bytes memory data) = address(share).call(bytes.concat(msg.data, bytes20(msg.sender)));\n        _successCheck(success);\n        return abi.decode(data, (bool));\n    }\n\n    function mint(address, uint256) public auth {\n        (bool success,) = address(share).call(bytes.concat(msg.data, bytes20(address(this))));\n        _successCheck(success);\n    }\n\n    function burn(address, uint256) public auth {\n        (bool success,) = address(share).call(bytes.concat(msg.data, bytes20(address(this))));"
    }
  ]
}