{
  "Title": "[M-16] `vMaia` is ERC-4626 compliant, but the `maxWithdraw` & `maxRedeem` functions are not fully up to EIP-4626's specification",
  "Content": "\nThe `maxWithdraw` & `maxRedeem` functions should return the `0` when the withdrawal is paused. But here, it's returning `balanceOf[user]`.\n\n### Proof of Concept\n\n`vMaia Withdrawal` is only allowed once per month during the 1st Tuesday (UTC+0) of the month.\n\nIt's checked by the below function:\n\n```\n\n     102       function beforeWithdraw(uint256, uint256) internal override {\n                /// @dev Check if unstake period has not ended yet, continue if it is the case.\n                if (unstakePeriodEnd >= block.timestamp) return;\n        \n                uint256 _currentMonth = DateTimeLib.getMonth(block.timestamp);\n                if (_currentMonth == currentMonth) revert UnstakePeriodNotLive();\n        \n                (bool isTuesday, uint256 _unstakePeriodStart) = DateTimeLib.isTuesday(block.timestamp);\n                if (!isTuesday) revert UnstakePeriodNotLive();\n        \n                currentMonth = _currentMonth;\n                unstakePeriodEnd = _unstakePeriodStart + 1 days;\n    114        }\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/maia/vMaia.sol#L102C1-L114C6>\n\n```\n\n    173            function maxWithdraw(address user) public view virtual override returns (uint256) {\n                      return balanceOf[user];\n                  }\n              \n                  /// @notice Returns the maximum amount of assets that can be redeemed by a user.\n                  /// @dev Assumes that the user has already forfeited all utility tokens.\n                  function maxRedeem(address user) public view virtual override returns (uint256) {\n                      return balanceOf[user];\n    181              }\n```\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/maia/tokens/ERC4626PartnerManager.sol#L173C3-L181C6>\n\nOther than that period (during the 1st Tuesday (UTC+0) of the month ), the `maxWithdraw` & `maxRedeem` functions should return the `0`.\n\nAccording to [EIP-4626 specifications](<https://eips.ethereum.org/EIPS/eip-4626>):\n\n`maxWithdraw`\n\n     MUST factor in both global and user-specific limits, like if withdrawals are entirely disabled (even temporarily) it MUST\n     return 0.\n\n`maxRedeem`\n\n     MUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST\n     return 0.\n\n### Recommended Mitigation Steps\n\nUse an if-else block and if the time period is within the 1st Tuesday (UTC+0) of the month, return `balanceOf[user]` and `else` return `0`.\n\nFor more information, reference [here](<https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#non-standard-erc-4626-vault-functionality>).\n\n### Assessed type\n\nERC4626\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/585#issuecomment-1655656724)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/585#issuecomment-1709162142):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/585).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/maia/vMaia.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {bHermesVotes as vMaiaVotes} from \"@hermes/tokens/bHermesVotes.sol\";\n\nimport {DateTimeLib} from \"./libraries/DateTimeLib.sol\";\nimport {ERC4626PartnerManager, PartnerManagerFactory} from \"./tokens/ERC4626PartnerManager.sol\";\n\n/**\n * @title vMaia: Yield bearing, boosting, voting, and gauge enabled MAIA\n * @author Maia DAO (https://github.com/Maia-DAO)\n * @notice vMaia is an ERC-4626 compliant MAIA token which:\n *         distributes bHermes utility tokens (Weight, Governance) and Maia Governance\n *         in exchange for staking MAIA.\n *\n *         NOTE: Withdraw is only allowed once per month,\n *               during the 1st Tuesday (UTC+0) of the month.\n */\ncontract vMaia is ERC4626PartnerManager {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                         vMAIA STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 private currentMonth;\n    uint256 private unstakePeriodEnd;\n\n    /**\n     * @notice Initializes the vMaia token.\n     * @param _factory The factory that created this contract.\n     * @param _bHermesRate The rate at which bHermes can be claimed.\n     * @param _partnerAsset The asset that will be used to deposit to get vMaia.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     * @param _bhermes The address of the bHermes token.\n     * @param _partnerVault The address of the partner vault.\n     * @param _owner The owner of the token.\n     */\n    constructor(\n        PartnerManagerFactory _factory,\n        uint256 _bHermesRate,\n        ERC20 _partnerAsset,\n        string memory _name,\n        string memory _symbol,\n        address _bhermes,\n        address _partnerVault,\n        address _owner\n    ) ERC4626PartnerManager(_factory, _bHermesRate, _partnerAsset, _name, _symbol, _bhermes, _partnerVault, _owner) {\n        // Set the current month to the current month.\n        currentMonth = DateTimeLib.getMonth(block.timestamp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks available weight allows for the call.\n    modifier checkWeight(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] < amount + userClaimedWeight[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available governance allows for the call.\n    modifier checkGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] < amount + userClaimedGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available partner governance allows for the call.\n    modifier checkPartnerGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] < amount + userClaimedPartnerGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Boost can't be claimed; does not fail. It is all used by the partner vault.\n    function claimBoost(uint256 amount) public override {}\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function that performs the necessary verifications before a user can withdraw from their vMaia position.\n     *  Checks if we're inside the unstaked period, if so then the user is able to withdraw.\n     * If we're not in the unstake period, then there will be checks to determine if this is the beginning of the month.\n     */\n    function beforeWithdraw(uint256, uint256) internal override {\n        /// @dev Check if unstake period has not ended yet, continue if it is the case.\n        if (unstakePeriodEnd >= block.timestamp) return;\n\n        uint256 _currentMonth = DateTimeLib.getMonth(block.timestamp);\n        if (_currentMonth == currentMonth) revert UnstakePeriodNotLive();\n\n        (bool isTuesday, uint256 _unstakePeriodStart) = DateTimeLib.isTuesday(block.timestamp);\n        if (!isTuesday) revert UnstakePeriodNotLive();\n\n        currentMonth = _currentMonth;\n        unstakePeriodEnd = _unstakePeriodStart + 1 days;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Error thrown when trying to withdraw and it is not the first Tuesday of the month.\n    error UnstakePeriodNotLive();\n}"
    },
    {
      "filename": "src/maia/tokens/ERC4626PartnerManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626} from \"@ERC4626/ERC4626.sol\";\n\nimport {bHermes} from \"@hermes/bHermes.sol\";\nimport {bHermesVotes as ERC20MultiVotes} from \"@hermes/tokens/bHermesVotes.sol\";\n\nimport {PartnerManagerFactory} from \"../factories/PartnerManagerFactory.sol\";\nimport {IBaseVault} from \"../interfaces/IBaseVault.sol\";\nimport {PartnerUtilityManager} from \"../PartnerUtilityManager.sol\";\n\nimport {IERC4626PartnerManager} from \"../interfaces/IERC4626PartnerManager.sol\";\n\n/// @title Yield bearing, boosting, voting, and gauge enabled Partner Token\nabstract contract ERC4626PartnerManager is PartnerUtilityManager, Ownable, ERC4626, IERC4626PartnerManager {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                         PARTNER MANAGER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    PartnerManagerFactory public immutable override factory;\n\n    /// @inheritdoc IERC4626PartnerManager\n    bHermes public immutable override bHermesToken;\n\n    /// @inheritdoc IERC4626PartnerManager\n    uint256 public override bHermesRate;\n\n    /**\n     * @notice Initializes the ERC4626PartnerManager token.\n     * @param _factory The partner manager factory.\n     * @param _bHermesRate The rate at which bHermes underlying's can be claimed.\n     * @param _partnerAsset The asset that will be used to deposit to get partner tokens.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     * @param _bhermes The address of the bHermes token.\n     * @param _partnerVault The address of the partner vault.\n     * @param _owner The owner of this contract.\n     */\n    constructor(\n        PartnerManagerFactory _factory,\n        uint256 _bHermesRate,\n        ERC20 _partnerAsset,\n        string memory _name,\n        string memory _symbol,\n        address _bhermes,\n        address _partnerVault,\n        address _owner\n    )\n        PartnerUtilityManager(\n            address(bHermes(_bhermes).gaugeWeight()),\n            address(bHermes(_bhermes).gaugeBoost()),\n            address(bHermes(_bhermes).governance()),\n            address(new ERC20MultiVotes(_owner)),\n            partnerVault\n        )\n        ERC4626(\n            _partnerAsset,\n            string.concat(_name, \" - Burned Hermes: Aggregated Gov + Yield + Boost\"),\n            string.concat(_symbol, \"-bHermes\")\n        )\n    {\n        _initializeOwner(_owner);\n        partnerVault = _partnerVault;\n        factory = _factory;\n        bHermesRate = _bHermesRate;\n        bHermesToken = bHermes(_bhermes);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            UTILITY MANAGER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function updateUnderlyingBalance() public virtual {\n        bHermesToken.claimOutstanding();\n    }\n\n    /// @inheritdoc IERC4626PartnerManager\n    function claimOutstanding() public virtual {\n        uint256 balance = balanceOf[msg.sender] * bHermesRate;\n        /// @dev Never overflows since balandeOf >= userClaimed.\n        claimWeight(balance - userClaimedWeight[msg.sender]);\n        claimBoost(balance - userClaimedBoost[msg.sender]);\n        claimGovernance(balance - userClaimedGovernance[msg.sender]);\n        claimPartnerGovernance(balance - userClaimedPartnerGovernance[msg.sender]);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ERC4626 ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Compute the amount of tokens available in contract.\n    /// @dev 1:1 with underlying asset.\n    function totalAssets() public view override returns (uint256) {\n        return totalSupply;\n    }\n\n    /**\n     * @notice Computes and returns the amount of shares from a given amount of assets.\n     * @param assets amount of assets to convert to shares\n     */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Computes and returns the amount of assets from a given amount of shares.\n     * @param shares amount of shares to convert to assets\n     */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Simulates the amount of shares that the assets deposited are worth.\n     * @param assets amount of assets to simulate the deposit.\n     */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Calculates the amount of shares that the assets deposited are worth.\n     */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be withdrawn from a given amount of shares.\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be redeemed from a given amount of shares.\n     * @param shares amount of shares to convert to assets.\n     */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    ER4626 DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxMint(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be withdrawn by a user.\n    /// @dev Assumes that the user has already forfeited all utility tokens.\n    function maxWithdraw(address user) public view virtual override returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /// @notice Returns the maximum amount of assets that can be redeemed by a user.\n    /// @dev Assumes that the user has already forfeited all utility tokens.\n    function maxRedeem(address user) public view virtual override returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MIGRATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function migratePartnerVault(address newPartnerVault) external onlyOwner {\n        if (factory.vaultIds(IBaseVault(newPartnerVault)) == 0) revert UnrecognizedVault();\n\n        address oldPartnerVault = partnerVault;\n        if (oldPartnerVault != address(0)) IBaseVault(oldPartnerVault).clearAll();\n        bHermesToken.claimOutstanding();\n\n        address(gaugeWeight).safeApprove(oldPartnerVault, 0);\n        address(gaugeBoost).safeApprove(oldPartnerVault, 0);\n        address(governance).safeApprove(oldPartnerVault, 0);\n        address(partnerGovernance).safeApprove(oldPartnerVault, 0);\n\n        address(gaugeWeight).safeApprove(newPartnerVault, type(uint256).max);\n        address(gaugeBoost).safeApprove(newPartnerVault, type(uint256).max);\n        address(governance).safeApprove(newPartnerVault, type(uint256).max);\n        address(partnerGovernance).safeApprove(newPartnerVault, type(uint256).max);\n\n        partnerVault = newPartnerVault;\n        if (newPartnerVault != address(0)) IBaseVault(newPartnerVault).applyAll();\n\n        emit MigratePartnerVault(address(this), newPartnerVault);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function increaseConversionRate(uint256 newRate) external onlyOwner {\n        if (newRate < bHermesRate) revert InvalidRate();\n\n        if (newRate > (address(bHermesToken).balanceOf(address(this)) / totalSupply)) {\n            revert InsufficientBacking();\n        }\n\n        bHermesRate = newRate;\n\n        partnerGovernance.mint(\n            address(this), totalSupply * newRate - address(partnerGovernance).balanceOf(address(this))\n        );\n        bHermesToken.claimOutstanding();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Mints new partner bhermes tokens to a specific address.\n     * @param to address to mints tokens to.\n     * @param amount amount of tokens to mint.\n     */\n    function _mint(address to, uint256 amount) internal virtual override {\n        if (amount > maxMint(to)) revert ExceedsMaxDeposit();\n        bHermesToken.claimOutstanding();\n\n        ERC20MultiVotes(partnerGovernance).mint(address(this), amount * bHermesRate);\n        super._mint(to, amount);\n    }\n\n    /**\n     * @notice Burns (or unstakes) the vMaia token in exchange for the underlying\n     *         Partner tokens, performing changes around bHermes tokens.\n     * @param from account to burn the partner manager from\n     * @param amount amounts of vMaia to burn\n     */\n    function _burn(address from, uint256 amount) internal virtual override checkTransfer(from, amount) {\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfer partner manager to a specific address.\n     * @param to address to transfer the tokens to.\n     * @param amount amounts of tokens to transfer.\n     */\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        override\n        checkTransfer(msg.sender, amount)\n        returns (bool)\n    {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfer tokens from a given address.\n     * @param from address to transfer the tokens from.\n     * @param to address to transfer the tokens to.\n     * @param amount amounts of tokens to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        virtual\n        override\n        checkTransfer(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks available weight allows for call.\n    modifier checkWeight(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedWeight[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available boost allows for call.\n    modifier checkBoost(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedBoost[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available governance allows for call.\n    modifier checkGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available partner governance allows for call.\n    modifier checkPartnerGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedPartnerGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    modifier checkTransfer(address from, uint256 amount) virtual {\n        uint256 userBalance = balanceOf[from] * bHermesRate;\n\n        if (\n            userBalance - userClaimedWeight[from] < amount || userBalance - userClaimedBoost[from] < amount\n                || userBalance - userClaimedGovernance[from] < amount\n                || userBalance - userClaimedPartnerGovernance[from] < amount\n        ) revert InsufficientUnderlying();\n\n        _;\n    }\n}"
    }
  ]
}