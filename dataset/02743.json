{
  "Title": "H-1: If a user approves junior vault tokens to WithdrawPeriphery, anyone can withdraw/redeem his/her token",
  "Content": "# Issue H-1: If a user approves junior vault tokens to WithdrawPeriphery, anyone can withdraw/redeem his/her token \n\nSource: https://github.com/sherlock-audit/2022-10-rage-trade-judging/issues/79 \n\n## Found by \nsimon135, cccz, Nyx, GimelSec, clems4ever\n\n## Summary\n\nIf users want to withdraw/redeem tokens by WithdrawPeriphery, they should approve token approval to WithdrawPeriphery, then call `withdrawToken()` or `redeemToken()`.\nBut if users approve `dnGmxJuniorVault` to WithdrawPeriphery, anyone can withdraw/redeem his/her token.\n\n## Vulnerability Detail\n\nUsers should approve `dnGmxJuniorVault` before calling `withdrawToken()` or `redeemToken()`:\n\n```solidity\n    function withdrawToken(\n        address from,\n        address token,\n        address receiver,\n        uint256 sGlpAmount\n    ) external returns (uint256 amountOut) {\n        // user has approved periphery to use junior vault shares\n        dnGmxJuniorVault.withdraw(sGlpAmount, address(this), from);\n...\n\n    function redeemToken(\n        address from,\n        address token,\n        address receiver,\n        uint256 sharesAmount\n    ) external returns (uint256 amountOut) {\n        // user has approved periphery to use junior vault shares\n        dnGmxJuniorVault.redeem(sharesAmount, address(this), from);\n...\n```\n\nFor better user experience, we always use `approve(WithdrawPeriphery, type(uint256).max)`. It means that if Alice approves the max amount, anyone can withdraw/redeem her tokens anytime.\nAnother scenario is that if Alice approves 30 amounts, she wants to call `withdrawToken` to withdraw 30 tokens. But in this case Alice should send two transactions separately, then an attacker can frontrun `withdrawToken` transaction and withdraw Aliceâ€™s token.\n\n## Impact\n\nAttackers can frontrun withdraw/redeem transactions and steal tokens. And some UI always approves max amount, which means that anyone can withdraw users tokens.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-rage-trade/blob/main/dn-gmx-vaults/contracts/periphery/WithdrawPeriphery.sol#L119-L120\nhttps://github.com/sherlock-audit/2022-10-rage-trade/blob/main/dn-gmx-vaults/contracts/periphery/WithdrawPeriphery.sol#L139-L140\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReplace `from` parameter by `msg.sender`.\n\n```solidity\n        // user has approved periphery to use junior vault shares\n        dnGmxJuniorVault.withdraw(sGlpAmount, address(this), msg.sender);\n\n        // user has approved periphery to use junior vault shares\n        dnGmxJuniorVault.redeem(sharesAmount, address(this), msg.sender);\n```\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/16",
  "Code": [
    {
      "filename": "dn-gmx-vaults/contracts/periphery/WithdrawPeriphery.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { IVault } from '../interfaces/gmx/IVault.sol';\nimport { IGlpManager } from '../interfaces/gmx/IGlpManager.sol';\nimport { ISglpExtended } from '../interfaces/gmx/ISglpExtended.sol';\nimport { IRewardRouterV2 } from '../interfaces/gmx/IRewardRouterV2.sol';\n\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\nimport { IERC20 } from '@openzeppelin/contracts/interfaces/IERC20.sol';\n\nimport { IDnGmxJuniorVault } from '../interfaces/IDnGmxJuniorVault.sol';\n\nimport { FullMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol';\n\n/**\n * @title Periphery to convert junior vault shares to tokens\n * @notice uses a fixed max slippage threshold\n * @notice primarily constructed to be used from frontend\n * @author RageTrade\n **/\n\ncontract WithdrawPeriphery is Ownable {\n    using FullMath for uint256;\n\n    event TokenWithdrawn(\n        address indexed from,\n        address indexed receiver,\n        address token,\n        uint256 sGlpAmount,\n        uint256 tokensRecevied\n    );\n\n    event TokenRedeemed(\n        address indexed from,\n        address indexed receiver,\n        address token,\n        uint256 sharesAmount,\n        uint256 tokensRecevied\n    );\n\n    event SlippageThresholdUpdated(uint256 newSlippageThreshold);\n\n    event AddressesUpdated(address juniorVault, address rewardRouter);\n\n    uint256 internal constant MAX_BPS = 1000;\n    // same price precision is used in gmx's Vault (Vault.sol)\n    uint256 internal constant PRICE_PRECISION = 1e30;\n\n    // max allowed slippage threshold (in bps) when sGlp to output token\n    uint256 public slippageThreshold;\n\n    // gmx's Glp (requird to query totalSupply)\n    IERC20 internal glp;\n    // staked glp tracker is requred to query balanceOf staked glp\n    // since staked glp returns 0 when balanceOf is called on it\n    IERC20 internal fsGlp;\n    // staked glp\n    ISglpExtended internal sGlp;\n\n    // gmx's Vault (vault.sol) contract\n    IVault internal gmxVault;\n    // gmx's GlpManager (GlpManager.sol), which can burn/mint glp\n    IGlpManager internal glpManager;\n    // gmx's RewardRouterV2 (RewardRouterV2.sol) contract\n    IRewardRouterV2 internal rewardRouter;\n\n    // delta neutral junior tranche\n    IDnGmxJuniorVault internal dnGmxJuniorVault;\n\n    /// @notice sets the maximum slippage threshold to be used for converting glp for asset\n    /// @param _slippageThreshold slippage threshold value in bps\n    function setSlippageThreshold(uint256 _slippageThreshold) external onlyOwner {\n        slippageThreshold = _slippageThreshold;\n        emit SlippageThresholdUpdated(_slippageThreshold);\n    }\n\n    /// @notice sets the required external contract address in order to swap glp for tokens\n    /// @dev only owner call this setter function\n    /// @param _dnGmxJuniorVault junior tranche of delta neutral vault\n    /// @param _rewardRouter reward router v2 of gmx protocol\n    function setAddresses(IDnGmxJuniorVault _dnGmxJuniorVault, IRewardRouterV2 _rewardRouter) external onlyOwner {\n        dnGmxJuniorVault = _dnGmxJuniorVault;\n\n        // query sGlp direclty from junior tranche\n        sGlp = ISglpExtended(dnGmxJuniorVault.asset());\n\n        // query glp from sGlp\n        glp = IERC20(sGlp.glp());\n        // query sGlp direclty from junior tranche\n        fsGlp = IERC20(sGlp.stakedGlpTracker());\n\n        rewardRouter = _rewardRouter;\n        // query glpManager from sGlp\n        glpManager = IGlpManager(sGlp.glpManager());\n\n        // query gmxVault from glpManager\n        gmxVault = IVault(glpManager.vault());\n\n        // give allowance to glpManager to pull & burn sGlp\n        sGlp.approve(address(glpManager), type(uint256).max);\n\n        emit AddressesUpdated(address(_dnGmxJuniorVault), address(_rewardRouter));\n    }\n\n    /// @notice allows to withdraw junior vault shares to any token available on gmx\n    /// @param from address which is giving shares\n    /// @param token output token\n    /// @param receiver address of the receiver\n    /// @param sGlpAmount amount of sGLP(asset) to withdraw\n    /// @return amountOut tokens received in exchange of glp\n    function withdrawToken(\n        address from,\n        address token,\n        address receiver,\n        uint256 sGlpAmount\n    ) external returns (uint256 amountOut) {\n        // user has approved periphery to use junior vault shares\n        dnGmxJuniorVault.withdraw(sGlpAmount, address(this), from);\n\n        amountOut = _convertToToken(token, receiver);\n\n        emit TokenWithdrawn(from, receiver, token, sGlpAmount, amountOut);\n    }\n\n    /// @notice allows to redeem junior vault shares to any token available on gmx\n    /// @param from address which is giving shares\n    /// @param token output token\n    /// @param receiver address of the receiver\n    /// @param sharesAmount amount of shares to burn\n    /// @return amountOut tokens received in exchange of glp\n    function redeemToken(\n        address from,\n        address token,\n        address receiver,\n        uint256 sharesAmount\n    ) external returns (uint256 amountOut) {\n        // user has approved periphery to use junior vault shares\n        dnGmxJuniorVault.redeem(sharesAmount, address(this), from);\n\n        amountOut = _convertToToken(token, receiver);\n\n        emit TokenRedeemed(from, receiver, token, sharesAmount, amountOut);\n    }\n\n    function _convertToToken(address token, address receiver) internal returns (uint256 amountOut) {\n        // this value should be whatever glp is received by calling withdraw/redeem to junior vault\n        uint256 outputGlp = fsGlp.balanceOf(address(this));\n\n        // using min price of glp because giving in glp\n        uint256 glpPrice = _getGlpPrice(false);\n        // using max price of token because taking token out of gmx\n        uint256 tokenPrice = gmxVault.getMaxPrice(token);\n\n        // apply slippage threshold on top of estimated output amount\n        uint256 minTokenOut = outputGlp.mulDiv(glpPrice * (MAX_BPS - slippageThreshold), tokenPrice * MAX_BPS);\n\n        // will revert if atleast minTokenOut is not received\n        amountOut = rewardRouter.unstakeAndRedeemGlp(address(token), outputGlp, minTokenOut, receiver);\n    }\n\n    function _getGlpPrice(bool maximize) private view returns (uint256) {\n        // aum is in 1e30\n        uint256 aum = glpManager.getAum(maximize);\n        // totalSupply is in 1e18\n        uint256 totalSupply = glp.totalSupply();\n\n        // price per glp token = (total AUM / total supply)\n        // div by 1e24 because of usdc unit (30 - 6)\n        return aum.mulDiv(PRICE_PRECISION, totalSupply * 1e24);\n    }\n}"
    },
    {
      "filename": "dn-gmx-vaults/contracts/periphery/WithdrawPeriphery.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { IVault } from '../interfaces/gmx/IVault.sol';\nimport { IGlpManager } from '../interfaces/gmx/IGlpManager.sol';\nimport { ISglpExtended } from '../interfaces/gmx/ISglpExtended.sol';\nimport { IRewardRouterV2 } from '../interfaces/gmx/IRewardRouterV2.sol';\n\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\nimport { IERC20 } from '@openzeppelin/contracts/interfaces/IERC20.sol';\n\nimport { IDnGmxJuniorVault } from '../interfaces/IDnGmxJuniorVault.sol';\n\nimport { FullMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol';\n\n/**\n * @title Periphery to convert junior vault shares to tokens\n * @notice uses a fixed max slippage threshold\n * @notice primarily constructed to be used from frontend\n * @author RageTrade\n **/\n\ncontract WithdrawPeriphery is Ownable {\n    using FullMath for uint256;\n\n    event TokenWithdrawn(\n        address indexed from,\n        address indexed receiver,\n        address token,\n        uint256 sGlpAmount,\n        uint256 tokensRecevied\n    );\n\n    event TokenRedeemed(\n        address indexed from,\n        address indexed receiver,\n        address token,\n        uint256 sharesAmount,\n        uint256 tokensRecevied\n    );\n\n    event SlippageThresholdUpdated(uint256 newSlippageThreshold);\n\n    event AddressesUpdated(address juniorVault, address rewardRouter);\n\n    uint256 internal constant MAX_BPS = 1000;\n    // same price precision is used in gmx's Vault (Vault.sol)\n    uint256 internal constant PRICE_PRECISION = 1e30;\n\n    // max allowed slippage threshold (in bps) when sGlp to output token\n    uint256 public slippageThreshold;\n\n    // gmx's Glp (requird to query totalSupply)\n    IERC20 internal glp;\n    // staked glp tracker is requred to query balanceOf staked glp\n    // since staked glp returns 0 when balanceOf is called on it\n    IERC20 internal fsGlp;\n    // staked glp\n    ISglpExtended internal sGlp;\n\n    // gmx's Vault (vault.sol) contract\n    IVault internal gmxVault;\n    // gmx's GlpManager (GlpManager.sol), which can burn/mint glp\n    IGlpManager internal glpManager;\n    // gmx's RewardRouterV2 (RewardRouterV2.sol) contract\n    IRewardRouterV2 internal rewardRouter;\n\n    // delta neutral junior tranche\n    IDnGmxJuniorVault internal dnGmxJuniorVault;\n\n    /// @notice sets the maximum slippage threshold to be used for converting glp for asset\n    /// @param _slippageThreshold slippage threshold value in bps\n    function setSlippageThreshold(uint256 _slippageThreshold) external onlyOwner {\n        slippageThreshold = _slippageThreshold;\n        emit SlippageThresholdUpdated(_slippageThreshold);\n    }\n\n    /// @notice sets the required external contract address in order to swap glp for tokens\n    /// @dev only owner call this setter function\n    /// @param _dnGmxJuniorVault junior tranche of delta neutral vault\n    /// @param _rewardRouter reward router v2 of gmx protocol\n    function setAddresses(IDnGmxJuniorVault _dnGmxJuniorVault, IRewardRouterV2 _rewardRouter) external onlyOwner {\n        dnGmxJuniorVault = _dnGmxJuniorVault;\n\n        // query sGlp direclty from junior tranche\n        sGlp = ISglpExtended(dnGmxJuniorVault.asset());\n\n        // query glp from sGlp\n        glp = IERC20(sGlp.glp());\n        // query sGlp direclty from junior tranche\n        fsGlp = IERC20(sGlp.stakedGlpTracker());\n\n        rewardRouter = _rewardRouter;\n        // query glpManager from sGlp\n        glpManager = IGlpManager(sGlp.glpManager());\n\n        // query gmxVault from glpManager\n        gmxVault = IVault(glpManager.vault());\n\n        // give allowance to glpManager to pull & burn sGlp\n        sGlp.approve(address(glpManager), type(uint256).max);\n\n        emit AddressesUpdated(address(_dnGmxJuniorVault), address(_rewardRouter));\n    }\n\n    /// @notice allows to withdraw junior vault shares to any token available on gmx\n    /// @param from address which is giving shares\n    /// @param token output token\n    /// @param receiver address of the receiver\n    /// @param sGlpAmount amount of sGLP(asset) to withdraw\n    /// @return amountOut tokens received in exchange of glp\n    function withdrawToken(\n        address from,\n        address token,\n        address receiver,\n        uint256 sGlpAmount\n    ) external returns (uint256 amountOut) {\n        // user has approved periphery to use junior vault shares\n        dnGmxJuniorVault.withdraw(sGlpAmount, address(this), from);\n\n        amountOut = _convertToToken(token, receiver);\n\n        emit TokenWithdrawn(from, receiver, token, sGlpAmount, amountOut);\n    }\n\n    /// @notice allows to redeem junior vault shares to any token available on gmx\n    /// @param from address which is giving shares\n    /// @param token output token\n    /// @param receiver address of the receiver\n    /// @param sharesAmount amount of shares to burn\n    /// @return amountOut tokens received in exchange of glp\n    function redeemToken(\n        address from,\n        address token,\n        address receiver,\n        uint256 sharesAmount\n    ) external returns (uint256 amountOut) {\n        // user has approved periphery to use junior vault shares\n        dnGmxJuniorVault.redeem(sharesAmount, address(this), from);\n\n        amountOut = _convertToToken(token, receiver);\n\n        emit TokenRedeemed(from, receiver, token, sharesAmount, amountOut);\n    }\n\n    function _convertToToken(address token, address receiver) internal returns (uint256 amountOut) {\n        // this value should be whatever glp is received by calling withdraw/redeem to junior vault\n        uint256 outputGlp = fsGlp.balanceOf(address(this));\n\n        // using min price of glp because giving in glp\n        uint256 glpPrice = _getGlpPrice(false);\n        // using max price of token because taking token out of gmx\n        uint256 tokenPrice = gmxVault.getMaxPrice(token);\n\n        // apply slippage threshold on top of estimated output amount\n        uint256 minTokenOut = outputGlp.mulDiv(glpPrice * (MAX_BPS - slippageThreshold), tokenPrice * MAX_BPS);\n\n        // will revert if atleast minTokenOut is not received\n        amountOut = rewardRouter.unstakeAndRedeemGlp(address(token), outputGlp, minTokenOut, receiver);\n    }\n\n    function _getGlpPrice(bool maximize) private view returns (uint256) {\n        // aum is in 1e30\n        uint256 aum = glpManager.getAum(maximize);\n        // totalSupply is in 1e18\n        uint256 totalSupply = glp.totalSupply();\n\n        // price per glp token = (total AUM / total supply)\n        // div by 1e24 because of usdc unit (30 - 6)\n        return aum.mulDiv(PRICE_PRECISION, totalSupply * 1e24);\n    }\n}"
    }
  ]
}