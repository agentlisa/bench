{
  "Title": "H-1: Anyone could call `depositReward` with zero reward to extend the period finish time",
  "Content": "# Issue H-1: Anyone could call `depositReward` with zero reward to extend the period finish time \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/11 \n\n## Found by \n0brxce, 0xAnmol, 0xboriskataa, 0xpiken, 0xvj, 14si2o\\_Flint, 9oelm, AMOW, Afriaudit, Bauer, CL001, Dliteofficial, Drynooo, FastTiger, Ironsidesec, Krace, Kunhah, Maniacs, Nihavent, Ruhum, SilverChariot, Timenov, Tychai0s, amar, araj, asui, blockchain555, cergyk, coffiasd, dany.armstrong90, dimulski, forgebyola, heedfxn, jasonxiale, joicygiore, krikolkk, lemonmon, marchev, mt030d, novaman33, pashap9990, rbserver, sakshamguruji, sl1, sunill\\_eth, t0x1c\n## Summary\n\nAnyone could extend the reward finish time, potentially resulting in users receiving fewer rewards than expected within the same time period.\n\n## Vulnerability Detail\n\nThe function `depositReward` can be called by anyone, even with zero rewards, allowing it to be exploited to extend the reward finish time at little cost. \nThis could result in loss of rewards; for instance, if there are 10 DAI rewards within a 10-day period, a malicious user could extend the finish time on *day 5*, extending the finish time to the 15th day. Participants would only receive 7.5 DAI by the 10th day.\n\n```solidity\n    function depositReward(address _rewardsToken, uint256 reward) external updateReward(address(0)) nonReentrant {\n        IERC20(_rewardsToken).safeTransferFrom(_msgSender(), address(this), reward);\n\n        // Update vesting accounting for reward (if existing rewards being distributed, increase proportionally).\n        if (block.timestamp >= rewardData[_rewardsToken].periodFinish) {\n            rewardData[_rewardsToken].rewardRate = reward.div(rewardData[_rewardsToken].rewardsDuration);\n        } else {\n            uint256 remaining = rewardData[_rewardsToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardData[_rewardsToken].rewardRate);\n            rewardData[_rewardsToken].rewardRate = reward.add(leftover).div(rewardData[_rewardsToken].rewardsDuration);\n        }\n\n        rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\n        rewardData[_rewardsToken].periodFinish = block.timestamp.add(rewardData[_rewardsToken].rewardsDuration);\n        emit RewardDeposited(_rewardsToken, reward, _msgSender());\n    }\n```\n\n### POC\nAdd the test to `zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol` and run it with `forge test --match-test test_ZivoeRewards_deposit_zero --rpc-url <RPC_URL_MAINNET>`\n\n```diff\ndiff --git a/zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol b/zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol\nindex f5353b6..870a531 100644\n--- a/zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol\n+++ b/zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewards.sol\n@@ -685,6 +685,33 @@ contract Test_ZivoeRewards is Utility {\n\n     }\n\n+    function test_ZivoeRewards_deposit_zero() public {\n+\n+        depositReward_DAI(address(stZVE), 1);\n+\n+        (\n+            uint256 rewardsDuration,\n+            uint256 _prePeriodFinish,\n+            uint256 _preRewardRate,\n+            uint256 lastUpdateTime,\n+            uint256 rewardPerTokenStored\n+        ) = stZVE.rewardData(DAI);\n+        console.log(\"period finish \", _prePeriodFinish);\n+\n+        vm.warp(block.timestamp + 1 days);\n+\n+        depositReward_DAI(address(stZVE), 0);\n+\n+        (,\n+            uint256 _afterPeriodFinish,\n+            ,\n+            ,\n+        ) = stZVE.rewardData(DAI);\n+        console.log(\"period finish \", _afterPeriodFinish);\n+        //  extend the Finish 1 day\n+        assertEq(_afterPeriodFinish - _prePeriodFinish, 1 days);\n+    }\n+\n     function test_ZivoeRewards_getRewards_works(uint96 random) public {\n\n         uint256 deposit = uint256(random) + 100 ether; // Minimum 100 DAI deposit.\n```\n\n## Impact\n\nAnyonce could extend the reward finish time and the users may receive less rewards than expected during the same time period.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeRewards.sol#L228-L243\n\n## Tool used\n\nFoundry\n\n## Recommendation\nOnly specific users are allowed to call function `depositReward`\n\n\n\n## Discussion\n\n**pseudonaut**\n\nValid, considering adding whitelist\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> high, allows anyone to extend reward finish time indefinitely and decrease reward rate.\n\n\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Zivoe/zivoe-core-foundry/pull/260\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/ZivoeRewards.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./libraries/ZivoeVotes.sol\";\n\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\";\n\ninterface IZivoeGlobals_ZivoeRewards {\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n}\n\n\n\n/// @notice This contract facilitates staking and yield distribution.\n///         This contract has the following responsibilities:\n///           - Allows staking and unstaking of modular \"stakingToken\".\n///           - Allows claiming yield distributed / \"deposited\" to this contract.\n///           - Allows multiple assets to be added as \"rewardToken\" for distributions.\n///           - Vests rewardTokens linearly overtime to stakers.\ncontract ZivoeRewards is ReentrancyGuard, Context, ZivoeVotes {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    struct Reward {\n        uint256 rewardsDuration;        /// @dev How long rewards take to vest, e.g. 30 days.\n        uint256 periodFinish;           /// @dev When current rewards will finish vesting.\n        uint256 rewardRate;             /// @dev Rewards emitted per second.\n        uint256 lastUpdateTime;         /// @dev Last time this data struct was updated.\n        uint256 rewardPerTokenStored;   /// @dev Last snapshot of rewardPerToken taken.\n    }\n\n    address public immutable GBL;       /// @dev The ZivoeGlobals contract.\n\n    address[] public rewardTokens;      /// @dev Array of ERC20 tokens distributed as rewards (if present).\n\n    uint256 private _totalSupply;       /// @dev Total supply of (non-transferrable) LP tokens for reards contract.\n\n    /// @dev Contains rewards information for each rewardToken.\n    mapping(address => Reward) public rewardData;\n\n    /// @dev The order is account -> rewardAsset -> amount.\n    mapping(address => mapping(address => uint256)) public accountRewardPerTokenPaid;\n\n    /// @dev The order is account -> rewardAsset -> amount.\n    mapping(address => mapping(address => uint256)) public rewards;\n\n     /// @dev Contains LP token balance of each account (is 1:1 ratio with amount deposited).\n    mapping(address => uint256) private _balances;\n\n    IERC20 public stakingToken;         /// @dev IERC20 wrapper for the stakingToken (deposited to receive LP tokens).\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the ZivoeRewards contract.\n    /// @param _stakingToken The ERC20 asset deposited to mint LP tokens (and returned when burning LP tokens).\n    /// @param _GBL The ZivoeGlobals contract.\n    constructor(address _stakingToken, address _GBL) {\n        stakingToken = IERC20(_stakingToken);\n        GBL = _GBL;\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during addReward().\n    /// @param  reward The asset that's being distributed.\n    event RewardAdded(address indexed reward);\n\n    /// @notice Emitted during depositReward().\n    /// @param  reward The asset that's being deposited.\n    /// @param  amount The amout deposited.\n    /// @param  depositor The _msgSender() who deposited said reward.\n    event RewardDeposited(address indexed reward, uint256 amount, address indexed depositor);\n\n    /// @notice Emitted during _getRewardAt().\n    /// @param  account The account receiving a reward.\n    /// @param  rewardsToken The ERC20 asset distributed as a reward.\n    /// @param  reward The amount of \"rewardsToken\" distributed.\n    event RewardDistributed(address indexed account, address indexed rewardsToken, uint256 reward);\n\n    /// @notice Emitted during stake().\n    /// @param  account The account staking \"stakingToken\".\n    /// @param  amount The amount of \"stakingToken\" staked.\n    event Staked(address indexed account, uint256 amount);\n\n    /// @notice Emitted during stakeFor().\n    /// @param  account The account receiveing the staked position of \"stakingToken\".\n    /// @param  amount The amount of \"stakingToken\" staked.\n    /// @param  by The account facilitating the staking.\n    event StakedFor(address indexed account, uint256 amount, address indexed by);\n\n    /// @notice Emitted during withdraw().\n    /// @param  account The account withdrawing \"stakingToken\".\n    /// @param  amount The amount of \"stakingToken\" withdrawn.\n    event Withdrawn(address indexed account, uint256 amount);\n\n\n\n    // ---------------\n    //    Modifiers\n    // ---------------\n\n    /// @notice This modifier ensures account rewards information is updated BEFORE mutative actions.\n    /// @param account The account to update personal rewards information if account != address(0).\n    modifier updateReward(address account) {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address token = rewardTokens[i];\n            rewardData[token].rewardPerTokenStored = rewardPerToken(token);\n            rewardData[token].lastUpdateTime = lastTimeRewardApplicable(token);\n            if (account != address(0)) {\n                rewards[account][token] = earned(account, token);\n                accountRewardPerTokenPaid[account][token] = rewardData[token].rewardPerTokenStored;\n            }\n        }\n        _;\n    }\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Returns the amount of tokens owned by \"account\", received when depositing via stake().\n    /// @param account The account to view information of.\n    /// @return amount The amount of tokens owned by \"account\".\n    function balanceOf(address account) external view returns (uint256 amount) { return _balances[account]; }\n    \n    /// @notice Returns the total amount of rewards being distributed to everyone for current rewardsDuration.\n    /// @param  _rewardsToken The asset that's being distributed.\n    /// @return amount The amount of rewards being distributed.\n    function getRewardForDuration(address _rewardsToken) external view returns (uint256 amount) {\n        return rewardData[_rewardsToken].rewardRate.mul(rewardData[_rewardsToken].rewardsDuration);\n    }\n\n    /// @notice Returns the amount of tokens in existence; these are minted and burned when depositing or withdrawing.\n    /// @return amount The amount of tokens in existence.\n    function totalSupply() external view returns (uint256 amount) { return _totalSupply; }\n\n    /// @notice Returns the last snapshot of rewardPerTokenStored taken for a reward asset.\n    /// @param account The account to view information of.\n    /// @param rewardAsset The reward token for which we want to return the rewardPerTokenstored.\n    /// @return amount The latest up-to-date value of rewardPerTokenStored.\n    function viewAccountRewardPerTokenPaid(\n        address account, address rewardAsset\n    ) external view returns (uint256 amount) {\n        return accountRewardPerTokenPaid[account][rewardAsset];\n    }\n\n    /// @notice Returns the rewards earned of a specific rewardToken for an address.\n    /// @param account The account to view information of.\n    /// @param rewardAsset The asset earned as a reward.\n    /// @return amount The amount of rewards earned.\n    function viewRewards(address account, address rewardAsset) external view returns (uint256 amount) {\n        return rewards[account][rewardAsset];\n    }\n\n    /// @notice Provides information on the rewards available for claim.\n    /// @param account The account to view information of.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return amount The amount of rewards earned.\n    function earned(address account, address _rewardsToken) public view returns (uint256 amount) {\n        return _balances[account].mul(\n            rewardPerToken(_rewardsToken).sub(accountRewardPerTokenPaid[account][_rewardsToken])\n        ).div(1e18).add(rewards[account][_rewardsToken]);\n    }\n\n    /// @notice Helper function for assessing distribution timelines.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return timestamp The most recent time (in UNIX format) at which rewards are available for distribution.\n    function lastTimeRewardApplicable(address _rewardsToken) public view returns (uint256 timestamp) {\n        return Math.min(block.timestamp, rewardData[_rewardsToken].periodFinish);\n    }\n\n    /// @notice Cumulative amount of rewards distributed per LP token.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return amount The cumulative amount of rewards distributed per LP token.\n    function rewardPerToken(address _rewardsToken) public view returns (uint256 amount) {\n        if (_totalSupply == 0) { return rewardData[_rewardsToken].rewardPerTokenStored; }\n        return rewardData[_rewardsToken].rewardPerTokenStored.add(\n            lastTimeRewardApplicable(_rewardsToken).sub(\n                rewardData[_rewardsToken].lastUpdateTime\n            ).mul(rewardData[_rewardsToken].rewardRate).mul(1e18).div(_totalSupply)\n        );\n    }\n\n    /// @notice Adds a new asset as a reward to this contract.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @param _rewardsDuration How long rewards take to vest, e.g. 30 days (denoted in seconds).\n    function addReward(address _rewardsToken, uint256 _rewardsDuration) external {\n        require(\n            _msgSender() == IZivoeGlobals_ZivoeRewards(GBL).ZVL(), \n            \"_msgSender() != IZivoeGlobals_ZivoeRewards(GBL).ZVL()\")\n        ;\n        require(_rewardsDuration > 0, \"ZivoeRewards::addReward() _rewardsDuration == 0\");\n        require(\n            rewardData[_rewardsToken].rewardsDuration == 0, \n            \"ZivoeRewards::addReward() rewardData[_rewardsToken].rewardsDuration != 0\"\n        );\n        require(rewardTokens.length < 10, \"ZivoeRewards::addReward() rewardTokens.length >= 10\");\n\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].rewardsDuration = _rewardsDuration;\n        emit RewardAdded(_rewardsToken);\n    }\n\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @param reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external updateReward(address(0)) nonReentrant {\n        IERC20(_rewardsToken).safeTransferFrom(_msgSender(), address(this), reward);\n\n        // Update vesting accounting for reward (if existing rewards being distributed, increase proportionally).\n        if (block.timestamp >= rewardData[_rewardsToken].periodFinish) {\n            rewardData[_rewardsToken].rewardRate = reward.div(rewardData[_rewardsToken].rewardsDuration);\n        } else {\n            uint256 remaining = rewardData[_rewardsToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardData[_rewardsToken].rewardRate);\n            rewardData[_rewardsToken].rewardRate = reward.add(leftover).div(rewardData[_rewardsToken].rewardsDuration);\n        }\n\n        rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\n        rewardData[_rewardsToken].periodFinish = block.timestamp.add(rewardData[_rewardsToken].rewardsDuration);\n        emit RewardDeposited(_rewardsToken, reward, _msgSender());\n    }\n\n    /// @notice Simultaneously calls withdraw() and getRewards() for convenience.\n    function fullWithdraw() external {\n        withdraw(_balances[_msgSender()]);\n        getRewards();\n    }\n\n    /// @notice Stakes the specified amount of stakingToken to this contract.\n    /// @param amount The amount of the _rewardsToken to deposit.\n    function stake(uint256 amount) external nonReentrant updateReward(_msgSender()) {\n        require(amount > 0, \"ZivoeRewards::stake() amount == 0\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n        _writeCheckpoint(_checkpoints[_msgSender()], _add, amount);\n        _balances[_msgSender()] = _balances[_msgSender()].add(amount);\n        stakingToken.safeTransferFrom(_msgSender(), address(this), amount);\n        emit Staked(_msgSender(), amount);\n    }\n\n    /// @notice Stakes the specified amount of stakingToken to this contract, awarded to someone else.\n    /// @dev    This takes stakingToken from _msgSender() and awards stake to \"account\".\n    /// @param amount The amount of the _rewardsToken to deposit.\n    /// @param account The account to stake for (that ultimately receives the stake).\n    function stakeFor(uint256 amount, address account) external nonReentrant updateReward(account) {\n        require(amount > 0, \"ZivoeRewards::stakeFor() amount == 0\");\n        require(account != address(0), \"ZivoeRewards::stakeFor() account == address(0)\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n        _writeCheckpoint(_checkpoints[account], _add, amount);\n        _balances[account] = _balances[account].add(amount);\n        stakingToken.safeTransferFrom(_msgSender(), address(this), amount);\n        emit StakedFor(account, amount, _msgSender());\n    }\n    \n    /// @notice Claim rewards for all possible _rewardTokens.\n    function getRewards() public updateReward(_msgSender()) {\n        for (uint256 i = 0; i < rewardTokens.length; i++) { _getRewardAt(i); }\n    }\n    \n    /// @notice Claim rewards for a specific _rewardToken.\n    /// @param index The index to claim, corresponds to a given index of rewardToken[].\n    function _getRewardAt(uint256 index) internal nonReentrant {\n        address _rewardsToken = rewardTokens[index];\n        uint256 reward = rewards[_msgSender()][_rewardsToken];\n        if (reward > 0) {\n            rewards[_msgSender()][_rewardsToken] = 0;\n            IERC20(_rewardsToken).safeTransfer(_msgSender(), reward);\n            emit RewardDistributed(_msgSender(), _rewardsToken, reward);\n        }\n    }\n\n    /// @notice Withdraws the specified amount of stakingToken from this contract.\n    /// @param amount The amount of the _rewardsToken to withdraw.\n    function withdraw(uint256 amount) public nonReentrant updateReward(_msgSender()) {\n        require(amount > 0, \"ZivoeRewards::withdraw() amount == 0\");\n\n        _totalSupply = _totalSupply.sub(amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n        _writeCheckpoint(_checkpoints[_msgSender()], _subtract, amount);\n        _balances[_msgSender()] = _balances[_msgSender()].sub(amount);\n        stakingToken.safeTransfer(_msgSender(), amount);\n        emit Withdrawn(_msgSender(), amount);\n    }\n\n}"
    }
  ]
}