{
  "Title": "[M-05] Add reentrancy protections on function `executeTrade`",
  "Content": "_Submitted by shw, also found by 0xRajeev_\n\nAs written in the to-do comments, reentrancy could happen in the `executeTrade` function of `Trader` since the `makeOrder.market` can be a user-controlled external contract. See [L121-L126](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L121-L126) in `Trader.sol`.\n\nRecommend adding a reentrancy guard (e.g., the [implementation from OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)) to prevent the users from reentering critical functions.\n\n**[raymogg (Tracer) disputed](https://github.com/code-423n4/2021-06-tracer-findings/issues/143#issuecomment-874405296):**\n > Disputing just as while this is important, its quite explicitly stated in the todo comment and as such is already known by the team as a potential issue.\n>\n> Realistically shouldn't be too much of a problem with whitelisting of the trader.\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-06-tracer-findings/issues/143#issuecomment-882105114):**\n > Marking this as medium risk as, regardless of being noted by the team, still poses a security threat.\n\n**[OsmanBran (Tracer) commented](https://github.com/code-423n4/2021-06-tracer-findings/issues/143#issuecomment-874405296):**\n > Duplicate of [#72](https://github.com/code-423n4/2021-06-tracer-findings/issues/72)\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-06-tracer",
  "Code": [
    {
      "filename": "src/contracts/Trader.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/Types.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./lib/LibBalances.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/**\n * The Trader contract is used to validate and execute off chain signed and matched orders\n */\ncontract Trader is ITrader {\n    // EIP712 Constants\n    // https://eips.ethereum.org/EIPS/eip-712\n    string private constant EIP712_DOMAIN_NAME = \"Tracer Protocol\";\n    string private constant EIP712_DOMAIN_VERSION = \"1.0\";\n    bytes32 private constant EIP712_DOMAIN_SEPERATOR =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // EIP712 Types\n    bytes32 private constant ORDER_TYPE =\n        keccak256(\n            \"Order(address maker,address market,uint256 price,uint256 amount,uint256 side,uint256 expires,uint256 created)\"\n        );\n\n    uint256 public constant override chainId = 1337; // Changes per chain\n    bytes32 public immutable override EIP712_DOMAIN;\n\n    // order hash to memory\n    mapping(bytes32 => Perpetuals.Order) public orders;\n    // maps an order hash to its signed order if seen before\n    mapping(bytes32 => Types.SignedLimitOrder) public orderToSig;\n    // order hash to amount filled\n    mapping(bytes32 => uint256) public override filled;\n    // order hash to average execution price thus far\n    mapping(bytes32 => uint256) public override averageExecutionPrice;\n\n    constructor() {\n        // Construct the EIP712 Domain\n        EIP712_DOMAIN = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_SEPERATOR,\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function filledAmount(Perpetuals.Order memory order) external view override returns (uint256) {\n        return filled[Perpetuals.orderId(order)];\n    }\n\n    function getAverageExecutionPrice(Perpetuals.Order memory order) external view override returns (uint256) {\n        return averageExecutionPrice[Perpetuals.orderId(order)];\n    }\n\n    /**\n     * @notice Batch executes maker and taker orders against a given market. Currently matching works\n     *         by matching orders 1 to 1\n     * @param makers An array of signed make orders\n     * @param takers An array of signed take orders\n     */\n    function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers)\n        external\n        override\n    {\n        require(makers.length == takers.length, \"TDR: Lengths differ\");\n\n        // safe as we've already bounds checked the array lengths\n        uint256 n = makers.length;\n\n        require(n > 0, \"TDR: Received empty arrays\");\n\n        for (uint256 i = 0; i < n; i++) {\n            // verify each order individually and together\n            if (\n                !isValidSignature(makers[i].order.maker, makers[i]) ||\n                !isValidSignature(takers[i].order.maker, takers[i]) ||\n                !isValidPair(takers[i], makers[i])\n            ) {\n                // skip if either order is invalid\n                continue;\n            }\n\n            // retrieve orders\n            // if the order does not exist, it is created here\n            Perpetuals.Order memory makeOrder = grabOrder(makers, i);\n            Perpetuals.Order memory takeOrder = grabOrder(takers, i);\n\n            bytes32 makerOrderId = Perpetuals.orderId(makeOrder);\n            bytes32 takerOrderId = Perpetuals.orderId(takeOrder);\n\n            uint256 makeOrderFilled = filled[makerOrderId];\n            uint256 takeOrderFilled = filled[takerOrderId];\n\n            uint256 fillAmount = Balances.fillAmount(makeOrder, makeOrderFilled, takeOrder, takeOrderFilled);\n\n            uint256 executionPrice = Perpetuals.getExecutionPrice(makeOrder, takeOrder);\n            uint256 newMakeAverage = Perpetuals.calculateAverageExecutionPrice(\n                makeOrderFilled,\n                averageExecutionPrice[makerOrderId],\n                fillAmount,\n                executionPrice\n            );\n            uint256 newTakeAverage = Perpetuals.calculateAverageExecutionPrice(\n                takeOrderFilled,\n                averageExecutionPrice[takerOrderId],\n                fillAmount,\n                executionPrice\n            );\n\n            // match orders\n            // referencing makeOrder.market is safe due to above require\n            // make low level call to catch revert\n            // todo this could be succeptible to re-entrancy as\n            // market is never verified\n            (bool success, ) = makeOrder.market.call(\n                abi.encodePacked(\n                    ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,\n                    abi.encode(makeOrder, takeOrder, fillAmount)\n                )\n            );\n\n            // ignore orders that cannot be executed\n            if (!success) continue;\n\n            // update order state\n            filled[makerOrderId] = makeOrderFilled + fillAmount;\n            filled[takerOrderId] = takeOrderFilled + fillAmount;\n            averageExecutionPrice[makerOrderId] = newMakeAverage;\n            averageExecutionPrice[takerOrderId] = newTakeAverage;\n        }\n    }\n\n    /**\n     * @notice Retrieves and validates an order from an order array\n     * @param signedOrders an array of signed orders\n     * @param index the index into the array where the desired order is\n     * @return the specified order\n     * @dev Should only be called with a verified signedOrder and with index\n     *      < signedOrders.length\n     */\n    function grabOrder(Types.SignedLimitOrder[] memory signedOrders, uint256 index)\n        internal\n        returns (Perpetuals.Order memory)\n    {\n        Perpetuals.Order memory rawOrder = signedOrders[index].order;\n\n        bytes32 orderHash = Perpetuals.orderId(rawOrder);\n        // check if order exists on chain, if not, create it\n        if (orders[orderHash].maker == address(0)) {\n            // store this order to keep track of state\n            orders[orderHash] = rawOrder;\n            // map the order hash to the signed order\n            orderToSig[orderHash] = signedOrders[index];\n        }\n\n        return orders[orderHash];\n    }\n\n    /**\n     * @notice hashes a limit order type in order to verify signatures, per EIP712\n     * @param order the limit order being hashed\n     * @return an EIP712 compliant hash (with headers) of the limit order\n     */\n    function hashOrder(Perpetuals.Order memory order) public view override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    EIP712_DOMAIN,\n                    keccak256(\n                        abi.encode(\n                            ORDER_TYPE,\n                            order.maker,\n                            order.market,\n                            order.price,\n                            order.amount,\n                            uint256(order.side),\n                            order.expires,\n                            order.created\n                        )\n                    )\n                )\n            );\n    }\n\n    /**\n     * @notice Gets the EIP712 domain hash of the contract\n     */\n    function getDomain() external view override returns (bytes32) {\n        return EIP712_DOMAIN;\n    }\n\n    /**\n     * @notice Verifies a given limit order has been signed by a given signer and has a correct nonce\n     * @param signer The signer who is being verified against the order\n     * @param signedOrder The signed order to verify the signature of\n     * @return if an order has a valid signature and a valid nonce\n     * @dev does not throw if the signature is invalid.\n     */\n    function isValidSignature(address signer, Types.SignedLimitOrder memory signedOrder) internal view returns (bool) {\n        return verifySignature(signer, signedOrder);\n    }\n\n    /**\n     * @notice Validates a given pair of signed orders against each other\n     * @param signedOrder1 the first signed order\n     * @param signedOrder2 the second signed order\n     * @return if signedOrder1 is compatible with signedOrder2\n     * @dev does not throw if pairs are invalid\n     */\n    function isValidPair(Types.SignedLimitOrder memory signedOrder1, Types.SignedLimitOrder memory signedOrder2)\n        internal\n        pure\n        returns (bool)\n    {\n        return (signedOrder1.order.market == signedOrder2.order.market);\n    }\n\n    /**\n     * @notice Verifies the signature component of a signed order\n     * @param signer The signer who is being verified against the order\n     * @param signedOrder The unsigned order to verify the signature of\n     * @return true is signer has signed the order, else false\n     */\n    function verifySignature(address signer, Types.SignedLimitOrder memory signedOrder)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            signer == ECDSA.recover(hashOrder(signedOrder.order), signedOrder.sigV, signedOrder.sigR, signedOrder.sigS);\n    }\n\n    /**\n     * @return An order that has been previously created in contract, given a user-supplied order\n     * @dev Useful for checking to see if a supplied order has actually been created\n     */\n    function getOrder(Perpetuals.Order calldata order) external view override returns (Perpetuals.Order memory) {\n        bytes32 orderId = Perpetuals.orderId(order);\n        return orders[orderId];\n    }\n}"
    }
  ]
}