{
  "Title": "[Gâ€‘09] Internal functions only called once can be inlined to save gas",
  "Content": "\n<details>\n\n```solidity\nFile: /ERC725/blob/v5.1.0/implementations/contracts/ERC725XCore.sol\n131    function _executeBatch(\n        uint256[] memory operationsType,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas\n    ) internal virtual returns (bytes[] memory) {  \n\n\n174   function _executeCall(\n        address target,\n        uint256 value,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n\n203   function _executeStaticCall(\n        address target,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n\n\n225     function _executeDelegateCall(\n        address target,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n\n247  function _deployCreate(\n        uint256 value,\n        bytes memory creationCode\n    ) internal virtual returns (bytes memory newContract) {\n\n288   function _deployCreate2(\n        uint256 value,\n        bytes memory creationCode\n    ) internal virtual returns (bytes memory newContract) {                \n```\nhttps://github.com/ERC725Alliance/ERC725/blob/v5.1.0/implementations/contracts/ERC725XCore.sol#L131\n\n```solidity\nFile: /contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol\n796   function _fallbackLSP17Extendable() internal virtual override {\n\n851   function _getExtension(\n        bytes4 functionSelector\n    ) internal view virtual override returns (address) {\n\n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol#L796\n\n```solidity\nFile: /contracts/LSP1UniversalReceiver/LSP1UniversalReceiverDelegateUP/LSP1UniversalReceiverDelegateUP.sol\n152    function _whenReceiving(\n        bytes32 typeId,\n        address notifier,\n        bytes32 notifierMapKey,\n        bytes4 interfaceID\n    ) internal virtual returns (bytes memory) {\n\n201   function _whenSending(\n        bytes32 typeId,\n        address notifier,\n        bytes32 notifierMapKey,\n        uint128 arrayIndex\n    ) internal virtual returns (bytes memory) {        \n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP1UniversalReceiver/LSP1UniversalReceiverDelegateUP/LSP1UniversalReceiverDelegateUP.sol#L152\n\n```solidity\nFile: /contracts/LSP4DigitalAssetMetadata/LSP4DigitalAssetMetadataInitAbstract.sol\n27   function _initialize(\n        string memory name_,\n        string memory symbol_,\n        address newOwner_\n    ) internal virtual onlyInitializing {\n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP4DigitalAssetMetadata/LSP4DigitalAssetMetadataInitAbstract.sol#L27\n\n```solidity\nFile: /contracts/LSP6KeyManager/LSP6Modules/LSP6ExecuteModule.sol\n153   function _verifyCanDeployContract(\n        address controller,\n        bytes32 permissions,\n        bool isFundingContract\n    ) internal view virtual {\n\n170   function _verifyCanStaticCall(\n        address controlledContract,\n        address controller,\n        bytes32 permissions,\n        bytes calldata payload\n    ) internal view virtual {\n\n188   function _verifyCanCall(\n        address controlledContract,\n        address controller,\n        bytes32 permissions,\n        bytes calldata payload\n    ) internal view virtual {\n\n317    function _extractCallType(\n        uint256 operationType,\n        uint256 value,\n        bool isEmptyCall\n    ) internal pure returns (bytes4 requiredCallTypes) {\n\n339   function _extractExecuteParameters(\n        bytes calldata executeCalldata\n    ) internal pure returns (uint256, address, uint256, bytes4, bool) {\n\n\n366   function _isAllowedAddress(\n        bytes memory allowedCall,\n        address to\n    ) internal pure returns (bool) {\n\n382     function _isAllowedStandard(\n        bytes memory allowedCall,\n        address to\n    ) internal view returns (bool) {\n\n399   function _isAllowedFunction(\n        bytes memory allowedCall,\n        bytes4 requiredFunction\n    ) internal pure returns (bool) {\n\n418  function _isAllowedCallType(\n        bytes memory allowedCall,\n        bytes4 requiredCallTypes\n    ) internal pure returns (bool) {\n\n\n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP6KeyManager/LSP6Modules/LSP6ExecuteModule.sol#L153\n\n```solidity\nFile: /contracts/LSP6KeyManager/LSP6KeyManagerCore.sol\n441       function _isValidNonce(\n        address from,\n        uint256 idx\n    ) internal view virtual returns (bool) {       \n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP6KeyManager/LSP6KeyManagerCore.sol#L441\n\n```solidity\nFile: /contracts/LSP6KeyManager/LSP6Modules/LSP6SetDataModule.sol\n334   function _getPermissionToSetPermissionsArray(\n        address controlledContract,\n        bytes32 inputDataKey,\n        bytes memory inputDataValue,\n        bool hasBothAddControllerAndEditPermissions\n    ) internal view virtual returns (bytes32) {\n\n385   function _getPermissionToSetControllerPermissions(\n        address controlledContract,\n        bytes32 inputPermissionDataKey\n    ) internal view virtual returns (bytes32) {\n\n406   function _getPermissionToSetAllowedCalls(\n        address controlledContract,\n        bytes32 dataKey,\n        bytes memory dataValue,\n        bool hasBothAddControllerAndEditPermissions\n    ) internal view virtual returns (bytes32) {\n\n438  function _getPermissionToSetAllowedERC725YDataKeys(\n        address controlledContract,\n        bytes32 dataKey,\n        bytes memory dataValue,\n        bool hasBothAddControllerAndEditPermissions\n    ) internal view returns (bytes32) {\n\n474   function _getPermissionToSetLSP1Delegate(\n        address controlledContract,\n        bytes32 lsp1DelegateDataKey\n    ) internal view virtual returns (bytes32) {\n\n490   function _getPermissionToSetLSP17Extension(\n        address controlledContract,\n        bytes32 lsp17ExtensionDataKey\n    ) internal view virtual returns (bytes32) {\n\n507  function _verifyAllowedERC725YSingleKey(\n        address controllerAddress,\n        bytes32 inputDataKey,\n        bytes memory allowedERC725YDataKeysCompacted\n    ) internal pure virtual {\n\n622    function _verifyAllowedERC725YDataKeys(\n        address controllerAddress,\n        bytes32[] memory inputDataKeys,\n        bytes memory allowedERC725YDataKeysCompacted,\n        bool[] memory validatedInputKeysList,\n        uint256 allowedDataKeysFound\n    ) internal pure virtual {\n\n\n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP6KeyManager/LSP6Modules/LSP6SetDataModule.sol#L334\n\n```solidity\nFile: /contracts/LSP7DigitalAsset/extensions/LSP7CappedSupply.sol\n53   function _mint(\n        address to,\n        uint256 amount,\n        bool allowNonLSP1Recipient,\n        bytes memory data\n    ) internal virtual override {\n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP7DigitalAsset/extensions/LSP7CappedSupply.sol#L53\n\n```solidity\nFile: \n107  function _updateOperator(\n        address tokenOwner,\n        address operator,\n        uint256 amount\n    ) internal virtual override {\n\n116   function _transfer(\n        address from,\n        address to,\n        uint256 amount,\n        bool allowNonLSP1Recipient,\n        bytes memory data\n    ) internal virtual override {\n\n127       function _mint(\n        address to,\n        uint256 amount,\n        bool allowNonLSP1Recipient,\n        bytes memory data\n    ) internal virtual override {\n\n137   function _burn(\n        address from,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual override {\n\n146  function _setData(\n        bytes32 key,\n        bytes memory value\n    ) internal virtual override(LSP4DigitalAssetMetadata, ERC725YCore) {                                \n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP7DigitalAsset/extensions/LSP7CompatibleERC20.sol#L107\n\n```solidity\nFile: /contracts/LSP7DigitalAsset/LSP7DigitalAssetCore.sol\n399   function _transfer(\n        address from,\n        address to,\n        uint256 amount,\n        bool allowNonLSP1Recipient,\n        bytes memory data\n    ) internal virtual {\n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP7DigitalAsset/LSP7DigitalAssetCore.sol#L399\n\n```solidity\nFile: /contracts/LSP7DigitalAsset/LSP7DigitalAssetInitAbstract.sol\n28   function _initialize(\n        string memory name_,\n        string memory symbol_,\n        address newOwner_,\n        bool isNonDivisible_\n    ) internal virtual onlyInitializing {\n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP7DigitalAsset/LSP7DigitalAssetInitAbstract.sol#L28\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-lukso",
  "Code": [
    {
      "filename": "implementations/contracts/ERC725XCore.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n// interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC725X} from \"./interfaces/IERC725X.sol\";\n\n// libraries\nimport {Create2} from \"@openzeppelin/contracts/utils/Create2.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\n// modules\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {OwnableUnset} from \"./custom/OwnableUnset.sol\";\n\n// constants\nimport {\n    _INTERFACEID_ERC725X,\n    OPERATION_0_CALL,\n    OPERATION_1_CREATE,\n    OPERATION_2_CREATE2,\n    OPERATION_3_STATICCALL,\n    OPERATION_4_DELEGATECALL\n} from \"./constants.sol\";\n\nimport \"./errors.sol\";\n\n/**\n * @title Core implementation of ERC725X executor\n * @author Fabian Vogelsteller <fabian@lukso.network>\n * @dev Implementation of a contract module which provides the ability to call arbitrary functions at any other smart contract and itself,\n * including using `delegatecall`, `staticcall` as well creating contracts using `create` and `create2`\n * This is the basis for a smart contract based account system, but could also be used as a proxy account system\n */\nabstract contract ERC725XCore is OwnableUnset, ERC165, IERC725X {\n    /**\n     * @inheritdoc IERC725X\n     */\n    function execute(\n        uint256 operationType,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) public payable virtual override onlyOwner returns (bytes memory) {\n        return _execute(operationType, target, value, data);\n    }\n\n    /**\n     * @inheritdoc IERC725X\n     */\n    function executeBatch(\n        uint256[] memory operationsType,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas\n    ) public payable virtual override onlyOwner returns (bytes[] memory) {\n        return _executeBatch(operationsType, targets, values, datas);\n    }\n\n    /**\n     * @inheritdoc ERC165\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceId == _INTERFACEID_ERC725X || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev check the `operationType` provided and perform the associated low-level opcode.\n     * see `IERC725X.execute(uint256,address,uint256,bytes)`.\n     */\n    function _execute(\n        uint256 operationType,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) internal virtual returns (bytes memory) {\n        // CALL\n        if (operationType == OPERATION_0_CALL) {\n            return _executeCall(target, value, data);\n        }\n\n        // Deploy with CREATE\n        if (operationType == OPERATION_1_CREATE) {\n            if (target != address(0)) revert ERC725X_CreateOperationsRequireEmptyRecipientAddress();\n            return _deployCreate(value, data);\n        }\n\n        // Deploy with CREATE2\n        if (operationType == OPERATION_2_CREATE2) {\n            if (target != address(0)) revert ERC725X_CreateOperationsRequireEmptyRecipientAddress();\n            return _deployCreate2(value, data);\n        }\n\n        // STATICCALL\n        if (operationType == OPERATION_3_STATICCALL) {\n            if (value != 0) revert ERC725X_MsgValueDisallowedInStaticCall();\n            return _executeStaticCall(target, data);\n        }\n\n        // DELEGATECALL\n        //\n        // WARNING! delegatecall is a dangerous operation type! use with EXTRA CAUTION\n        //\n        // delegate allows to call another deployed contract and use its functions\n        // to update the state of the current calling contract.\n        //\n        // this can lead to unexpected behaviour on the contract storage, such as:\n        // - updating any state variables (even if these are protected)\n        // - update the contract owner\n        // - run selfdestruct in the context of this contract\n        //\n        if (operationType == OPERATION_4_DELEGATECALL) {\n            if (value != 0) revert ERC725X_MsgValueDisallowedInDelegateCall();\n            return _executeDelegateCall(target, data);\n        }\n\n        revert ERC725X_UnknownOperationType(operationType);\n    }\n\n    /**\n     * @dev same as `_execute` but for batch execution\n     * see `IERC725X,execute(uint256[],address[],uint256[],bytes[])`\n     */\n    function _executeBatch(\n        uint256[] memory operationsType,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas\n    ) internal virtual returns (bytes[] memory) {\n        if (\n            operationsType.length != targets.length ||\n            (targets.length != values.length || values.length != datas.length)\n        ) {\n            revert ERC725X_ExecuteParametersLengthMismatch();\n        }\n\n        if (operationsType.length == 0) {\n            revert ERC725X_ExecuteParametersEmptyArray();\n        }\n\n        bytes[] memory result = new bytes[](operationsType.length);\n\n        for (uint256 i = 0; i < operationsType.length; ) {\n            result[i] = _execute(operationsType[i], targets[i], values[i], datas[i]);\n\n            // Increment the iterator in unchecked block to save gas\n            unchecked {\n                ++i;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev perform low-level call (operation type = 0)\n     * @param target The address on which call is executed\n     * @param value The value to be sent with the call\n     * @param data The data to be sent with the call\n     * @return result The data from the call\n     */\n    function _executeCall(\n        address target,\n        uint256 value,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n        if (address(this).balance < value) {\n            revert ERC725X_InsufficientBalance(address(this).balance, value);\n        }\n\n        emit Executed(OPERATION_0_CALL, target, value, bytes4(data));\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.call{value: value}(data);\n        result = Address.verifyCallResult(success, returnData, \"ERC725X: Unknown Error\");\n    }\n\n    /**\n     * @dev perform low-level staticcall (operation type = 3)\n     * @param target The address on which staticcall is executed\n     * @param data The data to be sent with the staticcall\n     * @return result The data returned from the staticcall\n     */\n    function _executeStaticCall(\n        address target,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n        emit Executed(OPERATION_3_STATICCALL, target, 0, bytes4(data));\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.staticcall(data);\n        result = Address.verifyCallResult(success, returnData, \"ERC725X: Unknown Error\");\n    }\n\n    /**\n     * @dev perform low-level delegatecall (operation type = 4)\n     * @param target The address on which delegatecall is executed\n     * @param data The data to be sent with the delegatecall\n     * @return result The data returned from the delegatecall\n     */\n    function _executeDelegateCall(\n        address target,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n        emit Executed(OPERATION_4_DELEGATECALL, target, 0, bytes4(data));\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.delegatecall(data);\n        result = Address.verifyCallResult(success, returnData, \"ERC725X: Unknown Error\");\n    }\n\n    /**\n     * @dev deploy a contract using the CREATE opcode (operation type = 1)\n     * @param value The value to be sent to the contract created\n     * @param creationCode The contract creation bytecode to deploy appended with the constructor argument(s)\n     * @return newContract The address of the contract created as bytes\n     */\n    function _deployCreate(\n        uint256 value,\n        bytes memory creationCode\n    ) internal virtual returns (bytes memory newContract) {\n        if (address(this).balance < value) {\n            revert ERC725X_InsufficientBalance(address(this).balance, value);\n        }\n\n        if (creationCode.length == 0) {\n            revert ERC725X_NoContractBytecodeProvided();\n        }\n\n        address contractAddress;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            contractAddress := create(value, add(creationCode, 0x20), mload(creationCode))\n        }\n\n        if (contractAddress == address(0)) {\n            revert ERC725X_ContractDeploymentFailed();\n        }\n\n        newContract = abi.encodePacked(contractAddress);\n        emit ContractCreated(OPERATION_1_CREATE, contractAddress, value, bytes32(0));\n    }\n\n    /**\n     * @dev deploy a contract using the CREATE2 opcode (operation type = 2)\n     * @param value The value to be sent to the contract created\n     * @param creationCode The contract creation bytecode to deploy appended with the constructor argument(s) and a bytes32 salt\n     * @return newContract The address of the contract created as bytes\n     */\n    function _deployCreate2(\n        uint256 value,\n        bytes memory creationCode\n    ) internal virtual returns (bytes memory newContract) {\n        if (creationCode.length == 0) {\n            revert ERC725X_NoContractBytecodeProvided();\n        }\n\n        bytes32 salt = BytesLib.toBytes32(creationCode, creationCode.length - 32);\n        bytes memory bytecode = BytesLib.slice(creationCode, 0, creationCode.length - 32);\n        address contractAddress = Create2.deploy(value, salt, bytecode);\n\n        newContract = abi.encodePacked(contractAddress);\n        emit ContractCreated(OPERATION_2_CREATE2, contractAddress, value, salt);\n    }\n}"
    }
  ]
}