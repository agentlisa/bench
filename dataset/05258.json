{
  "Title": "[M-30] Chainlink price feed uses BTC, not WBTC. In case of depegging, oracles will become easier to manipulate",
  "Content": "\n<https://github.com/code-423n4/2024-01-salty/blob/main/src/price_feed/CoreChainlinkFeed.sol#L15> \n\n<https://github.com/code-423n4/2024-01-salty/blob/main/src/price_feed/CoreSaltyFeed.sol#L32-L41> \n\n<https://github.com/code-423n4/2024-01-salty/blob/main/src/price_feed/PriceAggregator.sol#L108>\n\nChainlink BTC price feed is BTC/USD, not WBTC/USD. In the event of WBTC depegging, the oracle's return price will deviate from its actual value. We also provide a real-life WBTC depegging event as evidence.\n\nThis alone is not enough for the price aggregator to return the incorrect price, as an adversary needs to manipulate two of three price feeds to manipulate the price. However, due to the aggregator design, we also make an argument that in case of actual depegging, the price will indeed be easier to manipulate.\n\n### Vulnerability details\n\nAccording to the [official Chainlink docs](https://docs.chain.link/data-feeds/price-feeds/addresses?network=ethereum\\&page=1\\&search=btc), there are four price feeds for BTC on Ethereum Mainnet:\n\n*   BTC / ETH\n*   BTC / USD\n*   ETH / BTC\n*   WBTC / BTC\n\nBased on the following observations, we believe Salty will use BTC/USD on the Chainlink price feed, instead of WBTC:\n\n*   All test cases use BTC/USD feed, and nowhere in the code repo is the WBTC feed used.\n*   There is no WBTC/USD feed on Ethereum Mainnet (they are available on some other networks).\n*   Salty's Chainlink price fetcher uses only one feed for the WBTC price. At least two feeds are needed (WBTC/BTC and BTC/USD) to fetch the WBTC/USD price.\n\n[Historically, WBTC has depegged down to 0.98 before](https://thedefiant.io/wbtc-depeg), in the event of wild market swing, specifically during the LUNA crash.\n\n*   Even as of time of report writing, the Chainlink feed for WBTC/BTC does not return a price of 1. [Screenshot](https://imgur.com/UBYlhFH).\n\n[This article](https://thebitcoinmanual.com/articles/why-wrapped-bitcoin-depeg/) explains some of the reasons of why WBTC can depeg.\n\n**Full oracle manipulation (PoC)**\n\nThis alone is not enough to manipulate the oracle entirely, as Salty uses a triple-oracle setting, consisting of Uniswap V3 TWAP, Chainlink price, and Salty pool spot price:\n\n*   Out of the three prices, the oracle selects the two price with the lower absolute difference.\n*   If the two chosen prices are too different, returns 0 signalling failure. Otherwise, return the average of the chosen prices.\n\nHowever, if the Chainlink price has already deviates, then an adversary will only have to manipulate one more oracle to manipulate the price feed.\n\nThe weaker Oracle out of the remaining two is the Salty WBTC pool spot price. Assuming WBTC has already depegged, an adversary can perform the following attack to gain profit:\n\n*   Flash loan a large amount of WBTC from anywhere.\n*   Perform a swap on the WBTC Salty pool, skewing its spot price to be closer to the Chainlink (wrong) price feed.\n*   The aggregated price now reflects the BTC/USD price, instead of WBTC/USD.\n*   With a deviated price, there is a lot that the attacker can do for free:\n    *   Liquidate positions that is actually not yet underwater, and take profit.\n*   Return the flash loan amount.\n\nAn attacker can also take an undercollateralized position. However, this is more difficult to profit from, as it also requires rapid market swing and the lack of liquation before the position becomes insolvent. This also requires that an attacker has large enough capital.\n\n*   Given the scenario where the de-peg has already occured, then this becomes more realistic.\n\n### Impact\n\nIn the event of WBTC/BTC depeg, such as rapid market swing, the price oracle will become easier to manipulate.\n\n*   Given the price of BTC, even a 2% deviation can be considered large.\n\n### Recommended mitigation steps\n\nCollect the WBTC price from two Chainlink price feeds, the BTC/USD feed and the WBTC/BTC feed, as the source of truth.\n\n**[othernet-global (Salty.IO) acknowledged and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/60#issuecomment-1960685173):**\n\n > The stablecoin framework: /stablecoin, /price_feed, WBTC/WETH collateral, PriceAggregator, price feeds and USDS have been removed:\n\n> https://github.com/othernet-global/salty-io/commit/88b7fd1f3f5e037a155424a85275efd79f3e9bf9\n\n**Status:** Mitigation confirmed. Full details in reports from [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/91), [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/112), and [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/27).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/price_feed/CoreChainlinkFeed.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\n\n\n// Uses Chainlink price oracles to retrieve prices for BTC and ETH.\n// Prices are returned with 18 decimals.\ncontract CoreChainlinkFeed is IPriceFeed\n    {\n    uint256 constant MAX_ANSWER_DELAY = 60 minutes;\n\n\t// https://docs.chain.link/data-feeds/price-feeds/addresses\n\tAggregatorV3Interface immutable public CHAINLINK_BTC_USD;\n    AggregatorV3Interface immutable public CHAINLINK_ETH_USD;\n\n\n\tconstructor( address _CHAINLINK_BTC_USD, address _CHAINLINK_ETH_USD )\n\t\t{\n\t\tCHAINLINK_BTC_USD = AggregatorV3Interface(_CHAINLINK_BTC_USD);\n\t\tCHAINLINK_ETH_USD = AggregatorV3Interface(_CHAINLINK_ETH_USD);\n\t\t}\n\n\n\t// Returns a Chainlink oracle price with 18 decimals (converted from Chainlink's 8 decimals).\n\t// Returns zero on any type of failure.\n\tfunction latestChainlinkPrice(AggregatorV3Interface chainlinkFeed) public view returns (uint256)\n\t\t{\n\t\tint256 price = 0;\n\n\t\ttry chainlinkFeed.latestRoundData()\n\t\treturns (\n\t\t\tuint80, // _roundID\n\t\t\tint256 _price,\n\t\t\tuint256, // _startedAt\n\t\t\tuint256 _answerTimestamp,\n\t\t\tuint80 // _answeredInRound\n\t\t)\n\t\t\t{\n\t\t\t// Make sure that the Chainlink price update has occurred within its 60 minute heartbeat\n\t\t\t// https://docs.chain.link/data-feeds#check-the-timestamp-of-the-latest-answer\n\t\t\tuint256 answerDelay = block.timestamp - _answerTimestamp;\n\n\t\t\tif ( answerDelay <= MAX_ANSWER_DELAY )\n\t\t\t\tprice = _price;\n\t\t\telse\n\t\t\t\tprice = 0;\n\t\t\t}\n\t\tcatch (bytes memory) // Catching any failure\n\t\t\t{\n\t\t\t// In case of failure, price will remain 0\n\t\t\t}\n\n\t\tif ( price < 0 )\n\t\t\treturn 0;\n\n\t\t// Convert the 8 decimals from the Chainlink price to 18 decimals\n\t\treturn uint256(price) * 10**10;\n\t\t}\n\n\n\tfunction getPriceBTC() external view returns (uint256)\n\t\t{\n\t\treturn latestChainlinkPrice( CHAINLINK_BTC_USD );\n\t\t}\n\n\n\tfunction getPriceETH() external view returns (uint256)\n\t\t{\n\t\treturn latestChainlinkPrice( CHAINLINK_ETH_USD );\n\t\t}\n    }"
    },
    {
      "filename": "src/price_feed/CoreSaltyFeed.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"../pools/interfaces/IPools.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"../pools/PoolUtils.sol\";\n\n\n// Uses the Salty.IO pools to retrieve prices for BTC and ETH.\n// Prices are returned with 18 decimals.\ncontract CoreSaltyFeed is IPriceFeed\n    {\n    IPools immutable public pools;\n\n\tIERC20 immutable public wbtc;\n\tIERC20 immutable public weth;\n\tIERC20 immutable public usds;\n\n\n\tconstructor( IPools _pools, IExchangeConfig _exchangeConfig )\n\t\t{\n\t\tpools = _pools;\n\t\twbtc = _exchangeConfig.wbtc();\n\t\tweth = _exchangeConfig.weth();\n\t\tusds = _exchangeConfig.usds();\n\t\t}\n\n\n\t// Returns zero for an invalid price\n\tfunction getPriceBTC() external view returns (uint256)\n\t\t{\n        (uint256 reservesWBTC, uint256 reservesUSDS) = pools.getPoolReserves(wbtc, usds);\n\n\t\tif ( ( reservesWBTC < PoolUtils.DUST ) || ( reservesUSDS < PoolUtils.DUST ) )\n\t\t\treturn 0;\n\n\t\t// reservesWBTC has 8 decimals, keep the 18 decimals of reservesUSDS\n\t\treturn ( reservesUSDS * 10**8 ) / reservesWBTC;\n\t\t}\n\n\n\t// Returns zero for an invalid price\n\tfunction getPriceETH() external view returns (uint256)\n\t\t{\n        (uint256 reservesWETH, uint256 reservesUSDS) = pools.getPoolReserves(weth, usds);\n\n\t\tif ( ( reservesWETH < PoolUtils.DUST ) || ( reservesUSDS < PoolUtils.DUST ) )\n\t\t\treturn 0;\n\n\t\treturn ( reservesUSDS * 10**18 ) / reservesWETH;\n\t\t}\n    }"
    },
    {
      "filename": "src/price_feed/PriceAggregator.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"./interfaces/IPriceAggregator.sol\";\n\n\n// Compares three different price feeds to provide prices for BTC and ETH\n// The three price feeds are used so that if one fails to work properly, the other two can still correctly report price (the outlier is discarded).\n// setPriceFeed can only be called once every 35 days by default (to allow time to review performance of the most recently upgraded PriceFeed before setting another).\n// priceFeed1, priceFeed2, and priceFeed3 are updateable using DAO.proposeSetContractAddress( \"priceFeed1\" ), etc\ncontract PriceAggregator is IPriceAggregator, Ownable\n    {\n    event PriceFeedSet(uint256 indexed priceFeedNum, IPriceFeed indexed newPriceFeed);\n    event MaximumPriceFeedPercentDifferenceChanged(uint256 newMaxDifference);\n    event SetPriceFeedCooldownChanged(uint256 newCooldown);\n\n\tIPriceFeed public priceFeed1; // CoreUniswapFeed by default\n\tIPriceFeed public priceFeed2; // CoreChainlinkFeed by default\n\tIPriceFeed public priceFeed3; // CoreSaltyFeed by default\n\n\t// The next time at which setPriceFeed can be called\n\tuint256 public priceFeedModificationCooldownExpiration;\n\n\t// The maximum percent difference between two non-zero PriceFeed prices when aggregating price.\n\t// When the two closest PriceFeeds (out of the three) have prices further apart than this the aggregated price is considered invalid.\n\t// Range: 1% to 7% with an adjustment of .50%\n\tuint256 public maximumPriceFeedPercentDifferenceTimes1000 = 3000; // Defaults to 3.0% with a 1000x multiplier\n\n\t// The required cooldown between calls to setPriceFeed.\n\t// Allows time to evaluate the performance of the recently updatef PriceFeed before further updates are made.\n\t// Range: 30 to 45 days with an adjustment of 5 days\n\tuint256 public priceFeedModificationCooldown = 35 days;\n\n\n\tfunction setInitialFeeds( IPriceFeed _priceFeed1, IPriceFeed _priceFeed2, IPriceFeed _priceFeed3 ) public onlyOwner\n\t\t{\n\t\trequire( address(priceFeed1) == address(0), \"setInitialFeeds() can only be called once\" );\n\n\t\tpriceFeed1 = _priceFeed1;\n\t\tpriceFeed2 = _priceFeed2;\n\t\tpriceFeed3 = _priceFeed3;\n\t\t}\n\n\n\tfunction setPriceFeed( uint256 priceFeedNum, IPriceFeed newPriceFeed ) public onlyOwner\n\t\t{\n\t\t// If the required cooldown is not met, simply return without reverting so that the original proposal can be finalized and new setPriceFeed proposals can be made.\n\t\tif ( block.timestamp < priceFeedModificationCooldownExpiration )\n\t\t\treturn;\n\n\t\tif ( priceFeedNum == 1 )\n\t\t\tpriceFeed1 = newPriceFeed;\n\t\telse if ( priceFeedNum == 2 )\n\t\t\tpriceFeed2 = newPriceFeed;\n\t\telse if ( priceFeedNum == 3 )\n\t\t\tpriceFeed3 = newPriceFeed;\n\n\t\tpriceFeedModificationCooldownExpiration = block.timestamp + priceFeedModificationCooldown;\n\t\temit PriceFeedSet(priceFeedNum, newPriceFeed);\n\t\t}\n\n\n\tfunction changeMaximumPriceFeedPercentDifferenceTimes1000(bool increase) public onlyOwner\n\t\t{\n        if (increase)\n            {\n            if (maximumPriceFeedPercentDifferenceTimes1000 < 7000)\n                maximumPriceFeedPercentDifferenceTimes1000 += 500;\n            }\n        else\n            {\n            if (maximumPriceFeedPercentDifferenceTimes1000 > 1000)\n                maximumPriceFeedPercentDifferenceTimes1000 -= 500;\n            }\n\n\t\temit MaximumPriceFeedPercentDifferenceChanged(maximumPriceFeedPercentDifferenceTimes1000);\n\t\t}\n\n\n\tfunction changePriceFeedModificationCooldown(bool increase) public onlyOwner\n\t\t{\n        if (increase)\n            {\n            if (priceFeedModificationCooldown < 45 days)\n                priceFeedModificationCooldown += 5 days;\n            }\n        else\n            {\n            if (priceFeedModificationCooldown > 30 days)\n                priceFeedModificationCooldown -= 5 days;\n            }\n\n\t\temit SetPriceFeedCooldownChanged(priceFeedModificationCooldown);\n\t\t}\n\n\n\tfunction _absoluteDifference( uint256 x, uint256 y ) internal pure returns (uint256)\n\t\t{\n\t\tif ( x > y )\n\t\t\treturn x - y;\n\n\t\treturn y - x;\n\t\t}\n\n\n\tfunction _aggregatePrices( uint256 price1, uint256 price2, uint256 price3 ) internal view returns (uint256)\n\t\t{\n\t\tuint256 numNonZero;\n\n\t\tif (price1 > 0)\n\t\t\tnumNonZero++;\n\n\t\tif (price2 > 0)\n\t\t\tnumNonZero++;\n\n\t\tif (price3 > 0)\n\t\t\tnumNonZero++;\n\n\t\t// If less than two price sources then return zero to indicate failure\n\t\tif ( numNonZero < 2 )\n\t\t\treturn 0;\n\n\t\tuint256 diff12 = _absoluteDifference(price1, price2);\n\t\tuint256 diff13 = _absoluteDifference(price1, price3);\n\t\tuint256 diff23 = _absoluteDifference(price2, price3);\n\n\t\tuint256 priceA;\n\t\tuint256 priceB;\n\n\t\tif ( ( diff12 <= diff13 ) && ( diff12 <= diff23 ) )\n\t\t\t(priceA, priceB) = (price1, price2);\n\t\telse if ( ( diff13 <= diff12 ) && ( diff13 <= diff23 ) )\n\t\t\t(priceA, priceB) = (price1, price3);\n\t\telse if ( ( diff23 <= diff12 ) && ( diff23 <= diff13 ) )\n\t\t\t(priceA, priceB) = (price2, price3);\n\n\t\tuint256 averagePrice = ( priceA + priceB ) / 2;\n\n\t\t// If price sources are too far apart then return zero to indicate failure\n\t\tif (  (_absoluteDifference(priceA, priceB) * 100000) / averagePrice > maximumPriceFeedPercentDifferenceTimes1000 )\n\t\t\treturn 0;\n\n\t\treturn averagePrice;\n\t\t}\n\n\n\tfunction _getPriceBTC(IPriceFeed priceFeed) internal view returns (uint256 price)\n\t\t{\n \t\ttry priceFeed.getPriceBTC() returns (uint256 _price)\n\t\t\t{\n\t\t\tprice = _price;\n\t\t\t}\n\t\tcatch (bytes memory)\n\t\t\t{\n\t\t\t// price remains 0\n\t\t\t}\n\t\t}\n\n\n\tfunction _getPriceETH(IPriceFeed priceFeed) internal view returns (uint256 price)\n\t\t{\n \t\ttry priceFeed.getPriceETH() returns (uint256 _price)\n\t\t\t{\n\t\t\tprice = _price;\n\t\t\t}\n\t\tcatch (bytes memory)\n\t\t\t{\n\t\t\t// price remains 0\n\t\t\t}\n\t\t}\n\n\n\t// Return the current BTC price (with 18 decimals)\n\tfunction getPriceBTC() external view returns (uint256 price)\n\t\t{\n\t\tuint256 price1 = _getPriceBTC(priceFeed1);\n\t\tuint256 price2 = _getPriceBTC(priceFeed2);\n\t\tuint256 price3 = _getPriceBTC(priceFeed3);\n\n\t\tprice = _aggregatePrices(price1, price2, price3);\n\t\trequire (price != 0, \"Invalid BTC price\" );\n\t\t}\n\n\n\t// Return the current ETH price (with 18 decimals)\n\tfunction getPriceETH() external view returns (uint256 price)\n\t\t{\n\t\tuint256 price1 = _getPriceETH(priceFeed1);\n\t\tuint256 price2 = _getPriceETH(priceFeed2);\n\t\tuint256 price3 = _getPriceETH(priceFeed3);\n\n\t\tprice = _aggregatePrices(price1, price2, price3);\n\t\trequire (price != 0, \"Invalid ETH price\" );\n\t\t}\n    }"
    }
  ]
}