{
  "Title": "[M-02] No check `transferFrom()` return value",
  "Content": "_Submitted by s1m0, also found by pauliax, shw, 0xRajeev, JMukesh, Lucius and cmichel_\n\nThe smart contract doesn't check the return value of `token.transfer()` and `token.transferFrom()`, some erc20 token might not revert in case of error but return false.\nIn the [TracerPerpetualSwaps:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L151) and [Insurance:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L51) this would allow a user to deposit for free. See issue page for other places.\n\nRecommend wrapping the call into a `require()` or using openzeppelin's [SafeERC20 library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol).\n\n**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/115)**\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-06-tracer",
  "Code": [
    {
      "filename": "src/contracts/TracerPerpetualSwaps.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./lib/SafetyWithdraw.sol\";\nimport \"./lib/LibMath.sol\";\nimport {Balances} from \"./lib/LibBalances.sol\";\nimport {Types} from \"./Interfaces/Types.sol\";\nimport \"./lib/LibPrices.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"./Interfaces/IInsurance.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\ncontract TracerPerpetualSwaps is ITracerPerpetualSwaps, Ownable, SafetyWithdraw {\n    using LibMath for uint256;\n    using LibMath for int256;\n    using PRBMathSD59x18 for int256;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 public constant override LIQUIDATION_GAS_COST = 63516;\n    address public immutable override tracerQuoteToken;\n    uint256 public immutable override quoteTokenDecimals;\n    bytes32 public immutable override marketId;\n    IPricing public pricingContract;\n    IInsurance public insuranceContract;\n    address public override liquidationContract;\n    uint256 public override feeRate;\n    uint256 public override fees;\n    address public override feeReceiver;\n\n    /* Config variables */\n    // The price of gas in gwei\n    address public override gasPriceOracle;\n    // The maximum ratio of notionalValue to margin\n    uint256 public override maxLeverage;\n    // WAD value. sensitivity of 1 = 1*10^18\n    uint256 public override fundingRateSensitivity;\n    // WAD value. The percentage for insurance pool holdings/pool target where deleveraging begins\n    uint256 public override deleveragingCliff;\n    /* The percentage of insurance holdings to target at which the insurance pool\n       funding rate changes, and lowestMaxLeverage is reached */\n    uint256 public override insurancePoolSwitchStage;\n    // The lowest value that maxLeverage can be, if insurance pool is empty.\n    uint256 public override lowestMaxLeverage;\n\n    // Account State Variables\n    mapping(address => Balances.Account) public balances;\n    uint256 public tvl;\n    uint256 public override leveragedNotionalValue;\n\n    // Trading interfaces whitelist\n    mapping(address => bool) public override tradingWhitelist;\n\n    event FeeReceiverUpdated(address indexed receiver);\n    event FeeWithdrawn(address indexed receiver, uint256 feeAmount);\n    event Deposit(address indexed user, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed amount);\n    event Settled(address indexed account, int256 margin);\n    event MatchedOrders(\n        address indexed long,\n        address indexed short,\n        uint256 amount,\n        uint256 price,\n        bytes32 longOrderId,\n        bytes32 shortOrderId\n    );\n    event FailedOrders(address indexed long, address indexed short, bytes32 longOrderId, bytes32 shortOrderId);\n\n    /**\n     * @notice Creates a new tracer market and sets the initial funding rate of the market. Anyone\n     *         will be able to purchase and trade tracers after this deployment.\n     * @param _marketId the id of the market, given as BASE/QUOTE\n     * @param _tracerQuoteToken the address of the token used for margin accounts (i.e. The margin token)\n     * @param _tokenDecimals the number of decimal places the quote token supports\n     * @param _gasPriceOracle the address of the contract implementing gas price oracle\n     * @param _maxLeverage the max leverage of the market represented as a WAD value.\n     * @param _fundingRateSensitivity the affect funding rate changes have on funding paid; u60.18-decimal fixed-point number (WAD value)\n     * @param _feeRate the fee taken on trades; WAD value. e.g. 2% fee = 0.02 * 10^18 = 2 * 10^16\n     * @param _feeReceiver the address of the person who can withdraw the fees from trades in this market\n     * @param _deleveragingCliff The percentage for insurance pool holdings/pool target where deleveraging begins.\n     *                           WAD value. e.g. 20% = 20*10^18\n     * @param _lowestMaxLeverage The lowest value that maxLeverage can be, if insurance pool is empty.\n     * @param _insurancePoolSwitchStage The percentage of insurance holdings to target at which the insurance pool\n     *                                  funding rate changes, and lowestMaxLeverage is reached\n     */\n    constructor(\n        bytes32 _marketId,\n        address _tracerQuoteToken,\n        uint256 _tokenDecimals,\n        address _gasPriceOracle,\n        uint256 _maxLeverage,\n        uint256 _fundingRateSensitivity,\n        uint256 _feeRate,\n        address _feeReceiver,\n        uint256 _deleveragingCliff,\n        uint256 _lowestMaxLeverage,\n        uint256 _insurancePoolSwitchStage\n    ) Ownable() {\n        // don't convert to interface as we don't need to interact with the contract\n        tracerQuoteToken = _tracerQuoteToken;\n        quoteTokenDecimals = _tokenDecimals;\n        gasPriceOracle = _gasPriceOracle;\n        marketId = _marketId;\n        feeRate = _feeRate;\n        maxLeverage = _maxLeverage;\n        fundingRateSensitivity = _fundingRateSensitivity;\n        feeReceiver = _feeReceiver;\n        deleveragingCliff = _deleveragingCliff;\n        lowestMaxLeverage = _lowestMaxLeverage;\n        insurancePoolSwitchStage = _insurancePoolSwitchStage;\n    }\n\n    /**\n     * @notice Adjust the max leverage as insurance pool slides from 100% of target to 0% of target\n     */\n    function trueMaxLeverage() public view override returns (uint256) {\n        IInsurance insurance = IInsurance(insuranceContract);\n\n        return\n            Perpetuals.calculateTrueMaxLeverage(\n                insurance.getPoolHoldings(),\n                insurance.getPoolTarget(),\n                maxLeverage,\n                lowestMaxLeverage,\n                deleveragingCliff,\n                insurancePoolSwitchStage\n            );\n    }\n\n    /**\n     * @notice Allows a user to deposit into their margin account\n     * @dev this contract must be an approved spender of the markets quote token on behalf of the depositer.\n     * @param amount The amount of quote tokens to be deposited into the Tracer Market account. This amount\n     * should be given in WAD format.\n     */\n    function deposit(uint256 amount) external override {\n        Balances.Account storage userBalance = balances[msg.sender];\n        // settle outstanding payments\n        settle(msg.sender);\n\n        // convert the WAD amount to the correct token amount to transfer\n        // cast is safe since amount is a uint, and wadToToken can only\n        // scale down the value\n        uint256 rawTokenAmount = uint256(Balances.wadToToken(quoteTokenDecimals, amount).toInt256());\n        IERC20(tracerQuoteToken).transferFrom(msg.sender, address(this), rawTokenAmount);\n\n        // this prevents dust from being added to the user account\n        // eg 10^18 -> 10^8 -> 10^18 will remove lower order bits\n        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);\n\n        // update user state\n        userBalance.position.quote = userBalance.position.quote + convertedWadAmount;\n        _updateAccountLeverage(msg.sender);\n\n        // update market TVL\n        tvl = tvl + uint256(convertedWadAmount);\n        emit Deposit(msg.sender, amount);\n    }\n\n    /**\n     * @notice Allows a user to withdraw from their margin account\n     * @dev Ensures that the users margin percent is valid after withdraw\n     * @param amount The amount of margin tokens to be withdrawn from the tracer market account. This amount\n     * should be given in WAD format\n     */\n    function withdraw(uint256 amount) external override {\n        // settle outstanding payments\n        settle(msg.sender);\n\n        uint256 rawTokenAmount = Balances.wadToToken(quoteTokenDecimals, amount);\n        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);\n\n        Balances.Account storage userBalance = balances[msg.sender];\n        int256 newQuote = userBalance.position.quote - convertedWadAmount;\n\n        // this may be able to be optimised\n        Balances.Position memory newPosition = Balances.Position(newQuote, userBalance.position.base);\n\n        require(\n            Balances.marginIsValid(\n                newPosition,\n                userBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            ),\n            \"TCR: Withdraw below valid Margin\"\n        );\n\n        // update user state\n        userBalance.position.quote = newQuote;\n        _updateAccountLeverage(msg.sender);\n\n        // Safemath will throw if tvl < amount\n        tvl = tvl - amount;\n\n        // perform transfer\n        IERC20(tracerQuoteToken).transfer(msg.sender, rawTokenAmount);\n        emit Withdraw(msg.sender, uint256(convertedWadAmount));\n    }\n\n    /**\n     * @notice Attempt to match two orders that exist on-chain against each other\n     * @dev Emits a FailedOrders or MatchedOrders event based on whether the\n     *      orders were successfully able to be matched\n     * @param order1 The first order\n     * @param order2 The second order\n     * @param fillAmount Amount that the two orders are being filled for\n     * @return Whether the two orders were able to be matched successfully\n     */\n    function matchOrders(\n        Perpetuals.Order memory order1,\n        Perpetuals.Order memory order2,\n        uint256 fillAmount\n    ) external override onlyWhitelisted returns (bool) {\n        bytes32 order1Id = Perpetuals.orderId(order1);\n        bytes32 order2Id = Perpetuals.orderId(order2);\n        uint256 filled1 = ITrader(msg.sender).filled(order1Id);\n        uint256 filled2 = ITrader(msg.sender).filled(order2Id);\n\n        uint256 executionPrice = Perpetuals.getExecutionPrice(order1, order2);\n\n        // settle accounts\n        // note: this can revert and hence no order events will be emitted\n        settle(order1.maker);\n        settle(order2.maker);\n\n        (Balances.Position memory newPos1, Balances.Position memory newPos2) = _executeTrade(\n            order1,\n            order2,\n            fillAmount,\n            executionPrice\n        );\n        // validate orders can match, and outcome state is valid\n        if (\n            !Perpetuals.canMatch(order1, filled1, order2, filled2) ||\n            !Balances.marginIsValid(\n                newPos1,\n                balances[order1.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            ) ||\n            !Balances.marginIsValid(\n                newPos2,\n                balances[order2.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            )\n        ) {\n            // emit failed to match event and return false\n            if (order1.side == Perpetuals.Side.Long) {\n                emit FailedOrders(order1.maker, order2.maker, order1Id, order2Id);\n            } else {\n                emit FailedOrders(order2.maker, order1.maker, order2Id, order1Id);\n            }\n            return false;\n        }\n\n        // update account states\n        balances[order1.maker].position = newPos1;\n        balances[order2.maker].position = newPos2;\n\n        // update fees\n        fees =\n            fees +\n            // add 2 * fees since getFeeRate returns the fee rate for a single\n            // side of the order. Both users were charged fees\n            uint256(Balances.getFee(fillAmount, executionPrice, feeRate) * 2);\n\n        // update leverage\n        _updateAccountLeverage(order1.maker);\n        _updateAccountLeverage(order2.maker);\n\n        // Update internal trade state\n        pricingContract.recordTrade(executionPrice);\n\n        if (order1.side == Perpetuals.Side.Long) {\n            emit MatchedOrders(order1.maker, order2.maker, fillAmount, executionPrice, order1Id, order2Id);\n        } else {\n            emit MatchedOrders(order2.maker, order1.maker, fillAmount, executionPrice, order2Id, order1Id);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Updates account states of two accounts given two orders that are being executed\n     * @param order1 The first order\n     * @param order2 The second order\n     * @param fillAmount The amount that the two ordered are being filled for\n     * @param executionPrice The execution price of the trades\n     * @return The new balances of the two accounts after the trade\n     */\n    function _executeTrade(\n        Perpetuals.Order memory order1,\n        Perpetuals.Order memory order2,\n        uint256 fillAmount,\n        uint256 executionPrice\n    ) internal view returns (Balances.Position memory, Balances.Position memory) {\n        // Retrieve account state\n        Balances.Account memory account1 = balances[order1.maker];\n        Balances.Account memory account2 = balances[order2.maker];\n\n        // Construct `Trade` types suitable for use with LibBalances\n        (Balances.Trade memory trade1, Balances.Trade memory trade2) = (\n            Balances.Trade(executionPrice, fillAmount, order1.side),\n            Balances.Trade(executionPrice, fillAmount, order2.side)\n        );\n\n        // Calculate new account state\n        (Balances.Position memory newPos1, Balances.Position memory newPos2) = (\n            Balances.applyTrade(account1.position, trade1, feeRate),\n            Balances.applyTrade(account2.position, trade2, feeRate)\n        );\n\n        // return new account state\n        return (newPos1, newPos2);\n    }\n\n    /**\n     * @notice internal function for updating leverage. Called within the Account contract. Also\n     *         updates the total leveraged notional value for the tracer market itself.\n     */\n    function _updateAccountLeverage(address account) internal {\n        Balances.Account memory userBalance = balances[account];\n        uint256 originalLeverage = userBalance.totalLeveragedValue;\n        uint256 newLeverage = Balances.leveragedNotionalValue(userBalance.position, pricingContract.fairPrice());\n        balances[account].totalLeveragedValue = newLeverage;\n\n        // Update market leveraged notional value\n        _updateTracerLeverage(newLeverage, originalLeverage);\n    }\n\n    /**\n     * @notice Updates the global leverage value given an accounts new leveraged value and old leveraged value\n     * @param accountNewLeveragedNotional The future notional value of the account\n     * @param accountOldLeveragedNotional The stored notional value of the account\n     */\n    function _updateTracerLeverage(uint256 accountNewLeveragedNotional, uint256 accountOldLeveragedNotional) internal {\n        leveragedNotionalValue = Prices.globalLeverage(\n            leveragedNotionalValue,\n            accountOldLeveragedNotional,\n            accountNewLeveragedNotional\n        );\n    }\n\n    /**\n     * @notice When a liquidation occurs, Liquidation.sol needs to push this contract to update\n     *         account states as necessary.\n     * @param liquidator Address of the account that called liquidate(...)\n     * @param liquidatee Address of the under-margined account getting liquidated\n     * @param liquidatorQuoteChange Amount the liquidator's quote is changing\n     * @param liquidatorBaseChange Amount the liquidator's base is changing\n     * @param liquidateeQuoteChange Amount the liquidated account's quote is changing\n     * @param liquidateeBaseChange Amount the liquidated account's base is changing\n     * @param amountToEscrow The amount the liquidator has to put into escrow\n     */\n    function updateAccountsOnLiquidation(\n        address liquidator,\n        address liquidatee,\n        int256 liquidatorQuoteChange,\n        int256 liquidatorBaseChange,\n        int256 liquidateeQuoteChange,\n        int256 liquidateeBaseChange,\n        uint256 amountToEscrow\n    ) external override onlyLiquidation {\n        // Limits the gas use when liquidating\n        uint256 gasPrice = IOracle(gasPriceOracle).latestAnswer();\n        // Update liquidators last updated gas price\n        Balances.Account storage liquidatorBalance = balances[liquidator];\n        Balances.Account storage liquidateeBalance = balances[liquidatee];\n\n        // update liquidators balance\n        liquidatorBalance.lastUpdatedGasPrice = gasPrice;\n        liquidatorBalance.position.quote =\n            liquidatorBalance.position.quote +\n            liquidatorQuoteChange -\n            amountToEscrow.toInt256();\n        liquidatorBalance.position.base = liquidatorBalance.position.base + liquidatorBaseChange;\n\n        // update liquidatee balance\n        liquidateeBalance.position.quote = liquidateeBalance.position.quote + liquidateeQuoteChange;\n        liquidateeBalance.position.base = liquidateeBalance.position.base + liquidateeBaseChange;\n\n        // Checks if the liquidator is in a valid position to process the liquidation\n        require(userMarginIsValid(liquidator), \"TCR: Liquidator under min margin\");\n    }\n\n    /**\n     * @notice When a liquidation receipt is claimed by the liquidator (i.e. they experienced slippage),\n               Liquidation.sol needs to tell the market to update its balance and the balance of the\n               liquidated agent.\n     * @dev Gives the leftover amount from the receipt to the liquidated agent\n     * @param claimant The liquidator, who has experienced slippage selling the liquidated position\n     * @param amountToGiveToClaimant The amount the liquidator is owe based off slippage\n     * @param liquidatee The account that originally got liquidated\n     * @param amountToGiveToLiquidatee Amount owed to the liquidated account\n     * @param amountToTakeFromInsurance Amount that needs to be taken from the insurance pool\n                                        in order to cover liquidation\n     */\n    function updateAccountsOnClaim(\n        address claimant,\n        int256 amountToGiveToClaimant,\n        address liquidatee,\n        int256 amountToGiveToLiquidatee,\n        int256 amountToTakeFromInsurance\n    ) external override onlyLiquidation {\n        address insuranceAddr = address(insuranceContract);\n        balances[insuranceAddr].position.quote = balances[insuranceAddr].position.quote - amountToTakeFromInsurance;\n        balances[claimant].position.quote = balances[claimant].position.quote + amountToGiveToClaimant;\n        balances[liquidatee].position.quote = balances[liquidatee].position.quote + amountToGiveToLiquidatee;\n        require(balances[insuranceAddr].position.quote >= 0, \"TCR: Insurance not funded enough\");\n    }\n\n    /**\n     * @notice settles an account. Compares current global rate with the users last updated rate\n     *         Updates the accounts margin balance accordingly.\n     * @dev Ensures the account remains in a valid margin position. Will throw if account is under margin\n     *      and the account must then be liquidated.\n     * @param account the address to settle.\n     * @dev This function aggregates data to feed into account.sols settle function which sets\n     */\n    function settle(address account) public override {\n        // Get account and global last updated indexes\n        uint256 accountLastUpdatedIndex = balances[account].lastUpdatedIndex;\n        uint256 currentGlobalFundingIndex = pricingContract.currentFundingIndex();\n        Balances.Account storage accountBalance = balances[account];\n\n        // if this user has no positions, bring them in sync\n        if (accountBalance.position.base == 0) {\n            // set to the last fully established index\n            accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;\n            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n        } else if (accountLastUpdatedIndex + 1 < currentGlobalFundingIndex) {\n            // Only settle account if its last updated index was before the last established\n            // global index this is since we reference the last global index\n            // Get current and global funding statuses\n            uint256 lastEstablishedIndex = currentGlobalFundingIndex - 1;\n            // Note: global rates reference the last fully established rate (hence the -1), and not\n            // the current global rate. User rates reference the last saved user rate\n            Prices.FundingRateInstant memory currGlobalRate = pricingContract.getFundingRate(lastEstablishedIndex);\n            Prices.FundingRateInstant memory currUserRate = pricingContract.getFundingRate(accountLastUpdatedIndex);\n\n            Prices.FundingRateInstant memory currInsuranceGlobalRate = pricingContract.getInsuranceFundingRate(\n                lastEstablishedIndex\n            );\n\n            Prices.FundingRateInstant memory currInsuranceUserRate = pricingContract.getInsuranceFundingRate(\n                accountLastUpdatedIndex\n            );\n\n            // settle the account\n            Balances.Account storage insuranceBalance = balances[address(insuranceContract)];\n\n            accountBalance.position = Prices.applyFunding(accountBalance.position, currGlobalRate, currUserRate);\n\n            // Update account gas price\n            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n\n            if (accountBalance.totalLeveragedValue > 0) {\n                (Balances.Position memory newUserPos, Balances.Position memory newInsurancePos) = Prices.applyInsurance(\n                    accountBalance.position,\n                    insuranceBalance.position,\n                    currInsuranceGlobalRate,\n                    currInsuranceUserRate,\n                    accountBalance.totalLeveragedValue\n                );\n\n                balances[account].position = newUserPos;\n                balances[(address(insuranceContract))].position = newInsurancePos;\n            }\n\n            // Update account index\n            accountBalance.lastUpdatedIndex = lastEstablishedIndex;\n            require(userMarginIsValid(account), \"TCR: Target under-margined\");\n            emit Settled(account, accountBalance.position.quote);\n        }\n    }\n\n    /**\n     * @notice Checks if a given accounts margin is valid\n     * @param account The address of the account whose margin is to be checked\n     * @return true if the margin is valid or false otherwise\n     */\n    function userMarginIsValid(address account) public view returns (bool) {\n        Balances.Account memory accountBalance = balances[account];\n        return\n            Balances.marginIsValid(\n                accountBalance.position,\n                accountBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            );\n    }\n\n    /**\n     * @notice Withdraws the fees taken on trades, and sends them to the designated\n     *         fee receiver (set by the owner of the market)\n     * @dev Anyone can call this function, but fees are transferred to the fee receiver.\n     *      Fees is also subtracted from the total value locked in the market because\n     *      fees are taken out of trades that result in users' quotes being modified, and\n     *      don't otherwise get subtracted from the tvl of the market\n     */\n    function withdrawFees() external override {\n        uint256 tempFees = fees;\n        fees = 0;\n        tvl = tvl - tempFees;\n\n        // Withdraw from the account\n        IERC20(tracerQuoteToken).transfer(feeReceiver, tempFees);\n        emit FeeWithdrawn(feeReceiver, tempFees);\n    }\n\n    function getBalance(address account) external view override returns (Balances.Account memory) {\n        return balances[account];\n    }\n\n    function setLiquidationContract(address _liquidationContract) external override onlyOwner {\n        require(_liquidationContract != address(0), \"address(0) given\");\n        liquidationContract = _liquidationContract;\n    }\n\n    function setInsuranceContract(address insurance) external override onlyOwner {\n        require(insurance != address(0), \"address(0) given\");\n        insuranceContract = IInsurance(insurance);\n    }\n\n    function setPricingContract(address pricing) external override onlyOwner {\n        require(pricing != address(0), \"address(0) given\");\n        pricingContract = IPricing(pricing);\n    }\n\n    function setGasOracle(address _gasOracle) external override onlyOwner {\n        require(_gasOracle != address(0), \"address(0) given\");\n        gasPriceOracle = _gasOracle;\n    }\n\n    function setFeeReceiver(address _feeReceiver) external override onlyOwner {\n        require(_feeReceiver != address(0), \"address(0) given\");\n        feeReceiver = _feeReceiver;\n        emit FeeReceiverUpdated(_feeReceiver);\n    }\n\n    function setFeeRate(uint256 _feeRate) external override onlyOwner {\n        feeRate = _feeRate;\n    }\n\n    function setMaxLeverage(uint256 _maxLeverage) external override onlyOwner {\n        maxLeverage = _maxLeverage;\n    }\n\n    function setFundingRateSensitivity(uint256 _fundingRateSensitivity) external override onlyOwner {\n        fundingRateSensitivity = _fundingRateSensitivity;\n    }\n\n    function setDeleveragingCliff(uint256 _deleveragingCliff) external override onlyOwner {\n        deleveragingCliff = _deleveragingCliff;\n    }\n\n    function setLowestMaxLeverage(uint256 _lowestMaxLeverage) external override onlyOwner {\n        lowestMaxLeverage = _lowestMaxLeverage;\n    }\n\n    function setInsurancePoolSwitchStage(uint256 _insurancePoolSwitchStage) external override onlyOwner {\n        insurancePoolSwitchStage = _insurancePoolSwitchStage;\n    }\n\n    function transferOwnership(address newOwner) public override(Ownable, ITracerPerpetualSwaps) onlyOwner {\n        require(newOwner != address(0), \"address(0) given\");\n        super.transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice allows the owner of a market to set the whitelisting of a trading interface address\n     * @dev a permissioned interface may call the matchOrders function.\n     * @param tradingContract the contract to have its whitelisting permissions set\n     * @param whitelisted the permission of the contract. If true this contract make call makeOrder\n     */\n    function setWhitelist(address tradingContract, bool whitelisted) external onlyOwner {\n        tradingWhitelist[tradingContract] = whitelisted;\n    }\n\n    // Modifier such that only the set liquidation contract can call a function\n    modifier onlyLiquidation() {\n        require(msg.sender == liquidationContract, \"TCR: Sender not liquidation\");\n        _;\n    }\n\n    // Modifier such that only a whitelisted trader can call a function\n    modifier onlyWhitelisted() {\n        require(tradingWhitelist[msg.sender], \"TCR: Contract not whitelisted\");\n        _;\n    }\n}"
    }
  ]
}