{
  "Title": "[C01] Anyone can steal all the TRIBE tokens from the reward pool",
  "Content": "The [`FeiPool` contract](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/FeiPool.sol) allows users [to deposit](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L46) `FEI/TRIBE` liquidity pool (LP) tokens and earn `TRIBE` tokens as a reward. The amount of `TRIBE` that a user can claim is given by the following formula:\n\n\n![](https://i0.wp.com/blog.openzeppelin.com/wp-content/uploads/2021/02/fei-redeemable-reward.png?w=840&ssl=1)\n\n\nWhere `releasedReward` is the total amount of released reward tokens from the total amount available, `redeemablePoolTokens` is the amount of reward tokens that the user can claim, and `totalRedeemablePoolTokens` is the total amount of redeemable pool tokens by all the stakers participating in the pool. Both `redeemablePoolTokens` and `totalRedeemablePoolTokens` increase over time, which means that the more time the user leaves their stake in the pool, the more rewards they will be able to claim.\n\n\nThe issue lies in the fact that `burnFrom` function from the `Pool` contract [allows anyone that holds LP tokens to burn them](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L93) and, therefore, manipulate the [`amountReward` value returned by the `redeemableReward` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L66-L69). An attacker can do the following:\n\n\n1. Deposit an amount of `FEI/TRIBE` LP tokens when the pool opens from two different accounts, `account A` and `account B`.\n2. Let some time pass so that the [numerator in the formula that calculates the `amountReward` value](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L68) equals or is near the [pool’s `rewardBalance`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L89), which includes both the released and unreleased rewards. This will not take much time since the numerator is proportional to the released amount of rewards given by the [`releasedReward` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L71), the number of tokens staked, and the remaining time of the pool.\n3. Burn an amount of `_totalRedeemablePoolTokens - 1` pool tokens from `account B`. This way, the denominator in the formula will equal `1`, and the `amountReward` value returned by the `redeemableReward` function will equal the pool’s `rewardBalance` as calculated in 2.\n4. Withdraw or claim rewards from `account A`.\n5. Wait until the pool closes and withdraw staked tokens from `account B`.\n\n\nSince the `FeiPool` contract [holds 20% of `TRIBE`s total supply](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/orchestration/CoreOrchestrator.sol#L158), the attacker would be stealing 200,000,000 `TRIBE` tokens in the worst case. A step-by-step proof-of-concept exploit for this scenario can be found in [this secret gist](https://gist.github.com/jcarpanelli/ab8d0f8d830df51cf6a10abd58378f60).\n\n\nConsider disallowing external burns by removing the `ERC20Burnable` inheritance from the `Pool` contract, and only allow burning to be an internal operation triggered by claiming rewards.\n\n\n**Update:** *Fixed in [PR#32](https://github.com/fei-protocol/fei-protocol-core/pull/32). The `FeiPool` contract no longer inherits from the `ERC20Burnable` contract. Additionally, the `burnFrom` public function was removed, and a new `_burnFrom` function was added to be used in the `_withdraw` function.*\n\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/pool/Pool.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IPool.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../utils/SafeMath128.sol\";\nimport \"../external/SafeMathCopy.sol\";\nimport \"../external/Decimal.sol\";\n\n/// @title abstract implementation of IPool interface\n/// @author Fei Protocol\nabstract contract Pool is IPool, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\tusing SafeMath128 for uint128;\n\tusing SafeCast for uint;\n\n\tbool internal initialized;\n\n\tIERC20 public override rewardToken;\n\tIERC20 public override stakedToken;\n\n\tuint128 public override claimedRewards;\n\tuint128 public override totalStaked;\n\n    mapping (address => uint) public override stakedBalance;\n\n\t/// @notice Pool constructor\n\t/// @param _duration duration of the pool reward distribution\n\t/// @param _name the name of the pool token\n\t/// @param _ticker the token ticker for the pool token\n\tconstructor(\n\t\tuint32 _duration,\n\t\tstring memory _name,\n\t\tstring memory _ticker\n\t) public ERC20(_name, _ticker) Timed(_duration) {}\n\n\tfunction claim(address from, address to) external override returns(uint amountReward) {\n\t\tamountReward = _claim(from, to);\n\t\temit Claim(from, to, amountReward);\n\t\treturn amountReward;\n\t}\n\n\tfunction deposit(address to, uint amount) external override {\n\t\taddress from = msg.sender;\n\t\t_deposit(from, to, amount);\n\t\temit Deposit(from, to, amount);\n\t}\n\n\tfunction withdraw(address to) external override returns(uint amountStaked, uint amountReward) {\n\t\taddress from = msg.sender;\n\t\tamountReward = _claim(from, to);\n\t\tamountStaked = _withdraw(from, to);\n\t\temit Withdraw(from, to, amountStaked, amountReward);\n\t\treturn (amountStaked, amountReward);\n\t}\n\n\tfunction init() public override virtual {\n\t\trequire(!initialized, \"Pool: Already initialized\");\n\t\t_initTimed();\n\t\tinitialized = true;\n\t}\n\n    function redeemableReward(address account) public view override returns(uint amountReward, uint amountPool) {\n\t\tamountPool = _redeemablePoolTokens(account);\n\t\treturn (releasedReward() * amountPool / _totalRedeemablePoolTokens(), amountPool);\n    }\n\n\tfunction releasedReward() public view override returns (uint) {\n\t\tuint total = rewardBalance();\n\t\tuint unreleased = unreleasedReward();\n\t\trequire(total >= unreleased, \"Pool: Released Reward underflow\");\n\t\treturn total - unreleased;\n\t}\n\n\tfunction unreleasedReward() public view override returns (uint) {\n\t\tif (isTimeEnded()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn _unreleasedReward(totalReward(), uint(duration), uint(timestamp()));\n\t}\n\n\tfunction totalReward() public view override returns (uint) {\n\t\treturn rewardBalance() + uint(claimedRewards);\n\t}\n\n\tfunction rewardBalance() public view override returns (uint) {\n\t\treturn rewardToken.balanceOf(address(this));\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _totalRedeemablePoolTokens() internal view returns(uint) {\n\t\tuint total = totalSupply();\n\t\tuint balance = _twfb(uint(totalStaked));\n\t\trequire(total >= balance, \"Pool: Total redeemable underflow\");\n\t\treturn total - balance;\n\t}\n\n\tfunction _redeemablePoolTokens(address account) internal view returns(uint) {\n\t\tuint total = balanceOf(account);\n\t\tuint balance = _twfb(stakedBalance[account]);\n\t\trequire(total >= balance, \"Pool: Redeemable underflow\");\n\t\treturn total - balance;\n\t}\n\n\tfunction _unreleasedReward(uint _totalReward, uint _duration, uint _time) internal view virtual returns (uint);\n\n\tfunction _deposit(address from, address to, uint amount) internal {\n\t\trequire(initialized, \"Pool: Uninitialized\");\n\t\trequire(amount <= stakedToken.balanceOf(from), \"Pool: Balance too low to stake\");\n\n\t\tstakedToken.transferFrom(from, address(this), amount);\n\n\t\tstakedBalance[to] += amount;\n\t\t_incrementStaked(amount);\n\t\t\n\t\tuint poolTokens = _twfb(amount);\n\t\trequire(poolTokens != 0, \"Pool: Window has ended\");\n\n\t\t_mint(to, poolTokens);\n\t}\n\n\tfunction _withdraw(address from, address to) internal returns(uint amountStaked) {\n\t\tamountStaked = stakedBalance[from];\n\t\tstakedBalance[from] = 0;\n\t\tstakedToken.transfer(to, amountStaked);\n\n\t\tuint amountPool = balanceOf(from);\n\t\tif (amountPool != 0) {\n\t\t\t_burn(from, amountPool);\n\t\t}\n\t\treturn amountStaked;\t\n\t}\n\n\tfunction _claim(address from, address to) internal returns(uint) {\n\t\t(uint amountReward, uint amountPool) = redeemableReward(from);\n\t\trequire(amountPool != 0, \"Pool: User has no redeemable pool tokens\");\n\n\t\tburnFrom(from, amountPool);\n\t\t_incrementClaimed(amountReward);\n\n\t\trewardToken.transfer(to, amountReward);\n\t\treturn amountReward;\n\t}\n\n\tfunction _incrementClaimed(uint amount) internal {\n\t\tclaimedRewards = claimedRewards.add(amount.toUint128());\n\t}\n\n\tfunction _incrementStaked(uint amount) internal {\n\t\ttotalStaked = totalStaked.add(amount.toUint128());\n\t}\n\n\tfunction _twfb(uint amount) internal view returns(uint) {\n\t\treturn amount * uint(remainingTime());\n\t}\n\n\t// Updates stored staked balance pro-rata for transfer and transferFrom\n\tfunction _beforeTokenTransfer(address from, address to, uint amount) internal override {\n        if (from != address(0) && to != address(0)) {\n \t\t\tDecimal.D256 memory ratio = Decimal.ratio(amount, balanceOf(from));\n \t\t\tuint amountStaked = ratio.mul(stakedBalance[from]).asUint256();\n\t\t\t\n \t\t\tstakedBalance[from] -= amountStaked;\n \t\t\tstakedBalance[to] += amountStaked;\n        }\n    }\n\n\tfunction _setTokens(address _rewardToken, address _stakedToken) internal {\n\t\trewardToken = IERC20(_rewardToken);\n\t\tstakedToken = IERC20(_stakedToken);\t\n\t}\n}"
    },
    {
      "filename": "contracts/pool/Pool.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IPool.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../utils/SafeMath128.sol\";\nimport \"../external/SafeMathCopy.sol\";\nimport \"../external/Decimal.sol\";\n\n/// @title abstract implementation of IPool interface\n/// @author Fei Protocol\nabstract contract Pool is IPool, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\tusing SafeMath128 for uint128;\n\tusing SafeCast for uint;\n\n\tbool internal initialized;\n\n\tIERC20 public override rewardToken;\n\tIERC20 public override stakedToken;\n\n\tuint128 public override claimedRewards;\n\tuint128 public override totalStaked;\n\n    mapping (address => uint) public override stakedBalance;\n\n\t/// @notice Pool constructor\n\t/// @param _duration duration of the pool reward distribution\n\t/// @param _name the name of the pool token\n\t/// @param _ticker the token ticker for the pool token\n\tconstructor(\n\t\tuint32 _duration,\n\t\tstring memory _name,\n\t\tstring memory _ticker\n\t) public ERC20(_name, _ticker) Timed(_duration) {}\n\n\tfunction claim(address from, address to) external override returns(uint amountReward) {\n\t\tamountReward = _claim(from, to);\n\t\temit Claim(from, to, amountReward);\n\t\treturn amountReward;\n\t}\n\n\tfunction deposit(address to, uint amount) external override {\n\t\taddress from = msg.sender;\n\t\t_deposit(from, to, amount);\n\t\temit Deposit(from, to, amount);\n\t}\n\n\tfunction withdraw(address to) external override returns(uint amountStaked, uint amountReward) {\n\t\taddress from = msg.sender;\n\t\tamountReward = _claim(from, to);\n\t\tamountStaked = _withdraw(from, to);\n\t\temit Withdraw(from, to, amountStaked, amountReward);\n\t\treturn (amountStaked, amountReward);\n\t}\n\n\tfunction init() public override virtual {\n\t\trequire(!initialized, \"Pool: Already initialized\");\n\t\t_initTimed();\n\t\tinitialized = true;\n\t}\n\n    function redeemableReward(address account) public view override returns(uint amountReward, uint amountPool) {\n\t\tamountPool = _redeemablePoolTokens(account);\n\t\treturn (releasedReward() * amountPool / _totalRedeemablePoolTokens(), amountPool);\n    }\n\n\tfunction releasedReward() public view override returns (uint) {\n\t\tuint total = rewardBalance();\n\t\tuint unreleased = unreleasedReward();\n\t\trequire(total >= unreleased, \"Pool: Released Reward underflow\");\n\t\treturn total - unreleased;\n\t}\n\n\tfunction unreleasedReward() public view override returns (uint) {\n\t\tif (isTimeEnded()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn _unreleasedReward(totalReward(), uint(duration), uint(timestamp()));\n\t}\n\n\tfunction totalReward() public view override returns (uint) {\n\t\treturn rewardBalance() + uint(claimedRewards);\n\t}\n\n\tfunction rewardBalance() public view override returns (uint) {\n\t\treturn rewardToken.balanceOf(address(this));\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _totalRedeemablePoolTokens() internal view returns(uint) {\n\t\tuint total = totalSupply();\n\t\tuint balance = _twfb(uint(totalStaked));\n\t\trequire(total >= balance, \"Pool: Total redeemable underflow\");\n\t\treturn total - balance;\n\t}\n\n\tfunction _redeemablePoolTokens(address account) internal view returns(uint) {\n\t\tuint total = balanceOf(account);\n\t\tuint balance = _twfb(stakedBalance[account]);\n\t\trequire(total >= balance, \"Pool: Redeemable underflow\");\n\t\treturn total - balance;\n\t}\n\n\tfunction _unreleasedReward(uint _totalReward, uint _duration, uint _time) internal view virtual returns (uint);\n\n\tfunction _deposit(address from, address to, uint amount) internal {\n\t\trequire(initialized, \"Pool: Uninitialized\");\n\t\trequire(amount <= stakedToken.balanceOf(from), \"Pool: Balance too low to stake\");\n\n\t\tstakedToken.transferFrom(from, address(this), amount);\n\n\t\tstakedBalance[to] += amount;\n\t\t_incrementStaked(amount);\n\t\t\n\t\tuint poolTokens = _twfb(amount);\n\t\trequire(poolTokens != 0, \"Pool: Window has ended\");\n\n\t\t_mint(to, poolTokens);\n\t}\n\n\tfunction _withdraw(address from, address to) internal returns(uint amountStaked) {\n\t\tamountStaked = stakedBalance[from];\n\t\tstakedBalance[from] = 0;\n\t\tstakedToken.transfer(to, amountStaked);\n\n\t\tuint amountPool = balanceOf(from);\n\t\tif (amountPool != 0) {\n\t\t\t_burn(from, amountPool);\n\t\t}\n\t\treturn amountStaked;\t\n\t}\n\n\tfunction _claim(address from, address to) internal returns(uint) {\n\t\t(uint amountReward, uint amountPool) = redeemableReward(from);\n\t\trequire(amountPool != 0, \"Pool: User has no redeemable pool tokens\");\n\n\t\tburnFrom(from, amountPool);\n\t\t_incrementClaimed(amountReward);\n\n\t\trewardToken.transfer(to, amountReward);\n\t\treturn amountReward;\n\t}\n\n\tfunction _incrementClaimed(uint amount) internal {\n\t\tclaimedRewards = claimedRewards.add(amount.toUint128());\n\t}\n\n\tfunction _incrementStaked(uint amount) internal {\n\t\ttotalStaked = totalStaked.add(amount.toUint128());\n\t}\n\n\tfunction _twfb(uint amount) internal view returns(uint) {\n\t\treturn amount * uint(remainingTime());\n\t}\n\n\t// Updates stored staked balance pro-rata for transfer and transferFrom\n\tfunction _beforeTokenTransfer(address from, address to, uint amount) internal override {\n        if (from != address(0) && to != address(0)) {\n \t\t\tDecimal.D256 memory ratio = Decimal.ratio(amount, balanceOf(from));\n \t\t\tuint amountStaked = ratio.mul(stakedBalance[from]).asUint256();\n\t\t\t\n \t\t\tstakedBalance[from] -= amountStaked;\n \t\t\tstakedBalance[to] += amountStaked;\n        }\n    }\n\n\tfunction _setTokens(address _rewardToken, address _stakedToken) internal {\n\t\trewardToken = IERC20(_rewardToken);\n\t\tstakedToken = IERC20(_stakedToken);\t\n\t}\n}"
    },
    {
      "filename": "contracts/orchestration/CoreOrchestrator.sol",
      "content": "pragma solidity ^0.6.0;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../token/IUniswapIncentive.sol\";\nimport \"../token/IFei.sol\";\nimport \"../refs/IOracleRef.sol\";\nimport \"../core/Core.sol\";\n\ninterface IPCVDepositOrchestrator {\n\tfunction init(\n\t\taddress core, \n\t\taddress pair, \n\t\taddress router,\n\t\taddress oraclePair,\n\t\tuint32 twapDuration,\n\t\tbool price0\n\t) external returns(\n\t\taddress ethUniswapPCVDeposit,\n\t\taddress uniswapOracle\n\t);\n\n\tfunction detonate() external;\n}\n\ninterface IBondingCurveOrchestrator {\n\tfunction init(\n\t\taddress core, \n\t\taddress uniswapOracle, \n\t\taddress ethUniswapPCVDeposit, \n\t\tuint scale,\n\t\tuint32 thawingDuration,\n\t\tuint32 bondingCurveIncentiveDuration,\n\t\tuint bondingCurveIncentiveAmount\n\t) external returns(\n\t\taddress ethBondingCurve,\n\t\taddress bondingCurveOracle\n\t);\n\n\tfunction detonate() external;\n}\n\ninterface IIncentiveOrchestrator {\n\tfunction init(\n\t\taddress core, \n\t\taddress bondingCurveOracle, \n\t\taddress fei, \n\t\taddress router,\n\t\tuint32 growthRate\n\t) external returns(address uniswapIncentive);\n\tfunction detonate() external;\n}\n\ninterface IControllerOrchestrator {\n\tfunction init(\n\t\taddress core, \n\t\taddress bondingCurveOracle, \n\t\taddress uniswapIncentive, \n\t\taddress ethUniswapPCVDeposit, \n\t\taddress fei, \n\t\taddress router,\n\t\tuint reweightIncentive,\n\t\tuint reweightMinDistanceBPs\n\t) external returns(address ethUniswapPCVController);\n\tfunction detonate() external;\n}\n\ninterface IIDOOrchestrator {\n\tfunction init(\n\t\taddress core, \n\t\taddress admin, \n\t\taddress tribe, \n\t\taddress pair, \n\t\taddress router,\n\t\tuint32 releaseWindow\n\t) external returns (\n\t\taddress ido,\n\t\taddress timelockedDelegator\n\t);\n\tfunction detonate() external;\n}\n\ninterface IGenesisOrchestrator {\n\tfunction init(\n\t\taddress core, \n\t\taddress ethBondingCurve, \n\t\taddress ido,\n\t\taddress tribeFeiPair,\n\t\taddress oracle,\n\t\tuint32 genesisDuration,\n\t\tuint maxPriceBPs,\n\t\tuint exhangeRateDiscount,\n\t\tuint32 poolDuration\n\t) external returns (address genesisGroup, address pool);\n\tfunction detonate() external;\n}\n\ninterface IGovernanceOrchestrator {\n\tfunction init(address admin, address tribe, uint timelockDelay) external returns (\n\t\taddress governorAlpha, \n\t\taddress timelock\n\t);\n\tfunction detonate() external;\n}\n\ninterface ITribe {\n\tfunction setMinter(address minter_) external;\n}\n\n// solhint-disable-next-line max-states-count\ncontract CoreOrchestrator is Ownable {\n\taddress public admin;\n\tbool private constant TEST_MODE = true;\n\n\t// ----------- Uniswap Addresses -----------\n\taddress public constant ETH_USDC_UNI_PAIR = address(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n\taddress public constant ROUTER = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n\taddress public constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\tIUniswapV2Factory public constant UNISWAP_FACTORY = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n\n\taddress public ethFeiPair;\n\taddress public tribeFeiPair;\n\n\t// ----------- Time periods -----------\n\tuint32 constant public RELEASE_WINDOW = TEST_MODE ? 4 days : 4 * 365 days;\n\n\tuint public constant TIMELOCK_DELAY = TEST_MODE ? 1 hours : 3 days;\n\tuint32 public constant GENESIS_DURATION = TEST_MODE ? 1 minutes : 3 days;\n\n\tuint32 public constant POOL_DURATION = TEST_MODE ? 2 days : 2 * 365 days;\n\tuint32 public constant THAWING_DURATION = TEST_MODE ? 4 minutes : 4 weeks;\n\n\tuint32 public constant UNI_ORACLE_TWAP_DURATION = TEST_MODE ? 1 : 10 minutes; // 10 min twap\n\n\tuint32 public constant BONDING_CURVE_INCENTIVE_DURATION = TEST_MODE ? 1 : 1 days; // 1 day duration\n\n\t// ----------- Params -----------\n\tuint public constant MAX_GENESIS_PRICE_BPS = 9000;\n\tuint public constant EXCHANGE_RATE_DISCOUNT = 10;\n\n\tuint32 public constant INCENTIVE_GROWTH_RATE = TEST_MODE ? 1_000_000 : 333; // about 1 unit per hour assuming 12s block time\n\n\tuint public constant SCALE = 250_000_000e18;\n\tuint public constant BONDING_CURVE_INCENTIVE = 500e18;\n\n\tuint public constant REWEIGHT_INCENTIVE = 500e18;\n\tuint public constant MIN_REWEIGHT_DISTANCE_BPS = 100;\n\n\tbool public constant USDC_PER_ETH_IS_PRICE_0 = true;\n\n\n\tuint public tribeSupply;\n\tuint public constant IDO_TRIBE_PERCENTAGE = 20;\n\tuint public constant GENESIS_TRIBE_PERCENTAGE = 10;\n\tuint public constant DEV_TRIBE_PERCENTAGE = 20;\n\tuint public constant STAKING_TRIBE_PERCENTAGE = 20;\n\n\t// ----------- Orchestrators -----------\n\tIPCVDepositOrchestrator private pcvDepositOrchestrator;\n\tIBondingCurveOrchestrator private bcOrchestrator;\n\tIIncentiveOrchestrator private incentiveOrchestrator;\n\tIControllerOrchestrator private controllerOrchestrator;\n\tIIDOOrchestrator private idoOrchestrator;\n\tIGenesisOrchestrator private genesisOrchestrator;\n\tIGovernanceOrchestrator private governanceOrchestrator;\n\t\n\t// ----------- Deployed Contracts -----------\n\tCore public core;\n\taddress public fei;\n\taddress public tribe;\n\n\taddress public ethUniswapPCVDeposit;\n\taddress public ethBondingCurve;\n\t\t\n\taddress public uniswapOracle;\n\taddress public bondingCurveOracle;\n\n\taddress public uniswapIncentive;\n\n\taddress public ethUniswapPCVController;\n\n\taddress public ido;\n\taddress public timelockedDelegator;\n\n\taddress public genesisGroup;\n\taddress public pool;\n\n\taddress public governorAlpha;\n\taddress public timelock;\n\n\tconstructor(\n\t\taddress _pcvDepositOrchestrator,\n\t\taddress _bcOrchestrator, \n\t\taddress _incentiveOrchestrator, \n\t\taddress _controllerOrchestrator,\n\t\taddress _idoOrchestrator,\n\t\taddress _genesisOrchestrator, \n\t\taddress _governanceOrchestrator,\n\t\taddress _admin\n\t) public {\n\t\tcore = new Core();\n\t\ttribe = address(core.tribe());\n\t\tfei = address(core.fei());\n\n\t\tcore.grantRevoker(_admin);\n\n\t\tpcvDepositOrchestrator = IPCVDepositOrchestrator(_pcvDepositOrchestrator);\n\t\tbcOrchestrator = IBondingCurveOrchestrator(_bcOrchestrator);\n\t\tincentiveOrchestrator = IIncentiveOrchestrator(_incentiveOrchestrator);\n\t\tidoOrchestrator = IIDOOrchestrator(_idoOrchestrator);\n\t\tcontrollerOrchestrator = IControllerOrchestrator(_controllerOrchestrator);\n\t\tgenesisOrchestrator = IGenesisOrchestrator(_genesisOrchestrator);\n\t\tgovernanceOrchestrator = IGovernanceOrchestrator(_governanceOrchestrator);\n\n\t\tadmin = _admin;\n\t\ttribeSupply = IERC20(tribe).totalSupply();\n\t\tif (TEST_MODE) {\n\t\t\tcore.grantGovernor(_admin);\n\t\t}\n\t}\n\n\tfunction initPairs() public onlyOwner {\n\t\tethFeiPair = UNISWAP_FACTORY.createPair(fei, WETH);\n\t\ttribeFeiPair = UNISWAP_FACTORY.createPair(tribe, fei);\n\t}\n\n\tfunction initPCVDeposit() public onlyOwner() {\n\t\t(ethUniswapPCVDeposit, uniswapOracle) = pcvDepositOrchestrator.init(\n\t\t\taddress(core),\n\t\t\tethFeiPair,\n\t\t\tROUTER,\n\t\t\tETH_USDC_UNI_PAIR,\n\t\t\tUNI_ORACLE_TWAP_DURATION,\n\t\t\tUSDC_PER_ETH_IS_PRICE_0\n\t\t);\n\t\tcore.grantMinter(ethUniswapPCVDeposit);\n\t\tpcvDepositOrchestrator.detonate();\n\t}\n\n\tfunction initBondingCurve() public onlyOwner {\n\t\t(ethBondingCurve,\n\t\t bondingCurveOracle) = bcOrchestrator.init(\n\t\t\t address(core), \n\t\t\t uniswapOracle, \n\t\t\t ethUniswapPCVDeposit, \n\t\t\t SCALE, \n\t\t\t THAWING_DURATION,\n\t\t\t BONDING_CURVE_INCENTIVE_DURATION,\n\t\t\t BONDING_CURVE_INCENTIVE\n\t\t);\n\t\tcore.grantMinter(ethBondingCurve);\n\t\tIOracleRef(ethUniswapPCVDeposit).setOracle(bondingCurveOracle);\n\t\tbcOrchestrator.detonate();\n\t}\n\n\tfunction initIncentive() public onlyOwner {\n\t\tuniswapIncentive = incentiveOrchestrator.init(\n\t\t\taddress(core), \n\t\t\tbondingCurveOracle, \n\t\t\tethFeiPair,\n\t\t\tROUTER,\n\t\t\tINCENTIVE_GROWTH_RATE\n\t\t);\n\t\tcore.grantMinter(uniswapIncentive);\n\t\tcore.grantBurner(uniswapIncentive);\n\t\tIFei(fei).setIncentiveContract(ethFeiPair, uniswapIncentive);\n\t\tincentiveOrchestrator.detonate();\n\t}\n\n\tfunction initController() public onlyOwner {\n\t\tethUniswapPCVController = controllerOrchestrator.init(\n\t\t\taddress(core), \n\t\t\tbondingCurveOracle, \n\t\t\tuniswapIncentive, \n\t\t\tethUniswapPCVDeposit, \n\t\t\tethFeiPair,\n\t\t\tROUTER,\n\t\t\tREWEIGHT_INCENTIVE,\n\t\t\tMIN_REWEIGHT_DISTANCE_BPS\n\t\t);\n\t\tcore.grantMinter(ethUniswapPCVController);\n\t\tcore.grantPCVController(ethUniswapPCVController);\n\t\tIUniswapIncentive(uniswapIncentive).setExemptAddress(ethUniswapPCVDeposit, true);\n\t\tIUniswapIncentive(uniswapIncentive).setExemptAddress(ethUniswapPCVController, true);\n\t\tcontrollerOrchestrator.detonate();\n\t}\n\n\tfunction initIDO() public onlyOwner {\n\t\t(ido, timelockedDelegator) = idoOrchestrator.init(address(core), admin, tribe, tribeFeiPair, ROUTER, RELEASE_WINDOW);\n\t\tcore.grantMinter(ido);\n\t\tcore.allocateTribe(ido, tribeSupply * IDO_TRIBE_PERCENTAGE / 100);\n\t\tcore.allocateTribe(timelockedDelegator, tribeSupply * DEV_TRIBE_PERCENTAGE / 100);\n\t\tidoOrchestrator.detonate();\n\t}\n\n\tfunction initGenesis() public onlyOwner {\n\t\t(genesisGroup, pool) = genesisOrchestrator.init(\n\t\t\taddress(core), \n\t\t\tethBondingCurve, \n\t\t\tido,\n\t\t\ttribeFeiPair,\n\t\t\tbondingCurveOracle,\n\t\t\tGENESIS_DURATION,\n\t\t\tMAX_GENESIS_PRICE_BPS,\n\t\t\tEXCHANGE_RATE_DISCOUNT,\n\t\t\tPOOL_DURATION\n\t\t);\n\t\tcore.setGenesisGroup(genesisGroup);\n\t\tcore.allocateTribe(genesisGroup, tribeSupply * GENESIS_TRIBE_PERCENTAGE / 100);\n\t\tcore.allocateTribe(pool, tribeSupply * STAKING_TRIBE_PERCENTAGE / 100);\n\t\tgenesisOrchestrator.detonate();\n\t}\n\n\tfunction initGovernance() public onlyOwner {\n\t\t(governorAlpha, timelock) = governanceOrchestrator.init(\n\t\t\tadmin, \n\t\t\ttribe,\n\t\t\tTIMELOCK_DELAY\n\t\t);\n\t\tgovernanceOrchestrator.detonate();\n\t\tcore.grantGovernor(timelock);\n\t\tITribe(tribe).setMinter(timelock);\n\t}\n}"
    }
  ]
}