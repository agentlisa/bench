{
  "Title": "[M-05] Missing slippage protection in `liquidity_lockbox::withdraw`",
  "Content": "\nVanilla example of missing slippage protection.\n\n### Proof of Concept\n\nAs any AMM, Orca implements slippage protections by letting the caller specify the minimum amount of input and output tokens to be used in a given operation, so that if the transaction outputs a value less than the expected ones, it will revert preventing users from incurring in unacceptable losses.\n\nIn our situation, we are interested in the `decreaseLiquidity` handler:\n\n[**decrease_liquidity, lines 18 and 19**](https://github.com/orca-so/whirlpools/blob/3206c9cdfbf27c73c30cbcf5b6df2929cbf87618/programs/whirlpool/src/instructions/decrease_liquidity.rs#L18C1-L19C22)\n\n```rs\npub fn handler(\n    ctx: Context<ModifyLiquidity>,\n    liquidity_amount: u128,\n    token_min_a: u64,\n    token_min_b: u64,\n) -> Result<()> {\n    \n    ...\n\n    let (delta_a, delta_b) = calculate_liquidity_token_deltas(\n        ctx.accounts.whirlpool.tick_current_index,\n        ctx.accounts.whirlpool.sqrt_price,\n        &ctx.accounts.position,\n        liquidity_delta,\n    )?;\n\n    if delta_a < token_min_a {\n        return Err(ErrorCode::TokenMinSubceeded.into());\n    } else if delta_b < token_min_b {\n        return Err(ErrorCode::TokenMinSubceeded.into());\n    }\n\n    ...\n}\n```\n\nThe code snippet above calculates the delta variations of the two tokens amount in the given pool and reverts the whole transaction if the calculated amounts are less than the specified ones. However, if we go to:\n\n[**liquidity_lockbox, function withdraw**](https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/liquidity_lockbox.sol#L277)\n\n```solidity\n        ...\n\n        whirlpool.decreaseLiquidity{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(amount, 0, 0);\n\n        ...\n```\n\nWe see that `token_min_a` and `token_min_b` are hard-coded to $0$, meaning that the liquidity decrease operation will accept **ANY** amount in exchange, even $0$, leading to a loss of funds as MEV exists in Solana too (see [here](https://explorer.jito.wtf/)). The mathematical reason is that:\n\n$$x >= 0, \\forall x \\in \\[0, 2⁶⁴-1]$$\n\nSo the errors:\n\n```rs\n    if delta_a < token_min_a {\n        return Err(ErrorCode::TokenMinSubceeded.into());\n    } else if delta_b < token_min_b {\n        return Err(ErrorCode::TokenMinSubceeded.into());\n    }\n```\n\nWon't be triggered as:\n\n```rs\n    if delta_a < token_min_a { // @audit delta_a < 0 => false for all delta_a, so no error\n        return Err(ErrorCode::TokenMinSubceeded.into());\n    } else if delta_b < token_min_b { // @audit delta_b < 0 => false for al delta_b, so no error\n        return Err(ErrorCode::TokenMinSubceeded.into());\n    }\n\n    // @audit if token_min_a = token_min_b = 0, then delta_a and delta_b can be ANY value, \n    // @audit even 0, which means total loss of funds is possible\n```\n\nMeaning there is no slippage protection at all if called with `token_min_a = token_min_b = 0` (as it's the case with `liquidity_lockbock::withdraw`).\n\n### Recommended Mitigation Steps\n\nLet users provide the minimum amount of tokens they are willing to use as function arguments and pass them straight to `decreaseLiquidity` like:\n\n```diff\n-   function withdraw(uint64 amount) external {\n+   function withdraw(uint64 amount, uint64 minA, uint64 minB) external {\n        \n        ...\n\n-       whirlpool.decreaseLiquidity{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(amount, 0, 0);\n+       whirlpool.decreaseLiquidity{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(amount, minA, minB);\n\n        ...\n}\n```\n\n**[mariapiamo (Olas) confirmed, but disagreed with severity](https://github.com/code-423n4/2023-12-autonolas-findings/issues/339#issuecomment-1892161285)**\n\n**[LSDan (Judge) decreased severity to Medium](https://github.com/code-423n4/2023-12-autonolas-findings/issues/339#issuecomment-1901089282)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "programs/whirlpool/src/instructions/decrease_liquidity.rs",
      "content": "use anchor_lang::prelude::*;\n\nuse crate::errors::ErrorCode;\nuse crate::manager::liquidity_manager::{\n    calculate_liquidity_token_deltas, calculate_modify_liquidity, sync_modify_liquidity_values,\n};\nuse crate::math::convert_to_liquidity_delta;\nuse crate::util::{to_timestamp_u64, transfer_from_vault_to_owner, verify_position_authority};\n\nuse super::ModifyLiquidity;\n\n/*\n  Removes liquidity from an existing Whirlpool Position.\n*/\npub fn handler(\n    ctx: Context<ModifyLiquidity>,\n    liquidity_amount: u128,\n    token_min_a: u64,\n    token_min_b: u64,\n) -> Result<()> {\n    verify_position_authority(\n        &ctx.accounts.position_token_account,\n        &ctx.accounts.position_authority,\n    )?;\n\n    let clock = Clock::get()?;\n\n    if liquidity_amount == 0 {\n        return Err(ErrorCode::LiquidityZero.into());\n    }\n    let liquidity_delta = convert_to_liquidity_delta(liquidity_amount, false)?;\n    let timestamp = to_timestamp_u64(clock.unix_timestamp)?;\n\n    let update = calculate_modify_liquidity(\n        &ctx.accounts.whirlpool,\n        &ctx.accounts.position,\n        &ctx.accounts.tick_array_lower,\n        &ctx.accounts.tick_array_upper,\n        liquidity_delta,\n        timestamp,\n    )?;\n\n    sync_modify_liquidity_values(\n        &mut ctx.accounts.whirlpool,\n        &mut ctx.accounts.position,\n        &ctx.accounts.tick_array_lower,\n        &ctx.accounts.tick_array_upper,\n        update,\n        timestamp,\n    )?;\n\n    let (delta_a, delta_b) = calculate_liquidity_token_deltas(\n        ctx.accounts.whirlpool.tick_current_index,\n        ctx.accounts.whirlpool.sqrt_price,\n        &ctx.accounts.position,\n        liquidity_delta,\n    )?;\n\n    if delta_a < token_min_a {\n        return Err(ErrorCode::TokenMinSubceeded.into());\n    } else if delta_b < token_min_b {\n        return Err(ErrorCode::TokenMinSubceeded.into());\n    }\n\n    transfer_from_vault_to_owner(\n        &ctx.accounts.whirlpool,\n        &ctx.accounts.token_vault_a,\n        &ctx.accounts.token_owner_account_a,\n        &ctx.accounts.token_program,\n        delta_a,\n    )?;\n\n    transfer_from_vault_to_owner(\n        &ctx.accounts.whirlpool,\n        &ctx.accounts.token_vault_b,\n        &ctx.accounts.token_owner_account_b,\n        &ctx.accounts.token_program,\n        delta_b,\n    )?;\n\n    Ok(())\n}"
    },
    {
      "filename": "lockbox-solana/solidity/liquidity_lockbox.sol",
      "content": "import \"./library/spl_token.sol\";\nimport \"./interfaces/whirlpool.sol\";\n\n// Position struct\nstruct Position {\n    // Whirlpool (LP pool) address, 32 bytes\n    address whirlpool;\n    // Position mint (liquidity NFT) address, 32 bytes\n    address positionMint;\n    // Position liquidity, 16 bytes\n    uint128 liquidity;\n    // Tick lower index, 4 bytes\n    int32 tickLowerIndex;\n    /// Tick upper index, 4 bytes\n    int32 tickUpperIndex;\n}\n\n/// @dev The liquidity in the position cannot be practically bigger than the max of uint64 since\n///      spl token functions are limited by the uint64 value.\n\n@program_id(\"GUGGHzwC8wEKY3g7QS38YmoS8t5Q2faWAGAfxDK2bXbb\")\ncontract liquidity_lockbox {\n    // Orca whirlpool program address\n    address public constant orca = address\"whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc\";\n    // Whirlpool (LP) pool address\n    address public pool;\n    // Current program owned PDA account address\n    address public pdaProgram;\n    // Bridged token mint address\n    address public bridgedTokenMint;\n    // PDA bridged token account address\n    address public pdaBridgedTokenAccount;\n    // PDA header for position account\n    uint64 public pdaHeader = 0xd0f7407ae48fbcaa;\n    // Program PDA seed\n    bytes public constant pdaProgramSeed = \"pdaProgram\";\n    // Program PDA bump\n    bytes1 public pdaBump;\n    int32 public constant minTickLowerIndex = -443632;\n    int32 public constant maxTickLowerIndex = 443632;\n\n    // Total number of token accounts (even those that hold no positions anymore)\n    uint32 public numPositionAccounts;\n    // First available account index in the set of accounts;\n    uint32 public firstAvailablePositionAccountIndex;\n    // Total liquidity in a lockbox\n    uint64 public totalLiquidity;\n\n    //\n    mapping(address => uint64) public mapPositionAccountLiquidity;\n    mapping(address => address) public mapPositionAccountPdaAta;\n    address[type(uint32).max] public positionAccounts;\n\n    @space(10000)\n    @payer(payer)\n    @seed(\"pdaProgram\")\n    constructor(\n        address _pool,\n        address _bridgedTokenMint,\n        address _pdaBridgedTokenAccount,\n        @bump bytes1 _bump\n    ) {\n        pool = _pool;\n        bridgedTokenMint = _bridgedTokenMint;\n        pdaBridgedTokenAccount = _pdaBridgedTokenAccount;\n\n        // Independently derive the PDA address from the seeds, bump, and programId\n        (address pda, bytes1 bump) = try_find_program_address([\"pdaProgram\"], type(liquidity_lockbox).program_id);\n\n        // Verify that the bump passed to the constructor matches the bump derived from the seeds and programId\n        if (bump != _bump) {\n            revert(\"Invalid bump\");\n        }\n\n        // Assign pda and bump\n        pdaProgram = pda;\n        pdaBump = bump;\n    }\n\n    /// @dev Gets the position data.\n    /// @param position Position account.\n    /// @param positionMint Position mint (NFT).\n    /// @return positionData Position data.\n    function _getPositionData(AccountInfo position, address positionMint) internal view returns (Position positionData) {\n        // Extract the position data\n        positionData = Position({\n            whirlpool: position.data.readAddress(8),\n            positionMint: position.data.readAddress(40),\n            liquidity: position.data.readUint128LE(72),\n            tickLowerIndex: position.data.readInt32LE(88),\n            tickUpperIndex: position.data.readInt32LE(92)\n        });\n\n        // Check that the liquidity is within uint64 bounds\n        if (positionData.liquidity > type(uint64).max) {\n            revert(\"Liquidity overflow\");\n        }\n\n        // Check the whirlpool\n        if (positionData.whirlpool != pool) {\n            revert(\"Wrong pool address\");\n        }\n\n        // Check the NFT address\n        if (positionData.positionMint != positionMint) {\n            revert(\"Wrong NFT address\");\n        }\n\n        // Check tick values\n        if (positionData.tickLowerIndex != minTickLowerIndex || positionData.tickUpperIndex != maxTickLowerIndex) {\n            revert(\"Wrong ticks\");\n        }\n\n        // Check the PDA ownership\n        if (position.owner != orca) {\n            revert(\"Wrong PDA owner\");\n        }\n\n        // Check the PDA header data\n        uint64 header = position.data.readUint64LE(0);\n        if (header != pdaHeader) {\n            revert(\"Wrong PDA header\");\n        }\n\n        // Check the PDA address correctness\n        (address pdaPosition, ) = try_find_program_address([\"position\", positionData.positionMint], orca);\n        if (pdaPosition != position.key) {\n            revert(\"Wrong position PDA\");\n        }\n    }\n\n    /// @dev Deposits the position mint (NFT) in order to get a corresponding liquidity amount of bridged tokens\n    @mutableAccount(userPositionAccount)\n    @mutableAccount(pdaPositionAccount)\n    @mutableAccount(userBridgedTokenAccount)\n    @mutableAccount(bridgedTokenMint)\n    @account(position)\n    @account(positionMint)\n    @signer(userWallet)\n    function deposit() external {\n        // Get the position data based on provided accounts\n        Position positionData = _getPositionData(tx.accounts.position, tx.accounts.positionMint.key);\n\n        uint64 positionLiquidity = uint64(positionData.liquidity);\n\n        // Check that the mint of the user position ATA matches the position mint\n        address positionMint = tx.accounts.userPositionAccount.data.readAddress(0);\n        if (positionMint != tx.accounts.positionMint.key) {\n            revert(\"Wrong user position ATA\");\n        }\n\n        // Check that the bridged token mint account is correct\n        if (tx.accounts.bridgedTokenMint.key != bridgedTokenMint) {\n            revert(\"Wrong bridged token mint account\");\n        }\n\n        // PDA position account owner must be the PDA program account\n        address pdaPositionOwner = tx.accounts.pdaPositionAccount.data.readAddress(32);\n        if (pdaPositionOwner != pdaProgram) {\n            revert(\"Wrong PDA position owner\");\n        }\n\n        // Transfer the position NFT to the pdaPositionAccount address of this program\n        SplToken.transfer(\n            tx.accounts.userPositionAccount.key,\n            tx.accounts.pdaPositionAccount.key,\n            tx.accounts.userWallet.key,\n            1);\n\n        // Mint bridged tokens to the user\n        SplToken.pda_mint_to(\n            bridgedTokenMint,\n            tx.accounts.userBridgedTokenAccount.key,\n            pdaProgram,\n            positionLiquidity,\n            pdaProgramSeed,\n            pdaBump);\n\n        // Record position liquidity amount and its correspondent account address\n        address positionAddress = tx.accounts.position.key;\n        mapPositionAccountLiquidity[positionAddress] = positionLiquidity;\n        address pdaPositionAta = tx.accounts.pdaPositionAccount.key;\n        mapPositionAccountPdaAta[positionAddress] = pdaPositionAta;\n        positionAccounts[numPositionAccounts] = positionAddress;\n\n        // Increase the total number of positions\n        numPositionAccounts++;\n        // Increase the amount of total liquidity\n        totalLiquidity += positionLiquidity;\n    }\n\n    /// @dev Withdraws LP tokens separately to each token ATA and burns provided bridge tokens.\n    /// @param amount Bridged token amount.\n    @mutableAccount(pool)\n    @account(tokenProgramId)\n    @mutableAccount(position)\n    @mutableAccount(userBridgedTokenAccount)\n    @mutableAccount(pdaBridgedTokenAccount)\n    @mutableAccount(userWallet)\n    @mutableAccount(bridgedTokenMint)\n    @mutableAccount(pdaPositionAccount)\n    @mutableAccount(userTokenAccountA)\n    @mutableAccount(userTokenAccountB)\n    @mutableAccount(tokenVaultA)\n    @mutableAccount(tokenVaultB)\n    @mutableAccount(tickArrayLower)\n    @mutableAccount(tickArrayUpper)\n    @mutableAccount(positionMint)\n    @signer(sig)\n    function withdraw(uint64 amount) external {\n        address positionAddress = positionAccounts[firstAvailablePositionAccountIndex];\n        if (positionAddress != tx.accounts.position.key) {\n            revert(\"Wrong liquidity token account\");\n        }\n\n        address pdaPositionAta = tx.accounts.pdaPositionAccount.key;\n        if (mapPositionAccountPdaAta[positionAddress] != pdaPositionAta) {\n            revert(\"Wrong position ATA\");\n        }\n\n        uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];\n        // Check that the token account exists\n        if (positionLiquidity == 0) {\n            revert(\"No liquidity on a provided token account\");\n        }\n\n        // Check the requested amount to be smaller or equal than the position liquidity\n        if (amount > positionLiquidity) {\n            revert(\"Amount exceeds a position liquidity\");\n        }\n\n        // Check the pdaBridgedTokenAccount address\n        if (tx.accounts.pdaBridgedTokenAccount.key != pdaBridgedTokenAccount) {\n            revert(\"Wrong PDA bridged token ATA\");\n        }\n\n        // Check that the pool is correct\n        if (tx.accounts.pool.key != pool) {\n            revert(\"Pool address is incorrect\");\n        }\n\n        // Check that the bridged token mint account is correct\n        if (tx.accounts.bridgedTokenMint.key != bridgedTokenMint) {\n            revert(\"Wrong bridged token mint account\");\n        }\n\n        // Transfer bridged tokens to the pdaBridgedTokenAccount address of this program\n        SplToken.transfer(\n            tx.accounts.userBridgedTokenAccount.key,\n            pdaBridgedTokenAccount,\n            tx.accounts.userWallet.key,\n            amount);\n\n        // Decrease the total liquidity amount\n        totalLiquidity -= amount;\n\n        // Burn acquired bridged tokens\n        SplToken.pda_burn(pdaBridgedTokenAccount, bridgedTokenMint, pdaProgram, amount, pdaProgramSeed, pdaBump);\n\n        // Decrease the position liquidity\n        AccountMeta[11] metasDecreaseLiquidity = [\n            AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false}),\n            AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n            AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: pdaPositionAta, is_writable: false, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.userTokenAccountA.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.userTokenAccountB.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tokenVaultA.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tokenVaultB.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: true, is_signer: false})\n        ];\n        // a026d06f685b2c01 - decreaseLiquidity, eff0ae00000000000000000000000000 - amount, aaf1950200000000 - minA, b8522d0000000000 - minB\n        // bytes bincode = \"0xa026d06f685b2c01eff0ae00000000000000000000000000aaf1950200000000b8522d0000000000\";\n        // orca.call{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(bincode);\n        whirlpool.decreaseLiquidity{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(amount, 0, 0);\n\n        // Update the token remainder\n        uint64 remainder = positionLiquidity - amount;\n        // Update liquidity and its associated position account\n        mapPositionAccountLiquidity[positionAddress] = remainder;\n\n        // If requested amount can be fully covered by the current position liquidity, close the position\n        if (remainder == 0) {\n            // Update fees for the position\n            AccountMeta[4] metasUpdateFees = [\n                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: false, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: false, is_signer: false})\n            ];\n            whirlpool.updateFeesAndRewards{accounts: metasUpdateFees, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Collect fees from the position\n            AccountMeta[9] metasCollectFees = [\n                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaPositionAta, is_writable: false, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.userTokenAccountA.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tokenVaultA.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.userTokenAccountB.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tokenVaultB.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false})\n            ];\n            whirlpool.collectFees{accounts: metasCollectFees, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Close the position\n            AccountMeta[6] metasClosePosition = [\n                AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n                AccountMeta({pubkey: tx.accounts.userWallet.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.positionMint.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaPositionAta, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false})\n            ];\n            whirlpool.closePosition{accounts: metasClosePosition, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Increase the first available position account index\n            firstAvailablePositionAccountIndex++;\n        }\n    }\n\n    /// @dev Gets the position data.\n    /// @return Position data.\n    @account(position)\n    @account(positionMint)\n    function getPositionData() external view returns (Position) {\n        return _getPositionData(tx.accounts.position, tx.accounts.positionMint.key);\n    }\n\n    /// @dev Gets liquidity amounts and position accounts in order to correctly withdraw a specified liquidity amount.\n    /// @param amount Liquidity amount to withdraw.\n    /// @return positionAmounts Position amounts.\n    /// @return positionAddresses Position mint addresses.\n    /// @return positionPdaAtas Position PDA ATA-s controlled by the program.\n    function getLiquidityAmountsAndPositions(uint64 amount)\n        external view returns (uint64[] positionAmounts, address[] positionAddresses, address[] positionPdaAtas)\n    {\n        if (amount > totalLiquidity) {\n            revert (\"Requested amount is too big for the total available liquidity\");\n        }\n\n        uint64 liquiditySum = 0;\n        uint32 numPositions = 0;\n        uint64 amountLeft = 0;\n\n        // Get the number of allocated positions\n        for (uint32 i = firstAvailablePositionAccountIndex; i < numPositionAccounts; ++i) {\n            address positionAddress = positionAccounts[i];\n            uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];\n\n            // Increase a total calculated liquidity and a number of positions to return\n            liquiditySum += positionLiquidity;\n            numPositions++;\n\n            // Check if the accumulated liquidity is enough to cover the requested amount\n            if (liquiditySum >= amount) {\n                amountLeft = liquiditySum - amount;\n                break;\n            }\n        }\n\n        // Allocate the necessary arrays and fill the values\n        positionAddresses = new address[](numPositions);\n        positionAmounts = new uint64[](numPositions);\n        positionPdaAtas = new address[](numPositions);\n        for (uint32 i = 0; i < numPositions; ++i) {\n            positionAddresses[i] = positionAccounts[firstAvailablePositionAccountIndex + i];\n            positionAmounts[i] = mapPositionAccountLiquidity[positionAddresses[i]];\n            positionPdaAtas[i] = mapPositionAccountPdaAta[positionAddresses[i]];\n        }\n\n        // Adjust the last position, if it was not fully allocated\n        if (numPositions > 0 && amountLeft > 0) {\n            positionAmounts[numPositions - 1] = amountLeft;\n        }\n    }\n\n    /// @dev Gets token account balance.\n    @account(account)\n    function getBalance() external view returns (uint64) {\n        return SplToken.get_balance(tx.accounts.account);\n    }\n\n    /// @dev Gets total supply of a provided token account.\n    @account(account)\n    function totalSupply() external view returns (uint64) {\n        return SplToken.total_supply(tx.accounts.account);\n    }\n}"
    }
  ]
}