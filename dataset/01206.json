{
  "Title": "Missing Check that PrimePoolId Is a Valid poolId",
  "Content": "\n\n\nA valid `poolId` for a token must be less than the length of the `poolInfos` array for a particular `rewardToken` . A prime `poolId` should also match a pre-existing `poolId`, so this condition should also be true for Prime pools. However, the [`setPrimeToken`](https://github.com/VenusProtocol/venus-protocol/blob/f31a0543da039dab69112c6be3e36ea54959503b/contracts/XVSVault/XVSVault.sol#L873) function does not have this check. \n\n\nConsider adding a check in `setPrimeToken` to ensure that it matches a pre-existing `poolId`. \n\n\n\n\n\n***Update:** Resolved at commit [ad5b11a](https://github.com/VenusProtocol/venus-protocol/commit/ad5b11ab8f678ae581b6d3f129b32798086221f9).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/XVSVault/XVSVault.sol",
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../Utils/ECDSA.sol\";\nimport \"../Utils/SafeBEP20.sol\";\nimport \"../Utils/IBEP20.sol\";\nimport \"./XVSVaultStorage.sol\";\nimport \"./XVSVaultErrorReporter.sol\";\nimport \"../Tokens/Prime/IPrime.sol\";\nimport \"../Utils/SafeCast.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV5.sol\";\n\ninterface IXVSStore {\n    function safeRewardTransfer(address _token, address _to, uint256 _amount) external;\n\n    function setRewardToken(address _tokenAddress, bool status) external;\n\n    function rewardTokens(address _tokenAddress) external view returns (bool);\n}\n\ninterface IXVSVaultProxy {\n    function _acceptImplementation() external returns (uint);\n\n    function admin() external returns (address);\n}\n\ncontract XVSVault is XVSVaultStorage, ECDSA, AccessControlledV5 {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeBEP20 for IBEP20;\n\n    /// @notice The upper bound for the lock period in a pool, 10 years\n    uint256 public constant MAX_LOCK_PERIOD = 60 * 60 * 24 * 365 * 10;\n\n    /// @notice Event emitted when deposit\n    event Deposit(address indexed user, address indexed rewardToken, uint256 indexed pid, uint256 amount);\n\n    /// @notice Event emitted when execute withrawal\n    event ExecutedWithdrawal(address indexed user, address indexed rewardToken, uint256 indexed pid, uint256 amount);\n\n    /// @notice Event emitted when request withrawal\n    event RequestedWithdrawal(address indexed user, address indexed rewardToken, uint256 indexed pid, uint256 amount);\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChangedV2(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChangedV2(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /// @notice An event emitted when the reward store address is updated\n    event StoreUpdated(address oldXvs, address oldStore, address newXvs, address newStore);\n\n    /// @notice An event emitted when the withdrawal locking period is updated for a pool\n    event WithdrawalLockingPeriodUpdated(address indexed rewardToken, uint indexed pid, uint oldPeriod, uint newPeriod);\n\n    /// @notice An event emitted when the reward amount per block is modified for a pool\n    event RewardAmountUpdated(address indexed rewardToken, uint oldReward, uint newReward);\n\n    /// @notice An event emitted when a new pool is added\n    event PoolAdded(\n        address indexed rewardToken,\n        uint indexed pid,\n        address indexed token,\n        uint allocPoints,\n        uint rewardPerBlock,\n        uint lockPeriod\n    );\n\n    /// @notice An event emitted when a pool allocation points are updated\n    event PoolUpdated(address indexed rewardToken, uint indexed pid, uint oldAllocPoints, uint newAllocPoints);\n\n    /// @notice Event emitted when reward claimed\n    event Claim(address indexed user, address indexed rewardToken, uint256 indexed pid, uint256 amount);\n\n    /// @notice Event emitted when vault is paused\n    event VaultPaused(address indexed admin);\n\n    /// @notice Event emitted when vault is resumed after pause\n    event VaultResumed(address indexed admin);\n\n    /// @notice Event emitted when protocol logs a debt to a user due to insufficient funds for pending reward distribution\n    event VaultDebtUpdated(\n        address indexed rewardToken,\n        address indexed userAddress,\n        uint256 oldOwedAmount,\n        uint256 newOwedAmount\n    );\n\n    /// @notice Emitted when prime token contract address is changed\n    event NewPrimeToken(\n        IPrime indexed oldPrimeToken, \n        IPrime indexed newPrimeToken, \n        address oldPrimeRewardToken, \n        address newPrimeRewardToken, \n        uint256 oldPrimePoolId,\n        uint256 newPrimePoolId\n    );\n\n    constructor() public {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"only admin can\");\n        _;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n\n    /**\n     * @dev Prevents functions to execute when vault is paused.\n     */\n    modifier isActive() {\n        require(!vaultPaused, \"Vault is paused\");\n        _;\n    }\n\n    /**\n     * @notice Pauses vault\n     */\n    function pause() external {\n        _checkAccessAllowed(\"pause()\");\n        require(!vaultPaused, \"Vault is already paused\");\n        vaultPaused = true;\n        emit VaultPaused(msg.sender);\n    }\n\n    /**\n     * @notice Resume vault\n     */\n    function resume() external {\n        _checkAccessAllowed(\"resume()\");\n        require(vaultPaused, \"Vault is not paused\");\n        vaultPaused = false;\n        emit VaultResumed(msg.sender);\n    }\n\n    /**\n     * @notice Returns the number of pools with the specified reward token\n     * @param rewardToken Reward token address\n     * @return Number of pools that distribute the specified token as a reward\n     */\n    function poolLength(address rewardToken) external view returns (uint256) {\n        return poolInfos[rewardToken].length;\n    }\n\n    /**\n     * @notice Add a new token pool\n     * @dev This vault DOES NOT support deflationary tokens â€” it expects that\n     *   the amount of transferred tokens would equal the actually deposited\n     *   amount. In practice this means that this vault DOES NOT support USDT\n     *   and similar tokens (that do not provide these guarantees).\n     * @param _rewardToken Reward token address\n     * @param _allocPoint Number of allocation points assigned to this pool\n     * @param _token Staked token\n     * @param _rewardPerBlock Initial reward per block, in terms of _rewardToken\n     * @param _lockPeriod A period between withdrawal request and a moment when it's executable\n     */\n    function add(\n        address _rewardToken,\n        uint256 _allocPoint,\n        IBEP20 _token,\n        uint256 _rewardPerBlock,\n        uint256 _lockPeriod\n    ) external {\n        _checkAccessAllowed(\"add(address,uint256,address,uint256,uint256)\");\n        _ensureNonzeroAddress(_rewardToken);\n        _ensureNonzeroAddress(address(_token));\n        require(address(xvsStore) != address(0), \"Store contract address is empty\");\n        require(_allocPoint > 0, \"Alloc points must not be zero\");\n\n        massUpdatePools(_rewardToken);\n\n        PoolInfo[] storage poolInfo = poolInfos[_rewardToken];\n\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            require(poolInfo[pid].token != _token, \"Pool already added\");\n        }\n\n        // We use balanceOf to get the supply amount, so shouldn't be possible to\n        // configure pools with different reward token but the same staked token\n        require(!isStakedToken[address(_token)], \"Token exists in other pool\");\n\n        totalAllocPoints[_rewardToken] = totalAllocPoints[_rewardToken].add(_allocPoint);\n\n        rewardTokenAmountsPerBlock[_rewardToken] = _rewardPerBlock;\n\n        poolInfo.push(\n            PoolInfo({\n                token: _token,\n                allocPoint: _allocPoint,\n                lastRewardBlock: block.number,\n                accRewardPerShare: 0,\n                lockPeriod: _lockPeriod\n            })\n        );\n        isStakedToken[address(_token)] = true;\n\n        IXVSStore(xvsStore).setRewardToken(_rewardToken, true);\n\n        emit PoolAdded(_rewardToken, poolInfo.length - 1, address(_token), _allocPoint, _rewardPerBlock, _lockPeriod);\n    }\n\n    /**\n     * @notice Update the given pool's reward allocation point\n     * @param _rewardToken Reward token address\n     * @param _pid Pool index\n     * @param _allocPoint Number of allocation points assigned to this pool\n     */\n    function set(address _rewardToken, uint256 _pid, uint256 _allocPoint) external {\n        _checkAccessAllowed(\"set(address,uint256,uint256)\");\n        _ensureValidPool(_rewardToken, _pid);\n\n        massUpdatePools(_rewardToken);\n\n        PoolInfo[] storage poolInfo = poolInfos[_rewardToken];\n        uint256 newTotalAllocPoints = totalAllocPoints[_rewardToken].sub(poolInfo[_pid].allocPoint).add(_allocPoint);\n        require(newTotalAllocPoints > 0, \"Alloc points per reward token must not be zero\");\n\n        uint256 oldAllocPoints = poolInfo[_pid].allocPoint;\n        poolInfo[_pid].allocPoint = _allocPoint;\n        totalAllocPoints[_rewardToken] = newTotalAllocPoints;\n\n        emit PoolUpdated(_rewardToken, _pid, oldAllocPoints, _allocPoint);\n    }\n\n    /**\n     * @notice Update the given reward token's amount per block\n     * @param _rewardToken Reward token address\n     * @param _rewardAmount Number of allocation points assigned to this pool\n     */\n    function setRewardAmountPerBlock(address _rewardToken, uint256 _rewardAmount) external {\n        _checkAccessAllowed(\"setRewardAmountPerBlock(address,uint256)\");\n        require(IXVSStore(xvsStore).rewardTokens(_rewardToken), \"Invalid reward token\");\n        massUpdatePools(_rewardToken);\n        uint256 oldReward = rewardTokenAmountsPerBlock[_rewardToken];\n        rewardTokenAmountsPerBlock[_rewardToken] = _rewardAmount;\n\n        emit RewardAmountUpdated(_rewardToken, oldReward, _rewardAmount);\n    }\n\n    /**\n     * @notice Update the lock period after which a requested withdrawal can be executed\n     * @param _rewardToken Reward token address\n     * @param _pid Pool index\n     * @param _newPeriod New lock period\n     */\n    function setWithdrawalLockingPeriod(address _rewardToken, uint256 _pid, uint256 _newPeriod) external {\n        _checkAccessAllowed(\"setWithdrawalLockingPeriod(address,uint256,uint256)\");\n        _ensureValidPool(_rewardToken, _pid);\n        require(_newPeriod > 0 && _newPeriod < MAX_LOCK_PERIOD, \"Invalid new locking period\");\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\n        uint256 oldPeriod = pool.lockPeriod;\n        pool.lockPeriod = _newPeriod;\n\n        emit WithdrawalLockingPeriodUpdated(_rewardToken, _pid, oldPeriod, _newPeriod);\n    }\n\n    /**\n     * @notice Deposit XVSVault for XVS allocation\n     * @param _rewardToken The Reward Token Address\n     * @param _pid The Pool Index\n     * @param _amount The amount to deposit to vault\n     */\n    function deposit(address _rewardToken, uint256 _pid, uint256 _amount) external nonReentrant isActive {\n        _ensureValidPool(_rewardToken, _pid);\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\n        UserInfo storage user = userInfos[_rewardToken][_pid][msg.sender];\n        _updatePool(_rewardToken, _pid);\n        require(pendingWithdrawalsBeforeUpgrade(_rewardToken, _pid, msg.sender) == 0, \"execute pending withdrawal\");\n\n        if (user.amount > 0) {\n            uint256 pending = _computeReward(user, pool);\n            if (pending > 0) {\n                _transferReward(_rewardToken, msg.sender, pending);\n                emit Claim(msg.sender, _rewardToken, _pid, pending);\n            }\n        }\n        pool.token.safeTransferFrom(msg.sender, address(this), _amount);\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = _cumulativeReward(user, pool);\n\n        // Update Delegate Amount\n        if (address(pool.token) == xvsAddress) {\n            _moveDelegates(address(0), delegates[msg.sender], safe96(_amount, \"XVSVault::deposit: votes overflow\"));\n        }\n\n        if (primeRewardToken == _rewardToken && _pid == primePoolId) {\n            primeToken.xvsUpdated(msg.sender);\n        }\n\n        emit Deposit(msg.sender, _rewardToken, _pid, _amount);\n    }\n\n    /**\n     * @notice Claim rewards for pool\n     * @param _account The account for which to claim rewards\n     * @param _rewardToken The Reward Token Address\n     * @param _pid The Pool Index\n     */\n    function claim(address _account, address _rewardToken, uint256 _pid) external nonReentrant isActive {\n        _ensureValidPool(_rewardToken, _pid);\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\n        UserInfo storage user = userInfos[_rewardToken][_pid][_account];\n        _updatePool(_rewardToken, _pid);\n        require(pendingWithdrawalsBeforeUpgrade(_rewardToken, _pid, _account) == 0, \"execute pending withdrawal\");\n\n        if (user.amount > 0) {\n            uint256 pending = _computeReward(user, pool);\n\n            if (pending > 0) {\n                user.rewardDebt = _cumulativeReward(user, pool);\n\n                _transferReward(_rewardToken, _account, pending);\n                emit Claim(_account, _rewardToken, _pid, pending);\n            }\n        }\n    }\n\n    /**\n     * @notice Pushes withdrawal request to the requests array and updates\n     *   the pending withdrawals amount. The requests are always sorted\n     *   by unlock time (descending) so that the earliest to execute requests\n     *   are always at the end of the array.\n     * @param _user The user struct storage pointer\n     * @param _requests The user's requests array storage pointer\n     * @param _amount The amount being requested\n     */\n    function pushWithdrawalRequest(\n        UserInfo storage _user,\n        WithdrawalRequest[] storage _requests,\n        uint _amount,\n        uint _lockedUntil\n    ) internal {\n        uint i = _requests.length;\n        _requests.push(WithdrawalRequest(0, 0, 1));\n        // Keep it sorted so that the first to get unlocked request is always at the end\n        for (; i > 0 && _requests[i - 1].lockedUntil <= _lockedUntil; --i) {\n            _requests[i] = _requests[i - 1];\n        }\n        _requests[i] = WithdrawalRequest(_amount, _lockedUntil.toUint128(), 1);\n        _user.pendingWithdrawals = _user.pendingWithdrawals.add(_amount);\n    }\n\n    /**\n     * @notice Pops the requests with unlock time < now from the requests\n     *   array and deducts the computed amount from the user's pending\n     *   withdrawals counter. Assumes that the requests array is sorted\n     *   by unclock time (descending).\n     * @dev This function **removes** the eligible requests from the requests\n     *   array. If this function is called, the withdrawal should actually\n     *   happen (or the transaction should be reverted).\n     * @param _user The user struct storage pointer\n     * @param _requests The user's requests array storage pointer\n     * @return beforeUpgradeWithdrawalAmount The amount eligible for withdrawal before upgrade (this amount should be\n     *   sent to the user, otherwise the state would be inconsistent).\n     * @return afterUpgradeWithdrawalAmount The amount eligible for withdrawal after upgrade (this amount should be\n     *   sent to the user, otherwise the state would be inconsistent).\n     */\n    function popEligibleWithdrawalRequests(\n        UserInfo storage _user,\n        WithdrawalRequest[] storage _requests\n    ) internal returns (uint beforeUpgradeWithdrawalAmount, uint afterUpgradeWithdrawalAmount) {\n        // Since the requests are sorted by their unlock time, we can just\n        // pop them from the array and stop at the first not-yet-eligible one\n        for (uint i = _requests.length; i > 0 && isUnlocked(_requests[i - 1]); --i) {\n            if (_requests[i - 1].afterUpgrade == 1) {\n                afterUpgradeWithdrawalAmount = afterUpgradeWithdrawalAmount.add(_requests[i - 1].amount);\n            } else {\n                beforeUpgradeWithdrawalAmount = beforeUpgradeWithdrawalAmount.add(_requests[i - 1].amount);\n            }\n\n            _requests.pop();\n        }\n        _user.pendingWithdrawals = _user.pendingWithdrawals.sub(\n            afterUpgradeWithdrawalAmount.add(beforeUpgradeWithdrawalAmount)\n        );\n        return (beforeUpgradeWithdrawalAmount, afterUpgradeWithdrawalAmount);\n    }\n\n    /**\n     * @notice Checks if the request is eligible for withdrawal.\n     * @param _request The request struct storage pointer\n     * @return True if the request is eligible for withdrawal, false otherwise\n     */\n    function isUnlocked(WithdrawalRequest storage _request) private view returns (bool) {\n        return _request.lockedUntil <= block.timestamp;\n    }\n\n    /**\n     * @notice Execute withdrawal to XVSVault for XVS allocation\n     * @param _rewardToken The Reward Token Address\n     * @param _pid The Pool Index\n     */\n    function executeWithdrawal(address _rewardToken, uint256 _pid) external nonReentrant isActive {\n        _ensureValidPool(_rewardToken, _pid);\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\n        UserInfo storage user = userInfos[_rewardToken][_pid][msg.sender];\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][msg.sender];\n\n        uint256 beforeUpgradeWithdrawalAmount;\n        uint256 afterUpgradeWithdrawalAmount;\n\n        (beforeUpgradeWithdrawalAmount, afterUpgradeWithdrawalAmount) = popEligibleWithdrawalRequests(user, requests);\n        require(beforeUpgradeWithdrawalAmount > 0 || afterUpgradeWithdrawalAmount > 0, \"nothing to withdraw\");\n\n        // Having both old-style and new-style requests is not allowed and shouldn't be possible\n        require(beforeUpgradeWithdrawalAmount == 0 || afterUpgradeWithdrawalAmount == 0, \"inconsistent state\");\n\n        if (beforeUpgradeWithdrawalAmount > 0) {\n            _updatePool(_rewardToken, _pid);\n            uint256 pending = user.amount.mul(pool.accRewardPerShare).div(1e12).sub(user.rewardDebt);\n            IXVSStore(xvsStore).safeRewardTransfer(_rewardToken, msg.sender, pending);\n            user.amount = user.amount.sub(beforeUpgradeWithdrawalAmount);\n            user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);\n            pool.token.safeTransfer(address(msg.sender), beforeUpgradeWithdrawalAmount);\n        } else {\n            user.amount = user.amount.sub(afterUpgradeWithdrawalAmount);\n            totalPendingWithdrawals[_rewardToken][_pid] = totalPendingWithdrawals[_rewardToken][_pid].sub(\n                afterUpgradeWithdrawalAmount\n            );\n            pool.token.safeTransfer(address(msg.sender), afterUpgradeWithdrawalAmount);\n        }\n\n        emit ExecutedWithdrawal(\n            msg.sender,\n            _rewardToken,\n            _pid,\n            beforeUpgradeWithdrawalAmount.add(afterUpgradeWithdrawalAmount)\n        );\n    }\n\n    /**\n     * @notice Returns before and after upgrade pending withdrawal amount\n     * @param _requests The user's requests array storage pointer\n     * @return beforeUpgradeWithdrawalAmount The amount eligible for withdrawal before upgrade\n     * @return afterUpgradeWithdrawalAmount The amount eligible for withdrawal after upgrade\n     */\n    function getRequestedWithdrawalAmount(\n        WithdrawalRequest[] storage _requests\n    ) internal view returns (uint beforeUpgradeWithdrawalAmount, uint afterUpgradeWithdrawalAmount) {\n        for (uint i = _requests.length; i > 0; --i) {\n            if (_requests[i - 1].afterUpgrade == 1) {\n                afterUpgradeWithdrawalAmount = afterUpgradeWithdrawalAmount.add(_requests[i - 1].amount);\n            } else {\n                beforeUpgradeWithdrawalAmount = beforeUpgradeWithdrawalAmount.add(_requests[i - 1].amount);\n            }\n        }\n        return (beforeUpgradeWithdrawalAmount, afterUpgradeWithdrawalAmount);\n    }\n\n    /**\n     * @notice Request withdrawal to XVSVault for XVS allocation\n     * @param _rewardToken The Reward Token Address\n     * @param _pid The Pool Index\n     * @param _amount The amount to withdraw from the vault\n     */\n    function requestWithdrawal(address _rewardToken, uint256 _pid, uint256 _amount) external nonReentrant isActive {\n        _ensureValidPool(_rewardToken, _pid);\n        require(_amount > 0, \"requested amount cannot be zero\");\n        UserInfo storage user = userInfos[_rewardToken][_pid][msg.sender];\n        require(user.amount >= user.pendingWithdrawals.add(_amount), \"requested amount is invalid\");\n\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][msg.sender];\n\n        uint beforeUpgradeWithdrawalAmount;\n\n        (beforeUpgradeWithdrawalAmount, ) = getRequestedWithdrawalAmount(requests);\n        require(beforeUpgradeWithdrawalAmount == 0, \"execute pending withdrawal\");\n\n        _updatePool(_rewardToken, _pid);\n        uint256 pending = _computeReward(user, pool);\n        _transferReward(_rewardToken, msg.sender, pending);\n\n        uint lockedUntil = pool.lockPeriod.add(block.timestamp);\n\n        pushWithdrawalRequest(user, requests, _amount, lockedUntil);\n        totalPendingWithdrawals[_rewardToken][_pid] = totalPendingWithdrawals[_rewardToken][_pid].add(_amount);\n        user.rewardDebt = _cumulativeReward(user, pool);\n\n        // Update Delegate Amount\n        if (address(pool.token) == xvsAddress) {\n            _moveDelegates(\n                delegates[msg.sender],\n                address(0),\n                safe96(_amount, \"XVSVault::requestWithdrawal: votes overflow\")\n            );\n        }\n\n        if (primeRewardToken == _rewardToken && _pid == primePoolId) {\n            primeToken.xvsUpdated(msg.sender);\n        }\n\n        emit Claim(msg.sender, _rewardToken, _pid, pending);\n        emit RequestedWithdrawal(msg.sender, _rewardToken, _pid, _amount);\n    }\n\n    /**\n     * @notice Get unlocked withdrawal amount\n     * @param _rewardToken The Reward Token Address\n     * @param _pid The Pool Index\n     * @param _user The User Address\n     * @return withdrawalAmount Amount that the user can withdraw\n     */\n    function getEligibleWithdrawalAmount(\n        address _rewardToken,\n        uint256 _pid,\n        address _user\n    ) external view returns (uint withdrawalAmount) {\n        _ensureValidPool(_rewardToken, _pid);\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][_user];\n        // Since the requests are sorted by their unlock time, we can take\n        // the entries from the end of the array and stop at the first\n        // not-yet-eligible one\n        for (uint i = requests.length; i > 0 && isUnlocked(requests[i - 1]); --i) {\n            withdrawalAmount = withdrawalAmount.add(requests[i - 1].amount);\n        }\n        return withdrawalAmount;\n    }\n\n    /**\n     * @notice Get requested amount\n     * @param _rewardToken The Reward Token Address\n     * @param _pid The Pool Index\n     * @param _user The User Address\n     * @return Total amount of requested but not yet executed withdrawals (including both executable and locked ones)\n     */\n    function getRequestedAmount(address _rewardToken, uint256 _pid, address _user) external view returns (uint256) {\n        _ensureValidPool(_rewardToken, _pid);\n        UserInfo storage user = userInfos[_rewardToken][_pid][_user];\n        return user.pendingWithdrawals;\n    }\n\n    /**\n     * @notice Returns the array of withdrawal requests that have not been executed yet\n     * @param _rewardToken The Reward Token Address\n     * @param _pid The Pool Index\n     * @param _user The User Address\n     * @return An array of withdrawal requests\n     */\n    function getWithdrawalRequests(\n        address _rewardToken,\n        uint256 _pid,\n        address _user\n    ) external view returns (WithdrawalRequest[] memory) {\n        _ensureValidPool(_rewardToken, _pid);\n        return withdrawalRequests[_rewardToken][_pid][_user];\n    }\n\n    /**\n     * @notice View function to see pending XVSs on frontend\n     * @param _rewardToken Reward token address\n     * @param _pid Pool index\n     * @param _user User address\n     * @return Reward the user is eligible for in this pool, in terms of _rewardToken\n     */\n    function pendingReward(address _rewardToken, uint256 _pid, address _user) external view returns (uint256) {\n        _ensureValidPool(_rewardToken, _pid);\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\n        UserInfo storage user = userInfos[_rewardToken][_pid][_user];\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        uint256 supply = pool.token.balanceOf(address(this)).sub(totalPendingWithdrawals[_rewardToken][_pid]);\n        uint256 curBlockNumber = block.number;\n        uint256 rewardTokenPerBlock = rewardTokenAmountsPerBlock[_rewardToken];\n        if (curBlockNumber > pool.lastRewardBlock && supply != 0) {\n            uint256 multiplier = curBlockNumber.sub(pool.lastRewardBlock);\n            uint256 reward = multiplier.mul(rewardTokenPerBlock).mul(pool.allocPoint).div(\n                totalAllocPoints[_rewardToken]\n            );\n            accRewardPerShare = accRewardPerShare.add(reward.mul(1e12).div(supply));\n        }\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][_user];\n        (, uint256 afterUpgradeWithdrawalAmount) = getRequestedWithdrawalAmount(requests);\n        return user.amount.sub(afterUpgradeWithdrawalAmount).mul(accRewardPerShare).div(1e12).sub(user.rewardDebt);\n    }\n\n    // Update reward variables for all pools. Be careful of gas spending!\n    function massUpdatePools(address _rewardToken) internal {\n        uint256 length = poolInfos[_rewardToken].length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            _updatePool(_rewardToken, pid);\n        }\n    }\n\n    /**\n     * @notice Update reward variables of the given pool to be up-to-date\n     * @param _rewardToken Reward token address\n     * @param _pid Pool index\n     */\n    function updatePool(address _rewardToken, uint256 _pid) external isActive {\n        _ensureValidPool(_rewardToken, _pid);\n        _updatePool(_rewardToken, _pid);\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function _updatePool(address _rewardToken, uint256 _pid) internal {\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint256 supply = pool.token.balanceOf(address(this));\n        supply = supply.sub(totalPendingWithdrawals[_rewardToken][_pid]);\n        if (supply == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        uint256 curBlockNumber = block.number;\n        uint256 multiplier = curBlockNumber.sub(pool.lastRewardBlock);\n        uint256 reward = multiplier.mul(rewardTokenAmountsPerBlock[_rewardToken]).mul(pool.allocPoint).div(\n            totalAllocPoints[_rewardToken]\n        );\n        pool.accRewardPerShare = pool.accRewardPerShare.add(reward.mul(1e12).div(supply));\n        pool.lastRewardBlock = block.number;\n    }\n\n    function _ensureValidPool(address rewardToken, uint256 pid) internal view {\n        require(pid < poolInfos[rewardToken].length, \"vault: pool exists?\");\n    }\n\n    /**\n     * @notice Get user info with reward token address and pid\n     * @param _rewardToken Reward token address\n     * @param _pid Pool index\n     * @param _user User address\n     * @return amount Deposited amount\n     * @return rewardDebt Reward debt (technical value used to track past payouts)\n     * @return pendingWithdrawals Requested but not yet executed withdrawals\n     */\n    function getUserInfo(\n        address _rewardToken,\n        uint256 _pid,\n        address _user\n    ) external view returns (uint256 amount, uint256 rewardDebt, uint256 pendingWithdrawals) {\n        _ensureValidPool(_rewardToken, _pid);\n        UserInfo storage user = userInfos[_rewardToken][_pid][_user];\n        amount = user.amount;\n        rewardDebt = user.rewardDebt;\n        pendingWithdrawals = user.pendingWithdrawals;\n    }\n\n    /**\n     * @notice Gets the total pending withdrawal amount of a user before upgrade\n     * @param _rewardToken The Reward Token Address\n     * @param _pid The Pool Index\n     * @param _user The address of the user\n     * @return beforeUpgradeWithdrawalAmount Total pending withdrawal amount in requests made before the vault upgrade\n     */\n    function pendingWithdrawalsBeforeUpgrade(\n        address _rewardToken,\n        uint256 _pid,\n        address _user\n    ) public view returns (uint256 beforeUpgradeWithdrawalAmount) {\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][_user];\n        (beforeUpgradeWithdrawalAmount, ) = getRequestedWithdrawalAmount(requests);\n        return beforeUpgradeWithdrawalAmount;\n    }\n\n    /**\n     * @notice Get the XVS stake balance of an account (excluding the pending withdrawals)\n     * @param account The address of the account to check\n     * @return The balance that user staked\n     */\n    function getStakeAmount(address account) internal view returns (uint96) {\n        require(xvsAddress != address(0), \"XVSVault::getStakeAmount: xvs address is not set\");\n\n        PoolInfo[] storage poolInfo = poolInfos[xvsAddress];\n\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            if (address(poolInfo[pid].token) == address(xvsAddress)) {\n                UserInfo storage user = userInfos[xvsAddress][pid][account];\n                return safe96(user.amount.sub(user.pendingWithdrawals), \"XVSVault::getStakeAmount: votes overflow\");\n            }\n        }\n        return uint96(0);\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) external isActive {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external isActive {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"XVSVault\")), getChainId(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ECDSA.recover(digest, v, r, s);\n        require(nonce == nonces[signatory]++, \"XVSVault::delegateBySig: invalid nonce\");\n        require(block.timestamp <= expiry, \"XVSVault::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = getStakeAmount(delegator);\n        delegates[delegator] = delegatee;\n\n        emit DelegateChangedV2(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"XVSVault::_moveVotes: vote amount underflows\");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, \"XVSVault::_moveVotes: vote amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n        uint32 blockNumber = safe32("
    }
  ]
}