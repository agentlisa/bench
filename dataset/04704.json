{
  "Title": "[10] Protocol might be incompatible with some to-be integrated tokens due to dependency on `.decimals()` during withdrawal attempts",
  "Content": "\nhttps://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/src/core/VaultManagerV2.sol#L137-L158\n\n```solidity\n  function withdraw(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  )\n    public\n      isDNftOwner(id)\n  {\n    //@audit\n    if (idToBlockOfLastDeposit[id] == block.number) revert DepositedInSameBlock();\n    uint dyadMinted = dyad.mintedDyad(address(this), id);\n    Vault _vault = Vault(vault);\n    uint value = amount * _vault.assetPrice()\n                  * 1e18\n                  / 10**_vault.oracle().decimals()\n                  / 10**_vault.asset().decimals();\n    if (getNonKeroseneValue(id) - value < dyadMinted) revert NotEnoughExoCollat();\n    _vault.withdraw(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO)  revert CrTooLow();\n  }\n```\n\nWe can see that whenever there is a need to withdraw, protocol queries the `asset.decimals()` for the underlying asset; however, some very popular ERC20 that might be used as assets, do not support the `.decimals()`format and as such this attempt at withdrawal would always revert for these tokens\n\n### Impact\n\nSpecific assets would not work with protocol as it directly attempts to call `asset().decimals()`, which would revert since the functionality is non-existent for that token; leading to deposits to be completely locked in the vaults since withdrawals can't be processed and during deposits no query to `.decimals()` are being made.\n\n### Recommended Mitigation Steps\n\nConsider try/catching the logic or outrightly not supporting these tokens.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-04-dyad",
  "Code": [
    {
      "filename": "src/core/VaultManagerV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {DNft}            from \"./DNft.sol\";\nimport {Dyad}            from \"./Dyad.sol\";\nimport {Licenser}        from \"./Licenser.sol\";\nimport {Vault}           from \"./Vault.sol\";\nimport {IVaultManager}   from \"../interfaces/IVaultManager.sol\";\nimport {KerosineManager} from \"../../src/core/KerosineManager.sol\";\n\nimport {FixedPointMathLib} from \"@solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20}             from \"@solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib}   from \"@solmate/src/utils/SafeTransferLib.sol\";\nimport {EnumerableSet}     from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Initializable}     from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\ncontract VaultManagerV2 is IVaultManager, Initializable {\n  using EnumerableSet     for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint;\n  using SafeTransferLib   for ERC20;\n\n  uint public constant MAX_VAULTS          = 5;\n  uint public constant MAX_VAULTS_KEROSENE = 5;\n\n  uint public constant MIN_COLLATERIZATION_RATIO = 1.5e18; // 150%\n  uint public constant LIQUIDATION_REWARD        = 0.2e18; //  20%\n\n  DNft     public immutable dNft;\n  Dyad     public immutable dyad;\n  Licenser public immutable vaultLicenser;\n\n  KerosineManager public keroseneManager;\n\n  mapping (uint => EnumerableSet.AddressSet) internal vaults; \n  mapping (uint => EnumerableSet.AddressSet) internal vaultsKerosene; \n\n  mapping (uint => uint) public idToBlockOfLastDeposit;\n\n  modifier isDNftOwner(uint id) {\n    if (dNft.ownerOf(id) != msg.sender)   revert NotOwner();    _;\n  }\n  modifier isValidDNft(uint id) {\n    if (dNft.ownerOf(id) == address(0))   revert InvalidDNft(); _;\n  }\n  modifier isLicensed(address vault) {\n    if (!vaultLicenser.isLicensed(vault)) revert NotLicensed(); _;\n  }\n\n  constructor(\n    DNft          _dNft,\n    Dyad          _dyad,\n    Licenser      _licenser\n  ) {\n    dNft          = _dNft;\n    dyad          = _dyad;\n    vaultLicenser = _licenser;\n  }\n\n  function setKeroseneManager(KerosineManager _keroseneManager) \n    external\n      initializer \n    {\n      keroseneManager = _keroseneManager;\n  }\n\n  /// @inheritdoc IVaultManager\n  function add(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (vaults[id].length() >= MAX_VAULTS) revert TooManyVaults();\n    if (!vaultLicenser.isLicensed(vault))  revert VaultNotLicensed();\n    if (!vaults[id].add(vault))            revert VaultAlreadyAdded();\n    emit Added(id, vault);\n  }\n\n  function addKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (vaultsKerosene[id].length() >= MAX_VAULTS_KEROSENE) revert TooManyVaults();\n    if (!keroseneManager.isLicensed(vault))                 revert VaultNotLicensed();\n    if (!vaultsKerosene[id].add(vault))                     revert VaultAlreadyAdded();\n    emit Added(id, vault);\n  }\n\n  /// @inheritdoc IVaultManager\n  function remove(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0) revert VaultHasAssets();\n    if (!vaults[id].remove(vault))     revert VaultNotAdded();\n    emit Removed(id, vault);\n  }\n\n  function removeKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0)     revert VaultHasAssets();\n    if (!vaultsKerosene[id].remove(vault)) revert VaultNotAdded();\n    emit Removed(id, vault);\n  }\n\n  /// @inheritdoc IVaultManager\n  function deposit(\n    uint    id,\n    address vault,\n    uint    amount\n  ) \n    external \n      isValidDNft(id)\n  {\n    idToBlockOfLastDeposit[id] = block.number;\n    Vault _vault = Vault(vault);\n    _vault.asset().safeTransferFrom(msg.sender, address(vault), amount);\n    _vault.deposit(id, amount);\n  }\n\n  /// @inheritdoc IVaultManager\n  function withdraw(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  ) \n    public\n      isDNftOwner(id)\n  {\n    if (idToBlockOfLastDeposit[id] == block.number) revert DepositedInSameBlock();\n    uint dyadMinted = dyad.mintedDyad(address(this), id);\n    Vault _vault = Vault(vault);\n    uint value = amount * _vault.assetPrice() \n                  * 1e18 \n                  / 10**_vault.oracle().decimals() \n                  / 10**_vault.asset().decimals();\n    if (getNonKeroseneValue(id) - value < dyadMinted) revert NotEnoughExoCollat();\n    _vault.withdraw(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO)  revert CrTooLow(); \n  }\n\n  /// @inheritdoc IVaultManager\n  function mintDyad(\n    uint    id,\n    uint    amount,\n    address to\n  )\n    external \n      isDNftOwner(id)\n  {\n    uint newDyadMinted = dyad.mintedDyad(address(this), id) + amount;\n    if (getNonKeroseneValue(id) < newDyadMinted)     revert NotEnoughExoCollat();\n    dyad.mint(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO) revert CrTooLow(); \n    emit MintDyad(id, amount, to);\n  }\n\n  /// @inheritdoc IVaultManager\n  function burnDyad(\n    uint id,\n    uint amount\n  ) \n    external \n      isValidDNft(id)\n  {\n    dyad.burn(id, msg.sender, amount);\n    emit BurnDyad(id, amount, msg.sender);\n  }\n\n  /// @inheritdoc IVaultManager\n  function redeemDyad(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  )\n    external \n      isDNftOwner(id)\n    returns (uint) { \n      dyad.burn(id, msg.sender, amount);\n      Vault _vault = Vault(vault);\n      uint asset = amount \n                    * (10**(_vault.oracle().decimals() + _vault.asset().decimals())) \n                    / _vault.assetPrice() \n                    / 1e18;\n      withdraw(id, vault, asset, to);\n      emit RedeemDyad(id, vault, amount, to);\n      return asset;\n  }\n\n  /// @inheritdoc IVaultManager\n  function liquidate(\n    uint id,\n    uint to\n  ) \n    external \n      isValidDNft(id)\n      isValidDNft(to)\n    {\n      uint cr = collatRatio(id);\n      if (cr >= MIN_COLLATERIZATION_RATIO) revert CrTooHigh();\n      dyad.burn(id, msg.sender, dyad.mintedDyad(address(this), id));\n\n      uint cappedCr               = cr < 1e18 ? 1e18 : cr;\n      uint liquidationEquityShare = (cappedCr - 1e18).mulWadDown(LIQUIDATION_REWARD);\n      uint liquidationAssetShare  = (liquidationEquityShare + 1e18).divWadDown(cappedCr);\n\n      uint numberOfVaults = vaults[id].length();\n      for (uint i = 0; i < numberOfVaults; i++) {\n          Vault vault      = Vault(vaults[id].at(i));\n          uint  collateral = vault.id2asset(id).mulWadUp(liquidationAssetShare);\n          vault.move(id, to, collateral);\n      }\n      emit Liquidate(id, msg.sender, to);\n  }\n\n  function collatRatio(\n    uint id\n  )\n    public \n    view\n    returns (uint) {\n      uint _dyad = dyad.mintedDyad(address(this), id);\n      if (_dyad == 0) return type(uint).max;\n      return getTotalUsdValue(id).divWadDown(_dyad);\n  }\n\n  function getTotalUsdValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      return getNonKeroseneValue(id) + getKeroseneValue(id);\n  }\n\n  function getNonKeroseneValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      uint totalUsdValue;\n      uint numberOfVaults = vaults[id].length(); \n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaults[id].at(i));\n        uint usdValue;\n        if (vaultLicenser.isLicensed(address(vault))) {\n          usdValue = vault.getUsdValue(id);        \n        }\n        totalUsdValue += usdValue;\n      }\n      return totalUsdValue;\n  }\n\n  function getKeroseneValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      uint totalUsdValue;\n      uint numberOfVaults = vaultsKerosene[id].length(); \n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaultsKerosene[id].at(i));\n        uint usdValue;\n        if (keroseneManager.isLicensed(address(vault))) {\n          usdValue = vault.getUsdValue(id);        \n        }\n        totalUsdValue += usdValue;\n      }\n      return totalUsdValue;\n  }\n\n  // ----------------- MISC ----------------- //\n\n  function getVaults(\n    uint id\n  ) \n    external \n    view \n    returns (address[] memory) {\n      return vaults[id].values();\n  }\n\n  function hasVault(\n    uint    id,\n    address vault\n  ) \n    external \n    view \n    returns (bool) {\n      return vaults[id].contains(vault);\n  }\n}"
    }
  ]
}