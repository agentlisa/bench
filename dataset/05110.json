{
  "Title": "[G-04] Unnecessary copy of storage struct to memory in the `OracleHelper` contract",
  "Content": "\nThe `OracleHelper` contract has multiple instances where a complete struct is being copied to memory to end up using only one of its attributes. The contract should be refactored such that only the required attribute is read from storage and cached into stack variable.\n\n**Instance 1:**\n\nRefactor `OracleHelper._addAggregator()` function to avoid copying the storage struct `uniTwapPoolInfo[  _tokenAddress]` into memory struct variable `uniTwapPoolInfoStruct`.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/OracleHelper.sol#L49-#L51\n\nWe could save up to 2.1k gas units if we read the `Oracle` attribute of the storage struct `uniTwapPoolInfo[  _tokenAddress]` directly rather than having to copy the storage struct in to a memory struct variable before accessing the member.\n\n```solidity\nfile: contracts/WiseOracleHub/OracleHelper.sol\n\n32:    function _addAggregator(\n33:        address _tokenAddress\n34:    )\n35:        internal\n36:    {\n37:        IAggregator tokenAggregator = IAggregator(\n38:            priceFeed[_tokenAddress].aggregator()\n39:        );\n40:\n41:        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n42:            revert AggregatorAlreadySet();\n43:        }\n44:\n45:        if (_checkFunctionExistence(address(tokenAggregator)) == false) {\n46:            revert FunctionDoesntExist();\n47:        }\n48:\n49:        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[  \n50:            _tokenAddress\n51:        ];\n52:\n53:        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n54:            revert AggregatorNotNecessary();\n55:        }\n56:\n57:        tokenAggregatorFromTokenAddress[_tokenAddress] = tokenAggregator;\n58:    }\n```\n\n```diff\ndiff --git a/contracts/WiseOracleHub/OracleHelper.sol b/contracts/WiseOracleHub/OracleHelper.sol  \nindex 687b6f1..d3fb824 100644                                                                     \n--- a/contracts/WiseOracleHub/OracleHelper.sol                                                    \n+++ b/contracts/WiseOracleHub/OracleHelper.sol                                                    \n@@ -46,11 +46,7 @@ abstract contract OracleHelper is Declarations {                               \n             revert FunctionDoesntExist();                                                        \n         }                                                                                        \n\n-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          \n-            _tokenAddress                                                                        \n-        ];                                                                                       \n-                                                                                                 \n-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       \n+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              \n             revert AggregatorNotNecessary();                                                     \n         }                                                                                        \n```\n\nEstimated gas saved: 2100 gas units.\n\n**Instance 2:**\n\nRefactor `OracleHelper._validateAnswer()` function to avoid copying the storage struct `uniTwapPoolInfo[  _tokenAddress]` into memory struct variable `uniTwapPoolInfoStruct`.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/OracleHelper.sol#L138-#L140\n\nWe could save up to 2.1k gas units if we read the `oracle` attribute of the storage struct `uniTwapPoolInfo[  _tokenAddress]` directly rather than having to copy the storage struct in to a memory struct variable before accessing the member.\n\n```solidity\nfile: contracts/WiseOracleHub/OracleHelper.sol\n\n131:    function _validateAnswer(\n132:        address _tokenAddress\n133:    )\n134:        internal\n135:        view\n136:        returns (uint256)\n137:    {\n138:        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n139:            _tokenAddress\n140:        ];\n141:\n142:        uint256 fetchTwapValue;\n143:\n144:        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n145:            fetchTwapValue = latestResolverTwap(\n146:                _tokenAddress\n147:            );\n148:        }\n.\n.\n.\n174:    }\n```\n```diff\ndiff --git a/contracts/WiseOracleHub/OracleHelper.sol b/contracts/WiseOracleHub/OracleHelper.sol\nindex 687b6f1..9200896 100644\n--- a/contracts/WiseOracleHub/OracleHelper.sol\n+++ b/contracts/WiseOracleHub/OracleHelper.sol\n@@ -135,13 +135,10 @@ abstract contract OracleHelper is Declarations {\n         view\n         returns (uint256)\n     {\n-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n-            _tokenAddress\n-        ];\n\n         uint256 fetchTwapValue;\n\n-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {\n             fetchTwapValue = latestResolverTwap(\n                 _tokenAddress\n             );\n```\n\nEstimated gas saved: 2100 gas units.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseOracleHub/OracleHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./Declarations.sol\";\n\nabstract contract OracleHelper is Declarations {\n\n    /**\n     * @dev Adds priceFeed for a given token.\n     */\n    function _addOracle(\n        address _tokenAddress,\n        IPriceFeed _priceFeedAddress,\n        address[] calldata _underlyingFeedTokens\n    )\n        internal\n    {\n        if (priceFeed[_tokenAddress] > ZERO_FEED) {\n            revert OracleAlreadySet();\n        }\n\n        priceFeed[_tokenAddress] = _priceFeedAddress;\n\n        _tokenDecimals[_tokenAddress] = IERC20(\n            _tokenAddress\n        ).decimals();\n\n        underlyingFeedTokens[_tokenAddress] = _underlyingFeedTokens;\n    }\n\n    function _addAggregator(\n        address _tokenAddress\n    )\n        internal\n    {\n        IAggregator tokenAggregator = IAggregator(\n            priceFeed[_tokenAddress].aggregator()\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            revert AggregatorAlreadySet();\n        }\n\n        if (_checkFunctionExistence(address(tokenAggregator)) == false) {\n            revert FunctionDoesntExist();\n        }\n\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            revert AggregatorNotNecessary();\n        }\n\n        tokenAggregatorFromTokenAddress[_tokenAddress] = tokenAggregator;\n    }\n\n    function _checkFunctionExistence(\n        address _tokenAggregator\n    )\n        internal\n        returns (bool)\n    {\n        uint256 size;\n\n        assembly {\n            size := extcodesize(\n                _tokenAggregator\n            )\n        }\n\n        if (size == 0) {\n            return false;\n        }\n\n        (bool success, ) = _tokenAggregator.call(\n            abi.encodeWithSignature(\n                \"maxAnswer()\"\n            )\n        );\n\n        return success;\n    }\n\n    function _compareMinMax(\n        IAggregator _tokenAggregator,\n        int192 _answer\n    )\n        internal\n        view\n    {\n        int192 maxAnswer = _tokenAggregator.maxAnswer();\n        int192 minAnswer = _tokenAggregator.minAnswer();\n\n        if (_answer > maxAnswer || _answer < minAnswer) {\n            revert OracleIsDead();\n        }\n    }\n\n    /**\n     * @dev Returns Twaps latest USD value\n     * by passing the underlying token address.\n     */\n    function latestResolverTwap(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.isUniPool == true) {\n\n            return _getTwapPrice(\n                _tokenAddress,\n                uniTwapPoolInfoStruct.oracle\n            ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n        }\n\n        return _getTwapDerivatePrice(\n            _tokenAddress,\n            uniTwapPoolInfoStruct\n        ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n    }\n\n    function _validateAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        uint256 fetchTwapValue;\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            fetchTwapValue = latestResolverTwap(\n                _tokenAddress\n            );\n        }\n\n        uint256 answer = _getChainlinkAnswer(\n            _tokenAddress\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            _compareMinMax(\n                tokenAggregatorFromTokenAddress[_tokenAddress],\n                int192(uint192(answer))\n            );\n        }\n\n        if (fetchTwapValue > 0) {\n\n            uint256 relativeDifference = _getRelativeDifference(\n                answer,\n                fetchTwapValue\n            );\n\n            _compareDifference(\n                relativeDifference\n            );\n        }\n\n        return answer;\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token.\n     */\n    function _writeUniTwapPoolInfoStruct(\n        address _tokenAddress,\n        address _oracle,\n        bool _isUniPool\n    )\n        internal\n    {\n        uniTwapPoolInfo[_tokenAddress] = UniTwapPoolInfo({\n            oracle: _oracle,\n            isUniPool: _isUniPool\n        });\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token and its derivative.\n     */\n    function _writeUniTwapPoolInfoStructDerivative(\n        address _tokenAddress,\n        address _partnerTokenAddress,\n        address _oracleAddress,\n        address _partnerOracleAddress,\n        bool _isUniPool\n    )\n        internal\n    {\n        _writeUniTwapPoolInfoStruct(\n            _tokenAddress,\n            _oracleAddress,\n            _isUniPool\n        );\n\n        derivativePartnerTwap[_tokenAddress] = DerivativePartnerInfo(\n            _partnerTokenAddress,\n            _partnerOracleAddress\n        );\n    }\n\n    function _getRelativeDifference(\n        uint256 _answerUint256,\n        uint256 _fetchTwapValue\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (_answerUint256 > _fetchTwapValue) {\n            return _answerUint256\n                * PRECISION_FACTOR_E4\n                / _fetchTwapValue;\n        }\n\n        return _fetchTwapValue\n            * PRECISION_FACTOR_E4\n            / _answerUint256;\n    }\n\n    function _compareDifference(\n        uint256 _relativeDifference\n    )\n        internal\n        view\n    {\n        if (_relativeDifference > ALLOWED_DIFFERENCE) {\n            revert OraclesDeviate();\n        }\n    }\n\n    function _getChainlinkAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            int256 answer,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n\n        return uint256(\n            answer\n        );\n    }\n\n    function getETHPriceInUSD()\n        public\n        view\n        returns (uint256)\n    {\n        if (_chainLinkIsDead(ETH_USD_PLACEHOLDER) == true) {\n            revert OracleIsDead();\n        }\n\n        return _validateAnswer(\n            ETH_USD_PLACEHOLDER\n        );\n    }\n\n    /**\n    * @dev Retrieves the pool address for given\n    * tokens and fee from Uniswap V3 Factory.\n    */\n    function _getPool(\n        address _token0,\n        address _token1,\n        uint24 _fee\n    )\n        internal\n        view\n        returns (address pool)\n    {\n        return UNI_V3_FACTORY.getPool(\n            _token0,\n            _token1,\n            _fee\n        );\n    }\n\n    /**\n    * @dev Validates if the given token address\n    * is one of the two specified token addresses.\n    */\n    function _validateTokenAddress(\n        address _tokenAddress,\n        address _token0,\n        address _token1\n    )\n        internal\n        pure\n    {\n        if (_tokenAddress == ZERO_ADDRESS) {\n            revert ZeroAddressNotAllowed();\n        }\n\n        if (_tokenAddress != _token0 && _tokenAddress != _token1) {\n            revert TokenAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the given pool\n    * address matches the expected pool address.\n    */\n    function _validatePoolAddress(\n        address _pool,\n        address _expectedPool\n    )\n        internal\n        pure\n    {\n        if (_pool == ZERO_ADDRESS) {\n            revert PoolDoesNotExist();\n        }\n\n        if (_pool != _expectedPool) {\n            revert PoolAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the price feed for\n    * a given token address is set.\n    */\n    function _validatePriceFeed(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (priceFeed[_tokenAddress] == ZERO_FEED) {\n            revert ChainLinkOracleNotSet();\n        }\n    }\n\n    /**\n    * @dev Validates if the TWAP oracle for\n    * a given token address is already set.\n    */\n    function _validateTwapOracle(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {\n            revert TwapOracleAlreadySet();\n        }\n    }\n\n    /**\n     * @dev Returns twapPrice by passing\n     * the underlying token address.\n     */\n    function _getTwapPrice(\n        address _tokenAddress,\n        address _oracle\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _oracle\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            WETH_ADDRESS\n        );\n    }\n\n    function _getOneUnit(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint128)\n    {\n        return uint128(\n            10 ** _tokenDecimals[_tokenAddress]\n        );\n    }\n\n    function _getAverageTick(\n        address _oracle\n    )\n        internal\n        view\n        returns (int24)\n    {\n        uint32[] memory secondsAgo = new uint32[](\n            2\n        );\n\n        secondsAgo[0] = TWAP_PERIOD;\n        secondsAgo[1] = 0;\n\n        (\n            int56[] memory tickCumulatives\n            ,\n        ) = IUniswapV3Pool(_oracle).observe(\n            secondsAgo\n        );\n\n        int56 twapPeriodInt56 = int56(\n            int32(TWAP_PERIOD)\n        );\n\n        int56 tickCumulativesDelta = tickCumulatives[1]\n            - tickCumulatives[0];\n\n        int24 tick = int24(\n            tickCumulativesDelta\n            / twapPeriodInt56\n        );\n\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % twapPeriodInt56 != 0)) {\n            tick--;\n        }\n\n        return tick;\n    }\n\n    /**\n     * @dev Returns priceFeed decimals by\n     * passing the underlying token address.\n     */\n    function decimals(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint8)\n    {\n        return priceFeed[_tokenAddress].decimals();\n    }\n\n    function _getTwapDerivatePrice(\n        address _tokenAddress,\n        UniTwapPoolInfo memory _uniTwapPoolInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        DerivativePartnerInfo memory partnerInfo = derivativePartnerTwap[\n            _tokenAddress\n        ];\n\n        uint256 firstQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _uniTwapPoolInfo.oracle\n            ),\n            _getOneUnit(\n                partnerInfo.partnerTokenAddress\n            ),\n            partnerInfo.partnerTokenAddress,\n            WETH_ADDRESS\n        );\n\n        uint256 secondQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                partnerInfo.partnerOracleAddress\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            partnerInfo.partnerTokenAddress\n        );\n\n        return firstQuote\n            * secondQuote\n            / uint256(\n                _getOneUnit(\n                    partnerInfo.partnerTokenAddress\n                )\n            );\n    }\n\n    /**\n     * @dev Stores expected heartbeat\n     * value for a pricing feed token.\n     */\n    function _recalibrate(\n        address _tokenAddress\n    )\n        internal\n    {\n        heartBeat[_tokenAddress] = _recalibratePreview(\n            _tokenAddress\n        );\n    }\n\n    /**\n     * @dev Check if chainLink\n     * squencer is wroking.\n     */\n    function sequencerIsDead()\n        public\n        view\n        returns (bool)\n    {\n        if (IS_ARBITRUM_CHAIN == false) {\n            return false;\n        }\n\n        (\n            ,\n            int256 answer,\n            uint256 startedAt,\n            ,\n        ) = SEQUENCER.latestRoundData();\n\n        if (answer == 1) {\n            return true;\n        }\n\n        uint256 timeSinceUp = block.timestamp\n            - startedAt;\n\n        if (timeSinceUp <= GRACE_PEROID) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Check if chainLink feed was\n     * updated within expected timeFrame\n     * for single {_tokenAddress}.\n     */\n    function _chainLinkIsDead(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // @TODO: Add a check for TWAP comparison on 2.5%\n        // if TWAP exists for the token.\n\n        if (heartBeat[_tokenAddress] == 0) {\n            revert HeartBeatNotSet();\n        }\n\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 upd = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        unchecked {\n            upd = block.timestamp < upd\n                ? block.timestamp\n                : block.timestamp - upd;\n\n            return upd > heartBeat[_tokenAddress];\n        }\n    }\n\n    /**\n     * @dev Recalibrates expected\n     * heartbeat for a pricing feed.\n     */\n    function _recalibratePreview(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 latestTimestamp = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        uint80 iterationCount = _getIterationCount(\n            latestRoundId\n        );\n\n        if (iterationCount < MIN_ITERATION_COUNT) {\n            revert SampleTooSmall(\n                {\n                    size: iterationCount\n                }\n            );\n        }\n\n        uint80 i = 1;\n        uint256 currentDiff;\n        uint256 currentBiggest;\n        uint256 currentSecondBiggest;\n\n        while (i < iterationCount) {\n\n            uint256 currentTimestamp = _getRoundTimestamp(\n                _tokenAddress,\n                latestRoundId - i\n            );\n\n            currentDiff = latestTimestamp\n                - currentTimestamp;\n\n            latestTimestamp = currentTimestamp;\n\n            if (currentDiff >= currentBiggest) {\n\n                currentSecondBiggest = currentBiggest;\n                currentBiggest = currentDiff;\n\n            } else if (currentDiff > currentSecondBiggest) {\n                currentSecondBiggest = currentDiff;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return currentSecondBiggest;\n    }\n\n    /**\n     * @dev Determines number of iterations\n     * needed during heartbeat recalibration.\n     */\n    function _getIterationCount(\n        uint80 _latestAggregatorRoundId\n    )\n        internal\n        pure\n        returns (uint80 res)\n    {\n        res = _latestAggregatorRoundId < MAX_ROUND_COUNT\n            ? _latestAggregatorRoundId\n            : MAX_ROUND_COUNT;\n    }\n\n    /**\n     * @dev Fetches timestamp of a byteshifted\n     * aggregatorRound with specific _roundId.\n     */\n    function _getRoundTimestamp(\n        address _tokenAddress,\n        uint80 _roundId\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            ,\n            ,\n            uint256 timestamp\n            ,\n        ) = priceFeed[_tokenAddress].getRoundData(\n                _roundId\n            );\n\n        return timestamp;\n    }\n\n    /**\n     * @dev Routing latest round data from chainLink.\n     * Returns latestRoundData by passing underlying token address.\n     */\n    function getLatestRoundId(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (\n            uint80 roundId\n        )\n    {\n        (\n            roundId\n            ,\n            ,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n    }\n}"
    },
    {
      "filename": "contracts/WiseOracleHub/OracleHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./Declarations.sol\";\n\nabstract contract OracleHelper is Declarations {\n\n    /**\n     * @dev Adds priceFeed for a given token.\n     */\n    function _addOracle(\n        address _tokenAddress,\n        IPriceFeed _priceFeedAddress,\n        address[] calldata _underlyingFeedTokens\n    )\n        internal\n    {\n        if (priceFeed[_tokenAddress] > ZERO_FEED) {\n            revert OracleAlreadySet();\n        }\n\n        priceFeed[_tokenAddress] = _priceFeedAddress;\n\n        _tokenDecimals[_tokenAddress] = IERC20(\n            _tokenAddress\n        ).decimals();\n\n        underlyingFeedTokens[_tokenAddress] = _underlyingFeedTokens;\n    }\n\n    function _addAggregator(\n        address _tokenAddress\n    )\n        internal\n    {\n        IAggregator tokenAggregator = IAggregator(\n            priceFeed[_tokenAddress].aggregator()\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            revert AggregatorAlreadySet();\n        }\n\n        if (_checkFunctionExistence(address(tokenAggregator)) == false) {\n            revert FunctionDoesntExist();\n        }\n\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            revert AggregatorNotNecessary();\n        }\n\n        tokenAggregatorFromTokenAddress[_tokenAddress] = tokenAggregator;\n    }\n\n    function _checkFunctionExistence(\n        address _tokenAggregator\n    )\n        internal\n        returns (bool)\n    {\n        uint256 size;\n\n        assembly {\n            size := extcodesize(\n                _tokenAggregator\n            )\n        }\n\n        if (size == 0) {\n            return false;\n        }\n\n        (bool success, ) = _tokenAggregator.call(\n            abi.encodeWithSignature(\n                \"maxAnswer()\"\n            )\n        );\n\n        return success;\n    }\n\n    function _compareMinMax(\n        IAggregator _tokenAggregator,\n        int192 _answer\n    )\n        internal\n        view\n    {\n        int192 maxAnswer = _tokenAggregator.maxAnswer();\n        int192 minAnswer = _tokenAggregator.minAnswer();\n\n        if (_answer > maxAnswer || _answer < minAnswer) {\n            revert OracleIsDead();\n        }\n    }\n\n    /**\n     * @dev Returns Twaps latest USD value\n     * by passing the underlying token address.\n     */\n    function latestResolverTwap(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.isUniPool == true) {\n\n            return _getTwapPrice(\n                _tokenAddress,\n                uniTwapPoolInfoStruct.oracle\n            ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n        }\n\n        return _getTwapDerivatePrice(\n            _tokenAddress,\n            uniTwapPoolInfoStruct\n        ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n    }\n\n    function _validateAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        uint256 fetchTwapValue;\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            fetchTwapValue = latestResolverTwap(\n                _tokenAddress\n            );\n        }\n\n        uint256 answer = _getChainlinkAnswer(\n            _tokenAddress\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            _compareMinMax(\n                tokenAggregatorFromTokenAddress[_tokenAddress],\n                int192(uint192(answer))\n            );\n        }\n\n        if (fetchTwapValue > 0) {\n\n            uint256 relativeDifference = _getRelativeDifference(\n                answer,\n                fetchTwapValue\n            );\n\n            _compareDifference(\n                relativeDifference\n            );\n        }\n\n        return answer;\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token.\n     */\n    function _writeUniTwapPoolInfoStruct(\n        address _tokenAddress,\n        address _oracle,\n        bool _isUniPool\n    )\n        internal\n    {\n        uniTwapPoolInfo[_tokenAddress] = UniTwapPoolInfo({\n            oracle: _oracle,\n            isUniPool: _isUniPool\n        });\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token and its derivative.\n     */\n    function _writeUniTwapPoolInfoStructDerivative(\n        address _tokenAddress,\n        address _partnerTokenAddress,\n        address _oracleAddress,\n        address _partnerOracleAddress,\n        bool _isUniPool\n    )\n        internal\n    {\n        _writeUniTwapPoolInfoStruct(\n            _tokenAddress,\n            _oracleAddress,\n            _isUniPool\n        );\n\n        derivativePartnerTwap[_tokenAddress] = DerivativePartnerInfo(\n            _partnerTokenAddress,\n            _partnerOracleAddress\n        );\n    }\n\n    function _getRelativeDifference(\n        uint256 _answerUint256,\n        uint256 _fetchTwapValue\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (_answerUint256 > _fetchTwapValue) {\n            return _answerUint256\n                * PRECISION_FACTOR_E4\n                / _fetchTwapValue;\n        }\n\n        return _fetchTwapValue\n            * PRECISION_FACTOR_E4\n            / _answerUint256;\n    }\n\n    function _compareDifference(\n        uint256 _relativeDifference\n    )\n        internal\n        view\n    {\n        if (_relativeDifference > ALLOWED_DIFFERENCE) {\n            revert OraclesDeviate();\n        }\n    }\n\n    function _getChainlinkAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            int256 answer,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n\n        return uint256(\n            answer\n        );\n    }\n\n    function getETHPriceInUSD()\n        public\n        view\n        returns (uint256)\n    {\n        if (_chainLinkIsDead(ETH_USD_PLACEHOLDER) == true) {\n            revert OracleIsDead();\n        }\n\n        return _validateAnswer(\n            ETH_USD_PLACEHOLDER\n        );\n    }\n\n    /**\n    * @dev Retrieves the pool address for given\n    * tokens and fee from Uniswap V3 Factory.\n    */\n    function _getPool(\n        address _token0,\n        address _token1,\n        uint24 _fee\n    )\n        internal\n        view\n        returns (address pool)\n    {\n        return UNI_V3_FACTORY.getPool(\n            _token0,\n            _token1,\n            _fee\n        );\n    }\n\n    /**\n    * @dev Validates if the given token address\n    * is one of the two specified token addresses.\n    */\n    function _validateTokenAddress(\n        address _tokenAddress,\n        address _token0,\n        address _token1\n    )\n        internal\n        pure\n    {\n        if (_tokenAddress == ZERO_ADDRESS) {\n            revert ZeroAddressNotAllowed();\n        }\n\n        if (_tokenAddress != _token0 && _tokenAddress != _token1) {\n            revert TokenAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the given pool\n    * address matches the expected pool address.\n    */\n    function _validatePoolAddress(\n        address _pool,\n        address _expectedPool\n    )\n        internal\n        pure\n    {\n        if (_pool == ZERO_ADDRESS) {\n            revert PoolDoesNotExist();\n        }\n\n        if (_pool != _expectedPool) {\n            revert PoolAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the price feed for\n    * a given token address is set.\n    */\n    function _validatePriceFeed(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (priceFeed[_tokenAddress] == ZERO_FEED) {\n            revert ChainLinkOracleNotSet();\n        }\n    }\n\n    /**\n    * @dev Validates if the TWAP oracle for\n    * a given token address is already set.\n    */\n    function _validateTwapOracle(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {\n            revert TwapOracleAlreadySet();\n        }\n    }\n\n    /**\n     * @dev Returns twapPrice by passing\n     * the underlying token address.\n     */\n    function _getTwapPrice(\n        address _tokenAddress,\n        address _oracle\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _oracle\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            WETH_ADDRESS\n        );\n    }\n\n    function _getOneUnit(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint128)\n    {\n        return uint128(\n            10 ** _tokenDecimals[_tokenAddress]\n        );\n    }\n\n    function _getAverageTick(\n        address _oracle\n    )\n        internal\n        view\n        returns (int24)\n    {\n        uint32[] memory secondsAgo = new uint32[](\n            2\n        );\n\n        secondsAgo[0] = TWAP_PERIOD;\n        secondsAgo[1] = 0;\n\n        (\n            int56[] memory tickCumulatives\n            ,\n        ) = IUniswapV3Pool(_oracle).observe(\n            secondsAgo\n        );\n\n        int56 twapPeriodInt56 = int56(\n            int32(TWAP_PERIOD)\n        );\n\n        int56 tickCumulativesDelta = tickCumulatives[1]\n            - tickCumulatives[0];\n\n        int24 tick = int24(\n            tickCumulativesDelta\n            / twapPeriodInt56\n        );\n\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % twapPeriodInt56 != 0)) {\n            tick--;\n        }\n\n        return tick;\n    }\n\n    /**\n     * @dev Returns priceFeed decimals by\n     * passing the underlying token address.\n     */\n    function decimals(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint8)\n    {\n        return priceFeed[_tokenAddress].decimals();\n    }\n\n    function _getTwapDerivatePrice(\n        address _tokenAddress,\n        UniTwapPoolInfo memory _uniTwapPoolInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        DerivativePartnerInfo memory partnerInfo = derivativePartnerTwap[\n            _tokenAddress\n        ];\n\n        uint256 firstQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _uniTwapPoolInfo.oracle\n            ),\n            _getOneUnit(\n                partnerInfo.partnerTokenAddress\n            ),\n            partnerInfo.partnerTokenAddress,\n            WETH_ADDRESS\n        );\n\n        uint256 secondQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                partnerInfo.partnerOracleAddress\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            partnerInfo.partnerTokenAddress\n        );\n\n        return firstQuote\n            * secondQuote\n            / uint256(\n                _getOneUnit(\n                    partnerInfo.partnerTokenAddress\n                )\n            );\n    }\n\n    /**\n     * @dev Stores expected heartbeat\n     * value for a pricing feed token.\n     */\n    function _recalibrate(\n        address _tokenAddress\n    )\n        internal\n    {\n        heartBeat[_tokenAddress] = _recalibratePreview(\n            _tokenAddress\n        );\n    }\n\n    /**\n     * @dev Check if chainLink\n     * squencer is wroking.\n     */\n    function sequencerIsDead()\n        public\n        view\n        returns (bool)\n    {\n        if (IS_ARBITRUM_CHAIN == false) {\n            return false;\n        }\n\n        (\n            ,\n            int256 answer,\n            uint256 startedAt,\n            ,\n        ) = SEQUENCER.latestRoundData();\n\n        if (answer == 1) {\n            return true;\n        }\n\n        uint256 timeSinceUp = block.timestamp\n            - startedAt;\n\n        if (timeSinceUp <= GRACE_PEROID) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Check if chainLink feed was\n     * updated within expected timeFrame\n     * for single {_tokenAddress}.\n     */\n    function _chainLinkIsDead(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // @TODO: Add a check for TWAP comparison on 2.5%\n        // if TWAP exists for the token.\n\n        if (heartBeat[_tokenAddress] == 0) {\n            revert HeartBeatNotSet();\n        }\n\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 upd = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        unchecked {\n            upd = block.timestamp < upd\n                ? block.timestamp\n                : block.timestamp - upd;\n\n            return upd > heartBeat[_tokenAddress];\n        }\n    }\n\n    /**\n     * @dev Recalibrates expected\n     * heartbeat for a pricing feed.\n     */\n    function _recalibratePreview(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 latestTimestamp = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        uint80 iterationCount = _getIterationCount(\n            latestRoundId\n        );\n\n        if (iterationCount < MIN_ITERATION_COUNT) {\n            revert SampleTooSmall(\n                {\n                    size: iterationCount\n                }\n            );\n        }\n\n        uint80 i = 1;\n        uint256 currentDiff;\n        uint256 currentBiggest;\n        uint256 currentSecondBiggest;\n\n        while (i < iterationCount) {\n\n            uint256 currentTimestamp = _getRoundTimestamp(\n                _tokenAddress,\n                latestRoundId - i\n            );\n\n            currentDiff = latestTimestamp\n                - currentTimestamp;\n\n            latestTimestamp = currentTimestamp;\n\n            if (currentDiff >= currentBiggest) {\n\n                currentSecondBiggest = currentBiggest;\n                currentBiggest = currentDiff;\n\n            } else if (currentDiff > currentSecondBiggest) {\n                currentSecondBiggest = currentDiff;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return currentSecondBiggest;\n    }\n\n    /**\n     * @dev Determines number of iterations\n     * needed during heartbeat recalibration.\n     */\n    function _getIterationCount(\n        uint80 _latestAggregatorRoundId\n    )\n        internal\n        pure\n        returns (uint80 res)\n    {\n        res = _latestAggregatorRoundId < MAX_ROUND_COUNT\n            ? _latestAggregatorRoundId\n            : MAX_ROUND_COUNT;\n    }\n\n    /**\n     * @dev Fetches timestamp of a byteshifted\n     * aggregatorRound with specific _roundId.\n     */\n    function _getRoundTimestamp(\n        address _tokenAddress,\n        uint80 _roundId\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            ,\n            ,\n            uint256 timestamp\n            ,\n        ) = priceFeed[_tokenAddress].getRoundData(\n                _roundId\n            );\n\n        return timestamp;\n    }\n\n    /**\n     * @dev Routing latest round data from chainLink.\n     * Returns latestRoundData by passing underlying token address.\n     */\n    function getLatestRoundId(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (\n            uint80 roundId\n        )\n    {\n        (\n            roundId\n            ,\n            ,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n    }\n}"
    }
  ]
}