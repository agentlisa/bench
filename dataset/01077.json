{
  "Title": "H-1: Subsequent takes increase next kicker reward, allowing total kicker reward to be artificially amplified by splitting take into a batch",
  "Content": "# Issue H-1: Subsequent takes increase next kicker reward, allowing total kicker reward to be artificially amplified by splitting take into a batch \n\nSource: https://github.com/sherlock-audit/2023-09-ajna-judging/issues/69 \n\n## Found by \nhyh\n\nKicker reward is being determined as a proportion of auction price to neutral price (NP) distance to the distance between NP and threshold price (TP). The latter is determined on the fly, with the current debt and collateral, and in the presence of take penalty, actually rises with every take.\n\nThis way for any taker it will be profitable to perform many small takes atomically instead of one bigger take, bloating the kicker reward received simply due to rising TP as of time of each subsequent kick.\n\n## Vulnerability Detail\n\nTake penalty being imposed on a borrower worsens its TP. This way a take performed on the big enough debt being auctioned increases the kicker rewards produced by the next take.\n\nThis way multiple takes done atomically increase cumulative kicker reward, so if kicker and taker are affiliated then the kicker reward can be augmented above one stated in the protocol logic.\n\n## Impact\n\nKicker reward can be made excessive at the expense of the reserves part.\n\n## Code Snippet\n\nIf `auctionPrice_` is fixed to be `market_price - required_margin` then the bigger `thresholdPrice` the bigger the `sign` and resulting `_bpf()` returned value:\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/helpers/PoolHelper.sol#L382-L411\n\n```solidity\n    function _bpf(\n        ...\n    ) pure returns (int256) {\n        int256 thresholdPrice = int256(Maths.wdiv(debt_, collateral_));\n\n        int256 sign;\n>>      if (thresholdPrice < int256(neutralPrice_)) {\n            // BPF = BondFactor * min(1, max(-1, (neutralPrice - price) / (neutralPrice - thresholdPrice)))\n            sign = Maths.minInt(\n                1e18,\n                Maths.maxInt(\n                    -1 * 1e18,\n                    PRBMathSD59x18.div(\n                        int256(neutralPrice_) - int256(auctionPrice_),\n>>                      int256(neutralPrice_) - thresholdPrice\n                    )\n                )\n            );\n        } else {\n            int256 val = int256(neutralPrice_) - int256(auctionPrice_);\n            if (val < 0 )      sign = -1e18;\n>>          else if (val != 0) sign = 1e18;\n        }\n\n        return PRBMathSD59x18.mul(int256(bondFactor_), sign);\n    }\n```\n\n`thresholdPrice >= int256(neutralPrice_)` will not happen on initial kick as `npTpRatio` is always above 1, but can happen if TP is raised high enough by a series of smaller takes, i.e. taker in some cases can even force kicker reward to be maximal `+1 * bondFactor_`.\n\n`takePenaltyFactor` is paid by the borrower in addition to auction price:\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/external/TakerActions.sol#L724-L736\n\n```solidity\n    function _calculateTakeFlowsAndBondChange(\n        uint256              totalCollateral_,\n        uint256              inflator_,\n        uint256              collateralScale_,\n        TakeLocalVars memory vars\n    ) internal pure returns (\n        TakeLocalVars memory\n    ) {\n        // price is the current auction price, which is the price paid by the LENDER for collateral\n        // from the borrower point of view, there is a take penalty of  (1.25 * bondFactor - 0.25 * bpf)\n        // Therefore the price is actually price * (1.0 - 1.25 * bondFactor + 0.25 * bpf)\n        uint256 takePenaltyFactor    = uint256(5 * int256(vars.bondFactor) - vars.bpf + 3) / 4;  // Round up\n        uint256 borrowerPrice        = Maths.floorWmul(vars.auctionPrice, Maths.WAD - takePenaltyFactor);\n```\n\n`takePenaltyFactor` can be `3-3.75%` for `vars.bpf > 0` and `bondFactor` maximized to be `3%`, so if TP is above market price by a lower margin, say `TP = 1.025 * market_price`, then the removal of `3-3.75%` part will worsen it off.\n\nThe opposite will happen when TP is greater than that, but this calls for the singular executions and doesn't look exploitable.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider limiting the take penalty so it won't worsen the collaterization of the auctioned loan, e.g. limiting `takePenaltyFactor` to `TP / market_price - 1`.\n\n\n\n## Discussion\n\n**ith-harvey**\n\nWe wrote a test for this and determined that rewards do not increase with each subsequent take. As it is written this is an invalid issue. We did however discover an issue: when you take above the TP you move the TP down, this can increase the penalty to the bond holder and the borrower.\n\nWe will fix this separate issue and will memorialize the TP on kick.\n\n**midori-fuse**\n\nEscalate\n\nThis issue is invalid as per sponsor statement and therefore should not be rewarded.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This issue is invalid as per sponsor statement and therefore should not be rewarded.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**neeksec**\n\n@dmitriia \nCan you please provide a PoC test case for this one?\nI have to agree with the Escalation if no further PoC is provided.\n\n**dmitriia**\n\n> @dmitriia Can you please provide a PoC test case for this one?\n\nWill get back shortly on this.\n\n\n\n**dmitriia**\n\nThere is [one done by Proteek](https://gist.github.com/prateek105/4da00febe76990f77987d0560669117c#file-multipletakekickerrewardtest-t-sol-L135).\n\nIt shows the increasing reward when auction price is within `(TP / (1 - takePenalty), TP)` range:\n\n```solidity\n        // Reward is increased with subsequent take just above TP.\n        assertEq(totalBondAfterFullTake,       296.921313863332593428 * 1e18);\n        assertEq(totalBondAfterSubsequentTake, 299.032319479303523664 * 1e18);\n        assertGt(totalBondAfterSubsequentTake, totalBondAfterFullTake);\n```\n\nIt is practical for kicker/taker to atomically split the take in the series of a smaller ones as this enhances their total reward for the price of a moderate gas cost increase.\n\n**Czar102**\n\nResult:\nHigh\nUnique\n\nIn the future will have another way of dealing with low-effort issues. For now need to reject the escalation. I'm sorry @midori-fuse\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [midori-fuse](https://github.com/sherlock-audit/2023-09-ajna-judging/issues/69/#issuecomment-1798861159): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/114",
  "Code": [
    {
      "filename": "ajna-core/src/libraries/helpers/PoolHelper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { PRBMathSD59x18 } from \"@prb-math/contracts/PRBMathSD59x18.sol\";\nimport { Math }           from '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport { Buckets } from '../internal/Buckets.sol';\nimport { Maths }   from '../internal/Maths.sol';\n\n    error BucketIndexOutOfBounds();\n    error BucketPriceOutOfBounds();\n\n    /*************************/\n    /*** Price Conversions ***/\n    /*************************/\n\n    /// @dev constant price indices defining the min and max of the potential price range\n    int256  constant MAX_BUCKET_INDEX  =  4_156;\n    int256  constant MIN_BUCKET_INDEX  = -3_232;\n    uint256 constant MAX_FENWICK_INDEX =  7_388;\n\n    uint256 constant MIN_PRICE = 99_836_282_890;\n    uint256 constant MAX_PRICE = 1_004_968_987.606512354182109771 * 1e18;\n\n    uint256 constant MAX_INFLATED_PRICE = 50_248_449_380.325617709105488550 * 1e18; // 50 * MAX_PRICE\n\n    /// @dev deposit buffer (extra margin) used for calculating reserves\n    uint256 constant DEPOSIT_BUFFER = 1.000000001 * 1e18;\n\n    /// @dev step amounts in basis points. This is a constant across pools at `0.005`, achieved by dividing `WAD` by `10,000`\n    int256 constant FLOAT_STEP_INT = 1.005 * 1e18;\n\n    /**\n     *  @notice Calculates the price (`WAD` precision) for a given `Fenwick` index.\n     *  @dev    Reverts with `BucketIndexOutOfBounds` if index exceeds maximum constant.\n     *  @dev    Uses fixed-point math to get around lack of floating point numbers in `EVM`.\n     *  @dev    Fenwick index is converted to bucket index.\n     *  @dev    Fenwick index to bucket index conversion:\n     *  @dev      `1.00`      : bucket index `0`,     fenwick index `4156`: `7388-4156-3232=0`.\n     *  @dev      `MAX_PRICE` : bucket index `4156`,  fenwick index `0`:    `7388-0-3232=4156`.\n     *  @dev      `MIN_PRICE` : bucket index - `3232`, fenwick index `7388`: `7388-7388-3232=-3232`.\n     *  @dev    `V1`: `price = MIN_PRICE + (FLOAT_STEP * index)`\n     *  @dev    `V2`: `price = MAX_PRICE * (FLOAT_STEP ** (abs(int256(index - MAX_PRICE_INDEX))));`\n     *  @dev    `V3 (final)`: `x^y = 2^(y*log_2(x))`\n     */\n    function _priceAt(\n        uint256 index_\n    ) pure returns (uint256) {\n        // Lowest Fenwick index is highest price, so invert the index and offset by highest bucket index.\n        int256 bucketIndex = MAX_BUCKET_INDEX - int256(index_);\n        if (bucketIndex < MIN_BUCKET_INDEX || bucketIndex > MAX_BUCKET_INDEX) revert BucketIndexOutOfBounds();\n\n        return uint256(\n            PRBMathSD59x18.exp2(\n                PRBMathSD59x18.mul(\n                    PRBMathSD59x18.fromInt(bucketIndex),\n                    PRBMathSD59x18.log2(FLOAT_STEP_INT)\n                )\n            )\n        );\n    }\n\n    /**\n     *  @notice Calculates the  Fenwick  index for a given price.\n     *  @dev    Reverts with `BucketPriceOutOfBounds` if price exceeds maximum constant.\n     *  @dev    Price expected to be inputted as a `WAD` (`18` decimal).\n     *  @dev    `V1`: `bucket index = (price - MIN_PRICE) / FLOAT_STEP`\n     *  @dev    `V2`: `bucket index = (log(FLOAT_STEP) * price) /  MAX_PRICE`\n     *  @dev    `V3 (final)`: `bucket index =  log_2(price) / log_2(FLOAT_STEP)`\n     *  @dev    `Fenwick index = 7388 - bucket index + 3232`\n     */\n    function _indexOf(\n        uint256 price_\n    ) pure returns (uint256) {\n        if (price_ < MIN_PRICE || price_ > MAX_PRICE) revert BucketPriceOutOfBounds();\n\n        int256 index = PRBMathSD59x18.div(\n            PRBMathSD59x18.log2(int256(price_)),\n            PRBMathSD59x18.log2(FLOAT_STEP_INT)\n        );\n\n        int256 ceilIndex = PRBMathSD59x18.ceil(index);\n        if (index < 0 && ceilIndex - index > 0.5 * 1e18) {\n            return uint256(4157 - PRBMathSD59x18.toInt(ceilIndex));\n        }\n        return uint256(4156 - PRBMathSD59x18.toInt(ceilIndex));\n    }\n\n    /**********************/\n    /*** Pool Utilities ***/\n    /**********************/\n\n    /**\n     *  @notice Calculates the minimum debt amount that can be borrowed or can remain in a loan in pool.\n     *  @param  debt_          The debt amount to calculate minimum debt amount for.\n     *  @param  loansCount_    The number of loans in pool.\n     *  @return minDebtAmount_ Minimum debt amount value of the pool.\n     */\n    function _minDebtAmount(\n        uint256 debt_,\n        uint256 loansCount_\n    ) pure returns (uint256 minDebtAmount_) {\n        if (loansCount_ != 0) {\n            minDebtAmount_ = Maths.wdiv(Maths.wdiv(debt_, Maths.wad(loansCount_)), 10**19);\n        }\n    }\n\n    /**\n     *  @notice Calculates origination fee for a given interest rate.\n     *  @notice Calculated as greater of the current annualized interest rate divided by `52` (one week of interest) or `5` bps.\n     *  @param  interestRate_ The current interest rate.\n     *  @return Fee rate based upon the given interest rate.\n     */\n    function _borrowFeeRate(\n        uint256 interestRate_\n    ) pure returns (uint256) {\n        // greater of the current annualized interest rate divided by 52 (one week of interest) or 5 bps\n        return Maths.max(Maths.wdiv(interestRate_, 52 * 1e18), 0.0005 * 1e18);\n    }\n\n    /**\n     * @notice Calculates the unutilized deposit fee, charged to lenders who deposit below the `LUP`.\n     * @param  interestRate_ The current interest rate.\n     * @return Fee rate based upon the given interest rate, capped at 10%.\n     */\n    function _depositFeeRate(\n        uint256 interestRate_\n    ) pure returns (uint256) {\n        // current annualized rate divided by 365 (24 hours of interest), capped at 10%\n        return Maths.min(Maths.wdiv(interestRate_, 365 * 1e18), 0.1 * 1e18);\n    }\n\n    /**\n     *  @notice Calculates debt-weighted average threshold price.\n     *  @param  t0Debt_              Pool debt owed by borrowers in `t0` terms.\n     *  @param  inflator_            Pool's borrower inflator.\n     *  @param  t0Debt2ToCollateral_ `t0-debt-squared-to-collateral` accumulator. \n     */\n    function _dwatp(\n        uint256 t0Debt_,\n        uint256 inflator_,\n        uint256 t0Debt2ToCollateral_\n    ) pure returns (uint256) {\n        return t0Debt_ == 0 ? 0 : Maths.wdiv(Maths.wmul(inflator_, t0Debt2ToCollateral_), t0Debt_);\n    }\n\n    /**\n     *  @notice Collateralization calculation.\n     *  @param debt_       Debt to calculate collateralization for.\n     *  @param collateral_ Collateral to calculate collateralization for.\n     *  @param price_      Price to calculate collateralization for.\n     *  @param type_       Type of the pool.\n     *  @return `True` if collateralization calculated is equal or greater than `1`.\n     */\n    function _isCollateralized(\n        uint256 debt_,\n        uint256 collateral_,\n        uint256 price_,\n        uint8 type_\n    ) pure returns (bool) {\n        if (type_ == uint8(PoolType.ERC20)) return Maths.wmul(collateral_, price_) >= debt_;\n        else {\n            //slither-disable-next-line divide-before-multiply\n            collateral_ = (collateral_ / Maths.WAD) * Maths.WAD; // use collateral floor\n            return Maths.wmul(collateral_, price_) >= debt_;\n        }\n    }\n\n    /**\n     *  @notice Price precision adjustment used in calculating collateral dust for a bucket.\n     *          To ensure the accuracy of the exchange rate calculation, buckets with smaller prices require\n     *          larger minimum amounts of collateral.  This formula imposes a lower bound independent of token scale.\n     *  @param  bucketIndex_              Index of the bucket, or `0` for encumbered collateral with no bucket affinity.\n     *  @return pricePrecisionAdjustment_ Unscaled integer of the minimum number of decimal places the dust limit requires.\n     */\n    function _getCollateralDustPricePrecisionAdjustment(\n        uint256 bucketIndex_\n    ) pure returns (uint256 pricePrecisionAdjustment_) {\n        // conditional is a gas optimization\n        if (bucketIndex_ > 3900) {\n            int256 bucketOffset = int256(bucketIndex_ - 3900);\n            int256 result = PRBMathSD59x18.sqrt(PRBMathSD59x18.div(bucketOffset * 1e18, int256(36 * 1e18)));\n            pricePrecisionAdjustment_ = uint256(result / 1e18);\n        }\n    }\n\n    /**\n     *  @notice Returns the amount of collateral calculated for the given amount of `LP`.\n     *  @dev    The value returned is capped at collateral amount available in bucket.\n     *  @param  bucketCollateral_ Amount of collateral in bucket.\n     *  @param  bucketLP_         Amount of `LP` in bucket.\n     *  @param  deposit_          Current bucket deposit (quote tokens). Used to calculate bucket's exchange rate / `LP`.\n     *  @param  lenderLPBalance_  The amount of `LP` to calculate collateral for.\n     *  @param  bucketPrice_      Bucket's price.\n     *  @return collateralAmount_ Amount of collateral calculated for the given `LP `amount.\n     */\n    function _lpToCollateral(\n        uint256 bucketCollateral_,\n        uint256 bucketLP_,\n        uint256 deposit_,\n        uint256 lenderLPBalance_,\n        uint256 bucketPrice_\n    ) pure returns (uint256 collateralAmount_) {\n        collateralAmount_ = Buckets.lpToCollateral(\n            bucketCollateral_,\n            bucketLP_,\n            deposit_,\n            lenderLPBalance_,\n            bucketPrice_,\n            Math.Rounding.Down\n        );\n\n        if (collateralAmount_ > bucketCollateral_) {\n            // user is owed more collateral than is available in the bucket\n            collateralAmount_ = bucketCollateral_;\n        }\n    }\n\n    /**\n     *  @notice Returns the amount of quote tokens calculated for the given amount of `LP`.\n     *  @dev    The value returned is capped at available bucket deposit.\n     *  @param  bucketLP_         Amount of `LP` in bucket.\n     *  @param  bucketCollateral_ Amount of collateral in bucket.\n     *  @param  deposit_          Current bucket deposit (quote tokens). Used to calculate bucket's exchange rate / `LP`.\n     *  @param  lenderLPBalance_  The amount of `LP` to calculate quote token amount for.\n     *  @param  maxQuoteToken_    The max quote token amount to calculate `LP` for.\n     *  @param  bucketPrice_      Bucket's price.\n     *  @return quoteTokenAmount_ Amount of quote tokens calculated for the given `LP` amount, capped at available bucket deposit.\n     */\n    function _lpToQuoteToken(\n        uint256 bucketLP_,\n        uint256 bucketCollateral_,\n        uint256 deposit_,\n        uint256 lenderLPBalance_,\n        uint256 maxQuoteToken_,\n        uint256 bucketPrice_\n    ) pure returns (uint256 quoteTokenAmount_) {\n        quoteTokenAmount_ = Buckets.lpToQuoteTokens(\n            bucketCollateral_,\n            bucketLP_,\n            deposit_,\n            lenderLPBalance_,\n            bucketPrice_,\n            Math.Rounding.Down\n        );\n\n        if (quoteTokenAmount_ > deposit_)       quoteTokenAmount_ = deposit_;\n        if (quoteTokenAmount_ > maxQuoteToken_) quoteTokenAmount_ = maxQuoteToken_;\n    }\n\n    /**\n     *  @notice Rounds a token amount down to the minimum amount permissible by the token scale.\n     *  @param  amount_       Value to be rounded.\n     *  @param  tokenScale_   Scale of the token, presented as a power of `10`.\n     *  @return scaledAmount_ Rounded value.\n     */\n    function _roundToScale(\n        uint256 amount_,\n        uint256 tokenScale_\n    ) pure returns (uint256 scaledAmount_) {\n        scaledAmount_ = (amount_ / tokenScale_) * tokenScale_;\n    }\n\n    /**\n     *  @notice Rounds a token amount up to the next amount permissible by the token scale.\n     *  @param  amount_       Value to be rounded.\n     *  @param  tokenScale_   Scale of the token, presented as a power of `10`.\n     *  @return scaledAmount_ Rounded value.\n     */\n    function _roundUpToScale(\n        uint256 amount_,\n        uint256 tokenScale_\n    ) pure returns (uint256 scaledAmount_) {\n        if (amount_ % tokenScale_ == 0)\n            scaledAmount_ = amount_;\n        else\n            scaledAmount_ = _roundToScale(amount_, tokenScale_) + tokenScale_;\n    }\n\n    /*********************************/\n    /*** Reserve Auction Utilities ***/\n    /*********************************/\n\n    uint256 constant MINUTE_HALF_LIFE    = 0.988514020352896135_356867505 * 1e27;  // 0.5^(1/60)\n\n    /**\n     *  @notice Calculates claimable reserves within the pool.\n     *  @dev    Claimable reserve auctions and escrowed auction bonds are guaranteed by the pool.\n     *  @param  debt_                    Pool's debt.\n     *  @param  poolSize_                Pool's deposit size.\n     *  @param  totalBondEscrowed_       Total bond escrowed.\n     *  @param  reserveAuctionUnclaimed_ Pool's unclaimed reserve auction.\n     *  @param  quoteTokenBalance_       Pool's quote token balance.\n     *  @return claimable_               Calculated pool reserves.\n     */  \n    function _claimableReserves(\n        uint256 debt_,\n        uint256 poolSize_,\n        uint256 totalBondEscrowed_,\n        uint256 reserveAuctionUnclaimed_,\n        uint256 quoteTokenBalance_\n    ) pure returns (uint256 claimable_) {\n        uint256 guaranteedFunds = totalBondEscrowed_ + reserveAuctionUnclaimed_;\n\n        // calculate claimable reserves if there's quote token excess\n        if (quoteTokenBalance_ > guaranteedFunds) {\n            claimable_ = Maths.wmul(0.995 * 1e18, debt_) + quoteTokenBalance_;\n\n            claimable_ -= Maths.min(\n                claimable_,\n                // require 1.0 + 1e-9 deposit buffer (extra margin) for deposits\n                Maths.wmul(DEPOSIT_BUFFER, poolSize_) + guaranteedFunds\n            );\n\n            // incremental claimable reserve should not exceed excess quote in pool\n            claimable_ = Maths.min(\n                claimable_,\n                quoteTokenBalance_ - guaranteedFunds\n            );\n        }\n    }\n\n    /**\n     *  @notice Calculates reserves auction price.\n     *  @param  reserveAuctionKicked_ Time when reserve auction was started (kicked).\n     *  @return price_                Calculated auction price.\n     */     \n    function _reserveAuctionPrice(\n        uint256 reserveAuctionKicked_\n    ) view returns (uint256 price_) {\n        if (reserveAuctionKicked_ != 0) {\n            uint256 secondsElapsed   = block.timestamp - reserveAuctionKicked_;\n            uint256 hoursComponent   = 1e27 >> secondsElapsed / 3600;\n            uint256 minutesComponent = Maths.rpow(MINUTE_HALF_LIFE, secondsElapsed % 3600 / 60);\n\n            price_ = Maths.rayToWad(1_000_000_000 * Maths.rmul(hoursComponent, minutesComponent));\n        }\n    }\n\n    /*************************/\n    /*** Auction Utilities ***/\n    /*************************/\n\n    /**\n     *  @notice Calculates auction price.\n     *  @param  referencePrice_ Recorded at kick, used to calculate start price.\n     *  @param  kickTime_       Time when auction was kicked.\n     *  @return price_          Calculated auction price.\n     */\n    function _auctionPrice(\n        uint256 referencePrice_,\n        uint256 kickTime_\n    ) view returns (uint256 price_) {\n        uint256 elapsedMinutes = Maths.wdiv((block.timestamp - kickTime_) * 1e18, 1 minutes * 1e18);\n\n        int256 timeAdjustment;\n        if (elapsedMinutes < 120 * 1e18) {\n            timeAdjustment = PRBMathSD59x18.mul(-1 * 1e18, int256(elapsedMinutes / 20));\n            price_ = 256 * Maths.wmul(referencePrice_, uint256(PRBMathSD59x18.exp2(timeAdjustment)));\n        } else if (elapsedMinutes < 840 * 1e18) {\n            timeAdjustment = PRBMathSD59x18.mul(-1 * 1e18, int256((elapsedMinutes - 120 * 1e18) / 120));\n            price_ = 4 * Maths.wmul(referencePrice_, uint256(PRBMathSD59x18.exp2(timeAdjustment)));\n        } else {\n            timeAdjustment = PRBMathSD59x18.mul(-1 * 1e18, int256((elapsedMinutes - 840 * 1e18) / 60));\n            price_ = Maths.wmul(referencePrice_, uint256(PRBMathSD59x18.exp2(timeAdjustment))) / 16;\n        }\n    }\n\n    /**\n     *  @notice Calculates bond penalty factor.\n     *  @dev    Called in kick and take.\n     *  @param debt_         Borrower debt.\n     *  @param collateral_   Borrower collateral.\n     *  @param neutralPrice_ `NP` of auction.\n     *  @param bondFactor_   Factor used to determine bondSize.\n     *  @param auctionPrice_ Auction price at the time of call.\n     *  @return bpf_         Factor used in determining bond `reward` (positive) or `penalty` (negative).\n     */\n    function _bpf(\n        uint256 debt_,\n        uint256 collateral_,\n        uint256 neutralPrice_,\n        uint256 bondFactor_,\n        uint256 auctionPrice_\n    ) pure returns (int256) {\n        int256 thresholdPrice = int256(Maths.wdiv(debt_, collateral_));\n\n        int256 sign;\n        if (thresholdPrice < int256(neutralPrice_)) {\n            // BPF = BondFactor * min(1, max(-1, (neutralPrice - price) / (neutralPrice - thresholdPrice)))\n            sign = Maths.minInt(\n                1e18,\n                Maths.maxInt(\n                    -1 * 1e18,\n                    PRBMathSD59x18.div(\n                        int256(neutralPrice_) - int256(auctionPrice_),\n                        int256(neutralPrice_) - thresholdPrice\n                    )\n                )\n            );\n        } else {\n            int256 val = int256(neutralPrice_) - int256(auctionPrice_);\n            if (val < 0 )      sign = -1e18;\n            else if (val != 0) sign = 1e18;\n        }\n\n        return PRBMathSD59x18.mul(int256(bondFactor_), sign);\n    }\n\n    /**\n     *  @notice Calculates bond parameters of an auction.\n     *  @param  borrowerDebt_   Borrower's debt before entering in liquidation.\n     *  @param  npTpRatio_      Borrower's Np to Tp ratio\n     */\n    function _bondParams(\n        uint256 borrowerDebt_,\n        uint256 npTpRatio_\n    ) pure returns (uint256 bondFactor_, uint256 bondSize_) {\n        // bondFactor = min((NP-to-TP-ratio - 1)/10, 0.03)\n        bondFactor_ = Maths.min(\n            0.03 * 1e18,\n            (npTpRatio_ - 1e18) / 10\n        );\n\n        bondSize_ = Maths.wmul(bondFactor_,  borrowerDebt_);\n    }"
    },
    {
      "filename": "ajna-core/src/libraries/external/TakerActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { PRBMathSD59x18 } from \"@prb-math/contracts/PRBMathSD59x18.sol\";\nimport { Math }           from '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    BurnEvent,\n    DepositsState,\n    Liquidation,\n    LoansState,\n    PoolState,\n    ReserveAuctionState\n}                        from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    TakeResult\n}                        from '../../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _auctionPrice,\n    _bpf,\n    _priceAt,\n    _reserveAuctionPrice,\n    _roundToScale,\n    _roundUpToScale\n}                           from '../helpers/PoolHelper.sol';\nimport { _revertOnMinDebt } from '../helpers/RevertsHelper.sol';\n\nimport { SettlerActions } from './SettlerActions.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  Auction Taker Actions library\n    @notice External library containing actions involving taking auctions within pool:\n            - `take` and `bucketTake` auctioned collateral; take reserves\n */\nlibrary TakerActions {\n\n    /*******************************/\n    /*** Function Params Structs ***/\n    /*******************************/\n\n    /// @dev Struct used to hold `bucketTake` function params.\n    struct BucketTakeParams {\n        address borrower;        // borrower address to take from\n        bool    depositTake;     // deposit or arb take, used by bucket take\n        uint256 index;           // bucket index, used by bucket take\n        uint256 inflator;        // [WAD] current pool inflator\n        uint256 collateralScale; // precision of collateral token based on decimals\n    }\n\n    /// @dev Struct used to hold `take` function params.\n    struct TakeParams {\n        address borrower;        // borrower address to take from\n        uint256 takeCollateral;  // [WAD] desired amount to take\n        uint256 inflator;        // [WAD] current pool inflator\n        uint256 poolType;        // pool type (ERC20 or NFT)\n        uint256 collateralScale; // precision of collateral token based on decimals\n    }\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `take` function local vars.\n    struct TakeLocalVars {\n        uint256 auctionPrice;                // [WAD] The price of auction.\n        uint256 bondChange;                  // [WAD] The change made on the bond size (beeing reward or penalty).\n        uint256 borrowerDebt;                // [WAD] The accrued debt of auctioned borrower.\n        int256  bpf;                         // The bond penalty factor.\n        uint256 bondFactor;                  // [WAD] The bond factor.\n        uint256 bucketPrice;                 // [WAD] The bucket price.\n        uint256 bucketScale;                 // [WAD] The bucket scale.\n        uint256 collateralAmount;            // [WAD] The amount of collateral taken.\n        uint256 excessQuoteToken;            // [WAD] Difference of quote token that borrower receives after take (for fractional NFT only)\n        uint256 factor;                      // The take factor, calculated based on bond penalty factor.\n        bool    isRewarded;                  // True if kicker is rewarded (auction price lower than neutral price), false if penalized (auction price greater than neutral price).\n        address kicker;                      // Address of auction kicker.\n        uint256 quoteTokenAmount;            // [WAD] Scaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral\n        uint256 t0RepayAmount;               // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.\n        uint256 t0BorrowerDebt;              // [WAD] Borrower's t0 debt.\n        uint256 unscaledDeposit;             // [WAD] Unscaled bucket quantity\n        uint256 unscaledQuoteTokenAmount;    // [WAD] The unscaled token amount that taker should pay for collateral taken.\n        uint256 depositCollateralConstraint; // [WAD] Constraint on bucket take from deposit present in bucket\n        uint256 debtCollateralConstraint;    // [WAD] Constraint on take due to debt.\n   }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event BucketTake(address indexed borrower, uint256 index, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);\n    event BucketTakeLPAwarded(address indexed taker, address indexed kicker, uint256 lpAwardedTaker, uint256 lpAwardedKicker);\n    event Take(address indexed borrower, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);\n    event ReserveAuction(uint256 claimableReservesRemaining, uint256 auctionPrice, uint256 currentBurnEpoch);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error AuctionNotTakeable();\n    error AuctionPriceGtBucketPrice();\n    error CollateralRoundingNeededButNotPossible();\n    error InsufficientLiquidity();\n    error InsufficientCollateral();\n    error InvalidAmount();\n    error NoAuction();\n    error NoReserves();\n    error NoReservesAuction();\n    error ReserveAuctionTooSoon();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IPoolTakerActions` for descriptions.\n     *  @notice Performs bucket take collateral on an auction, rewards taker and kicker (if case) and updates loan info (settles auction if case).\n     *  @dev    === Reverts on ===\n     *  @dev    not enough collateral to take `InsufficientCollateral()`\n     *  @return result_ `TakeResult` struct containing details of bucket take result.\n    */\n    function bucketTake(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_,\n        uint256 collateralScale_\n    ) external returns (TakeResult memory result_) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n        // revert if borrower's collateral is 0\n        if (borrower.collateral == 0) revert InsufficientCollateral();\n\n        result_.debtPreAction       = borrower.t0Debt;\n        result_.collateralPreAction = borrower.collateral;\n\n        // bucket take auction\n        TakeLocalVars memory vars = _takeBucket(\n            auctions_,\n            buckets_,\n            deposits_,\n            borrower,\n            BucketTakeParams({\n                borrower:        borrowerAddress_,\n                inflator:        poolState_.inflator,\n                depositTake:     depositTake_,\n                index:           index_,\n                collateralScale: collateralScale_\n            })\n        );\n\n        // update borrower after take\n        borrower.collateral -= vars.collateralAmount;\n        borrower.t0Debt     = vars.t0BorrowerDebt - vars.t0RepayAmount;\n        // update pool params after take\n        poolState_.t0Debt -= vars.t0RepayAmount;\n        poolState_.debt   = Maths.wmul(poolState_.t0Debt, poolState_.inflator);\n\n        // update loan after take\n        (\n            result_.newLup,\n            result_.settledAuction,\n            result_.remainingCollateral,\n            result_.compensatedCollateral\n        ) = _takeLoan(auctions_, buckets_, deposits_, loans_, poolState_, borrower, borrowerAddress_);\n\n        // complete take result struct\n        result_.debtPostAction       = borrower.t0Debt;\n        result_.collateralPostAction = borrower.collateral;\n        result_.t0PoolDebt           = poolState_.t0Debt;\n        result_.poolDebt             = poolState_.debt;\n        result_.collateralAmount     = vars.collateralAmount;\n        // if settled then debt in auction changed is the entire borrower debt, otherwise only repaid amount\n        result_.t0DebtInAuctionChange = result_.settledAuction ? vars.t0BorrowerDebt : vars.t0RepayAmount;\n    }\n\n    /**\n     *  @notice See `IPoolTakerActions` for descriptions.\n     *  @notice Performs take collateral on an auction, rewards taker and kicker (if case) and updates loan info (settles auction if case).\n     *  @dev    === Reverts on ===\n     *  @dev    insufficient collateral to take `InsufficientCollateral()`\n     *  @return result_ `TakeResult` struct containing details of take result.\n    */\n    function take(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        address borrowerAddress_,\n        uint256 collateral_,\n        uint256 collateralScale_\n    ) external returns (TakeResult memory result_) {\n        // revert if no amount to take\n        if (collateral_ == 0) revert InvalidAmount();\n\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        if (\n            // revert in case of NFT take when there isn't a full token to be taken\n            (poolState_.poolType == uint8(PoolType.ERC721) && borrower.collateral < 1e18) ||\n            // revert in case of ERC20 take when no collateral to be taken\n            (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)\n        ) {\n            revert InsufficientCollateral();\n        }\n\n        result_.debtPreAction       = borrower.t0Debt;\n        result_.collateralPreAction = borrower.collateral;\n\n        // take auction\n        TakeLocalVars memory vars = _take(\n            auctions_,\n            borrower,\n            TakeParams({\n                borrower:        borrowerAddress_,\n                takeCollateral:  collateral_,\n                inflator:        poolState_.inflator,\n                poolType:        poolState_.poolType,\n                collateralScale: collateralScale_\n            })\n        );\n\n        // update borrower after take\n        borrower.collateral -= vars.collateralAmount;\n        borrower.t0Debt     = vars.t0BorrowerDebt - vars.t0RepayAmount;\n        // update pool params after take\n        poolState_.t0Debt -= vars.t0RepayAmount;\n        poolState_.debt   = Maths.wmul(poolState_.t0Debt, poolState_.inflator);\n\n        // update loan after take\n        (\n            result_.newLup,\n            result_.settledAuction,\n            result_.remainingCollateral,\n            result_.compensatedCollateral\n        ) = _takeLoan(auctions_, buckets_, deposits_, loans_, poolState_, borrower, borrowerAddress_);\n\n        // complete take result struct\n        result_.debtPostAction       = borrower.t0Debt;\n        result_.collateralPostAction = borrower.collateral;\n        result_.t0PoolDebt           = poolState_.t0Debt;\n        result_.poolDebt             = poolState_.debt;\n        result_.collateralAmount     = vars.collateralAmount;\n        result_.quoteTokenAmount     = vars.quoteTokenAmount;\n        result_.excessQuoteToken     = vars.excessQuoteToken;\n        // if settled then debt in auction changed is the entire borrower debt, otherwise only repaid amount\n        result_.t0DebtInAuctionChange = result_.settledAuction ? vars.t0BorrowerDebt : vars.t0RepayAmount;\n    }\n\n    /*************************/\n    /***  Reserve Auction  ***/\n    /*************************/\n\n    /**\n     *  @notice See `IPoolTakerActions` for descriptions.\n     *  @dev    === Write state ===\n     *  @dev    decrement `reserveAuction.unclaimed` accumulator\n     *  @dev    === Reverts on ===\n     *  @dev    not kicked or `72` hours didn't pass `NoReservesAuction()`\n     *  @dev    === Emit events ===\n     *  @dev    - `ReserveAuction`\n     */\n    function takeReserves(\n        ReserveAuctionState storage reserveAuction_,\n        uint256 maxAmount_\n    ) external returns (uint256 amount_, uint256 ajnaRequired_) {\n        // revert if no amount to be taken\n        if (maxAmount_ == 0) revert InvalidAmount();\n\n        uint256 kicked = reserveAuction_.kicked;\n\n        if (kicked != 0 && block.timestamp - kicked <= 72 hours) {\n            uint256 unclaimed = reserveAuction_.unclaimed;\n            uint256 price     = _reserveAuctionPrice(kicked);\n\n            amount_       = Maths.min(unclaimed, maxAmount_);\n            ajnaRequired_ = Maths.ceilWmul(amount_, price);\n\n            unclaimed -= amount_;\n\n            reserveAuction_.unclaimed = unclaimed;\n\n            uint256 totalBurned = reserveAuction_.totalAjnaBurned + ajnaRequired_;\n            \n            // accumulate additional ajna burned\n            reserveAuction_.totalAjnaBurned = totalBurned;\n\n            uint256 burnEventEpoch = reserveAuction_.latestBurnEventEpoch;\n\n            // record burn event information to enable querying by staking rewards\n            BurnEvent storage burnEvent = reserveAuction_.burnEvents[burnEventEpoch];\n            burnEvent.totalInterest = reserveAuction_.totalInterestEarned;\n            burnEvent.totalBurned   = totalBurned;\n\n            emit ReserveAuction(\n                unclaimed,\n                price,\n                burnEventEpoch\n            );\n        } else {\n            revert NoReservesAuction();\n        }\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Performs take collateral on an auction and updates bond size and kicker balance accordingly.\n     *  @dev    === Emit events ===\n     *  @dev    - `Take`\n     *  @param  auctions_ Struct for pool auctions state.\n     *  @param  borrower_ Struct containing auctioned borrower details.\n     *  @param  params_   Struct containing take action params details.\n     *  @return vars_     Struct containing auction take vars.\n    */\n    function _take(\n        AuctionsState storage auctions_,\n        Borrower memory borrower_,\n        TakeParams memory params_\n    ) internal returns (TakeLocalVars memory vars_) {\n        Liquidation storage liquidation = auctions_.liquidations[params_.borrower];\n\n        // Auction may not be taken in the same block it was kicked\n        if (liquidation.kickTime == block.timestamp) revert AuctionNotTakeable();\n\n        vars_ = _prepareTake(\n            liquidati"
    }
  ]
}