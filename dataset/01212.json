{
  "Title": "Inaccurate Documentation",
  "Content": "\nThere are multiple areas where the protocol would benefit from more accurate documentation:\n\n\n* The `_validateOrder` function documentation of the `[DutchOrderReactor](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/reactors/DutchOrderReactor.sol#L64)` and `[ExclusiveDutchOrderReactor](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/reactors/ExclusiveDutchOrderReactor.sol#L70)` contracts describe order properties that must be fulfilled. However, these functions only validate a subset of those properties.\n* The documentation of the [`checkExclusivity` function](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/lib/ExclusivityOverrideLib.sol#L53-L56) does not mention the  \ntimestamp impact on the exclusivity. Furthermore, the function name does not fully align with the code's intention. For instance, the return is `true` if the deadline has expired, or the exclusivity was disabled through the `exclusive` address being zero. Consider renaming the function to something like `hasFillingRights` which matches the intention of the check.\n* The Fees section of the [whitepaper](https://uniswap.org/whitepaper-uniswapx.pdf) states that a fee is only taken on the output tokens of the swap, while [the code also allows a fee](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/base/ProtocolFees.sol#L83-L86) on the input token.\n* The documentation on the website elaborating on [Direct Fill](https://docs.uniswap.org/contracts/uniswapx/overview#direct-fill) appears to be outdated.\n\n\nConsider updating the documentation to be aligned with the intentions of the code.\n\n\n\n***Update:** Resolved in [pull request #193](https://github.com/Uniswap/UniswapX/pull/193) of the [UniswapX](https://github.com/Uniswap/UniswapX) repository at commit [cdd4e33](https://github.com/Uniswap/UniswapX/commit/cdd4e338012efa49f096ae53473002f48131af07) and [pull request #626](https://github.com/Uniswap/docs/pull/626) of the [docs](https://github.com/Uniswap/docs) repository at commit [24d90ab](https://github.com/Uniswap/docs/commit/24d90abcc0f9c3c244661642a61b861c1afda9cb).*\n\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/reactors/DutchOrderReactor.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {IPermit2} from \"permit2/src/interfaces/IPermit2.sol\";\nimport {BaseReactor} from \"./BaseReactor.sol\";\nimport {Permit2Lib} from \"../lib/Permit2Lib.sol\";\nimport {DutchDecayLib} from \"../lib/DutchDecayLib.sol\";\nimport {DutchOrderLib, DutchOrder, DutchOutput, DutchInput} from \"../lib/DutchOrderLib.sol\";\nimport {SignedOrder, ResolvedOrder, InputToken, OrderInfo, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @notice Reactor for dutch orders\ncontract DutchOrderReactor is BaseReactor {\n    using Permit2Lib for ResolvedOrder;\n    using DutchOrderLib for DutchOrder;\n    using DutchDecayLib for DutchOutput[];\n    using DutchDecayLib for DutchInput;\n\n    /// @notice thrown when an order's deadline is before its end time\n    error DeadlineBeforeEndTime();\n\n    /// @notice thrown when an order's inputs and outputs both decay\n    error InputAndOutputDecay();\n\n    constructor(IPermit2 _permit2, address _protocolFeeOwner) BaseReactor(_permit2, _protocolFeeOwner) {}\n\n    /// @inheritdoc BaseReactor\n    function resolve(SignedOrder calldata signedOrder)\n        internal\n        view\n        virtual\n        override\n        returns (ResolvedOrder memory resolvedOrder)\n    {\n        DutchOrder memory order = abi.decode(signedOrder.order, (DutchOrder));\n        _validateOrder(order);\n\n        resolvedOrder = ResolvedOrder({\n            info: order.info,\n            input: order.input.decay(order.decayStartTime, order.decayEndTime),\n            outputs: order.outputs.decay(order.decayStartTime, order.decayEndTime),\n            sig: signedOrder.sig,\n            hash: order.hash()\n        });\n    }\n\n    /// @inheritdoc BaseReactor\n    function transferInputTokens(ResolvedOrder memory order, address to) internal override {\n        permit2.permitWitnessTransferFrom(\n            order.toPermit(),\n            order.transferDetails(to),\n            order.info.swapper,\n            order.hash,\n            DutchOrderLib.PERMIT2_ORDER_TYPE,\n            order.sig\n        );\n    }\n\n    /// @notice validate the dutch order fields\n    /// - deadline must be greater than or equal than decayEndTime\n    /// - decayEndTime must be greater than or equal to decayStartTime\n    /// - if there's input decay, outputs must not decay\n    /// - for input decay, startAmount must < endAmount\n    /// @dev Throws if the order is invalid\n    function _validateOrder(DutchOrder memory order) internal pure {\n        if (order.info.deadline < order.decayEndTime) {\n            revert DeadlineBeforeEndTime();\n        }\n\n        if (order.input.startAmount != order.input.endAmount) {\n            unchecked {\n                for (uint256 i = 0; i < order.outputs.length; i++) {\n                    if (order.outputs[i].startAmount != order.outputs[i].endAmount) {\n                        revert InputAndOutputDecay();\n                    }\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/lib/ExclusivityOverrideLib.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @title ExclusiveOverride\n/// @dev This library handles order exclusivity\n///  giving the configured filler exclusive rights to fill the order before exclusivityEndTime\n///  or enforcing an override price improvement by non-exclusive fillers\nlibrary ExclusivityOverrideLib {\n    using FixedPointMathLib for uint256;\n\n    /// @notice thrown when an order has strict exclusivity and the filler does not have it\n    error NoExclusiveOverride();\n\n    uint256 private constant STRICT_EXCLUSIVITY = 0;\n    uint256 private constant BPS = 10_000;\n\n    /// @notice Applies exclusivity override to the resolved order if necessary\n    /// @param order The order to apply exclusivity override to\n    /// @param exclusive The exclusive address\n    /// @param exclusivityEndTime The exclusivity end time\n    /// @param exclusivityOverrideBps The exclusivity override BPS\n    function handleOverride(\n        ResolvedOrder memory order,\n        address exclusive,\n        uint256 exclusivityEndTime,\n        uint256 exclusivityOverrideBps\n    ) internal view {\n        // if the filler has fill right, we proceed with the order as-is\n        if (checkExclusivity(exclusive, exclusivityEndTime)) {\n            return;\n        }\n\n        // if override is 0, then assume strict exclusivity so the order cannot be filled\n        if (exclusivityOverrideBps == STRICT_EXCLUSIVITY) {\n            revert NoExclusiveOverride();\n        }\n\n        // scale outputs by override amount\n        OutputToken[] memory outputs = order.outputs;\n        for (uint256 i = 0; i < outputs.length;) {\n            OutputToken memory output = outputs[i];\n            output.amount = output.amount.mulDivDown(BPS + exclusivityOverrideBps, BPS);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @notice checks if the order currently passes the exclusivity check\n    /// @dev if the order has no exclusivity, always returns true\n    /// @dev if the order has exclusivity and the current filler is the exclusive address, returns true\n    /// @dev if the order has exclusivity and the current filler is not the exclusive address, returns false\n    function checkExclusivity(address exclusive, uint256 exclusivityEndTime) internal view returns (bool pass) {\n        return exclusive == address(0) || block.timestamp > exclusivityEndTime || exclusive == msg.sender;\n    }\n}"
    },
    {
      "filename": "src/base/ProtocolFees.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {IProtocolFeeController} from \"../interfaces/IProtocolFeeController.sol\";\nimport {CurrencyLibrary} from \"../lib/CurrencyLibrary.sol\";\nimport {ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @notice Handling for protocol fees\nabstract contract ProtocolFees is Owned {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n    using CurrencyLibrary for address;\n\n    /// @notice thrown if two fee outputs have the same token\n    error DuplicateFeeOutput(address duplicateToken);\n    /// @notice thrown if a given fee output is greater than MAX_FEE_BPS of the order outputs\n    error FeeTooLarge(address token, uint256 amount, address recipient);\n    /// @notice thrown if a fee output token does not have a corresponding non-fee output\n    error InvalidFeeToken(address feeToken);\n\n    event ProtocolFeeControllerSet(address oldFeeController, address newFeeController);\n\n    uint256 private constant BPS = 10_000;\n    uint256 private constant MAX_FEE_BPS = 5;\n\n    /// @dev The address of the fee controller\n    IProtocolFeeController public feeController;\n\n    // @notice Required to customize owner from constructor of BaseReactor.sol\n    constructor(address _owner) Owned(_owner) {}\n\n    /// @notice Injects fees into an order\n    /// @dev modifies the orders to include protocol fee outputs\n    /// @param order The encoded order to inject fees into\n    function _injectFees(ResolvedOrder memory order) internal view {\n        if (address(feeController) == address(0)) {\n            return;\n        }\n\n        OutputToken[] memory feeOutputs = feeController.getFeeOutputs(order);\n        uint256 outputsLength = order.outputs.length;\n        uint256 feeOutputsLength = feeOutputs.length;\n\n        // apply fee outputs\n        // fill new outputs with old outputs\n        OutputToken[] memory newOutputs = new OutputToken[](\n            outputsLength + feeOutputsLength\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < outputsLength; i++) {\n                newOutputs[i] = order.outputs[i];\n            }\n        }\n\n        for (uint256 i = 0; i < feeOutputsLength;) {\n            OutputToken memory feeOutput = feeOutputs[i];\n            // assert no duplicates\n            unchecked {\n                for (uint256 j = 0; j < i; j++) {\n                    if (feeOutput.token == feeOutputs[j].token) {\n                        revert DuplicateFeeOutput(feeOutput.token);\n                    }\n                }\n            }\n\n            // assert not greater than MAX_FEE_BPS\n            uint256 tokenValue;\n            for (uint256 j = 0; j < outputsLength;) {\n                OutputToken memory output = order.outputs[j];\n                if (output.token == feeOutput.token) {\n                    tokenValue += output.amount;\n                }\n                unchecked {\n                    j++;\n                }\n            }\n\n            // allow fee on input token as well\n            if (address(order.input.token) == feeOutput.token) {\n                tokenValue += order.input.amount;\n            }\n\n            if (tokenValue == 0) revert InvalidFeeToken(feeOutput.token);\n\n            if (feeOutput.amount > tokenValue.mulDivDown(MAX_FEE_BPS, BPS)) {\n                revert FeeTooLarge(feeOutput.token, feeOutput.amount, feeOutput.recipient);\n            }\n            newOutputs[outputsLength + i] = feeOutput;\n\n            unchecked {\n                i++;\n            }\n        }\n\n        order.outputs = newOutputs;\n    }\n\n    /// @notice sets the protocol fee controller\n    /// @dev only callable by the owner\n    /// @param _newFeeController the new fee controller\n    function setProtocolFeeController(address _newFeeController) external onlyOwner {\n        address oldFeeController = address(feeController);\n        feeController = IProtocolFeeController(_newFeeController);\n        emit ProtocolFeeControllerSet(oldFeeController, _newFeeController);\n    }\n}"
    }
  ]
}