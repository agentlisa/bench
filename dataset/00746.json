{
  "Title": "Locked ETH in Contract",
  "Content": "Throughout the [codebase](https://github.com/Ion-Protocol/ion-protocol/tree/98e282514ac5827196b49f688938e1e44709505a/), there are several contracts that include functions that can receive ETH but with no corresponding function for withdrawing ETH. As a result, any ETH sent to these contracts could be permanently lost. In particular:\n\n\n* The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/admin/TransparentUpgradeableProxy.sol#L79) of the `TransparentUpgradeableProxy` contract\n* The [`flashLeverageWeth` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/BalancerFlashloanDirectMintHandler.sol#L99-L106) in the `BalancerFlashloanDirectMintHandler` contract\n* The [`zapDepositWstEth` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/periphery/IonZapper.sol#L67) in the `IonZapper` contract\n\n\nConsider removing the `payable` attribute or adding a withdrawal feature.\n\n\n***Update:** Resolved in [pull request #23](https://github.com/Ion-Protocol/ion-protocol/pull/23).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/admin/TransparentUpgradeableProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.20;\n\nimport { ERC1967Utils } from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport { ERC1967Proxy } from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport { IERC1967 } from \"@openzeppelin/contracts/interfaces/IERC1967.sol\";\nimport { ProxyAdmin } from \"./ProxyAdmin.sol\";\n\n/**\n * @notice Copy of OpenZeppelin's `TransparentUpgradeableProxy` that uses alternative `ProxyAdmin`\n *\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and its upgradeability mechanism is implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function upgradeToAndCall(address, bytes calldata) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable through an associated {ProxyAdmin} instance.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches the {ITransparentUpgradeableProxy-upgradeToAndCall} function exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can call the `upgradeToAndCall` function but any other call won't be forwarded to\n * the implementation. If the admin tries to call a function on the implementation it will fail with an error indicating\n * the proxy admin cannot fallback to the target implementation.\n *\n * These properties mean that the admin account can only be used for upgrading the proxy, so it's best if it's a\n * dedicated account that is not used for anything else. This will avoid headaches due to sudden errors when trying to\n * call a function from the proxy implementation. For this reason, the proxy deploys an instance of {ProxyAdmin} and\n * allows upgrades only if they come through it. You should think of the `ProxyAdmin` instance as the administrative\n * interface of the proxy, including the ability to change who can trigger upgrades by transferring ownership.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead `upgradeToAndCall` is implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * NOTE: This proxy does not inherit from {Context} deliberately. The {ProxyAdmin} of this contract won't send a\n * meta-transaction in any way, and any other meta-transaction setup should be made in the implementation contract.\n *\n * IMPORTANT: This contract avoids unnecessary storage reads by setting the admin only during construction as an\n * immutable variable, preventing any changes thereafter. However, the admin slot defined in ERC-1967 can still be\n * overwritten by the implementation logic pointed to by this proxy. In such cases, the contract may end up in an\n * undesirable state where the admin slot is different from the actual admin.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the\n * compiler will not check that there are no selector conflicts, due to the note above. A selector clash between any new\n * function and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This\n * could render the `upgradeToAndCall` function inaccessible, preventing upgradeability and compromising transparency.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    // An immutable address for the admin to avoid unnecessary SLOADs before each call\n    // at the expense of removing the ability to change the admin once it's set.\n    // This is acceptable if the admin is always a ProxyAdmin instance or similar contract\n    // with its own ability to transfer the permissions to another account.\n    address private immutable ADMIN;\n\n    /**\n     * @dev The proxy caller is the current admin, and can't fallback to the proxy target.\n     */\n    error ProxyDeniedAdminAccess();\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by an instance of a {ProxyAdmin} with an `initialOwner`,\n     * backed by the implementation at `_logic`, and optionally initialized with `_data` as explained in\n     * {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address initialOwner, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        ADMIN = address(new ProxyAdmin(initialOwner));\n        // Set the storage value and emit an event for ERC-1967 compatibility\n        ERC1967Utils.changeAdmin(_proxyAdmin());\n    }\n\n    /**\n     * @dev Returns the admin of this proxy.\n     */\n    function _proxyAdmin() internal virtual returns (address) {\n        return ADMIN;\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior.\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _proxyAdmin()) {\n            if (msg.sig != ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                revert ProxyDeniedAdminAccess();\n            } else {\n                _dispatchUpgradeToAndCall();\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy. See {ERC1967Utils-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    function _dispatchUpgradeToAndCall() private {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        ERC1967Utils.upgradeToAndCall(newImplementation, data);\n    }\n}"
    },
    {
      "filename": "src/flash/handlers/base/BalancerFlashloanDirectMintHandler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IonHandlerBase } from \"./IonHandlerBase.sol\";\n\nimport { IVault, IERC20 as IERC20Balancer } from \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\nimport { IFlashLoanRecipient } from \"@balancer-labs/v2-interfaces/contracts/vault/IFlashLoanRecipient.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nIVault constant VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n\n/**\n * @dev There are a couple things to consider here from a security perspective. The\n * first one is that the flashloan callback must only be callable from the\n * Balancer vault. This ensures that nobody can pass arbitrary data to the\n * callback. The second one is that the flashloan must only be initialized from\n * this contract. This is a trickier one to enforce since Balancer flashloans\n * are not EIP-3156 compliant and do not pass on the initiator through the\n * callback. To get around this, an inverse reentrancy lock of sorts is used.\n * The lock is set to 2 when a flashloan is initiated and set to 1 once the\n * callback execution terminates. If the lock is not 2 when the callback is\n * called, then the flashloan was not initiated by this contract and the tx is\n * reverted.\n *\n * This contract currently deposits directly into LST contract 1:1. It should be\n * noted that a more favorable trade could be possible via DEXs.\n */\nabstract contract BalancerFlashloanDirectMintHandler is IonHandlerBase, IFlashLoanRecipient {\n    using SafeERC20 for IERC20;\n\n    error ReceiveCallerNotVault(address unauthorizedCaller);\n    error FlashLoanedTooManyTokens(uint256 amountTokens);\n    error FlashloanedInvalidToken(address tokenAddress);\n    error ExternalBalancerFlashloanNotAllowed();\n\n    uint256 private flashloanInitiated = 1;\n\n    /**\n     * @notice Code assumes Balancer flashloans remain free\n     * @param initialDeposit in collateral terms\n     * @param resultingAdditionalCollateral in collateral terms\n     * @param maxResultingDebt in WETH terms. While it is unlikely that the\n     * exchange rate changes from when a transaction is submitted versus when it\n     * is executed, it is still possible so we want to allow for a bound here,\n     * even though it doesn't pose the same level of threat as slippage.\n     */\n    function flashLeverageCollateral(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        external\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n\n        uint256 amountToLeverage = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n\n        IERC20Balancer[] memory addresses = new IERC20Balancer[](1);\n        addresses[0] = IERC20Balancer(address(LST_TOKEN));\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amountToLeverage;\n\n        if (amounts[0] == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        uint256 wethRequiredForRepayment = _getEthAmountInForLstAmountOut(amountToLeverage);\n        if (wethRequiredForRepayment > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(wethRequiredForRepayment, maxResultingDebt);\n        }\n\n        // Prevents attackers from initiating flashloan and passing malicious data through callback\n        flashloanInitiated = 2;\n\n        VAULT.flashLoan(\n            IFlashLoanRecipient(address(this)),\n            addresses,\n            amounts,\n            abi.encode(msg.sender, initialDeposit, resultingAdditionalCollateral, maxResultingDebt)\n        );\n\n        flashloanInitiated = 1;\n    }\n\n    /**\n     * @notice Code assumes Balancer flashloans remain free\n     * @param initialDeposit in collateral terms\n     * @param resultingAdditionalCollateral in collateral terms\n     * @param maxResultingDebt in WETH terms. While it is unlikely that the\n     * exchange rate changes from when a transaction is submitted versus when it\n     * is executed, it is still possible so we want to allow for a bound here,\n     * even though it doesn't pose the same level of threat as slippage.\n     */\n    function flashLeverageWeth(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        external\n        payable\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n\n        IERC20Balancer[] memory addresses = new IERC20Balancer[](1);\n        addresses[0] = IERC20Balancer(address(WETH));\n\n        uint256 amountLst = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n        uint256 amountWethToFlashloan = _getEthAmountInForLstAmountOut(amountLst);\n\n        if (amountWethToFlashloan == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        // It is technically possible to accrue slight dust amounts more of debt\n        // than maxResultingDebt because you may need to borrow slightly more at\n        // the IonPool level to receieve the desired amount of WETH. This is\n        // because the IonPool will round in its favor and always gives out dust\n        // amounts less of WETH than the debt accrued to the position. However,\n        // this will always be bounded by the rate of the ilk at the time\n        // divided by RAY and will NEVER be subject to slippage, which is what\n        // we really want to protect against.\n        if (amountWethToFlashloan > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(amountWethToFlashloan, maxResultingDebt);\n        }\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amountWethToFlashloan;\n\n        flashloanInitiated = 2;\n\n        VAULT.flashLoan(\n            IFlashLoanRecipient(address(this)),\n            addresses,\n            amounts,\n            abi.encode(msg.sender, initialDeposit, resultingAdditionalCollateral, maxResultingDebt)\n        );\n\n        flashloanInitiated = 1;\n    }\n\n    /**\n     * @notice Code assumes Balancer flashloans remain free.\n     * @dev This function is intended to never be called directly. It should\n     * only be called by the Balancer VAULT during a flashloan initiated by this\n     * contract. This callback logic only handles the creation of leverage\n     * positions by minting. Since not all tokens have withdrawable liquidity\n     * via the LST protocol directly, deleverage through the protocol will need\n     * to be implemented in the inheriting contract.\n     *\n     * @param tokens Array of tokens flash loaned\n     * @param amounts amounts flash loaned\n     * @param userData arbitrary data passed from initiator of flash loan\n     */\n    function receiveFlashLoan(\n        IERC20Balancer[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory,\n        bytes memory userData\n    )\n        external\n        override\n    {\n        if (tokens.length > 1) revert FlashLoanedTooManyTokens(tokens.length);\n        if (msg.sender != address(VAULT)) revert ReceiveCallerNotVault(msg.sender);\n        if (flashloanInitiated != 2) revert ExternalBalancerFlashloanNotAllowed();\n\n        IERC20Balancer token = tokens[0];\n        (address user, uint256 initialDeposit, uint256 resultingAdditionalCollateral, uint256 maxResultingDebt) =\n            abi.decode(userData, (address, uint256, uint256, uint256));\n\n        // Flashloaned WETH needs to be converted into collateral asset\n        if (address(token) == address(WETH)) {\n            uint256 collateralFromDeposit = _depositWethForLst(amounts[0]);\n\n            // Sanity checks\n            assert(collateralFromDeposit + initialDeposit == resultingAdditionalCollateral);\n            assert(collateralFromDeposit <= maxResultingDebt);\n\n            // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed to cover flashloan\n            _depositAndBorrow(user, address(this), resultingAdditionalCollateral, amounts[0], AmountToBorrow.IS_MIN);\n\n            WETH.transfer(address(VAULT), amounts[0]);\n        } else {\n            if (address(LST_TOKEN) != address(token)) revert FlashloanedInvalidToken(address(token));\n\n            uint256 wethToBorrow = _getEthAmountInForLstAmountOut(amounts[0]);\n\n            // Sanity checks\n            assert(amounts[0] + initialDeposit == resultingAdditionalCollateral);\n            assert(wethToBorrow <= maxResultingDebt);\n\n            // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed to cover flashloan\n            _depositAndBorrow(user, address(this), resultingAdditionalCollateral, wethToBorrow, AmountToBorrow.IS_MIN);\n\n            // Convert borrowed WETH back to collateral token\n            uint256 tokenAmountReceived = _depositWethForLst(wethToBorrow);\n\n            LST_TOKEN.safeTransfer(address(VAULT), tokenAmountReceived);\n        }\n    }\n\n    /**\n     * @dev Unwraps weth into eth and deposits into lst contract\n     * @param amountWeth to deposit\n     * @return amountLst received\n     */\n    function _depositWethForLst(uint256 amountWeth) internal virtual returns (uint256);\n\n    function _getEthAmountInForLstAmountOut(uint256 amountLst) internal view virtual returns (uint256);\n}"
    },
    {
      "filename": "src/periphery/IonZapper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IonPool } from \"src/IonPool.sol\";\nimport { RAY } from \"src/libraries/math/WadRayMath.sol\";\nimport { IWETH9 } from \"src/interfaces/IWETH9.sol\";\nimport { Whitelist } from \"src/Whitelist.sol\";\nimport { IWstEth } from \"src/interfaces/ProviderInterfaces.sol\";\nimport { GemJoin } from \"src/join/GemJoin.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract IonZapper {\n    IonPool public immutable POOL;\n    IWETH9 public immutable WETH;\n\n    IERC20 public immutable STETH;\n    IWstEth public immutable WSTETH;\n    GemJoin public immutable WSTETH_JOIN;\n\n    Whitelist public immutable WHITELIST;\n\n    modifier onlyWhitelistedLenders(bytes32[] memory proof) {\n        WHITELIST.isWhitelistedLender(msg.sender, proof);\n        _;\n    }\n\n    constructor(\n        IonPool _ionPool,\n        IWETH9 _weth,\n        IERC20 _stEth,\n        IWstEth _wstEth,\n        GemJoin _wstEthJoin,\n        Whitelist _whitelist\n    ) {\n        POOL = _ionPool;\n        WETH = _weth;\n\n        STETH = _stEth;\n        WSTETH = _wstEth;\n        WSTETH_JOIN = _wstEthJoin;\n\n        WHITELIST = _whitelist;\n        _weth.approve(address(_ionPool), type(uint256).max);\n    }\n\n    function zapSupply(bytes32[] calldata proof) external payable onlyWhitelistedLenders(proof) {\n        uint256 amount = msg.value;\n\n        WETH.deposit{ value: amount }();\n        POOL.supply(msg.sender, amount, proof);\n    }\n\n    function zapRepay(uint8 ilkIndex) external payable {\n        uint256 amount = msg.value;\n\n        uint256 currentIlkRate = POOL.rate(ilkIndex);\n        (,, uint256 ilkRateIncrease,,) = POOL.calculateRewardAndDebtDistribution(ilkIndex);\n        uint256 newIlkRate = currentIlkRate + ilkRateIncrease;\n\n        uint256 normalizedAmountToRepay = amount * RAY / newIlkRate;\n\n        WETH.deposit{ value: amount }();\n        POOL.repay(ilkIndex, msg.sender, msg.sender, normalizedAmountToRepay);\n    }\n\n    function zapDepositWstEth(uint256 amountStEth) external payable {\n        STETH.transferFrom(msg.sender, address(this), amountStEth);\n\n        uint256 outputWstEthAmount = WSTETH.wrap(amountStEth);\n        WSTETH_JOIN.join(msg.sender, outputWstEthAmount);\n    }\n}"
    }
  ]
}