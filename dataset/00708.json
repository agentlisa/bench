{
  "Title": "M-4: Frontrunning validator freeze to withdraw tokens",
  "Content": "# Issue M-4: Frontrunning validator freeze to withdraw tokens \n\nSource: https://github.com/sherlock-audit/2023-11-covalent-judging/issues/50 \n\n## Found by \nPUSH0\n## Summary\n\nCovalent implements a freeze mechanism to disable malicious Validators, this allows the protocol to block all interactions with a validator when he behaves maliciously. \nCovalent also implements a timelock to ensure tokens are only withdraw after a certain amount of time. \nAfter the cooldown ends, tokens can always be withdrawn. \n\nFollowing problem arise now: \nbecause the tokens can always be withdrawn, a malicious Validator can listen for a potential \"freeze\" transaction in the mempool, front run this transaction to unstake his tokens and withdraw them after the cooldown end.\n\n## Vulnerability Detail\n\nAlmost every action on the Operational Staking contract checks if the validator is frozen or not:\n\n```solidity\n require(!v.frozen, \"Validator is frozen\");\n```\n\nThe methods transferUnstakedOut() and recoverUnstaking() are both not checking for this, making the unstake transaction front runnable.\nHere are the only checks of transferUnstakedOut():\n\n```solidity\nrequire(validatorId < validatorsN, \"Invalid validator\");\n        require(_validators[validatorId].unstakings[msg.sender].length > unstakingId, \"Unstaking does not exist\");\n        Unstaking storage us = _validators[validatorId].unstakings[msg.sender][unstakingId];\n        require(us.amount >= amount, \"Unstaking has less tokens\");\n```\nhttps://github.com/sherlock-audit/2023-11-covalent/blob/main/cqt-staking/contracts/OperationalStaking.sol#L559-L572\n\nThis makes following attack possible:\n1. Validator cheats and gets rewarded fees.\n2. Protocol notices the misbehavior and initiates a Freeze transaction\n3. Validator sees the transaction and starts a unstake() transaction with higher gas.\n4. Validator gets frozen, but the unstaking is already done\n5. Validator waits for cooldown and withdraws tokens.\n\nNow the validator has gained unfairly obtained tokens and withdrawn his stake.\n\n## Impact\n\nMalicious validators can front run freeze to withdraw tokens.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-11-covalent/blob/main/cqt-staking/contracts/OperationalStaking.sol#L559-L572\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement a check if validator is frozen on `transferUnstakedOut()` and `recoverUnstaking()`, and revert transaction if true.\n\nIf freezing all unstakings is undesirable (e.g. not freezing honest unstakes), the sponsor may consider storing the unstake timestamp as well:\n- Store the unstaking block number for each unstake.\n- Freeze the validator from a certain past block only, only unstakings that occur from that block onwards will get frozen.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid: this is theoretically not possile due to the cooldown time; the time will allow the governance to pause the contract/function\n\n\n\n**noslav**\n\nfixed by [check validator not frozen for recoverUnstaking & transferUnstakedOut](https://github.com/covalenthq/cqt-staking/pull/125/commits/de86308999d093a3f4553aa7094ed4d29be8beb0)\n\n**nevillehuang**\n\nInvalid, both are user facing functions, not validators.\n\n**Oot2k**\n\nEscalate\n\nI believe this issue was mistakenly excluded, the frontrunning of freeze transaction is indeed a problem like described in the Report.\n\nThe impact described is clearly medium, because this attack makes the freeze function almost useless. Also it generates clear loss of funds for the protocol, because in most cases a malicious validator might accrue rewards which do not belong to him.  \n\nThis issue can not really be fixed by governance pausing the contract, this would pause the contract for everyone else aswell and cause even more damage.\n\nThe fix by protocol teams looks good.\n\nTo summarize: \nIssue is fixed, impact is High, issue should be open and valid.\n\n**sherlock-admin**\n\n> Escalate\n> \n> I believe this issue was mistakenly excluded, the frontrunning of freeze transaction is indeed a problem like described in the Report.\n> \n> The impact described is clearly medium, because this attack makes the freeze function almost useless. Also it generates clear loss of funds for the protocol, because in most cases a malicious validator might accrue rewards which do not belong to him.  \n> \n> This issue can not really be fixed by governance pausing the contract, this would pause the contract for everyone else aswell and cause even more damage.\n> \n> The fix by protocol teams looks good.\n> \n> To summarize: \n> Issue is fixed, impact is High, issue should be open and valid.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**midori-fuse**\n\nAdding to the escalation point, there is no way for governance to forcefully claim an unstaking (or any rewards that has been distributed). Therefore eventually the contract must be unpaused to avoid locking of existing funds, and the malicious actor fully gets away.\n\n**Oot2k**\n\nAdditionally I think this issue should be judged as HIGH severity based on following facts:\n- it create a clear loss of funds for the protocol (The main reason to freeze a validator is to penalize him for malicious behavior, this can include stealing funds / rewards) \n- there is no way to prevent this behavior without causing more damage\n- attack cost is really low -> just transaction fee\n\n**nevillehuang**\n\n@Oot2k @midori-fuse @noslav Could you shed more details on how the validator can cheat and get rewarded fees and in what scenarios is a freeze initiated. It seems to me like a hypothetical scenario given my understanding is validator is still unstaking amounts that belongs to him, but could be significant.\n\n> 1. Validator cheats and gets rewarded fees.\n\nAdditionally, this issue seems to be dependent on a front-running attack vector, so:\n\n- If flashbots are considered similar to issue [here](https://github.com/sherlock-audit/2023-11-convergence-judging/issues/165#issuecomment-1884638007) to mitigate front-running, I believe this could be low severity\n- If not, if it is true that the freeze mechanism can be bypassed, then I believe this is medium severity, since it is dependent on a hypothetical scenario that validators turn malicious. \n\nAdditionally, is there any mechanisms in place to mitigate malicious validators?\n\n**midori-fuse**\n\nProviding evidence for the bypassing of freeze mechanism. Search the following phrase within the contract:\n```solidity\nrequire(!v.frozen, \"Validator is frozen\");\n```\n\nIt appears 6 times throughout the contract, and covers all entry points except `transferUnstakedOut()` (except admin and reward manager functions). Eyeballing all other external functions (except the ones mentioned) will show that they all go through `_stake()` or `_unstake()`, which has the appropriate check.\n\nFor [`transferUnstakedOut()`](https://github.com/sherlock-audit/2023-11-covalent/blob/main/cqt-staking/contracts/OperationalStaking.sol#L559-L572), there is no check for whether the validator corresponding to that unstake has been frozen or not, neither is there in [`_transferFromContract()`](https://github.com/sherlock-audit/2023-11-covalent/blob/main/cqt-staking/contracts/OperationalStaking.sol#L379-L381).\n\nThe flow for an unstaking to happen (for delegators or validators alike) is that:\n- The user calls `unstake()` or `unstakeAll()`.\n- Wait for the cooldown.\n- Call `transferUnstakedOut()` to actually receive those tokens.\n\nThen the freeze is bypassed if the user is able to call unstake before the validator is frozen. Front-running is only required to maximize the getaway amounts by squeezing some extra rewards, you can just unstake before getting freeze and you bypass the freeze already. Therefore this is just a bypassing of freeze, and not dependent on front-running. We simply show the scenario which has the maximum impact.\n\n\n**midori-fuse**\n\nFor the scenario where a validator cheats, there are certain ways for it to happen:\n- Two or more validators collude and are able to force quorum on certain sessions, earning them rewards on an incorrect block specimen. \n- A validator finds a systemic exploit and/or simply not doing work correctly (e.g. admin determined them to repeatedly copy-paste other validators' works by watching the mempool or copying existing submissions, despite it being wrong or not). Note that a disabled validator can still unstake and get away with funds, unlike the frozen scenario (without the current bypassing issue).\n\nThe freeze is there to protect against these kind of situations.\n\n**nevillehuang**\n\nI personally am not convinced of this issue because the admins can always perform a system wide contract pause before freezing validators in separate transactions via flashbots (which pauses all actions, including `transferUnstakedOut`), which possibly mitigates this issue. This is in addition to the fact that there is a 28 day unstaking cooldown period which is more than sufficient time to react to malicious validators by admins (which in itself is a mitigation).\n\nSo I will leave it up to @Czar102 and sponsors to decide validity.\n\n**midori-fuse**\n\n28 day unstaking cooldown does not mitigate this. As soon as the unstaking is done, the amount can be transferred out after 28 days (and the admin unpauses the system). Even if the system is paused, there are no admin actions that can revoke an unstaking that's on cooldown.\n\nKeeping the system paused equates to locking all funds, including other validators' funds and their respective delegators, and the admin still cannot take over the stolen funds. \n\nFurthermore the issue shows that freezing can be bypassed, and front-running is not a condition. The validator can just unstake right after the exploit, and the admin is already powerless before noticing the issue.\n\nJust adding some extra points. As part of the team making the escalation, we have the responsibility to provide extra information and any context the judges' might have missed, but we respect the judges' decision in any case.\n\n**Oot2k**\n\nAgree with @midori-fuse here. \nCooldown -> does not do anything because the malicious user still transfers tokens out (this is the root cause of this issue)\nAdmin can pause protocol -> this will pause all actions for other users as well, as soon as the protocol is unpaused funds can be withdrawn again\nMalicious funds -> yes this report assumes there is a way to get funds maliciously and for this reason the team implemented the freeze mechanism\n\nI think this summarizes the issue pretty well and should be enough for Sherlock to validate. \n\n**nevillehuang**\n\nIf the hypothetical scenario of a way to cheat funds/validators being malicious is considered as a valid reason that break admin initiated pause mechanism, I can agree this is a valid medium since I believe the only way to resolve the issue is for the owner to perform an upgrade to the contract.\n\nAlthough I must say, the whole original submission is only presenting a front-running scenario, and the watsons only realized after that front-running is not necessary but did not include it in the original submission, and hence my arguments. \n\n**Czar102**\n\nGreat points made, the frontrunning argument is also not convincing to me since it's quite clear that this race condition is by design and it's admin's responsibility to keep the information about the freeze private until confirmation.\n\nBut, this issue can also be considered a loss of functionality (freezing stakes) due to the existence of a beneficial optimal game-theoretic behavior of the attacker.\n\nI'm currently inclined to accept this as a Medium severity issue.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Oot2k](https://github.com/sherlock-audit/2023-11-covalent-judging/issues/50/#issuecomment-1940886577): accepted\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/covalenthq/cqt-staking/pull/125/commits/de86308999d093a3f4553aa7094ed4d29be8beb0.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/127",
  "Code": [
    {
      "filename": "cqt-staking/contracts/OperationalStaking.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\ncontract OperationalStaking is OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 public constant DIVIDER = 10 ** 18; // 18 decimals used for scaling rates\n    uint128 public constant REWARD_REDEEM_THRESHOLD = 10 ** 8; // minimum number of tokens that can be redeemed\n    uint128 public constant DEFAULT_VALIDATOR_ENABLE_MIN_STAKE = 35000 * 10 ** 18; // minimum number of self-staked tokens for a validator to become / stay enabled\n    uint128 public constant DEFAULT_DELEGATOR_MIN_STAKE = 10 ** 18; // stake/unstake operations are invalid if they put you below this threshold (except unstaking to 0)\n\n    IERC20Upgradeable public CQT;\n    uint128 public rewardPool; // how many tokens are allocated for rewards\n    uint128 public validatorCoolDown; // how many blocks until validator unstaking is unlocked\n    uint128 public delegatorCoolDown; // how many blocks until delegator unstaking is unlocked\n    uint128 public maxCapMultiplier; // *see readme\n    uint128 public validatorMaxStake; // how many tokens validators can stake at most\n    address public stakingManager;\n    uint128 public validatorsN; // number of validators, used to get validator ids\n    mapping(uint128 => Validator) internal _validators; // id -> validator instance\n\n    uint128 public validatorEnableMinStake; // minimum number of self-staked tokens for a validator to become / stay enabled\n    uint128 public delegatorMinStake; // stake/unstake operations are invalid if they put you below this threshold (except unstaking to 0)\n\n    bool private _unpaused;\n\n    struct Staking {\n        uint128 shares; // # of validator shares that the delegator owns\n        uint128 staked; // # of CQT that a delegator delegated originally through stake() transaction\n    }\n\n    struct Unstaking {\n        uint128 coolDownEnd; // epoch when unstaking can be redeemed\n        uint128 amount; // # of unstaked CQT\n    }\n\n    struct Validator {\n        uint128 commissionAvailableToRedeem;\n        uint128 exchangeRate; // validator exchange rate\n        address _address; // wallet address of the operator which is mapped to the validator instance\n        uint128 delegated; // track amount of tokens delegated\n        uint128 totalShares; // total number of validator shares\n        uint128 commissionRate;\n        uint256 disabledAtBlock;\n        mapping(address => Staking) stakings;\n        mapping(address => Unstaking[]) unstakings;\n        bool frozen;\n    }\n\n    event InitializedSemantics(\n        address cqt,\n        uint128 validatorCoolDown,\n        uint128 delegatorCoolDown,\n        uint128 maxCapMultiplier,\n        uint128 validatorMaxStake,\n        uint128 validatorEnableMinStake,\n        uint128 delegatorMinStake\n    );\n\n    event RewardTokensDeposited(uint128 amount);\n\n    event ValidatorAdded(uint128 indexed id, uint128 commissionRate, address indexed validator);\n\n    event Staked(uint128 indexed validatorId, address delegator, uint128 amount);\n\n    event Unstaked(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakeId);\n\n    event RecoveredUnstake(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakingId);\n\n    event UnstakeRedeemed(uint128 indexed validatorId, address indexed delegator, uint128 indexed unstakeId, uint128 amount);\n\n    event AllocatedTokensTaken(uint128 amount);\n\n    event RewardFailedDueLowPool(uint128 indexed validatorId, uint128 amount);\n\n    event RewardFailedDueZeroStake(uint128 indexed validatorId, uint128 amount);\n\n    event RewardFailedDueValidatorDisabled(uint128 indexed validatorId, uint128 amount);\n\n    event RewardFailedDueValidatorFrozen(uint128 indexed validatorId, uint128 amount);\n\n    event RewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);\n\n    event CommissionRewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);\n\n    event StakingManagerChanged(address indexed operationalManager);\n\n    event ValidatorCommissionRateChanged(uint128 indexed validatorId, uint128 amount);\n\n    event ValidatorMaxCapChanged(uint128 amount);\n\n    event ValidatorEnableMinStakeChanged(uint128 amount);\n\n    event DelegatorMinStakeChanged(uint128 amount);\n\n    event ValidatorUnstakeCooldownChanged(uint128 amount);\n\n    event DelegatorUnstakeCooldownChanged(uint128 amount);\n\n    event ValidatorDisabled(uint128 indexed validatorId, uint256 blockNumber);\n\n    event Redelegated(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId);\n\n    event MaxCapMultiplierChanged(uint128 newMaxCapMultiplier);\n\n    event ValidatorEnabled(uint128 indexed validatorId);\n\n    event ValidatorAddressChanged(uint128 indexed validatorId, address indexed newAddress);\n\n    event Paused(address account);\n\n    event Unpaused(address account);\n\n    event ValidatorFrozen(uint128 indexed validatorId, string reason);\n\n    event ValidatorUnfrozen(uint128 indexed validatorId);\n\n    event RewardsDisbursed(uint128 indexed rewardId);\n\n    modifier onlyStakingManager() {\n        require(stakingManager == msg.sender, \"Caller is not stakingManager\");\n        _;\n    }\n\n    modifier onlyStakingManagerOrOwner() {\n        require(msg.sender == stakingManager || msg.sender == owner(), \"Caller is not stakingManager or owner\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(_unpaused, \"paused\");\n        _;\n    }\n\n    function initialize(address cqt, uint128 dCoolDown, uint128 vCoolDown, uint128 maxCapM, uint128 vMaxStake) external initializer {\n        __Ownable_init();\n        validatorCoolDown = vCoolDown; // 180*6857 = ~ 6 months\n        delegatorCoolDown = dCoolDown; //  28*6857 = ~ 28 days\n        maxCapMultiplier = maxCapM;\n        validatorMaxStake = vMaxStake;\n\n        validatorEnableMinStake = DEFAULT_VALIDATOR_ENABLE_MIN_STAKE;\n        delegatorMinStake = DEFAULT_DELEGATOR_MIN_STAKE;\n\n        _unpaused = true;\n\n        CQT = IERC20Upgradeable(cqt);\n        emit InitializedSemantics(cqt, vCoolDown, dCoolDown, maxCapM, vMaxStake, validatorEnableMinStake, delegatorMinStake);\n    }\n\n    function setStakingManagerAddress(address newAddress) external onlyOwner {\n        require(newAddress != address(0), \"Invalid address\");\n        stakingManager = newAddress;\n        emit StakingManagerChanged(newAddress);\n    }\n\n    /*\n     * Transfer CQT from the owner to the contract for reward allocation\n     */\n    function depositRewardTokens(uint128 amount) external onlyOwner {\n        require(amount > 0, \"Amount is 0\");\n        unchecked {\n            rewardPool += amount;\n        }\n        _transferToContract(msg.sender, amount);\n        emit RewardTokensDeposited(amount);\n    }\n\n    /*\n     * Transfer reward CQT from the contract to the owner\n     */\n    function takeOutRewardTokens(uint128 amount) external onlyOwner {\n        require(amount > 0, \"Amount is 0\");\n        require(amount <= rewardPool, \"Reward pool is too small\");\n        unchecked {\n            rewardPool -= amount;\n        }\n        emit AllocatedTokensTaken(amount);\n        _transferFromContract(msg.sender, amount);\n    }\n\n    /*\n     * Updates validator max cap multiplier that determines how many tokens can be delegated\n     */\n    function setMaxCapMultiplier(uint128 newMaxCapMultiplier) external onlyOwner {\n        require(newMaxCapMultiplier > 0, \"Must be greater than 0\");\n        maxCapMultiplier = newMaxCapMultiplier;\n        emit MaxCapMultiplierChanged(newMaxCapMultiplier);\n    }\n\n    /*\n     * Updates maximum number of tokens that a validator can stake\n     */\n    function setValidatorMaxStake(uint128 maxStake) external onlyOwner {\n        require(maxStake > 0, \"Provided max stake is 0\");\n        validatorMaxStake = maxStake;\n        emit ValidatorMaxCapChanged(maxStake);\n    }\n\n    /*\n     * Updates minimum number of tokens that a validator must self-stake before enabling\n     */\n    function setValidatorEnableMinStake(uint128 minStake) public onlyOwner {\n        require(minStake <= validatorMaxStake, \"minStake cannot be greater than validatorMaxStake\");\n        validatorEnableMinStake = minStake;\n        emit ValidatorEnableMinStakeChanged(minStake);\n    }\n\n    /*\n     * Updates minimum valid position threshold for per-delegator stake\n     */\n    function setDelegatorMinStake(uint128 minStake) public onlyOwner {\n        require(minStake <= validatorMaxStake, \"minStake cannot be greater than validatorMaxStake\");\n        delegatorMinStake = minStake;\n        emit DelegatorMinStakeChanged(minStake);\n    }\n\n    /*\n     * Updates the validator cool down period (in blocks)\n     * Note: this doesn't effect the existing unstakes\n     */\n    function setValidatorCoolDown(uint128 coolDown) external onlyOwner {\n        validatorCoolDown = coolDown;\n        emit ValidatorUnstakeCooldownChanged(coolDown);\n    }\n\n    /*\n     * Updates the delegator cool down period (in blocks)\n     * Note: this doesn't effect the existing unstakes\n     */\n    function setDelegatorCoolDown(uint128 coolDown) external onlyOwner {\n        delegatorCoolDown = coolDown;\n        emit DelegatorUnstakeCooldownChanged(coolDown);\n    }\n\n    /*\n     * Adds new validator instance\n     */\n    function addValidator(address validator, uint128 commissionRate) external onlyStakingManager whenNotPaused returns (uint256 id) {\n        require(commissionRate < DIVIDER, \"Rate must be less than 100%\");\n        require(validator != address(0), \"Validator address is 0\");\n        Validator storage v = _validators[validatorsN]; // use current number of validators for the id of a new validator instance\n        v._address = validator;\n        v.exchangeRate = uint128(DIVIDER); // make it 1:1 initially\n        v.commissionRate = commissionRate;\n        v.disabledAtBlock = 1; // set it to 1 to indicate that the validator is disabled\n\n        emit ValidatorAdded(validatorsN, commissionRate, validator);\n        unchecked {\n            validatorsN += 1;\n        }\n\n        return validatorsN - 1;\n    }\n\n    /*\n     * Reward emission\n     */\n    function rewardValidators(uint128 rewardId, uint128[] calldata ids, uint128[] calldata amounts) external onlyStakingManager whenNotPaused {\n        require(ids.length == amounts.length, \"Given ids and amounts arrays must be of the same length\");\n        uint128 newRewardPool = rewardPool;\n        uint128 amount;\n        uint128 validatorId;\n        uint128 commissionPaid;\n\n        for (uint256 j = 0; j < ids.length; j++) {\n            amount = amounts[j];\n            validatorId = ids[j];\n\n            // make sure there are enough tokens in the reward pool\n            if (newRewardPool < amount) {\n                emit RewardFailedDueLowPool(validatorId, amount);\n                continue;\n            }\n\n            Validator storage v = _validators[validatorId];\n\n            if (v.frozen) {\n                emit RewardFailedDueValidatorFrozen(validatorId, amount);\n                continue;\n            }\n\n            if (v.disabledAtBlock != 0) {\n                // validator became disabled (due to e.g. unstaking past base stake)\n                // between proof submission and finalization\n                emit RewardFailedDueValidatorDisabled(validatorId, amount);\n                continue;\n            }\n\n            if (v.totalShares == 0) {\n                // mathematically undefined -- no exchangeRate can turn zero into nonzero\n                // (this condition is only possible in testing with minValidatorEnableStake == 0;\n                //  in prod, validators with zero stake will always be disabled and so will trigger\n                //  the above check, not this one)\n                emit RewardFailedDueZeroStake(validatorId, amount);\n                continue;\n            }\n\n            commissionPaid = uint128((uint256(amount) * uint256(v.commissionRate)) / DIVIDER);\n\n            // distribute the tokens by increasing the exchange rate\n            // div by zero impossible due to check above\n            // (and in fact, presuming minValidatorEnableStake >= DIVIDER, v.totalShares will\n            //  always be >= DIVIDER while validator is enabled)\n            v.exchangeRate += uint128((uint256(amount - commissionPaid) * uint256(DIVIDER)) / v.totalShares);\n\n            // commission is not compounded\n            // commisison is distributed under the validator instance\n            v.commissionAvailableToRedeem += commissionPaid;\n\n            newRewardPool -= amount;\n        }\n\n        rewardPool = newRewardPool; // can never access these tokens anymore, reserved for validator rewards\n        emit RewardsDisbursed(rewardId);\n    }\n\n    /*\n     * Disables validator instance starting from the given block\n     */\n    function disableValidator(uint128 validatorId) external onlyStakingManagerOrOwner {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        _validators[validatorId].disabledAtBlock = block.number;\n        emit ValidatorDisabled(validatorId, block.number);\n    }\n\n    /*\n     * Enables validator instance by setting the disabledAtBlock to 0\n     */\n    function enableValidator(uint128 validatorId) external onlyStakingManagerOrOwner {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = _validators[validatorId];\n\n        if (v.disabledAtBlock == 0) {\n            // if validator is already enabled, succeed quietly\n            return;\n        }\n\n        uint128 staked = _sharesToTokens(v.stakings[v._address].shares, v.exchangeRate);\n\n        require(staked >= validatorEnableMinStake, \"Validator is insufficiently staked\");\n\n        v.disabledAtBlock = 0;\n        emit ValidatorEnabled(validatorId);\n    }\n\n    /*\n     * Determines whether a validator is currently able to be used by operators\n     */\n    function isValidatorEnabled(uint128 validatorId) external view returns (bool) {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        return _validators[validatorId].disabledAtBlock == 0;\n    }\n\n    /*\n     * Updates validator comission rate\n     * Commission rate is a number between 0 and 10^18 (0%-100%)\n     */\n    function setValidatorCommissionRate(uint128 validatorId, uint128 amount) external onlyOwner {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(amount < DIVIDER, \"Rate must be less than 100%\");\n        _validators[validatorId].commissionRate = amount;\n        emit ValidatorCommissionRateChanged(validatorId, amount);\n    }\n\n    /*\n     * Used to transfer CQT from delegators, validators, and the owner to the contract\n     */\n    function _transferToContract(address from, uint128 amount) internal {\n        CQT.safeTransferFrom(from, address(this), amount);\n    }\n\n    /*\n     * Used to transfer CQT from contract, for reward redemption or transferring out unstaked tokens\n     */\n    function _transferFromContract(address to, uint128 amount) internal {\n        CQT.safeTransfer(to, amount);\n    }\n\n    /*\n     * Used to convert validator shares to CQT\n     */\n    function _sharesToTokens(uint128 sharesN, uint128 rate) internal pure returns (uint128) {\n        return uint128((uint256(sharesN) * uint256(rate)) / DIVIDER);\n    }\n\n    /*\n     * Used to convert CQT to validator shares\n     */\n    function _tokensToShares(uint128 amount, uint128 rate) internal pure returns (uint128) {\n        return uint128((uint256(amount) * DIVIDER) / uint256(rate));\n    }\n\n    /*\n     * Delegates tokens under the provided validator\n     */\n    function stake(uint128 validatorId, uint128 amount) external whenNotPaused {\n        _stake(validatorId, amount, true);\n    }\n\n    /*\n     * withTransfer is set to false when delegators recover unstaked or redelegated tokens.\n     * These tokens are already in the contract.\n     */\n    function _stake(uint128 validatorId, uint128 amount, bool withTransfer) internal {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(amount >= REWARD_REDEEM_THRESHOLD, \"Stake amount is too small\");\n        Validator storage v = _validators[validatorId];\n        bool isValidator = msg.sender == v._address;\n\n        require(!v.frozen, \"Validator is frozen\");\n\n        // validators should be able to stake if they are disabled.\n        if (!isValidator) require(v.disabledAtBlock == 0, \"Validator is disabled\");\n\n        Staking storage s = v.stakings[msg.sender];\n\n        uint128 newStaked = s.staked + amount;\n\n        require(newStaked >= delegatorMinStake, \"Cannot stake to a position less than delegatorMinStake\");\n\n        uint128 sharesAdd = _tokensToShares(amount, v.exchangeRate);\n\n        if (isValidator) {\n            // compares with newStaked to ignore compounded rewards\n            require(newStaked <= validatorMaxStake, \"Validator max stake exceeded\");\n        } else {\n            // cannot stake more than validator delegation max cap\n            uint128 delegationMaxCap = v.stakings[v._address].staked * maxCapMultiplier;\n            uint128 newDelegated = v.delegated + amount;\n            require(newDelegated <= delegationMaxCap, \"Validator max delegation exceeded\");\n            v.delegated = newDelegated;\n        }\n\n        // \"buy/mint\" shares\n        v.totalShares += sharesAdd;\n        s.shares += sharesAdd;\n\n        // keep track of staked tokens\n        s.staked = newStaked;\n        if (withTransfer) _transferToContract(msg.sender, amount);\n        emit Staked(validatorId, msg.sender, amount);\n    }\n\n    /*\n     * Undelegates all staked tokens from the provided validator\n     */\n    function unstakeAll(uint128 validatorId) external whenNotPaused {\n        _unstake(validatorId, 0); // pass 0 to request full amount\n    }\n\n    /*\n     * Undelegates some number of tokens from the provided validator\n     */\n    function unstake(uint128 validatorId, uint128 amount) external whenNotPaused {\n        require(amount > 0, \"Amount is 0\");\n        _unstake(validatorId, amount);\n    }\n\n    /*\n     * Undelegates tokens from the provided validator\n     */\n    function _unstake(uint128 validatorId, uint128 amount) internal {\n        require(validatorId < validatorsN, \"Invalid validator\");\n\n        Validator storage v = _validators[validatorId];\n        Staking storage s = v.stakings[msg.sender];\n\n        require(!v.frozen, \"Validator is frozen\");\n\n        require(amount <= s.staked, \"Cannot unstake amount greater than current stake\");\n\n        bool isUnstakingAll = amount == 0 || amount == s.staked;\n        uint128 effectiveAmount = isUnstakingAll ? s.staked : amount;\n        uint128 newStaked = s.staked - effectiveAmount;\n\n        if (isUnstakingAll) {\n            // enforce precondition for later math that effectiveAmount is always nonzero\n            require(effectiveAmount > 0, \"Already fully unstaked\");\n        } else {\n            // to prevent buildup of Unstaking[] elements, do not allow user to repeatedly unstake trivial amounts\n            // (but do allow removal of a trivial amount if it is the entire remaining stake)\n            require(effectiveAmount >= REWARD_REDEEM_THRESHOLD, \"Unstake amount is too small\");\n\n            // to prevent \"spam\" delegations, and runaway exchangeRate inflation from all-but-dust self-stake unstaking,\n            // disallow unstaking that would result in a new stake below delegatorMinStake\n            // (with the exception of an unstaking that takes the stake exactly to zero)\n            require(newStaked >= delegatorMinStake, \"Cannot unstake to a position below delegatorMinStake (except to zero)\");\n        }\n\n        bool isValidator = msg.sender == v._address;\n        if (isValidator && v.disabledAtBlock == 0) {\n            // validators will have to disable themselves if they want to unstake tokens below delegation max cap\n            uint128 newValidatorMaxCap = newStaked * maxCapMultiplier;\n            require(v.delegated <= newValidatorMaxCap, \"Cannot decrease delegation max-cap below current delegation while validator is enabled\");\n        }\n        if (!isValidator) {\n            v.delegated -= effectiveAmount;\n        }\n\n        uint128 sharesToRemove = _tokensToShares(effectiveAmount, v.exchangeRate);\n\n        // sometimes, due to conversion inconsistencies, sharesToRemove might end up larger than s.shares;\n        // so we clamp sharesToRemove to s.shares (the redeemer unstakes trivially more tokens in this case)\n        if (sharesToRemove > s.shares) sharesToRemove = s.shares;\n\n        // sanity check: sharesToRemove should never be zero while amount is nonzero, as this would enable\n        // infinite draining of funds\n        require(sharesToRemove > 0, \"Underflow error\");\n\n        unchecked {\n            s.shares -= sharesToRemove;\n        }\n        v.totalShares -= sharesToRemove;\n\n        // remove staked tokens\n        s.staked = newStaked;\n\n        // disable validator if they unstaked to below their required self-stake\n        if (isValidator && validatorEnableMinStake > 0 && v.disabledAtBlock == 0 && s.staked < validatorEnableMinStake) {\n            uint256 disabledAtBlock = block.number;\n            v.disabledAtBlock = disabledAtBlock;\n            emit ValidatorDisabled(validatorId, disabledAtBlock);\n        }\n\n        // create unstaking instance\n        uint128 coolDownEnd = uint128(v.disabledAtBlock != 0 ? v.disabledAtBlock : block.number);\n        unchecked {\n            coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown);\n        }\n        uint128 unstakeId = uint128(v.unstakings[msg.sender].length);\n        v.unstakings[msg.sender].push(Unstaking(coolDownEnd, effectiveAmount));\n        emit Unstaked(validatorId, msg.sender, effectiveAmount, unstakeId);\n    }\n\n    /*\n     * Restakes unstaked tokens (with the same validator)\n     */\n    function recoverUnstaking(uint128 amount, uint128 validatorId, uint128 unstakingId) external whenNotPaused {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(_validators[validatorId].unstakings[msg.sender].length > unstakingId, \"Unstaking does not exist\");\n        Unstaking storage us = _validators[validatorId].unstakings[msg.sender][unstakingId];\n        require(us.amount >= amount, \"Unstaking has less tokens\");\n        unchecked {\n            us.amount -= amount;\n        }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if (us.amount == 0) us.coolDownEnd = 0;\n        emit RecoveredUnstake(validatorId, msg.sender, amount, unstakingId);\n        _stake(validatorId, amount, false);\n    }\n\n    /*\n     * Transfers out unlocked unstaked tokens back to the delegator\n     */\n    function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 unstakingId) external whenNotPaused {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(_validators[validatorId].unstakings[msg.sender].length > unstakingId, \"Unstaking does not exist\");\n        Unstaking storage us = _validators[validatorId].unstakings[msg.sender][unstakingId];\n        require(uint128(block.number) > us.coolDownEnd, \"Cooldown period has not ended\");\n        require(us.amount >= amount, \"Amount is too high\");\n        unchecked {\n            us.amount -= amount;\n        }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if (us.amount == 0) us.coolDownEnd = 0;\n        emit UnstakeRedeemed(validatorId, msg.sender, unstakingId, amount);\n        _transferFromContract(msg.sender, amount);\n    }\n\n    /*\n     * Redeems all available rewards\n     */\n    function redeemAllRewards(uint128 validatorId, address beneficiary) external whenNotPaused {\n        _redeemRewards(validatorId, beneficiary, 0); // pass 0 to request full amount\n    }\n\n    /*\n     * Redeems partial rewards\n     */\n    function redeemRewards(uint128 validatorId, address beneficiary, uint128 amount) external whenNotPaused {\n        require(amount > 0, \"Amount is 0\");\n        _redeemRewards(validatorId, beneficiary, amount);\n    }\n\n    function _redeemRewards(uint128 validatorId, address beneficiary, uint128 amount) internal {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(beneficiary != address(0x0), \"Invalid beneficiary\");\n        Validator storage v = _validators[validatorId];\n        Staking storage s = v.stakings[msg.sender];\n\n        require(!v.frozen, \"Validator is frozen\");\n\n        // how many tokens a delegator/validator has in total on the contract\n        // include earned commission if the delegator is the validator\n        uint128 totalValue = _sharesToTokens(s.shares, v.exchangeRate);\n\n        // how many tokens a delegator/validator has \"unlocked\", free to be redeemed\n        // (i.e. not staked or in unstaking cooldown)\n        uint128 totalUnlockedValue = (totalValue < s.staked) ? 0 : (totalValue - s.staked);\n\n        bool isRedeemingAll = (amount == 0 || amount == totalUnlockedValue); // amount is 0 when it's requested to redeem all rewards\n\n        // make sure rewards exist\n        // (note that this still works in the case where we're redeeming all! always doing this check saves a branch op)\n        require(amount <= totalUnlockedValue, \"Cannot redeem amount greater than held, unstaked rewards\");\n\n        uint128 effectiveAmount = isRedeemingAll ? totalUnlockedValue : amount;\n\n        // can only redeem above redeem threshold\n        require(effectiveAmount >= REWARD_REDEEM_THRESHOLD, \"Requested amount must be higher than redeem threshold\");\n\n        uint128 sharesToBurn = _tokensToShares(effectiveAmount, v.exchangeRate);\n\n        // sometimes, due to conversion inconsistencies, sharesToBurn might end up larger than s.shares;\n        // so we clamp sharesToBurn to s.shares (the redeemer gets trivially more value out in this case)\n        if (sharesToBurn > s.shares) sharesToBurn = s.shares;\n\n        // sanity check: sharesToBurn should never be zero while effectiveAmount is nonzero, as this\n        // would enable infinite draining of funds\n        require(sharesToBurn > 0, \"Underflow error\");\n\n        unchecked {\n            v.totalShares -= sharesToBurn;\n        }\n        unchecked {\n            s.shares -= sharesToBurn;\n        }\n\n        emit RewardRedeemed(validatorId, beneficiary, effectiveAmount);\n        _transferFromContract(beneficiary, effectiveAmount);\n    }\n\n    function redeemCommission(uint128 validatorId, address beneficiary, uint128 amount) public whenNotPaused {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(beneficiary != address(0x0), \"Invalid beneficiary\");\n        Validator storage v = _validators[validatorId];\n        require(v._address == msg.sender, \"The sender is not the validator\");\n\n        require(!v.frozen, \"Validator is frozen\");\n\n        require(v.commissionAvailableToRedeem > 0, \"No commission available to redeem\");\n        require(amount > 0, \"The requested amount is 0\");\n        require(amount <= v.commissionAvailableToRedeem, \"Requested amount is higher than commission available to redeem\");\n        unchecked {\n            v.commissionAvailableToRedeem -= amount;\n        }\n\n        _transferFromContract(beneficiary, amount);\n        emit CommissionRewardRedeemed(validatorId, beneficiary, amount);\n    }\n\n    function redeemAllCommission(uint128 validatorId, address beneficiary) external whenNotPaused {\n        redeemCommission(validatorId, beneficiary, _validators[validatorId].commissionAvailableToRedeem);\n    }\n\n    /*\n     * Redelegates tokens to another validator if a validator got disabled.\n     * First the tokens need to be unstaked\n     */\n    function redelegateUnstaked(uint128 amount, uint128 oldValidatorId, uint128 newValidatorId, uint128 unstakingId) external whenNotPaused {\n        require(oldValidatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = _validators[oldValidatorId];\n\n        // assets of delegators cannot be moved while validator is frozen\n        require(!v.frozen, \"Validator is frozen\");\n\n        require(v.disabledAtBlock != 0, \"Validator is not disabled\");\n        require(v._address != msg.sender, \"Validator cannot redelegate\");\n        require(v.unstakings[msg.sender].length > unstakingId, \"Unstaking does not exist\");\n        Unstaking storage us = v.unstakings[msg.sender][unstakingId];\n        require(us.amount >= amount, \"Unstaking has less tokens\");\n        // stake tokens back to the contract using new validator, set withTransfer to false since the tokens are already in the contract\n        unchecked {\n            us.amount -= amount;\n        }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if (us.amount == 0) us.coolDownEnd = 0;\n        emit Redelegated(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId);\n        _stake(newValidatorId, amount, false);\n    }\n\n    /*\n     * Changes the validator staking address, this will transfer validator staking data and optionally unstakings\n     */\n    function setValidatorAddress(uint128 validatorId, address newAddress) external whenNotPaused {\n        Validator storage v = _validators[validatorId];\n        require(msg.sender == v._address, \"Sender is not the validator\");\n        require(v._address != newAddress, \"The new address cannot be equal to the current validator address\");\n        require(newAddress != address(0), \"Invalid validator address\");\n        require(!v.frozen, \"Validator is frozen\");\n\n        v.stakings[newAddress].shares += v.stakings[msg.sender].shares;\n        v.stakings[newAddress].staked += v.stakings[msg.sender].staked;\n        delete v.stakings[msg.sender];\n\n        Unstaking[] storage oldUnstakings = v.unstakings[msg.sender];\n        uint256 length = oldUnstakings.length;\n        require(length <= 300, \"Cannot transfer more than 300 unstakings\");\n        Unstaking[] storage newUnstakings = v.unstakings[newAddress];\n        for (uint128 i = 0; i < length; ++i) {\n            newUnstakings.push(oldUnstakings[i]);\n        }\n        delete v.unstakings[msg.sender];\n\n        v._address = newAddress;\n        emit ValidatorAddressChanged(validatorId, newAddress);\n    }\n\n    /*\n     * Gets metadata\n     */\n    function getMetadata()\n        external\n        view\n        returns (\n            address CQTaddress,\n            address _stakingManager,\n            uint128 _validatorsN,\n            uint128 _rewardPool,\n            uint128 _validatorCoolDown,\n            uint128 _delegatorCoolDown,\n            uint128 _maxCapMultiplier,\n            uint128 _validatorMaxStake,\n            uint128 _validatorEnableMinStake,\n            uint128 _delegatorMinStake\n        )\n    {\n        return (\n            address(CQT),\n            stakingManager,\n            validatorsN,\n            rewardPool,\n            validatorCoolDown,\n            delegatorCoolDown,\n            maxCapMultiplier,\n            validatorMaxStake,\n            validatorEnableMinStake,\n            delegatorMinStake\n        );\n    }\n\n    /*\n     * Returns validator metadata with how many tokens were staked and delegated excluding compounded rewards\n     */\n    function getValidatorMetadata(uint128 validatorId) public view returns (address _address, uint128 staked, uint128 delegated, uint128 commissionRate, uint256 disabledAtBlock) {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = _validators[validatorId];\n        return (v._address, v.stakings[v._address].staked, v.delegated, v.commissionRate, v.disabledAtBlock);\n    }\n\n    /*\n     * Returns metadata for each validator\n     */\n    function getAllValidatorsMetadata()\n        external\n        view\n        returns (address[] memory addresses, uint128[] memory staked, uint128[] memory delegated, uint128[] memory commissionRates, uint256[] memory disabledAtBlocks)\n    {\n        return getValidatorsMetadata(0, validatorsN);\n    }\n\n    /*\n     * Returns metadata for validators whose ids are between startId and endId exclusively\n     */\n    function getValidatorsMetadata(\n        uint128 startId,\n        uint128 endId\n    ) public view returns (address[] memory addresses, uint128[] memory staked, uint128[] memory delegated, uint128[] memory commissionRates, uint256[] memory disabledAtBlocks) {\n        require(endId <= validatorsN, \"Invalid end id\");\n        require(startId < endId, \"Start id must be less than end id\");\n\n        uint128 n = endI"
    }
  ]
}