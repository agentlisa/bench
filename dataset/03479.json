{
  "Title": "[C04] Valid L1-to-L2 queue transactions may be proven fraudulent spoofing queue origin",
  "Content": "When initializing a fraud proof via the `initializeFraudVerification` function of the `OVM_FraudVerifier` contract, the relevant [transaction is provided](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L96) so it can be [verified to exist](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L124) within the Canonical Transaction Chain. However, when verifying a transaction that was added through the L1-to-L2 queue (that is, via the [`enqueue` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L256) of the `OVM_CanonicalTransactionChain` contract), the [`l1QueueOrigin` field](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/codec/Lib_OVMCodec.sol#L63) of the transaction [is not validated](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L1189-L1194).\n\n\nAs a result, anyone can provide a transaction maliciously setting its `l1QueueOrigin` field to `SEQUENCER_QUEUE` (instead of `L1TOL2_QUEUE`) when disputing a transaction that originated in the L1-to-L2 queue. The gas used by this transaction will be [attributed to the wrong queue](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L216)and any logic that relies on the [`ovmL1QUEUEORIGIN` opcode](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L330) may evaluate incorrectly. Naturally, this will produce a different final state, thus allowing the fraud proof to succeed even if the original transition was valid.\n\n\nConsider validating the `l1QueueOrigin` field of the provided transaction when initializing a fraud proof.\n\n\n***Update**: Fixed in [pull request #1155](https://github.com/ethereum-optimism/optimism/pull/1155/commits/aafb141bf798c657e8e0193e718068bed9211ebf).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\n\n/* Interface Imports */\nimport { iOVM_FraudVerifier } from \"../../iOVM/verification/iOVM_FraudVerifier.sol\";\nimport { iOVM_StateTransitioner } from \"../../iOVM/verification/iOVM_StateTransitioner.sol\";\nimport { iOVM_StateTransitionerFactory } from \"../../iOVM/verification/iOVM_StateTransitionerFactory.sol\";\nimport { iOVM_BondManager } from \"../../iOVM/verification/iOVM_BondManager.sol\";\nimport { iOVM_StateCommitmentChain } from \"../../iOVM/chain/iOVM_StateCommitmentChain.sol\";\nimport { iOVM_CanonicalTransactionChain } from \"../../iOVM/chain/iOVM_CanonicalTransactionChain.sol\";\n\n/* Contract Imports */\nimport { Abs_FraudContributor } from \"./Abs_FraudContributor.sol\";\n\n\n\n/**\n * @title OVM_FraudVerifier\n * @dev The Fraud Verifier contract coordinates the entire fraud proof verification process. \n * If the fraud proof was successful it prunes any state batches from State Commitment Chain\n * which were published after the fraudulent state root.\n * \n * Compiler used: solc\n * Runtime target: EVM\n */\ncontract OVM_FraudVerifier is Lib_AddressResolver, Abs_FraudContributor, iOVM_FraudVerifier {\n\n    /*******************************************\n     * Contract Variables: Internal Accounting *\n     *******************************************/\n\n    mapping (bytes32 => iOVM_StateTransitioner) internal transitioners;\n\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     */\n    constructor(\n        address _libAddressManager\n    )\n        Lib_AddressResolver(_libAddressManager)\n    {}\n\n\n    /***************************************\n     * Public Functions: Transition Status *\n     ***************************************/\n\n    /**\n     * Retrieves the state transitioner for a given root.\n     * @param _preStateRoot State root to query a transitioner for.\n     * @return _transitioner Corresponding state transitioner contract.\n     */\n    function getStateTransitioner(\n        bytes32 _preStateRoot,\n        bytes32 _txHash\n    )\n        override\n        public\n        view\n        returns (\n            iOVM_StateTransitioner _transitioner\n        )\n    {\n        return transitioners[keccak256(abi.encodePacked(_preStateRoot, _txHash))];\n    }\n\n\n    /****************************************\n     * Public Functions: Fraud Verification *\n     ****************************************/\n\n    /**\n     * Begins the fraud verification process.\n     * @param _preStateRoot State root before the fraudulent transaction.\n     * @param _preStateRootBatchHeader Batch header for the provided pre-state root.\n     * @param _preStateRootProof Inclusion proof for the provided pre-state root.\n     * @param _transaction OVM transaction claimed to be fraudulent.\n     * @param _txChainElement OVM transaction chain element.\n     * @param _transactionBatchHeader Batch header for the provided transaction.\n     * @param _transactionProof Inclusion proof for the provided transaction.\n     */\n    function initializeFraudVerification(\n        bytes32 _preStateRoot,\n        Lib_OVMCodec.ChainBatchHeader memory _preStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _preStateRootProof,\n        Lib_OVMCodec.Transaction memory _transaction,\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader memory _transactionBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _transactionProof\n    )\n        override\n        public\n        contributesToFraudProof(_preStateRoot, Lib_OVMCodec.hashTransaction(_transaction))\n    {\n        bytes32 _txHash = Lib_OVMCodec.hashTransaction(_transaction);\n\n        if (_hasStateTransitioner(_preStateRoot, _txHash)) {\n            return;\n        }\n\n        iOVM_StateCommitmentChain ovmStateCommitmentChain = iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n        iOVM_CanonicalTransactionChain ovmCanonicalTransactionChain = iOVM_CanonicalTransactionChain(resolve(\"OVM_CanonicalTransactionChain\"));\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _preStateRoot,\n                _preStateRootBatchHeader,\n                _preStateRootProof\n            ),\n            \"Invalid pre-state root inclusion proof.\"\n        );\n\n        require(\n            ovmCanonicalTransactionChain.verifyTransaction(\n                _transaction,\n                _txChainElement,\n                _transactionBatchHeader,\n                _transactionProof\n            ),\n            \"Invalid transaction inclusion proof.\"\n        );\n\n        require (\n            _preStateRootBatchHeader.prevTotalElements + _preStateRootProof.index + 1 == _transactionBatchHeader.prevTotalElements + _transactionProof.index,\n            \"Pre-state root global index must equal to the transaction root global index.\"\n        );\n\n        _deployTransitioner(_preStateRoot, _txHash, _preStateRootProof.index);\n\n        emit FraudProofInitialized(\n            _preStateRoot,\n            _preStateRootProof.index,\n            _txHash,\n            msg.sender\n        );\n    }\n\n    /**\n     * Finalizes the fraud verification process.\n     * @param _preStateRoot State root before the fraudulent transaction.\n     * @param _preStateRootBatchHeader Batch header for the provided pre-state root.\n     * @param _preStateRootProof Inclusion proof for the provided pre-state root.\n     * @param _txHash The transaction for the state root\n     * @param _postStateRoot State root after the fraudulent transaction.\n     * @param _postStateRootBatchHeader Batch header for the provided post-state root.\n     * @param _postStateRootProof Inclusion proof for the provided post-state root.\n     */\n    function finalizeFraudVerification(\n        bytes32 _preStateRoot,\n        Lib_OVMCodec.ChainBatchHeader memory _preStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _preStateRootProof,\n        bytes32 _txHash,\n        bytes32 _postStateRoot,\n        Lib_OVMCodec.ChainBatchHeader memory _postStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _postStateRootProof\n    )\n        override\n        public\n        contributesToFraudProof(_preStateRoot, _txHash)\n    {\n        iOVM_StateTransitioner transitioner = getStateTransitioner(_preStateRoot, _txHash);\n        iOVM_StateCommitmentChain ovmStateCommitmentChain = iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n\n        require(\n            transitioner.isComplete() == true,\n            \"State transition process must be completed prior to finalization.\"\n        );\n\n        require (\n            _postStateRootBatchHeader.prevTotalElements + _postStateRootProof.index == _preStateRootBatchHeader.prevTotalElements + _preStateRootProof.index + 1,\n            \"Post-state root global index must equal to the pre state root global index plus one.\"\n        );\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _preStateRoot,\n                _preStateRootBatchHeader,\n                _preStateRootProof\n            ),\n            \"Invalid pre-state root inclusion proof.\"\n        );\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _postStateRoot,\n                _postStateRootBatchHeader,\n                _postStateRootProof\n            ),\n            \"Invalid post-state root inclusion proof.\"\n        );\n\n        // If the post state root did not match, then there was fraud and we should delete the batch\n        require(\n            _postStateRoot != transitioner.getPostStateRoot(),\n            \"State transition has not been proven fraudulent.\"\n        );\n        \n        _cancelStateTransition(_postStateRootBatchHeader, _preStateRoot);\n\n        // TEMPORARY: Remove the transitioner; for minnet.\n        transitioners[keccak256(abi.encodePacked(_preStateRoot, _txHash))] = iOVM_StateTransitioner(0x0000000000000000000000000000000000000000);\n\n        emit FraudProofFinalized(\n            _preStateRoot,\n            _preStateRootProof.index,\n            _txHash,\n            msg.sender\n        );\n    }\n\n\n    /************************************\n     * Internal Functions: Verification *\n     ************************************/\n\n    /**\n     * Checks whether a transitioner already exists for a given pre-state root.\n     * @param _preStateRoot Pre-state root to check.\n     * @return _exists Whether or not we already have a transitioner for the root.\n     */\n    function _hasStateTransitioner(\n        bytes32 _preStateRoot,\n        bytes32 _txHash\n    )\n        internal\n        view\n        returns (\n            bool _exists\n        )\n    {\n        return address(getStateTransitioner(_preStateRoot, _txHash)) != address(0);\n    }\n\n    /**\n     * Deploys a new state transitioner.\n     * @param _preStateRoot Pre-state root to initialize the transitioner with.\n     * @param _txHash Hash of the transaction this transitioner will execute.\n     * @param _stateTransitionIndex Index of the transaction in the chain.\n     */\n    function _deployTransitioner(\n        bytes32 _preStateRoot,\n        bytes32 _txHash,\n        uint256 _stateTransitionIndex\n    )\n        internal\n    {\n        transitioners[keccak256(abi.encodePacked(_preStateRoot, _txHash))] = iOVM_StateTransitionerFactory(\n            resolve(\"OVM_StateTransitionerFactory\")\n        ).create(\n            address(libAddressManager),\n            _stateTransitionIndex,\n            _preStateRoot,\n            _txHash\n        );\n    }\n\n    /**\n     * Removes a state transition from the state commitment chain.\n     * @param _postStateRootBatchHeader Header for the post-state root.\n     * @param _preStateRoot Pre-state root hash.\n     */\n    function _cancelStateTransition(\n        Lib_OVMCodec.ChainBatchHeader memory _postStateRootBatchHeader,\n        bytes32 _preStateRoot\n    )\n        internal\n    {\n        iOVM_StateCommitmentChain ovmStateCommitmentChain = iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n        iOVM_BondManager ovmBondManager = iOVM_BondManager(resolve(\"OVM_BondManager\"));\n\n        // Delete the state batch.\n        ovmStateCommitmentChain.deleteStateBatch(\n            _postStateRootBatchHeader\n        );\n\n        // Get the timestamp and publisher for that block.\n        (uint256 timestamp, address publisher) = abi.decode(_postStateRootBatchHeader.extraData, (uint256, address));\n\n        // Slash the bonds at the bond manager.\n        ovmBondManager.finalize(\n            _preStateRoot,\n            publisher,\n            timestamp\n        );\n    }\n}"
    },
    {
      "filename": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n// @unsupported: ovm\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\nimport { Lib_EthUtils } from \"../../libraries/utils/Lib_EthUtils.sol\";\nimport { Lib_ErrorUtils } from \"../../libraries/utils/Lib_ErrorUtils.sol\";\n\n/* Interface Imports */\nimport { iOVM_ExecutionManager } from \"../../iOVM/execution/iOVM_ExecutionManager.sol\";\nimport { iOVM_StateManager } from \"../../iOVM/execution/iOVM_StateManager.sol\";\nimport { iOVM_SafetyChecker } from \"../../iOVM/execution/iOVM_SafetyChecker.sol\";\n\n/* Contract Imports */\nimport { OVM_ECDSAContractAccount } from \"../accounts/OVM_ECDSAContractAccount.sol\";\nimport { OVM_ProxyEOA } from \"../accounts/OVM_ProxyEOA.sol\";\nimport { OVM_DeployerWhitelist } from \"../predeploys/OVM_DeployerWhitelist.sol\";\n\n/**\n * @title OVM_ExecutionManager\n * @dev The Execution Manager (EM) is the core of our OVM implementation, and provides a sandboxed\n * environment allowing us to execute OVM transactions deterministically on either Layer 1 or\n * Layer 2.\n * The EM's run() function is the first function called during the execution of any\n * transaction on L2.\n * For each context-dependent EVM operation the EM has a function which implements a corresponding\n * OVM operation, which will read state from the State Manager contract.\n * The EM relies on the Safety Checker to verify that code deployed to Layer 2 does not contain any\n * context-dependent operations.\n *\n * Compiler used: solc\n * Runtime target: EVM\n */\ncontract OVM_ExecutionManager is iOVM_ExecutionManager, Lib_AddressResolver {\n\n    /********************************\n     * External Contract References *\n     ********************************/\n\n    iOVM_SafetyChecker internal ovmSafetyChecker;\n    iOVM_StateManager internal ovmStateManager;\n\n\n    /*******************************\n     * Execution Context Variables *\n     *******************************/\n\n    GasMeterConfig internal gasMeterConfig;\n    GlobalContext internal globalContext;\n    TransactionContext internal transactionContext;\n    MessageContext internal messageContext;\n    TransactionRecord internal transactionRecord;\n    MessageRecord internal messageRecord;\n\n\n    /**************************\n     * Gas Metering Constants *\n     **************************/\n\n    address constant GAS_METADATA_ADDRESS = 0x06a506A506a506A506a506a506A506A506A506A5;\n    uint256 constant NUISANCE_GAS_SLOAD = 20000;\n    uint256 constant NUISANCE_GAS_SSTORE = 20000;\n    uint256 constant MIN_NUISANCE_GAS_PER_CONTRACT = 30000;\n    uint256 constant NUISANCE_GAS_PER_CONTRACT_BYTE = 100;\n    uint256 constant MIN_GAS_FOR_INVALID_STATE_ACCESS = 30000;\n\n    /**************************\n     * Default Context Values *\n     **************************/\n\n    uint256 constant DEFAULT_UINT256 = 0xdefa017defa017defa017defa017defa017defa017defa017defa017defa017d;\n    address constant DEFAULT_ADDRESS = 0xdEfa017defA017DeFA017DEfa017DeFA017DeFa0;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     */\n    constructor(\n        address _libAddressManager,\n        GasMeterConfig memory _gasMeterConfig,\n        GlobalContext memory _globalContext\n    )\n        Lib_AddressResolver(_libAddressManager)\n    {\n        ovmSafetyChecker = iOVM_SafetyChecker(resolve(\"OVM_SafetyChecker\"));\n        gasMeterConfig = _gasMeterConfig;\n        globalContext = _globalContext;\n        _resetContext();\n    }\n\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Applies dynamically-sized refund to a transaction to account for the difference in execution\n     * between L1 and L2, so that the overall cost of the ovmOPCODE is fixed.\n     * @param _cost Desired gas cost for the function after the refund.\n     */\n    modifier netGasCost(\n        uint256 _cost\n    ) {\n        uint256 gasProvided = gasleft();\n        _;\n        uint256 gasUsed = gasProvided - gasleft();\n\n        // We want to refund everything *except* the specified cost.\n        if (_cost < gasUsed) {\n            transactionRecord.ovmGasRefund += gasUsed - _cost;\n        }\n    }\n\n    /**\n     * Applies a fixed-size gas refund to a transaction to account for the difference in execution\n     * between L1 and L2, so that the overall cost of an ovmOPCODE can be lowered.\n     * @param _discount Amount of gas cost to refund for the ovmOPCODE.\n     */\n    modifier fixedGasDiscount(\n        uint256 _discount\n    ) {\n        uint256 gasProvided = gasleft();\n        _;\n        uint256 gasUsed = gasProvided - gasleft();\n\n        // We want to refund the specified _discount, unless this risks underflow.\n        if (_discount < gasUsed) {\n            transactionRecord.ovmGasRefund += _discount;\n        } else {\n            // refund all we can without risking underflow.\n            transactionRecord.ovmGasRefund += gasUsed;\n        }\n    }\n\n    /**\n     * Makes sure we're not inside a static context.\n     */\n    modifier notStatic() {\n        if (messageContext.isStatic == true) {\n            _revertWithFlag(RevertFlag.STATIC_VIOLATION);\n        }\n        _;\n    }\n\n\n    /************************************\n     * Transaction Execution Entrypoint *\n     ************************************/\n\n    /**\n     * Starts the execution of a transaction via the OVM_ExecutionManager.\n     * @param _transaction Transaction data to be executed.\n     * @param _ovmStateManager iOVM_StateManager implementation providing account state.\n     */\n    function run(\n        Lib_OVMCodec.Transaction memory _transaction,\n        address _ovmStateManager\n    )\n        override\n        public\n    {\n        // Make sure that run() is not re-enterable.  This condition should awlways be satisfied\n        // Once run has been called once, due to the behvaior of _isValidInput().\n        if (transactionContext.ovmNUMBER != DEFAULT_UINT256) {\n            return;\n        }\n\n        // Store our OVM_StateManager instance (significantly easier than attempting to pass the\n        // address around in calldata).\n        ovmStateManager = iOVM_StateManager(_ovmStateManager);\n\n        // Make sure this function can't be called by anyone except the owner of the\n        // OVM_StateManager (expected to be an OVM_StateTransitioner). We can revert here because\n        // this would make the `run` itself invalid.\n        require(\n            // This method may return false during fraud proofs, but always returns true in L2 nodes' State Manager precompile.\n            ovmStateManager.isAuthenticated(msg.sender),\n            \"Only authenticated addresses in ovmStateManager can call this function\"\n        );\n\n        // Initialize the execution context, must be initialized before we perform any gas metering\n        // or we'll throw a nuisance gas error.\n        _initContext(_transaction);\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Check whether we need to start a new epoch, do so if necessary.\n        // _checkNeedsNewEpoch(_transaction.timestamp);\n\n        // Make sure the transaction's gas limit is valid. We don't revert here because we reserve\n        // reverts for INVALID_STATE_ACCESS.\n        if (_isValidInput(_transaction) == false) {\n            _resetContext();\n            return;\n        }\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Check gas right before the call to get total gas consumed by OVM transaction.\n        // uint256 gasProvided = gasleft();\n\n        // Run the transaction, make sure to meter the gas usage.\n        ovmCALL(\n            _transaction.gasLimit - gasMeterConfig.minTransactionGasLimit,\n            _transaction.entrypoint,\n            _transaction.data\n        );\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Update the cumulative gas based on the amount of gas used.\n        // uint256 gasUsed = gasProvided - gasleft();\n        // _updateCumulativeGas(gasUsed, _transaction.l1QueueOrigin);\n\n        // Wipe the execution context.\n        _resetContext();\n    }\n\n\n    /******************************\n     * Opcodes: Execution Context *\n     ******************************/\n\n    /**\n     * @notice Overrides CALLER.\n     * @return _CALLER Address of the CALLER within the current message context.\n     */\n    function ovmCALLER()\n        override\n        public\n        view\n        returns (\n            address _CALLER\n        )\n    {\n        address caller = messageContext.ovmCALLER;\n        if (caller == address(0)) {\n            _revertWithFlag(RevertFlag.UNINITIALIZED_ACCESS);\n        } else {\n            return caller;\n        }\n    }\n\n    /**\n     * @notice Overrides ADDRESS.\n     * @return _ADDRESS Active ADDRESS within the current message context.\n     */\n    function ovmADDRESS()\n        override\n        public\n        view\n        returns (\n            address _ADDRESS\n        )\n    {\n        return messageContext.ovmADDRESS;\n    }\n\n    /**\n     * @notice Overrides TIMESTAMP.\n     * @return _TIMESTAMP Value of the TIMESTAMP within the transaction context.\n     */\n    function ovmTIMESTAMP()\n        override\n        public\n        view\n        returns (\n            uint256 _TIMESTAMP\n        )\n    {\n        return transactionContext.ovmTIMESTAMP;\n    }\n\n    /**\n     * @notice Overrides NUMBER.\n     * @return _NUMBER Value of the NUMBER within the transaction context.\n     */\n    function ovmNUMBER()\n        override\n        public\n        view\n        returns (\n            uint256 _NUMBER\n        )\n    {\n        return transactionContext.ovmNUMBER;\n    }\n\n    /**\n     * @notice Overrides GASLIMIT.\n     * @return _GASLIMIT Value of the block's GASLIMIT within the transaction context.\n     */\n    function ovmGASLIMIT()\n        override\n        public\n        view\n        returns (\n            uint256 _GASLIMIT\n        )\n    {\n        return transactionContext.ovmGASLIMIT;\n    }\n\n    /**\n     * @notice Overrides CHAINID.\n     * @return _CHAINID Value of the chain's CHAINID within the global context.\n     */\n    function ovmCHAINID()\n        override\n        public\n        view\n        returns (\n            uint256 _CHAINID\n        )\n    {\n        return globalContext.ovmCHAINID;\n    }\n\n    /*********************************\n     * Opcodes: L2 Execution Context *\n     *********************************/\n\n    /**\n     * @notice Specifies from which L1 rollup queue this transaction originated from.\n     * @return _queueOrigin Address of the ovmL1QUEUEORIGIN within the current message context.\n     */\n    function ovmL1QUEUEORIGIN()\n        override\n        public\n        view\n        returns (\n            Lib_OVMCodec.QueueOrigin _queueOrigin\n        )\n    {\n        return transactionContext.ovmL1QUEUEORIGIN;\n    }\n\n    /**\n     * @notice Specifies which L1 account, if any, sent this transaction by calling enqueue().\n     * @return _l1TxOrigin Address of the account which sent the tx into L2 from L1.\n     */\n    function ovmL1TXORIGIN()\n        override\n        public\n        view\n        returns (\n            address _l1TxOrigin\n        )\n    {\n        return transactionContext.ovmL1TXORIGIN;\n    }\n\n    /********************\n     * Opcodes: Halting *\n     ********************/\n\n    /**\n     * @notice Overrides REVERT.\n     * @param _data Bytes data to pass along with the REVERT.\n     */\n    function ovmREVERT(\n        bytes memory _data\n    )\n        override\n        public\n        view\n    {\n        _revertWithFlag(RevertFlag.INTENTIONAL_REVERT, _data);\n    }\n\n\n    /******************************\n     * Opcodes: Contract Creation *\n     ******************************/\n\n    /**\n     * @notice Overrides CREATE.\n     * @param _bytecode Code to be used to CREATE a new contract.\n     * @return Address of the created contract.\n     * @return Revert data, if and only if the creation threw an exception.\n     */\n    function ovmCREATE(\n        bytes memory _bytecode\n    )\n        override\n        public\n        notStatic\n        fixedGasDiscount(40000)\n        returns (\n            address,\n            bytes memory\n        )\n    {\n        // Creator is always the current ADDRESS.\n        address creator = ovmADDRESS();\n\n        // Check that the deployer is whitelisted, or\n        // that arbitrary contract deployment has been enabled.\n        _checkDeployerAllowed(creator);\n\n        // Generate the correct CREATE address.\n        address contractAddress = Lib_EthUtils.getAddressForCREATE(\n            creator,\n            _getAccountNonce(creator)\n        );\n\n        return _createContract(\n            contractAddress,\n            _bytecode\n        );\n    }\n\n    /**\n     * @notice Overrides CREATE2.\n     * @param _bytecode Code to be used to CREATE2 a new contract.\n     * @param _salt Value used to determine the contract's address.\n     * @return Address of the created contract.\n     * @return Revert data, if and only if the creation threw an exception.\n     */\n    function ovmCREATE2(\n        bytes memory _bytecode,\n        bytes32 _salt\n    )\n        override\n        public\n        notStatic\n        fixedGasDiscount(40000)\n        returns (\n            address,\n            bytes memory\n        )\n    {\n        // Creator is always the current ADDRESS.\n        address creator = ovmADDRESS();\n\n        // Check that the deployer is whitelisted, or\n        // that arbitrary contract deployment has been enabled.\n        _checkDeployerAllowed(creator);\n\n        // Generate the correct CREATE2 address.\n        address contractAddress = Lib_EthUtils.getAddressForCREATE2(\n            creator,\n            _bytecode,\n            _salt\n        );\n\n        return _createContract(\n            contractAddress,\n            _bytecode\n        );\n    }\n\n\n    /*******************************\n     * Account Abstraction Opcodes *\n     ******************************/\n\n    /**\n     * Retrieves the nonce of the current ovmADDRESS.\n     * @return _nonce Nonce of the current contract.\n     */\n    function ovmGETNONCE()\n        override\n        public\n        returns (\n            uint64 _nonce\n        )\n    {\n        return _getAccountNonce(ovmADDRESS());\n    }\n\n    /**\n     * Bumps the nonce of the current ovmADDRESS by one.\n     */\n    function ovmINCREMENTNONCE()\n        override\n        public\n        notStatic\n    {\n        address account = ovmADDRESS();\n        uint64 nonce = _getAccountNonce(account);\n\n        // Prevent overflow.\n        if (nonce + 1 > nonce) {\n            _setAccountNonce(account, nonce + 1);\n        }\n    }\n\n    /**\n     * Creates a new EOA contract account, for account abstraction.\n     * @dev Essentially functions like ovmCREATE or ovmCREATE2, but we can bypass a lot of checks\n     *      because the contract we're creating is trusted (no need to do safety checking or to\n     *      handle unexpected reverts). Doesn't need to return an address because the address is\n     *      assumed to be the user's actual address.\n     * @param _messageHash Hash of a message signed by some user, for verification.\n     * @param _v Signature `v` parameter.\n     * @param _r Signature `r` parameter.\n     * @param _s Signature `s` parameter.\n     */\n    function ovmCREATEEOA(\n        bytes32 _messageHash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        override\n        public\n        notStatic\n    {\n        // Recover the EOA address from the message hash and signature parameters. Since we do the\n        // hashing in advance, we don't have handle different message hashing schemes. Even if this\n        // function were to return the wrong address (rather than explicitly returning the zero\n        // address), the rest of the transaction would simply fail (since there's no EOA account to\n        // actually execute the transaction).\n        address eoa = ecrecover(\n            _messageHash,\n            _v + 27,\n            _r,\n            _s\n        );\n\n        // Invalid signature is a case we proactively handle with a revert. We could alternatively\n        // have this function return a `success` boolean, but this is just easier.\n        if (eoa == address(0)) {\n            ovmREVERT(bytes(\"Signature provided for EOA contract creation is invalid.\"));\n        }\n\n        // If the user already has an EOA account, then there's no need to perform this operation.\n        if (_hasEmptyAccount(eoa) == false) {\n            return;\n        }\n\n        // We always need to initialize the contract with the default account values.\n        _initPendingAccount(eoa);\n\n        // Temporarily set the current address so it's easier to access on L2.\n        address prevADDRESS = messageContext.ovmADDRESS;\n        messageContext.ovmADDRESS = eoa;\n\n        // Now actually create the account and get its bytecode. We're not worried about reverts\n        // (other than out of gas, which we can't capture anyway) because this contract is trusted.\n        OVM_ProxyEOA proxyEOA = new OVM_ProxyEOA(0x4200000000000000000000000000000000000003);\n\n        // Reset the address now that we're done deploying.\n        messageContext.ovmADDRESS = prevADDRESS;\n\n        // Commit the account with its final values.\n        _commitPendingAccount(\n            eoa,\n            address(proxyEOA),\n            keccak256(Lib_EthUtils.getCode(address(proxyEOA)))\n        );\n\n        _setAccountNonce(eoa, 0);\n    }\n\n\n    /*********************************\n     * Opcodes: Contract Interaction *\n     *********************************/\n\n    /**\n     * @notice Overrides CALL.\n     * @param _gasLimit Amount of gas to be passed into this call.\n     * @param _address Address of the contract to call.\n     * @param _calldata Data to send along with the call.\n     * @return _success Whether or not the call returned (rather than reverted).\n     * @return _returndata Data returned by the call.\n     */\n    function ovmCALL(\n        uint256 _gasLimit,\n        address _address,\n        bytes memory _calldata\n    )\n        override\n        public\n        fixedGasDiscount(100000)\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        // CALL updates the CALLER and ADDRESS.\n        MessageContext memory nextMessageContext = messageContext;\n        nextMessageContext.ovmCALLER = nextMessageContext.ovmADDRESS;\n        nextMessageContext.ovmADDRESS = _address;\n\n        return _callContract(\n            nextMessageContext,\n            _gasLimit,\n            _address,\n            _calldata\n        );\n    }\n\n    /**\n     * @notice Overrides STATICCALL.\n     * @param _gasLimit Amount of gas to be passed into this call.\n     * @param _address Address of the contract to call.\n     * @param _calldata Data to send along with the call.\n     * @return _success Whether or not the call returned (rather than reverted).\n     * @return _returndata Data returned by the call.\n     */\n    function ovmSTATICCALL(\n        uint256 _gasLimit,\n        address _address,\n        bytes memory _calldata\n    )\n        override\n        public\n        fixedGasDiscount(80000)\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        // STATICCALL updates the CALLER, updates the ADDRESS, and runs in a static context.\n        MessageContext memory nextMessageContext = messageContext;\n        nextMessageContext.ovmCALLER = nextMessageContext.ovmADDRESS;\n        nextMessageContext.ovmADDRESS = _address;\n        nextMessageContext.isStatic = true;\n\n        return _callContract(\n            nextMessageContext,\n            _gasLimit,\n            _address,\n            _calldata\n        );\n    }\n\n    /**\n     * @notice Overrides DELEGATECALL.\n     * @param _gasLimit Amount of gas to be passed into this call.\n     * @param _address Address of the contract to call.\n     * @param _calldata Data to send along with the call.\n     * @return _success Whether or not the call returned (rather than reverted).\n     * @return _returndata Data returned by the call.\n     */\n    function ovmDELEGATECALL(\n        uint256 _gasLimit,\n        address _address,\n        bytes memory _calldata\n    )\n        override\n        public\n        fixedGasDiscount(40000)\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        // DELEGATECALL does not change anything about the message context.\n        MessageContext memory nextMessageContext = messageContext;\n\n        return _callContract(\n            nextMessageContext,\n            _gasLimit,\n            _address,\n            _calldata\n        );\n    }\n\n\n    /************************************\n     * Opcodes: Contract Storage Access *\n     ************************************/\n\n    /**\n     * @notice Overrides SLOAD.\n     * @param _key 32 byte key of the storage slot to load.\n     * @return _value 32 byte value of the requested storage slot.\n     */\n    function ovmSLOAD(\n        bytes32 _key\n    )\n        override\n        public\n        netGasCost(40000)\n        returns (\n            bytes32 _value\n        )\n    {\n        // We always SLOAD from the storage of ADDRESS.\n        address contractAddress = ovmADDRESS();\n\n        return _getContractStorage(\n            contractAddress,\n            _key\n        );\n    }\n\n    /**\n     * @notice Overrides SSTORE.\n     * @param _key 32 byte key of the storage slot to set.\n     * @param _value 32 byte value for the storage slot.\n     */\n    function ovmSSTORE(\n        bytes32 _key,\n        bytes32 _value\n    )\n        override\n        public\n        notStatic\n        netGasCo"
    }
  ]
}