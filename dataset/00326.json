{
  "Title": "M-1: Some unusual problems arise in the use of the `GoatV1Factory.sol#createPair()` function.",
  "Content": "# Issue M-1: Some unusual problems arise in the use of the `GoatV1Factory.sol#createPair()` function. \n\nSource: https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/18 \n\n## Found by \nFastTiger\n## Summary\nIf you create a new pool for tokens and add liquidity using the `GoatRouterV1.sol#addLiquidity()` function, the bootstrap function of the protocol is broken.\nTherefore, an attacker can perform the front running attack on the `GoatRouterV1.sol#addLiquidity()` function by front calling `GoatV1Factory.sol#createPair()`. \n## Vulnerability Detail\nIf a pool for the token does not exist, the LP can create a new pool using the `GoatV1Factory.sol#createPair()` function. Next he calls `GoatRouterV1.sol#addLiquidity()` to provide liquidity. At this time, the amount of WETH and ERC20Token provided to the pool is calculated in the `GoatRouterV1.sol#_addLiquidity()` function.\n```solidity\n    function _addLiquidity(\n        address token,\n        uint256 tokenDesired,\n        uint256 wethDesired,\n        uint256 tokenMin,\n        uint256 wethMin,\n        GoatTypes.InitParams memory initParams\n    ) internal returns (uint256, uint256, bool) {\n        GoatTypes.LocalVariables_AddLiquidity memory vars;\n        GoatV1Pair pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n        if (address(pair) == address(0)) {\n            // First time liquidity provider\n            pair = GoatV1Pair(GoatV1Factory(FACTORY).createPair(token, initParams));\n            vars.isNewPair = true;\n        }\n\n        if (vars.isNewPair) {\n...SNIP\n        } else {\n            /**\n             * @dev This block is accessed after the presale period is over and the pool is converted to AMM\n             */\n250:        (uint256 wethReserve, uint256 tokenReserve) = pair.getReserves();\n251:        uint256 tokenAmountOptimal = GoatLibrary.quote(wethDesired, wethReserve, tokenReserve);\n252:        if (tokenAmountOptimal <= tokenDesired) {\n253:            if (tokenAmountOptimal < tokenMin) {\n254:                revert GoatErrors.InsufficientTokenAmount();\n255:            }\n256:            (vars.tokenAmount, vars.wethAmount) = (tokenAmountOptimal, wethDesired);\n257:        } else {\n258:            uint256 wethAmountOptimal = GoatLibrary.quote(tokenDesired, tokenReserve, wethReserve);\n259:            assert(wethAmountOptimal <= wethDesired);\n260:            if (wethAmountOptimal < wethMin) revert GoatErrors.InsufficientWethAmount();\n261:            (vars.tokenAmount, vars.wethAmount) = (tokenDesired, wethAmountOptimal);\n262:        }\n263:    }\n264:    return (vars.tokenAmount, vars.wethAmount, vars.isNewPair);\n    }\n```\n\nFor simplicity, let’s only consider from #L250 to #L256.\n\nL250:wethReserve = virtualEth, \n     tokenReserve = initialTokenMatch - (initialTokenMatch - ((virtualEth * initialTokenMatch)/(virtualEth + bootstrapEth)) + \n                    + (virtualEth*initialTokenMatch*bootstrapEth)/(virtualEth + bootstrapEth) ^ 2) = \n                    = ((virtualEth * initialTokenMatch)/(virtualEth + bootstrapEth)) - (virtualEth*initialTokenMatch*bootstrapEth)/(virtualEth + bootstrapEth) ^ 2\nL251:tokenAmountOptimal = wethDesired * wethReserve / tokenReserve\n     vars.tokenAmount = tokenAmountOptimal\n     vars.wethAmount = wethDesired\n\nAt this time, At this time, the calculated balance of ETH and token is sent to the pool, and `GoatV1Pair(vars.pair).mint()` is called in the `GoatRouterV1.sol#addLiquidity()` function.\n```solidity\n    function addLiquidity(\n        address token,\n        uint256 tokenDesired,\n        uint256 wethDesired,\n        uint256 tokenMin,\n        uint256 wethMin,\n        address to,\n        uint256 deadline,\n        GoatTypes.InitParams memory initParams\n    ) external nonReentrant ensure(deadline) returns (uint256, uint256, uint256) {\n...SNIP\n65:     IERC20(vars.token).safeTransferFrom(msg.sender, vars.pair, vars.actualTokenAmount);\n66:     if (vars.wethAmount != 0) {\n67:         IERC20(WETH).safeTransferFrom(msg.sender, vars.pair, vars.wethAmount);\n68:     }\n69:     vars.liquidity = GoatV1Pair(vars.pair).mint(to);\n...SNIP\n    }\n```\nNext, the `GoatV1Pair(vars.pair).mint()` function checks the validity of the transmitted token.\n```solidity\n    function mint(address to) external nonReentrant returns (uint256 liquidity) {\n    ...SNIP\n        if (_vestingUntil == _MAX_UINT32) {\n            // Do not allow to add liquidity in presale period\n            if (totalSupply_ > 0) revert GoatErrors.PresalePeriod();\n            // don't allow to send more eth than bootstrap eth\n            if (balanceEth > mintVars.bootstrapEth) {\n                revert GoatErrors.SupplyMoreThanBootstrapEth();\n            }\n\n            if (balanceEth < mintVars.bootstrapEth) {\n                (uint256 tokenAmtForPresale, uint256 tokenAmtForAmm) = _tokenAmountsForLiquidityBootstrap(\n                    mintVars.virtualEth, mintVars.bootstrapEth, balanceEth, mintVars.initialTokenMatch\n                );\n139:            if (balanceToken != (tokenAmtForPresale + tokenAmtForAmm)) {\n                    revert GoatErrors.InsufficientTokenAmount();\n                }\n                liquidity =\n                    Math.sqrt(uint256(mintVars.virtualEth) * uint256(mintVars.initialTokenMatch)) - MINIMUM_LIQUIDITY;\n            } else {\n                // This means that user is willing to make this pool an amm pool in first liquidity mint\n146:            liquidity = Math.sqrt(balanceEth * balanceToken) - MINIMUM_LIQUIDITY;\n147:            uint32 timestamp = uint32(block.timestamp);\n148:            _vestingUntil = timestamp + VESTING_PERIOD;\n            }\n            mintVars.isFirstMint = true;\n        }\n    ...SNIP\n    }\n```\n\nIn here, `balanceToken = vars.tokenAmount (value:tokenAmountOptimal)` and `tokenAmtForPresale + tokenAmtForAmm` is calculated follows.\n\ntokenAmtForPresale = initialTokenMatch - (virtualEth * initialTokenMatch / (virtualEth + bootstrapEth)) - \n                    - (balanceEth(value:wethDesired)*initialTokenMatch/(virtualEth+balanceEth))\ntokenAmtForAmm = (virtualEth * initialTokenMatch * bootstrapEth) / (virtualEth + bootstrapEth) ^ 2\n\nAs a result, `(balanceToken != (tokenAmtForPresale + tokenAmtForAmm)) == true`, the `GoatRouterV1.sol#addLiquidity()` function is reverted.\nIn this case, If the initial LP want to provide liquidity to the pool, he must pay an amount of WETH equivalent to bootstrapEth to execute #L146.\nAs a result, the bootstrap function is broken.\n\nBased on this fact, an attacker can front run the `createPair()` function if he finds the `addLiquidity()` function in the mempool.\n## Impact\nThe bootstrap function of the protocol is broken and the initial LP must pay an amount of WETH equivalent to bootstrapEth.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Factory.sol#L33\nhttps://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/periphery/GoatRouterV1.sol#L51\nhttps://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/periphery/GoatRouterV1.sol#L287\nhttps://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/periphery/GoatRouterV1.sol#L233\nhttps://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L139-L141\n## Tool used\n\nManual Review\n\n## Recommendation\nIt is recommended that the `GoatV1Factory.sol#.createPair()` function be called only from the `GoatRouterV1` contract.\n\n\n\n## Discussion\n\n**kennedy1030**\n\nI think that this issue should be seen as a user mistake.\nIf a user is going to create pair and add some liquidity, he has to use the GoatRouterV1.addLiquidity(), not the GoatV1Factory.sol#createPair(). The first minter has to set the first 4 parameters of GoatRouterV1.addLiquidity() as 0. If so, this front running attack can do nothing. I think that this issue should be seen as invalid, because the correct use of  GoatRouterV1 can prevent this attack. \nSo, I think that this one could be seen as a user mistake.\n\n**FastTiger777**\n\nIn #L139 of `GoatV1Pair.sol`, `(balanceToken != (tokenAmtForPresale + tokenAmtForAmm)) == true` because `(tokenAmtForPresale + tokenAmtForAmm)` is calculated the parameters of `createPair()` function.\nTherefore, this is not a user mistake.\n\n**kennedy1030**\n\nHowever, a normal user would use the GoatRouterV1.addLiquidity(), not the GoatV1Factory.sol#createPair(). Then, nothing would happen. \n\n\n**zzykxx**\n\nEscalate\n\nOut of scope. It's known that attackers can frontrun a pair creation, this is why the function `takeOverPool()` exists in the first place.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Out of scope. It's known that attackers can frontrun a pair creation, this is why the function `takeOverPool()` exists in the first place.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**FastTiger777**\n\nHowever, the takeOverPool() function is not enough to completely prevent the attacker's preemption attack, and the loss of initial LP due to the attack still exists. \nAs @zzykxx said, if the takeOverPool() function is to prevent an attacker's attack, the attacker's attack cannot be prevented unless the takeOverPool() function is always called within the same transaction.\n\n\n**FastTiger777**\n\nAdditionally, even if a user takes over a pool using takeOverPool(), there will still be the loss of fund of the initial LP  due to #L139.\n\n**cvetanovv**\n\nI disagree with the escalation. Nowhere do I see front-run a pair creation as a known issue. But even if we assume that `takeOverPool()` is for this then Watson has shown a valid attack vector.\n\n**F01ivor4**\n\nI think this is not high.\n\n**FastTiger777**\n\nIn this case, I think it should be considered high because the initial LP must pay an amount of ETH equivalent to bootstrap ETH when adding liquidity, which damages the bootstrap function of the protocol and causes a loss of funds for the initial LP.\n\n**Evert0x**\n\n> It's known that attackers can frontrun a pair creation\n\nI don't see this mentioned as a known issue. That's why I believe the escalation should be rejected and the issue should stay as is. \n\n**zzykxx**\n\nMaybe I'm missing something? The function `takeOverPool()` exists for the exact purpose of taking back control of pools that an attacker created before a team, here's [the comment](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L432). Given the devs implemented the  `takeOverPool()` function for this reason, how is this not a known issue?\n\n\n**FastTiger777**\n\nWhat I mean is that although takeOverPool() is used to restore the pool, the main point is that the initial liquidity provider loses funds and destroys the bootstrap function of the protocol. Therefore I think this issue is valid.\n\n**kennedy1030**\n\nI believe this issue should be considered a user mistake. If a user creates a pair with the `GoatRouterV1`, no action will occur. Front running could only occur when a user attempts to create a pair without a router. Since most users will use the `GoatRouterV1` to create pairs, I consider this to be a user mistake and classify it as a medium-security issue at most.\n\n**FastTiger777**\n\nI think front running is not the mistake of the user and it is intentional attack of the attacker. The attacker create the pool intentionally before addLiquiditi() function is called. At this time, the user calls takeOverPool() to take over the pool, but user pay an amount of ETH equivalent to bootstrap ETH to provide liquidities. This is a clear destruction of the protocol's bootstrap functionality.\n\n**kennedy1030**\n\nHowever, if all users create pairs with the GoatRouterV1, front running cannot occur. The recommendation also states, \"GoatV1Factory.sol#.createPair() function should be called only from the GoatRouterV1 contract.\" This implies that all users must create pairs with the GoatRouterV1. Furthermore, it means that if all users adhere to this rule, no issues should arise. In this sense, I believe the recommendation also acknowledges that this issue is rooted in user mistake.\n\n**FastTiger777**\n\n@zzykxx , could you please look at the comment of the takeOverPool()? takeOverPool() is used to take over the pool when the malicious actors set the unfavoral initial conditions. So the action of users that create the pool by using router is also involved in here. So I think this is not known issue.\n\n**FastTiger777**\n\nHi @kennedy1030 , the attacker creates the pool before the user calls addLiquidity() function of Router. So the front running attack is existed surely.\nRefer this. \n\n> Based on this fact, an attacker can front run the createPair() function if he finds the addLiquidity() function in the mempool.\n\n**kennedy1030**\n\nI cannot understand why this issue could be a valid high severity. I think that the impact is not high severity. It cannot lead to loss of funds.\n\n**FastTiger777**\n\nIn my report, I clearly stated the attacker's front running attack.\n\n**FastTiger777**\n\n> I cannot understand why this issue could be a valid high severity. I think that the impact is not high severity. It cannot lead to loss of funds.\n\nBecause the initial LP losses the fund.\nThe point of the bootstrap feature is that LPs can provide liquidity even without a sufficient amount of ETH. However, due to the attack, the initial LP must pay an amount of ETH equivalent to the bootstrap ETH, so this is an obvious loss of funds.\n\n**kennedy1030**\n\nI have read it. But the front running attack can do nothing, if user create a pair with GoatRouterV1.sol#_addLiquidity() and set the first 4 parameters as 0s. The first 4 parameters have no meaning in the initial LP, so the initial LP must set the first 4 parameters as 0s and all the test set them as 0s. Then the initial LP would lose nothing. You can check it. Could you submit valid POC? This issue assumed that the first 4 parameters as non-zeros. So, I believe that this issue should be seen as user mistake.\n\n**FastTiger777**\n\n> I have read it. But the front running attack can do nothing, if user create a pair with GoatRouterV1.sol#_addLiquidity() and set the first 4 parameters as 0s. The first 4 parameters have no meaning in the initial LP, so the initial LP must set the first 4 parameters as 0s and all the test set them as 0s. Then the initial LP would lose nothing. You can check it. Could you submit valid POC? This issue assumed that the first 4 parameters as non-zeros. So, I believe that this issue should be seen as user mistake.\n\nThis is the purpose of the takeOverPool() function that @zzykxx mentions. Setting the four parameters to 0 should be considered a malicious action by the user thoroughly. This is because it may result in protocol interruption due to potential DOS.\n\n**kennedy1030**\n\nI mean the from 2nd to 5th parameters of addLiquidity(). That is, `tokenDesired`, `wethDesired`, `tokenMin`,`wethMin`. \nSetting them to 0s is not a malicious action. It is a normal action for the initial LP. Because they have no meaning for the initial LP. This is the example code of BaseTest.t.sol. From 2nd to 5th parameters of addLiquidity() are set as 0s for the initial LP. \n```solidity\nfunction addLiquidityParams(bool initial, bool sendInitWeth) public returns (AddLiquidityParams memory) {\n        weth.deposit{value: 100e18}();\n        if (initial) {\n            /* ------------------------------- SET PARAMS ------------------------------- */\n            addLiqParams.token = address(token);\n            addLiqParams.tokenDesired = 0;\n            addLiqParams.wethDesired = 0;\n            addLiqParams.tokenMin = 0;\n            addLiqParams.wethMin = 0;\n            addLiqParams.to = address(this);\n            addLiqParams.deadline = block.timestamp + 1000;\n\n            addLiqParams.initParams = GoatTypes.InitParams(10e18, 10e18, sendInitWeth ? 5e18 : 0, 1000e18);\n        } else {\n            addLiqParams.token = address(token);\n            addLiqParams.tokenDesired = 100e18;\n            addLiqParams.wethDesired = 1e18;\n            addLiqParams.tokenMin = 0;\n            addLiqParams.wethMin = 0;\n            addLiqParams.to = address(this);\n            addLiqParams.deadline = block.timestamp + 1000;\n\n            addLiqParams.initParams = GoatTypes.InitParams(0, 0, 0, 0);\n        }\n        return addLiqParams;\n    }\n```\n\n**FastTiger777**\n\n> I mean the from 2nd to 5th parameters of addLiquidity(). That is, `tokenDesired`, `wethDesired`, `tokenMin`,`wethMin`. Setting them to 0s is not a malicious action. It is a normal action for the initial LP. Because they have no meaning for the initial LP.\n\nIn getReserve() function, DOS occurs due to division by 0. Please take a look again.\n\n**kennedy1030**\n\nIt means that loss of funds for initial LP is impossible. I think that this kind of DOS could be only seen as a medium severity at most.\n\n**FastTiger777**\n\nWhen totalSupply=0, the liquidity provider can be the initial LP. Therefore, there is still a loss of user funds.\n\n**kennedy1030**\n\nCould you provide the valid POC? I do not believe that this attack could lead to loss of fund. And I think that the effective `takeOver` could take over the pools created by the malicious action like that,\n\n**FastTiger777**\n\n> Could you provide the valid POC? I do not believe that this attack could lead to loss of fund. And I think that the effective `takeOver` could take over the pools created by the malicious action like that,\n\nWhat do you mean by effective `takeOver`, how do you set the 4 parameters? Can you explain about that?\n\n**kennedy1030**\n\nYou should provide the valid POC that shows loss of fund. If not, your issue can only be seen as a DOS. \n`takeOver` is another problem. I think that `takeOverPool()` should be made to take over the pools created by any malicious users.\n\n**FastTiger777**\n\nwhen the user takes over the pool, how to set initial parameters?\n\n**kennedy1030**\n\nDo you agree that the front running attack cannot lead to loss of funds without any user mistake?\n\n**FastTiger777**\n\nNo, As mentioned before, due to a front running attack, LP must pay an amount of ETH equivalent to bootstrapETH. Although the protocol states that LPs can create a pool without a sufficient amount of ETH, due to the attack, LPs must pay a corresponding amount of ETH, so this should clearly be seen as a loss of funds.\nAnd then, the front running attack is not the mistake of the user. You cannot correlate front running attacks with user error. I think you are thinking wrong.\n\n**kennedy1030**\n\nBut I could not agree that this could be seen as a loss of funds. It can only be seen as a DOS. How can it be seen as loss of fund if a user can know the result before calling? So, the impact is only DOS, not loss of fund. Who would call a function when he already knows that it could lead to his loss of fund? Also, setting parameters to 0s can prevent the front running. So, I think that this front running is no any meaning.\nI believe that judges will make correct decision.\n\n**FastTiger777**\n\nAs a result, LPs cannot add liquidity, The bootstrap function of the protocol is destroyed and serious losses are incurred.\nI also believe that the judges will make the right decision.\n\n**kennedy1030**\n\nI think that you`d better provide a valid POC that show the loss of funds.\n\n**FastTiger777**\n\nThe sponsors also acknowledged that the bootstrap function be broken. Let's wait for the judges' decision.\n\n**Evert0x**\n\nResult:\nHigh\nUnique\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [zzykxx](https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/18/#issuecomment-2041378668): rejected\n\n**FastTiger777**\n\n@Evert0x , @cvetanovv , thank you for your work. I would also like to thank @zzykxx and @kennedy1030 for kindly reviewing my issue.\n\n**zzykxx**\n\n@Evert0x can you please explain your decision on why this is high severity and why is it not known? Even if this is considered valid, which I still don't understand why it should be, how can it be high severity given there's no loss of funds? \n\nThere's a section about the `takeOverPool()` function and why it exists in the [docs](https://goattrading.gitbook.io/goat/technical/functionality#takeover-function) as well.\n\n**FastTiger777**\n\nThis is because the bootstrap function, a core function of the protocol, is destroyed.\n\n**zzykxx**\n\n> This is because the bootstrap function, a core function of the protocol, is destroyed.\n\nFrom the [docs](https://goattrading.gitbook.io/goat/technical/functionality#takeover-function) about `takeOverPool()`:\n\n> This function exists to avoid griefing. Because only one pool can be created for each token (since we only allow a token to be matched with Weth for simplicity’s sake), and that one pool has settings that could affect its performance, there are possible scenarios where a griefer starts a pool that has bad settings to block someone from creating a useful pool.\nThe griefer could, for example, set the pool so that 1 token is worth 100 virtual Ether and they want to raise 100 Ether. No one would buy the token at this price, and the pool would never be able to turn into an unrestricted AMM.\n\n\n**Evert0x**\n\nIt's not a known issue because it isn't listed in the known issues section of the README. \n\nHowever, I believe it should actually be Medium instead of High. As the following language fits the impact the best.\n\n> **V. How to identify a medium issue:**\n> **Breaks core contract functionality**, rendering the contract useless or leading to loss of funds.\n\n**FastTiger777**\n\nAs mentioned before, the bootstrap function, a core function of the protocol, is destroyed. Therefore the initial LP has to pay an amount of ETH equivalent to bootstrapETH. As a result, this leads the loss of fund of the initial LP, so I think this is considerred to high. @Evert0x , @cvetanovv , could you please check this issue again?\n\n**FastTiger777**\n\nI think it is high issue: I think this is more suitable.\n\n> In sherlock docs \nIV. How to identify a high issue:\nDefinite loss of funds without (extensive) limitations of external conditions.\n\n @Evert0x , @cvetanovv , could you please check this issue again?\n\n**FastTiger777**\n\nDue to the bootstrap function, LPs can provide liquidity even without a sufficient amount of ETH. However, because this feature is destroyed, the initial LP has to pay more funds. This results in a loss of funds for the initial LP. Therefore, I believe that this issue should be considered high.\n\n**adamidarrha**\n\n@Evert0x @FastTiger777 @zzykxx @kennedy1030, I recommend making this issue a low severity one.\n\nThe discussion has been quite scattered, so let's focus on the main points:\n\n1. Main Issue in Report: Watson highlighted that the `addLiquidity` function in the router reverts if initialETH is not specified as bootstrapETH. This is the only issue clearly identified in his report. and also he brushed up on frontrunning this transaction which could be done with this issue or not. Everything else was brought up in subsequent discussions.\n\n2. Frontrunning Concern: The discussion touched on the potential for someone to frontrun a deployer of a pair by creating it themselves. However, this is a well-known scenario within the protocol. The explicit purpose of the takeOverPool function, as zzykxx pointed out, addresses this. This is not a new issue and similar issues have been raised in this contest and were invalidated. Therefore, to be impartial any discussions about frontrunning should not impact the validity of the current issue.\n\n3. Recommendation: The recommendation by Watson states that createPair should only be called from the router, which wont solve the first issue, and it wont solve frontrunning , because anybody can call `GoatV1Router:addLiquidity` which calls createPair.\n\nGiven these clarifications, there is no significant impact for the issue presented by the current report, especially considering the known frontrunning strategy handled by takeOverPool. Thus, this issue should be low/informational.\n\n**FastTiger777**\n\nHi, @adamidarrha , It seems that the discussion on the issue is quite off.\n\n> Main Issue in Report: Watson highlighted that the addLiquidity function in the router reverts if initialETH is not specified as bootstrapETH. This is the only issue clearly identified in his report. and also he brushed up on frontrunning this transaction which could be done with this issue or not. Everything else was brought up in subsequent discussions.\n\nThe first problem you mentioned is not the basic point of the problem I raised.\nAlso the reason the addLiquidity() function is returned is directly related to the front running attack using createPair(), and as emphasized several times before, the pool argument using takeOverPool() cannot prevent DOS that occurs in the addLiquidity() function. Additionally, the problem of designating the initial ETH as bootstrapETH that you mentioned is a feature that the protocol team is specifically trying to implement, unlike other DEXs (Uniswap, Shushiswap, etc), and is a core function of this protocol. In other words, this problem is valid because the core function of this protocol is damaged.\n\n**adamidarrha**\n\n@FastTiger777 , I understand the issue you highlighted in the report where `addLiquidity` fails if `initialETH` is less than `bootstrapETH`. because initialTokenMatch being sent to `GoatV1Pair` instead of  `tokenAmtForPresale + tokenAmtForAmm`, which then causes the mint function in `GoatV1Pair` to revert. However, this does not constitute a denial of service (DOS) as it affects only that specific transaction. The deployer can resolve this by transferring the difference then calling mint so it matches the required sum, thereby allowing the transaction to succeed. this doesn't qualify for a DOS because of only reverting that transaction. If you believe that this warants a medium severity, could you please provide an attack path of how there can be a DOS.\n\n**FastTiger777**\n\n> The deployer can resolve this by transferring the difference then calling mint so it matches the required sum, thereby allowing the transaction to succeed. this doesn't qualify for a DOS because of only reverting that transaction. If you believe that this warants a medium severity, could you please provide an attack path of how there can be a DOS.\n\nAs you mentioned, for the transaction to succeed, the LP must transfer an amount of ETH equivalent to bootstraETH. This is the basic point of what you mentioned. However, the reason I emphasize this problem is that sending the required amount of ETH destroys the bootstrap function, which is the core function of this protocol. Please check the DOC and entire code base again.\n\nDOC:\n\n> For teams:\nWhen creating our MVP, inedibleX, we faced problems with teams not being able to create multiple pools because of a lack of Ether to match their tokens for a new pool, and new tokens being immediately sniped and dumped when they had inadequate liquidity, leading to a crash in the charts and death of the token.\nThe solution for both of these problems was the same: allow a pool to be created without any matching Ether liquidity, and use natural market movements of the token to generate the Ether required for a traditional liquidity pool. This creates a product that allows a sale to generate funds for the pool to occur while users enjoy trading as they would on any other token.\nTeams can now, whether creating their very first token pool or adding to one of their many on different chains, launch a pool with 0 Ether while providing the same experience to which users are accustomed.\n\n**adamidarrha**\n\n@FastTiger777, there's no need to transfer bootstrapETH. if you don't give bootstrapETH then `GoatV1Router:addLiquidity` call will revert. However, the deployer can directly call `GoatV1Pair:mint` with the correct amount of tokens to ensure success, as previously mentioned.\n\n@Evert0x, this issue describes a scenario where a transaction to `GoatV1Router:addLiquidity` reverts under specific conditions: namely, when a pool isn't deployed and the initial deployer opts to provide initialETH less than bootstrapETH. The router is merely a contract implementing safety checks, and a reverting transaction here does not signify a threat, as the user can simply execute `GoatV1Pair:mint` directly.\n\nAccording to Sherlock documentation, medium severity requires:\n\n- Constrained loss of funds ❌\n- Break in core protocol functionality ❌\n\nthe issue doesn't result in a loss of funds, nor breaks any functionality so It has no real impact and should therefore be classified as low severity.\n\ni can provide POC if needed. \n\n**FastTiger777**\n\nCalling `GoatV1Pair:mint` directly is not a preferred manipulation of the protocol, but a kind of attack. Think about it carefully.\nIf a pool does not initially exist, the protocol prefers to create a pool in addLiquidity().\n\n**FastTiger777**\n\n@Evert0x , as a result, I think it should be set high.\n\n**adamidarrha**\n\n@FastTiger777 the point is there is no impact of the issue that you stated. it can just be bypassed by directly calling mint, so it should be low unless you specify an attack path for it to warant a medium.\n\n**FastTiger777**\n\nIn the report, I clearly mentioned that the bootsrtap function of the protocol is damaged due to front running attacks, and I think this has already been discussed accurately previously.\nDiscussions on this have already progressed sufficiently, so I believe the judges will make the right decision.\n\n**adamidarrha**\n\n@FastTiger777 we will let the judge decide, i can also provide a poc to show why it's low impact\n\n**FastTiger777**\n\nWhat is clear is that core functionality of the protocol is broken.\n\n> According to Sherlock documentation, medium severity requires:\n\n> Constrained loss of funds \n> Break in core protocol functionality \n\nTherefore, this problem meets the above conditions.\n\n> In sherlock docs\nIV. How to identify a high issue:\nDefinite loss of funds without (extensive) limitations of external conditions.\n\nAlso, when creating any pool, the core functionality of the protocol is damaged due to front running attacks, and as a result, initial LPs always pay more funds, so this is always a loss from the LP's perspective. Therefore, this issue meets the above high condition.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/178",
  "Code": [
    {
      "filename": "goat-trading/contracts/exchange/GoatV1Factory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {GoatV1Pair} from \"./GoatV1Pair.sol\";\nimport {GoatTypes} from \"../library/GoatTypes.sol\";\nimport {GoatErrors} from \"../library/GoatErrors.sol\";\n\n/**\n * @title Goat Trading Factory\n * @notice Factory contract for creating Goat Trading Pair contracts.\n * @dev This contract is used to create Goat Trading Pair contracts.\n * @author Goat Trading -- Chiranjibi Poudyal, Robert M.C. Forster\n */\ncontract GoatV1Factory {\n    address public immutable weth;\n    string private baseName;\n    address public treasury;\n    address public pendingTreasury;\n    mapping(address => address) public pools;\n    uint256 public minimumCollectableFees = 0.1 ether;\n\n    event PairCreated(address indexed weth, address indexed token, address pair);\n    event PairRemoved(address indexed token, address pair);\n\n    constructor(address _weth) {\n        weth = _weth;\n        baseName = IERC20Metadata(_weth).name();\n        treasury = msg.sender;\n    }\n\n    function createPair(address token, GoatTypes.InitParams memory params) external returns (address) {\n        // @note is there a need to have minimum values for theser params so it can't be frontrun?\n        if (params.bootstrapEth == 0 || params.virtualEth == 0 || params.initialTokenMatch == 0) {\n            revert GoatErrors.InvalidParams();\n        }\n        if (pools[token] != address(0)) {\n            revert GoatErrors.PairExists();\n        }\n        if (token == weth) {\n            revert GoatErrors.CannnotPairWithBaseAsset();\n        }\n        GoatV1Pair pair = new GoatV1Pair();\n        pair.initialize(token, weth, baseName, params);\n        pools[token] = address(pair);\n        emit PairCreated(token, weth, address(pair));\n        return address(pair);\n    }\n\n    function removePair(address token) external {\n        address pair = pools[token];\n        if (msg.sender != pair) {\n            revert GoatErrors.Forbidden();\n        }\n        delete pools[token];\n\n        emit PairRemoved(token, pair);\n    }\n\n    function getPool(address token) external view returns (address) {\n        return pools[token];\n    }\n\n    function setTreasury(address _pendingTreasury) external {\n        if (msg.sender != treasury) {\n            revert GoatErrors.Forbidden();\n        }\n        pendingTreasury = _pendingTreasury;\n    }\n\n    function acceptTreasury() external {\n        if (msg.sender != pendingTreasury) {\n            revert GoatErrors.Forbidden();\n        }\n        pendingTreasury = address(0);\n        treasury = msg.sender;\n    }\n\n    function setFeeToTreasury(uint256 _minimumCollectibleFees) external {\n        if (msg.sender != treasury) {\n            revert GoatErrors.Forbidden();\n        }\n        minimumCollectableFees = _minimumCollectibleFees;\n    }\n}"
    },
    {
      "filename": "goat-trading/contracts/periphery/GoatRouterV1.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// library imports\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n// local imports\nimport {GoatTypes} from \"../library/GoatTypes.sol\";\nimport {GoatV1Factory} from \"../exchange/GoatV1Factory.sol\";\nimport {GoatV1Pair} from \"../exchange/GoatV1Pair.sol\";\nimport {GoatErrors} from \"../library/GoatErrors.sol\";\nimport {GoatLibrary} from \"../library/GoatLibrary.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\n\n/**\n * @title Goat V1 Router\n * @notice Router for stateless execution of swaps and liquidity provision\n * @dev This contract is used for adding/removing liquidity, swapping tokens and withdrawing fees\n * @dev This contract is stateless and does not store any data\n * @author Goat Trading -- Chiranjibi Poudyal, Robert M.C. Forster\n */\ncontract GoatV1Router is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    address public immutable FACTORY;\n    address public immutable WETH;\n    uint32 private constant MAX_UINT32 = type(uint32).max;\n    uint8 private constant ZERO = 0;\n\n    modifier ensure(uint256 deadline) {\n        if (block.timestamp > deadline) {\n            revert GoatErrors.Expired();\n        }\n        _;\n    }\n\n    constructor(address factory, address weth) {\n        FACTORY = factory;\n        WETH = weth;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n\n    function addLiquidity(\n        address token,\n        uint256 tokenDesired,\n        uint256 wethDesired,\n        uint256 tokenMin,\n        uint256 wethMin,\n        address to,\n        uint256 deadline,\n        GoatTypes.InitParams memory initParams\n    ) external nonReentrant ensure(deadline) returns (uint256, uint256, uint256) {\n        GoatTypes.LocalVariables_AddLiquidity memory vars = _ensurePoolAndPrepareLiqudityParameters(\n            token, tokenDesired, wethDesired, tokenMin, wethMin, initParams, false\n        );\n\n        IERC20(vars.token).safeTransferFrom(msg.sender, vars.pair, vars.actualTokenAmount);\n        if (vars.wethAmount != 0) {\n            IERC20(WETH).safeTransferFrom(msg.sender, vars.pair, vars.wethAmount);\n        }\n        vars.liquidity = GoatV1Pair(vars.pair).mint(to);\n        if (vars.isNewPair) {\n            vars.wethAmount =\n                initParams.bootstrapEth == initParams.initialEth ? initParams.initialEth : initParams.virtualEth;\n        }\n        return (vars.tokenAmount, vars.wethAmount, vars.liquidity);\n    }\n\n    function addLiquidityETH(\n        address token,\n        uint256 tokenDesired,\n        uint256 tokenMin,\n        uint256 ethMin,\n        address to,\n        uint256 deadline,\n        GoatTypes.InitParams memory initParams\n    ) external payable ensure(deadline) returns (uint256, uint256, uint256) {\n        GoatTypes.LocalVariables_AddLiquidity memory vars =\n            _ensurePoolAndPrepareLiqudityParameters(token, tokenDesired, msg.value, tokenMin, ethMin, initParams, true);\n        IERC20(token).safeTransferFrom(msg.sender, vars.pair, vars.actualTokenAmount);\n        if (vars.wethAmount != 0) {\n            IWETH(WETH).deposit{value: vars.wethAmount}();\n            IERC20(WETH).safeTransfer(vars.pair, vars.wethAmount);\n        }\n\n        vars.liquidity = GoatV1Pair(vars.pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > vars.wethAmount) {\n            (bool success,) = payable(msg.sender).call{value: msg.value - vars.wethAmount}(\"\");\n            if (!success) {\n                revert GoatErrors.EthTransferFailed();\n            }\n        }\n\n        if (vars.isNewPair) {\n            vars.wethAmount =\n                initParams.bootstrapEth == initParams.initialEth ? initParams.initialEth : initParams.virtualEth;\n        }\n        return (vars.tokenAmount, vars.wethAmount, vars.liquidity);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address token,\n        uint256 liquidity,\n        uint256 tokenMin,\n        uint256 wethMin,\n        address to,\n        uint256 deadline\n    ) public nonReentrant ensure(deadline) returns (uint256 amountWeth, uint256 amountToken) {\n        address pair = GoatV1Factory(FACTORY).getPool(token);\n\n        IERC20(pair).safeTransferFrom(msg.sender, pair, liquidity);\n        (amountWeth, amountToken) = GoatV1Pair(pair).burn(to);\n        if (amountWeth < wethMin) {\n            revert GoatErrors.InsufficientWethAmount();\n        }\n        if (amountToken < tokenMin) {\n            revert GoatErrors.InsufficientTokenAmount();\n        }\n    }\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 tokenMin,\n        uint256 ethMin,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256 amountWeth, uint256 amountToken) {\n        (amountWeth, amountToken) = removeLiquidity(token, liquidity, tokenMin, ethMin, address(this), deadline);\n        IERC20(token).safeTransfer(to, amountToken);\n        IWETH(WETH).withdraw(amountWeth);\n        (bool success,) = to.call{value: amountWeth}(\"\");\n        if (!success) {\n            revert GoatErrors.EthTransferFailed();\n        }\n    }\n\n    /* ----------------------------- SWAP FUNCTIONS ----------------------------- */\n    function swapWethForExactTokens(uint256 amountIn, uint256 amountOutMin, address token, address to, uint256 deadline)\n        external\n        ensure(deadline)\n        nonReentrant\n        returns (uint256 amountTokenOut)\n    {\n        GoatV1Pair pair;\n        (amountTokenOut, pair) = _getAmountTokenOut(amountIn, amountOutMin, token);\n        IERC20(WETH).safeTransferFrom(msg.sender, address(pair), amountIn);\n        pair.swap(amountTokenOut, ZERO, to);\n    }\n\n    function swapExactETHForTokens(uint256 amountOutMin, address token, address to, uint256 deadline)\n        external\n        payable\n        ensure(deadline)\n        nonReentrant\n        returns (uint256 amountTokenOut)\n    {\n        GoatV1Pair pair;\n        (amountTokenOut, pair) = _getAmountTokenOut(msg.value, amountOutMin, token);\n        IWETH(WETH).deposit{value: msg.value}();\n        IERC20(WETH).safeTransfer(address(pair), msg.value);\n        pair.swap(amountTokenOut, 0, to);\n    }\n\n    function swapExactTokensForWeth(uint256 amountIn, uint256 amountOutMin, address token, address to, uint256 deadline)\n        public\n        ensure(deadline)\n        nonReentrant\n        returns (uint256 amountWethOut)\n    {\n        if (amountIn == 0) {\n            revert GoatErrors.InsufficientInputAmount();\n        }\n\n        GoatTypes.LocalVariables_PairStateInfo memory vars;\n        GoatV1Pair pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n        if (pair == GoatV1Pair(address(0))) {\n            revert GoatErrors.GoatPoolDoesNotExist();\n        }\n        if (pair.vestingUntil() != type(uint32).max) {\n            (uint112 reserveEth, uint112 reserveToken) = pair.getStateInfoAmm();\n            amountWethOut = GoatLibrary.getWethAmountOutAmm(amountIn, reserveEth, reserveToken);\n        } else {\n            (vars.reserveEth, vars.reserveToken, vars.virtualEth,,, vars.virtualToken) = pair.getStateInfoForPresale();\n\n            amountWethOut = GoatLibrary.getWethAmountOutPresale(\n                amountIn, vars.reserveEth, vars.reserveToken, vars.virtualEth, vars.virtualToken\n            );\n        }\n\n        if (amountWethOut < amountOutMin) {\n            revert GoatErrors.InsufficientAmountOut();\n        }\n        IERC20(token).safeTransferFrom(msg.sender, address(pair), amountIn);\n        pair.swap(0, amountWethOut, to);\n    }\n\n    /* ------------------------------ WITHDRAW FEES ----------------------------- */\n    function withdrawFees(address token, address to) external nonReentrant {\n        if (to == address(0)) {\n            revert GoatErrors.ZeroAddress();\n        }\n        GoatV1Pair pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n\n        if (address(pair) == address(0)) {\n            revert GoatErrors.GoatPoolDoesNotExist();\n        }\n        pair.withdrawFees(to);\n    }\n\n    /* ----------------------------- PUBLIC VIEW FUNCTIONS ----------------------------- */\n\n    function getActualBootstrapTokenAmount(\n        uint256 virtualEth,\n        uint256 bootstrapEth,\n        uint256 initialEth,\n        uint256 initialTokenMatch\n    ) public pure returns (uint256 actualTokenAmount) {\n        return GoatLibrary.getActualBootstrapTokenAmount(virtualEth, bootstrapEth, initialEth, initialTokenMatch);\n    }\n\n    /* --------------------------- INTERNAL FUNCTIONS --------------------------- */\n    function _addLiquidity(\n        address token,\n        uint256 tokenDesired,\n        uint256 wethDesired,\n        uint256 tokenMin,\n        uint256 wethMin,\n        GoatTypes.InitParams memory initParams\n    ) internal returns (uint256, uint256, bool) {\n        GoatTypes.LocalVariables_AddLiquidity memory vars;\n        GoatV1Pair pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n        if (address(pair) == address(0)) {\n            // First time liquidity provider\n            pair = GoatV1Pair(GoatV1Factory(FACTORY).createPair(token, initParams));\n            vars.isNewPair = true;\n        }\n\n        if (vars.isNewPair) {\n            if (initParams.initialEth < initParams.bootstrapEth) {\n                /**\n                 * @dev if it's a first mint and pool is not directly converting to AMM,\n                 * initialTokenMatch and virtualEth is used for liquidity calculation\n                 */\n                (vars.tokenAmount, vars.wethAmount) = (initParams.initialTokenMatch, initParams.virtualEth);\n            } else {\n                vars.actualTokenAmount = GoatLibrary.getBootstrapTokenAmountForAmm(\n                    initParams.virtualEth, initParams.bootstrapEth, initParams.initialTokenMatch\n                );\n                /**\n                 * @dev if it's a first mint and pool is directly converting to AMM,\n                 * actual calculated token amount and real weth is used for liquidity calculation\n                 */\n                (vars.tokenAmount, vars.wethAmount) = (vars.actualTokenAmount, initParams.initialEth);\n            }\n        } else {\n            /**\n             * @dev This block is accessed after the presale period is over and the pool is converted to AMM\n             */\n            (uint256 wethReserve, uint256 tokenReserve) = pair.getReserves();\n            uint256 tokenAmountOptimal = GoatLibrary.quote(wethDesired, wethReserve, tokenReserve);\n            if (tokenAmountOptimal <= tokenDesired) {\n                if (tokenAmountOptimal < tokenMin) {\n                    revert GoatErrors.InsufficientTokenAmount();\n                }\n                (vars.tokenAmount, vars.wethAmount) = (tokenAmountOptimal, wethDesired);\n            } else {\n                uint256 wethAmountOptimal = GoatLibrary.quote(tokenDesired, tokenReserve, wethReserve);\n                assert(wethAmountOptimal <= wethDesired);\n                if (wethAmountOptimal < wethMin) revert GoatErrors.InsufficientWethAmount();\n                (vars.tokenAmount, vars.wethAmount) = (tokenDesired, wethAmountOptimal);\n            }\n        }\n        return (vars.tokenAmount, vars.wethAmount, vars.isNewPair);\n    }\n\n    function _ensurePoolAndPrepareLiqudityParameters(\n        address token,\n        uint256 tokenDesired,\n        uint256 wethDesired,\n        uint256 tokenMin,\n        uint256 wethMin,\n        GoatTypes.InitParams memory initParams,\n        bool isEth\n    ) internal returns (GoatTypes.LocalVariables_AddLiquidity memory vars) {\n        if (token == WETH || token == address(0)) {\n            revert GoatErrors.WrongToken();\n        }\n        vars.token = token;\n        (vars.tokenAmount, vars.wethAmount, vars.isNewPair) =\n            _addLiquidity(token, tokenDesired, wethDesired, tokenMin, wethMin, initParams);\n\n        if (vars.isNewPair) {\n            // only for the first time\n            vars.wethAmount = Math.min(initParams.initialEth, initParams.bootstrapEth);\n            vars.actualTokenAmount = GoatLibrary.getActualBootstrapTokenAmount(\n                initParams.virtualEth, initParams.bootstrapEth, vars.wethAmount, initParams.initialTokenMatch\n            );\n        } else {\n            vars.actualTokenAmount = vars.tokenAmount;\n        }\n        if (isEth && wethDesired != vars.wethAmount) {\n            revert GoatErrors.InvalidEthAmount();\n        }\n        vars.pair = GoatV1Factory(FACTORY).getPool(vars.token);\n    }\n\n    function _getAmountTokenOut(uint256 amountIn, uint256 amountOutMin, address token)\n        internal\n        view\n        returns (uint256 amountTokenOut, GoatV1Pair pair)\n    {\n        if (amountIn == 0) {\n            revert GoatErrors.InsufficientInputAmount();\n        }\n        GoatTypes.LocalVariables_PairStateInfo memory vars;\n        pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n        if (address(pair) == address(0)) {\n            revert GoatErrors.GoatPoolDoesNotExist();\n        }\n        if (pair.vestingUntil() != MAX_UINT32) {\n            /**\n             * @dev If pool is not in presale period, then it's in AMM mode\n             * Normal amountOut calculation is done with real reserves\n             */\n            (uint112 reserveEth, uint112 reserveToken) = pair.getStateInfoAmm();\n            amountTokenOut = GoatLibrary.getTokenAmountOutAmm(amountIn, reserveEth, reserveToken);\n        } else {\n            /**\n             * @dev If pool is in presale period,\n             * amountOut calculation is done with inflated reserves and initParams\n             */\n            (\n                vars.reserveEth,\n                vars.reserveToken,\n                vars.virtualEth,\n                vars.initialTokenMatch,\n                vars.bootstrapEth,\n                vars.virtualToken\n            ) = pair.getStateInfoForPresale();\n\n            uint256 tokenAmountForAmm =\n                GoatLibrary.getBootstrapTokenAmountForAmm(vars.virtualEth, vars.bootstrapEth, vars.initialTokenMatch);\n            amountTokenOut = GoatLibrary.getTokenAmountOutPresale(\n                amountIn,\n                vars.virtualEth,\n                vars.reserveEth,\n                vars.bootstrapEth,\n                vars.reserveToken,\n                vars.virtualToken,\n                tokenAmountForAmm\n            );\n        }\n        if (amountTokenOut < amountOutMin) {\n            revert GoatErrors.InsufficientAmountOut();\n        }\n    }\n}"
    },
    {
      "filename": "goat-trading/contracts/periphery/GoatRouterV1.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// library imports\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n// local imports\nimport {GoatTypes} from \"../library/GoatTypes.sol\";\nimport {GoatV1Factory} from \"../exchange/GoatV1Factory.sol\";\nimport {GoatV1Pair} from \"../exchange/GoatV1Pair.sol\";\nimport {GoatErrors} from \"../library/GoatErrors.sol\";\nimport {GoatLibrary} from \"../library/GoatLibrary.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\n\n/**\n * @title Goat V1 Router\n * @notice Router for stateless execution of swaps and liquidity provision\n * @dev This contract is used for adding/removing liquidity, swapping tokens and withdrawing fees\n * @dev This contract is stateless and does not store any data\n * @author Goat Trading -- Chiranjibi Poudyal, Robert M.C. Forster\n */\ncontract GoatV1Router is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    address public immutable FACTORY;\n    address public immutable WETH;\n    uint32 private constant MAX_UINT32 = type(uint32).max;\n    uint8 private constant ZERO = 0;\n\n    modifier ensure(uint256 deadline) {\n        if (block.timestamp > deadline) {\n            revert GoatErrors.Expired();\n        }\n        _;\n    }\n\n    constructor(address factory, address weth) {\n        FACTORY = factory;\n        WETH = weth;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n\n    function addLiquidity(\n        address token,\n        uint256 tokenDesired,\n        uint256 wethDesired,\n        uint256 tokenMin,\n        uint256 wethMin,\n        address to,\n        uint256 deadline,\n        GoatTypes.InitParams memory initParams\n    ) external nonReentrant ensure(deadline) returns (uint256, uint256, uint256) {\n        GoatTypes.LocalVariables_AddLiquidity memory vars = _ensurePoolAndPrepareLiqudityParameters(\n            token, tokenDesired, wethDesired, tokenMin, wethMin, initParams, false\n        );\n\n        IERC20(vars.token).safeTransferFrom(msg.sender, vars.pair, vars.actualTokenAmount);\n        if (vars.wethAmount != 0) {\n            IERC20(WETH).safeTransferFrom(msg.sender, vars.pair, vars.wethAmount);\n        }\n        vars.liquidity = GoatV1Pair(vars.pair).mint(to);\n        if (vars.isNewPair) {\n            vars.wethAmount =\n                initParams.bootstrapEth == initParams.initialEth ? initParams.initialEth : initParams.virtualEth;\n        }\n        return (vars.tokenAmount, vars.wethAmount, vars.liquidity);\n    }\n\n    function addLiquidityETH(\n        address token,\n        uint256 tokenDesired,\n        uint256 tokenMin,\n        uint256 ethMin,\n        address to,\n        uint256 deadline,\n        GoatTypes.InitParams memory initParams\n    ) external payable ensure(deadline) returns (uint256, uint256, uint256) {\n        GoatTypes.LocalVariables_AddLiquidity memory vars =\n            _ensurePoolAndPrepareLiqudityParameters(token, tokenDesired, msg.value, tokenMin, ethMin, initParams, true);\n        IERC20(token).safeTransferFrom(msg.sender, vars.pair, vars.actualTokenAmount);\n        if (vars.wethAmount != 0) {\n            IWETH(WETH).deposit{value: vars.wethAmount}();\n            IERC20(WETH).safeTransfer(vars.pair, vars.wethAmount);\n        }\n\n        vars.liquidity = GoatV1Pair(vars.pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > vars.wethAmount) {\n            (bool success,) = payable(msg.sender).call{value: msg.value - vars.wethAmount}(\"\");\n            if (!success) {\n                revert GoatErrors.EthTransferFailed();\n            }\n        }\n\n        if (vars.isNewPair) {\n            vars.wethAmount =\n                initParams.bootstrapEth == initParams.initialEth ? initParams.initialEth : initParams.virtualEth;\n        }\n        return (vars.tokenAmount, vars.wethAmount, vars.liquidity);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address token,\n        uint256 liquidity,\n        uint256 tokenMin,\n        uint256 wethMin,\n        address to,\n        uint256 deadline\n    ) public nonReentrant ensure(deadline) returns (uint256 amountWeth, uint256 amountToken) {\n        address pair = GoatV1Factory(FACTORY).getPool(token);\n\n        IERC20(pair).safeTransferFrom(msg.sender, pair, liquidity);\n        (amountWeth, amountToken) = GoatV1Pair(pair).burn(to);\n        if (amountWeth < wethMin) {\n            revert GoatErrors.InsufficientWethAmount();\n        }\n        if (amountToken < tokenMin) {\n            revert GoatErrors.InsufficientTokenAmount();\n        }\n    }\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 tokenMin,\n        uint256 ethMin,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256 amountWeth, uint256 amountToken) {\n        (amountWeth, amountToken) = removeLiquidity(token, liquidity, tokenMin, ethMin, address(this), deadline);\n        IERC20(token).safeTransfer(to, amountToken);\n        IWETH(WETH).withdraw(amountWeth);\n        (bool success,) = to.call{value: amountWeth}(\"\");\n        if (!success) {\n            revert GoatErrors.EthTransferFailed();\n        }\n    }\n\n    /* ----------------------------- SWAP FUNCTIONS ----------------------------- */\n    function swapWethForExactTokens(uint256 amountIn, uint256 amountOutMin, address token, address to, uint256 deadline)\n        external\n        ensure(deadline)\n        nonReentrant\n        returns (uint256 amountTokenOut)\n    {\n        GoatV1Pair pair;\n        (amountTokenOut, pair) = _getAmountTokenOut(amountIn, amountOutMin, token);\n        IERC20(WETH).safeTransferFrom(msg.sender, address(pair), amountIn);\n        pair.swap(amountTokenOut, ZERO, to);\n    }\n\n    function swapExactETHForTokens(uint256 amountOutMin, address token, address to, uint256 deadline)\n        external\n        payable\n        ensure(deadline)\n        nonReentrant\n        returns (uint256 amountTokenOut)\n    {\n        GoatV1Pair pair;\n        (amountTokenOut, pair) = _getAmountTokenOut(msg.value, amountOutMin, token);\n        IWETH(WETH).deposit{value: msg.value}();\n        IERC20(WETH).safeTransfer(address(pair), msg.value);\n        pair.swap(amountTokenOut, 0, to);\n    }\n\n    function swapExactTokensForWeth(uint256 amountIn, uint256 amountOutMin, address token, address to, uint256 deadline)\n        public\n        ensure(deadline)\n        nonReentrant\n        returns (uint256 amountWethOut)\n    {\n        if (amountIn == 0) {\n            revert GoatErrors.InsufficientInputAmount();\n        }\n\n        GoatTypes.LocalVariables_PairStateInfo memory vars;\n        GoatV1Pair pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n        if (pair == GoatV1Pair(address(0))) {\n            revert GoatErrors.GoatPoolDoesNotExist();\n        }\n        if (pair.vestingUntil() != type(uint32).max) {\n            (uint112 reserveEth, uint112 reserveToken) = pair.getStateInfoAmm();\n            amountWethOut = GoatLibrary.getWethAmountOutAmm(amountIn, reserveEth, reserveToken);\n        } else {\n            (vars.reserveEth, vars.reserveToken, vars.virtualEth,,, vars.virtualToken) = pair.getStateInfoForPresale();\n\n            amountWethOut = GoatLibrary.getWethAmountOutPresale(\n                amountIn, vars.reserveEth, vars.reserveToken, vars.virtualEth, vars.virtualToken\n            );\n        }\n\n        if (amountWethOut < amountOutMin) {\n            revert GoatErrors.InsufficientAmountOut();\n        }\n        IERC20(token).safeTransferFrom(msg.sender, address(pair), amountIn);\n        pair.swap(0, amountWethOut, to);\n    }\n\n    /* ------------------------------ WITHDRAW FEES ----------------------------- */\n    function withdrawFees(address token, address to) external nonReentrant {\n        if (to == address(0)) {\n            revert GoatErrors.ZeroAddress();\n        }\n        GoatV1Pair pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n\n        if (address(pair) == address(0)) {\n            revert GoatErrors.GoatPoolDoesNotExist();\n        }\n        pair.withdrawFees(to);\n    }\n\n    /* ----------------------------- PUBLIC VIEW FUNCTIONS ----------------------------- */\n\n    function getActualBootstrapTokenAmount(\n        uint256 virtualEth,\n        uint256 bootstrapEth,\n        uint256 initialEth,\n        uint256 initialTokenMatch\n    ) public pure returns (uint256 actualTokenAmount) {\n        return GoatLibrary.getActualBootstrapTokenAmount(virtualEth, bootstrapEth, initialEth, initialTokenMatch);\n    }\n\n    /* --------------------------- INTERNAL FUNCTIONS --------------------------- */\n    function _addLiquidity(\n        address token,\n        uint256 tokenDesired,\n        uint256 wethDesired,\n        uint256 tokenMin,\n        uint256 wethMin,\n        GoatTypes.InitParams memory initParams\n    ) internal returns (uint256, uint256, bool) {\n        GoatTypes.LocalVariables_AddLiquidity memory vars;\n        GoatV1Pair pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n        if (address(pair) == address(0)) {\n            // First time liquidity provider\n            pair = GoatV1Pair(GoatV1Factory(FACTORY).createPair(token, initParams));\n            vars.isNewPair = true;\n        }\n\n        if (vars.isNewPair) {\n            if (initParams.initialEth < initParams.bootstrapEth) {\n                /**\n                 * @dev if it's a first mint and pool is not directly converting to AMM,\n                 * initialTokenMatch and virtualEth is used for liquidity calculation\n                 */\n                (vars.tokenAmount, vars.wethAmount) = (initParams.initialTokenMatch, initParams.virtualEth);\n            } else {\n                vars.actualTokenAmount = GoatLibrary.getBootstrapTokenAmountForAmm(\n                    initParams.virtualEth, initParams.bootstrapEth, initParams.initialTokenMatch\n                );\n                /**\n                 * @dev if it's a first mint and pool is directly converting to AMM,\n                 * actual calculated token amount and real weth is used for liquidity calculation\n                 */\n                (vars.tokenAmount, vars.wethAmount) = (vars.actualTokenAmount, initParams.initialEth);\n            }\n        } else {\n            /**\n             * @dev This block is accessed after the presale period is over and the pool is converted to AMM\n             */\n            (uint256 wethReserve, uint256 tokenReserve) = pair.getReserves();\n            uint256 tokenAmountOptimal = GoatLibrary.quote(wethDesired, wethReserve, tokenReserve);\n            if (tokenAmountOptimal <= tokenDesired) {\n                if (tokenAmountOptimal < tokenMin) {\n                    revert GoatErrors.InsufficientTokenAmount();\n                }\n                (vars.tokenAmount, vars.wethAmount) = (tokenAmountOptimal, wethDesired);\n            } else {\n                uint256 wethAmountOptimal = GoatLibrary.quote(tokenDesired, tokenReserve, wethReserve);\n                assert(wethAmountOptimal <= wethDesired);\n                if (wethAmountOptimal < wethMin) revert GoatErrors.InsufficientWethAmount();\n                (vars.tokenAmount, vars.wethAmount) = (tokenDesired, wethAmountOptimal);\n            }\n        }\n        return (vars.tokenAmount, vars.wethAmount, vars.isNewPair);\n    }\n\n    function _ensurePoolAndPrepareLiqudityParameters(\n        address token,\n        uint256 tokenDesired,\n        uint256 wethDesired,\n        uint256 tokenMin,\n        uint256 wethMin,\n        GoatTypes.InitParams memory initParams,\n        bool isEth\n    ) internal returns (GoatTypes.LocalVariables_AddLiquidity memory vars) {\n        if (token == WETH || token == address(0)) {\n            revert GoatErrors.WrongToken();\n        }\n        vars.token = token;\n        (vars.tokenAmount, vars.wethAmount, vars.isNewPair) =\n            _addLiquidity(token, tokenDesired, wethDesired, tokenMin, wethMin, initParams);\n\n        if (vars.isNewPair) {\n            // only for the first time\n            vars.wethAmount = Math.min(initParams.initialEth, initParams.bootstrapEth);\n            vars.actualTokenAmount = GoatLibrary.getActualBootstrapTokenAmount(\n                initParams.virtualEth, initParams.bootstrapEth, vars.wethAmount, initParams.initialTokenMatch\n            );\n        } else {\n            vars.actualTokenAmount = vars.tokenAmount;\n        }\n        if (isEth && wethDesired != vars.wethAmount) {\n            revert GoatErrors.InvalidEthAmount();\n        }\n        vars.pair = GoatV1Factory(FACTORY).getPool(vars.token);\n    }\n\n    function _getAmountTokenOut(uint256 amountIn, uint256 amountOutMin, address token)\n        internal\n        view\n        returns (uint256 amountTokenOut, GoatV1Pair pair)\n    {\n        if (amountIn == 0) {\n            revert GoatErrors.InsufficientInputAmount();\n        }\n        GoatTypes.LocalVariables_PairStateInfo memory vars;\n        pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n        if (address(pair) == address(0)) {\n            revert GoatErrors.GoatPoolDoesNotExist();\n        }\n        if (pair.vestingUntil() != MAX_UINT32) {\n            /**\n             * @dev If pool is not in presale period, then it's in AMM mode\n             * Normal amountOut calculation is done with real reserves\n             */\n            (uint112 reserveEth, uint112 reserveToken) = pair.getStateInfoAmm();\n            amountTokenOut = GoatLibrary.getTokenAmountOutAmm(amountIn, reserveEth, reserveToken);\n        } else {\n            /**\n             * @dev If pool is in presale period,\n             * amountOut calculation is done with inflated reserves and initParams\n             */\n            (\n                vars.reserveEth,\n                vars.reserveToken,\n                vars.virtualEth,\n                vars.initialTokenMatch,\n                vars.bootstrapEth,\n                vars.virtualToken\n            ) = pair.getStateInfoForPresale();\n\n            uint256 tokenAmountForAmm =\n                GoatLibrary.getBootstrapTokenAmountForAmm(vars.virtualEth, vars.bootstrapEth, vars.initialTokenMatch);\n            amountTokenOut = GoatLibrary.getTokenAmountOutPresale(\n                amountIn,\n                vars.virtualEth,\n                vars.reserveEth,\n                vars.bootstrapEth,\n                vars.reserveToken,\n                vars.virtualToken,\n                tokenAmountForAmm\n            );\n        }\n        if (amountTokenOut < amountOutMin) {\n            revert GoatErrors.InsufficientAmountOut();\n        }\n    }\n}"
    },
    {
      "filename": "goat-trading/contracts/periphery/GoatRouterV1.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// library import"
    }
  ]
}