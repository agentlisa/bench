{
  "Title": "[G-08] `>=` costs less gas than `>`",
  "Content": "\nThe compiler uses opcodes for solidity code that uses `>`, but only requires for `>=`, which saves 3 gas.\n\n```solidity\nFile:  src/erc-4626/ERC4626MultiToken.sol\n252    if (share > shares) shares = share;\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/ERC4626MultiToken.sol#L52\n\n```solidity\nFile:  src/gauges/factories/BaseV2GaugeFactory.sol\n91     if (end > length) end = length;\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeFactory.sol#L252\n\n```solidity\nFile:     src/talos/boost-aggregator/BoostAggregator.sol\n93       if (_daoShare > max_dao_share) revert DaoShareTooHigh();\n\n99       if (_tail_emission > max_tail_emission) revert TailEmissionTooHigh();\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L93\n\n```solidity\nFile:    src/rewards/rewards/FlywheelGaugeRewards.sol\n120     if (currentCycle > nextCycle)\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelGaugeRewards.sol#L120\n\n```solidity\nFile:   /src/talos/base/TalosBaseStrategy.sol\n158    if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n219    if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n398    if (amount0 > _protocolFees0)\n\n401    if (amount1 > _protocolFees1)\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L158\n\n```solidity\nFile:   src/talos/factories/TalosBaseStrategyFactory.sol\n138     if (balance > assets)\n\n171     if (index > MAX_DESTINATIONS) revert TooManyDestinations();\n\n185     if (newTotalWeights > MAX_TOTAL_WEIGHT) revert InvalidWeight();\n\n243     if (totalWeights > MAX_TOTAL_WEIGHT || oldTotalWeights == newTotalWeights)\n\n252     if (oldTotalWeights > newTotalWeights)\n\n310     if (_fees.lambda1 > MAX_LAMBDA1) revert InvalidFee();\n\n315     if (_fees.sigma1 > DIVISIONER) revert InvalidFee();\n\n327     if (_protocolFee > MAX_PROTOCOL_FEE) revert InvalidFee();\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/factories/TalosBaseStrategyFactory.sol#L138\n\n```solidity\nFile: src/talos/TalosOptimizer.sol\n115   if (assetBalance > newAssetBalance)\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosOptimizer.sol#L47\n\n```solidity\nFile: /src/ulysses-omnichain/BranchBridgeAgent.sol\n1035    if (minExecCost > gasRemaining) \n\n1050    if (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD) \n\n1069    if (minExecCost > getDeposit[_depositNonce].depositedGas)\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1035\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-4626/ERC4626MultiToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IERC4626MultiToken} from \"./interfaces/IERC4626MultiToken.sol\";\n\n/// @title Minimal ERC4626 tokenized Vault multi asset implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract ERC4626MultiToken is ERC20, ReentrancyGuard, IERC4626MultiToken {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    address[] public assets;\n\n    /// @inheritdoc IERC4626MultiToken\n    uint256[] public weights;\n\n    /// @inheritdoc IERC4626MultiToken\n    mapping(address => uint256) public assetId;\n\n    /// @inheritdoc IERC4626MultiToken\n    uint256 public totalWeights;\n\n    /// @inheritdoc IERC4626MultiToken\n    function getAssets() external view returns (address[] memory) {\n        return assets;\n    }\n\n    constructor(address[] memory _assets, uint256[] memory _weights, string memory _name, string memory _symbol)\n        ERC20(_name, _symbol, 18)\n    {\n        assets = _assets;\n        weights = _weights;\n\n        uint256 length = _weights.length;\n        uint256 _totalWeights;\n\n        if (length != _assets.length || length == 0) revert InvalidLength();\n\n        for (uint256 i = 0; i < length;) {\n            require(ERC20(_assets[i]).decimals() == 18);\n            require(_weights[i] > 0);\n\n            _totalWeights += _weights[i];\n            assetId[_assets[i]] = i + 1;\n\n            emit AssetAdded(_assets[i], _weights[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n        totalWeights = _totalWeights;\n    }\n\n    function receiveAssets(uint256[] memory assetsAmounts) private {\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            assets[i].safeTransferFrom(msg.sender, address(this), assetsAmounts[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function sendAssets(uint256[] memory assetsAmounts, address receiver) private {\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            assets[i].safeTransfer(receiver, assetsAmounts[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function deposit(uint256[] calldata assetsAmounts, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assetsAmounts)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        receiveAssets(assetsAmounts);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assetsAmounts, shares);\n\n        afterDeposit(assetsAmounts, shares);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n        assetsAmounts = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        receiveAssets(assetsAmounts);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assetsAmounts, shares);\n\n        afterDeposit(assetsAmounts, shares);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function withdraw(uint256[] calldata assetsAmounts, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n        shares = previewWithdraw(assetsAmounts); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assetsAmounts, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assetsAmounts, shares);\n\n        sendAssets(assetsAmounts, receiver);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        assetsAmounts = previewRedeem(shares);\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            // Check for rounding error since we round down in previewRedeem.\n            if (assetsAmounts[i] == 0) revert ZeroAssets();\n            unchecked {\n                i++;\n            }\n        }\n\n        beforeWithdraw(assetsAmounts, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assetsAmounts, shares);\n\n        sendAssets(assetsAmounts, receiver);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    /// @inheritdoc IERC4626MultiToken\n    function convertToShares(uint256[] calldata assetsAmounts) public view virtual returns (uint256 shares) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assetsAmounts.length;\n\n        if (length != assets.length) revert InvalidLength();\n\n        shares = type(uint256).max;\n        for (uint256 i = 0; i < length;) {\n            uint256 share = assetsAmounts[i].mulDiv(_totalWeights, weights[i]);\n            if (share < shares) shares = share;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function convertToAssets(uint256 shares) public view virtual returns (uint256[] memory assetsAmounts) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assets.length;\n\n        assetsAmounts = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            assetsAmounts[i] = shares.mulDiv(weights[i], _totalWeights);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewDeposit(uint256[] calldata assetsAmounts) public view virtual returns (uint256) {\n        return convertToShares(assetsAmounts);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewMint(uint256 shares) public view virtual returns (uint256[] memory assetsAmounts) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assets.length;\n\n        assetsAmounts = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            assetsAmounts[i] = shares.mulDivUp(weights[i], _totalWeights);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewWithdraw(uint256[] calldata assetsAmounts) public view virtual returns (uint256 shares) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assetsAmounts.length;\n\n        if (length != assets.length) revert InvalidLength();\n\n        for (uint256 i = 0; i < length;) {\n            uint256 share = assetsAmounts[i].mulDivUp(_totalWeights, weights[i]);\n            if (share > shares) shares = share;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewRedeem(uint256 shares) public view virtual returns (uint256[] memory) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxWithdraw(address owner) public view virtual returns (uint256[] memory) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256[] memory assetsAmounts, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256[] memory assetsAmounts, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/gauges/factories/BaseV2GaugeFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\nimport {BaseV2Gauge} from \"@gauges/BaseV2Gauge.sol\";\n\nimport {BribesFactory} from \"./BribesFactory.sol\";\nimport {BaseV2GaugeManager} from \"./BaseV2GaugeManager.sol\";\n\nimport {IBaseV2GaugeFactory} from \"../interfaces/IBaseV2GaugeFactory.sol\";\n\n/// @title Base V2 Gauge Factory\nabstract contract BaseV2GaugeFactory is Ownable, IBaseV2GaugeFactory {\n    /*///////////////////////////////////////////////////////////////\n                            FACTORY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BaseV2GaugeManager public immutable override gaugeManager;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    bHermesBoost public immutable override bHermesBoostToken;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BribesFactory public immutable override bribesFactory;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BaseV2Gauge[] public override gauges;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(BaseV2Gauge => uint256) public override gaugeIds;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(BaseV2Gauge => bool) public override activeGauges;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(address => BaseV2Gauge) public override strategyGauges;\n\n    /**\n     * @notice Creates a new gauge factory\n     * @param _gaugeManager The gauge manager to use\n     * @param _bHermesBoost The bHermes boost token to use\n     * @param _bribesFactory The bribes factory to use\n     * @param _owner The owner of the factory\n     */\n    constructor(\n        BaseV2GaugeManager _gaugeManager,\n        bHermesBoost _bHermesBoost,\n        BribesFactory _bribesFactory,\n        address _owner\n    ) {\n        _initializeOwner(_owner);\n        bribesFactory = _bribesFactory;\n        bHermesBoostToken = _bHermesBoost;\n        gaugeManager = _gaugeManager;\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function getGauges() external view returns (BaseV2Gauge[] memory) {\n        return gauges;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         EPOCH LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function newEpoch() external {\n        BaseV2Gauge[] storage _gauges = gauges;\n\n        uint256 length = _gauges.length;\n        for (uint256 i = 0; i < length;) {\n            if (activeGauges[_gauges[i]]) _gauges[i].newEpoch();\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function newEpoch(uint256 start, uint256 end) external {\n        BaseV2Gauge[] storage _gauges = gauges;\n\n        uint256 length = _gauges.length;\n        if (end > length) end = length;\n\n        for (uint256 i = start; i < end;) {\n            if (activeGauges[_gauges[i]]) _gauges[i].newEpoch();\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         GAUGE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates a new gauge for the given strategy\n    /// @param strategy The strategy address to create a gauge for\n    /// @param data The information to pass to create a new gauge.\n    function createGauge(address strategy, bytes memory data) external onlyOwner {\n        if (address(strategyGauges[strategy]) != address(0)) revert GaugeAlreadyExists();\n\n        BaseV2Gauge gauge = newGauge(strategy, data);\n        strategyGauges[strategy] = gauge;\n\n        uint256 id = gauges.length;\n        gauges.push(gauge);\n        gaugeIds[gauge] = id;\n        activeGauges[gauge] = true;\n\n        gaugeManager.addGauge(address(gauge));\n\n        afterCreateGauge(strategy, data);\n    }\n\n    function afterCreateGauge(address strategy, bytes memory data) internal virtual;\n\n    function newGauge(address strategy, bytes memory data) internal virtual returns (BaseV2Gauge gauge);\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function removeGauge(BaseV2Gauge gauge) external onlyOwner {\n        if (!activeGauges[gauge] || gauges[gaugeIds[gauge]] != gauge) revert InvalidGauge();\n        delete gauges[gaugeIds[gauge]];\n        delete gaugeIds[gauge];\n        delete activeGauges[gauge];\n        delete strategyGauges[gauge.strategy()];\n        gaugeManager.removeGauge(address(gauge));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           BRIBE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function addBribeToGauge(BaseV2Gauge gauge, address bribeToken) external onlyOwnerOrBribesFactoryOwner {\n        if (!activeGauges[gauge]) revert InvalidGauge();\n        gauge.addBribeFlywheel(bribesFactory.flywheelTokens(bribeToken));\n        bribesFactory.addGaugetoFlywheel(address(gauge), bribeToken);\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function removeBribeFromGauge(BaseV2Gauge gauge, address bribeToken) external onlyOwnerOrBribesFactoryOwner {\n        if (!activeGauges[gauge]) revert InvalidGauge();\n        gauge.removeBribeFlywheel(bribesFactory.flywheelTokens(bribeToken));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    modifier onlyOwnerOrBribesFactoryOwner() {\n        if (msg.sender != bribesFactory.owner() && msg.sender != owner()) {\n            revert NotOwnerOrBribesFactoryOwner();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/talos/boost-aggregator/BoostAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\nimport {UniswapV3Staker} from \"@v3-staker/UniswapV3Staker.sol\";\n\nimport {IBoostAggregator} from \"../interfaces/IBoostAggregator.sol\";\n\n/// @title Boost Aggregator for Uniswap V3 NFTs\ncontract BoostAggregator is Ownable, IBoostAggregator {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                        BOOST AGGREGATOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    INonfungiblePositionManager public immutable nonfungiblePositionManager;\n\n    /// @inheritdoc IBoostAggregator\n    UniswapV3Staker public immutable uniswapV3Staker;\n\n    /// @inheritdoc IBoostAggregator\n    bHermesBoost public immutable hermesGaugeBoost;\n\n    /// @inheritdoc IBoostAggregator\n    ERC20 public immutable hermes;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(address => address) public userToRewardsDepot;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(uint256 => address) public tokenIdToUser;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(uint256 => uint256) public tokenIdRewards;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(address => bool) public whitelistedAddresses;\n\n    /// @inheritdoc IBoostAggregator\n    uint256 public protocolRewards;\n\n    /// @inheritdoc IBoostAggregator\n    uint256 public protocolFee = 2000; // 20%\n    // divisioner for protocol fee\n    uint256 private constant DIVISIONER = 10000;\n\n    /**\n     * @notice Creates a new BoostAggregator\n     * @param _uniswapV3Staker The UniswapV3Staker contract\n     * @param _hermes The hermes token contract\n     * @param _owner The owner of this contract\n     */\n    constructor(UniswapV3Staker _uniswapV3Staker, ERC20 _hermes, address _owner) {\n        _initializeOwner(_owner);\n        uniswapV3Staker = _uniswapV3Staker;\n        hermesGaugeBoost = uniswapV3Staker.hermesGaugeBoost();\n        nonfungiblePositionManager = uniswapV3Staker.nonfungiblePositionManager();\n        hermes = _hermes;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    /// @dev msg.sender not validated to be nonfungiblePositionManager in order to allow\n    ///      whitelisted addresses to retrieve NFTs incorrectly sent to this contract\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata)\n        external\n        override\n        onlyWhitelisted(from)\n        returns (bytes4)\n    {\n        // update tokenIdRewards prior to staking\n        tokenIdRewards[tokenId] = uniswapV3Staker.tokenIdRewards(tokenId);\n        // map tokenId to user\n        tokenIdToUser[tokenId] = from;\n        // stake NFT to Uniswap V3 Staker\n        nonfungiblePositionManager.safeTransferFrom(address(this), address(uniswapV3Staker), tokenId);\n\n        return this.onERC721Received.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARD DEPOTS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function setOwnRewardsDepot(address rewardsDepot) external {\n        userToRewardsDepot[msg.sender] = rewardsDepot;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            UNSTAKE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function unstakeAndWithdraw(uint256 tokenId) external {\n        address user = tokenIdToUser[tokenId];\n        if (user != msg.sender) revert NotTokenIdOwner();\n\n        // unstake NFT from Uniswap V3 Staker\n        uniswapV3Staker.unstakeToken(tokenId);\n\n        uint256 pendingRewards = uniswapV3Staker.tokenIdRewards(tokenId) - tokenIdRewards[tokenId];\n\n        if (pendingRewards > DIVISIONER) {\n            uint256 newProtocolRewards = (pendingRewards * protocolFee) / DIVISIONER;\n            /// @dev protocol rewards stay in stake contract\n            protocolRewards += newProtocolRewards;\n            pendingRewards -= newProtocolRewards;\n\n            address rewardsDepot = userToRewardsDepot[user];\n            if (rewardsDepot != address(0)) {\n                // claim rewards to user's rewardsDepot\n                uniswapV3Staker.claimReward(rewardsDepot, pendingRewards);\n            } else {\n                // claim rewards to user\n                uniswapV3Staker.claimReward(user, pendingRewards);\n            }\n        }\n\n        // withdraw rewards from Uniswap V3 Staker\n        uniswapV3Staker.withdrawToken(tokenId, user, \"\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function addWhitelistedAddress(address user) external onlyOwner {\n        whitelistedAddresses[user] = true;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function removeWhitelistedAddress(address user) external onlyOwner {\n        delete whitelistedAddresses[user];\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function setProtocolFee(uint256 _protocolFee) external onlyOwner {\n        if (_protocolFee > DIVISIONER) revert FeeTooHigh();\n        protocolFee = _protocolFee;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawProtocolFees(address to) external onlyOwner {\n        uniswapV3Staker.claimReward(to, protocolRewards);\n        delete protocolRewards;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawAllGaugeBoost(address to) external onlyOwner {\n        /// @dev May run out of gas.\n        hermesGaugeBoost.decrementAllGaugesAllBoost();\n        address(hermesGaugeBoost).safeTransfer(to, hermesGaugeBoost.balanceOf(address(this)));\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawGaugeBoost(address to, uint256 amount) external onlyOwner {\n        /// @dev May run out of gas.\n        hermesGaugeBoost.decrementAllGaugesBoost(amount);\n        hermesGaugeBoost.updateUserBoost(address(this));\n        address(hermesGaugeBoost).safeTransfer(to, amount);\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) external onlyOwner {\n        hermesGaugeBoost.decrementGaugesBoostIndexed(boost, offset, num);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Only whitelisted addresses\n    /// @param from The address who the NFT is being transferred from\n    modifier onlyWhitelisted(address from) {\n        if (!whitelistedAddresses[from]) revert Unauthorized();\n        _;\n    }\n}"
    },
    {
      "filename": "src/rewards/rewards/FlywheelGaugeRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by Tribe DAO Contracts (flywheel-v2/src/rewards/FlywheelGaugeRewards.sol)\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC20Gauges} from \"@ERC20/ERC20Gauges.sol\";\n\nimport {IFlywheelGaugeRewards} from \"../interfaces/IFlywheelGaugeRewards.sol\";\n\nimport {IBaseV2Minter} from \"@hermes/interfaces/IBaseV2Minter.sol\";\n\n/// @title Flywheel Gauge Reward Stream\ncontract FlywheelGaugeRewards is Ownable, IFlywheelGaugeRewards {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARDS CONTRACT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    ERC20Gauges public immutable override gaugeToken;\n\n    /// @notice the minter contract, is a rewardsStream to collect rewards from\n    IBaseV2Minter public immutable minter;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    address public immutable override rewardToken;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    uint32 public override gaugeCycle;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    uint32 public immutable override gaugeCycleLength;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    mapping(ERC20 => QueuedRewards) public override gaugeQueuedRewards;\n\n    /// @notice the start of the next cycle being partially queued\n    uint32 internal nextCycle;\n\n    // rewards that made it into a partial queue but didn't get completed\n    uint112 internal nextCycleQueuedRewards;\n\n    // the offset during pagination of the queue\n    uint32 internal paginationOffset;\n\n    constructor(address _rewardToken, address _owner, ERC20Gauges _gaugeToken, IBaseV2Minter _minter) {\n        _initializeOwner(_owner);\n        rewardToken = _rewardToken;\n\n        gaugeCycleLength = _gaugeToken.gaugeCycleLength();\n\n        // seed initial gaugeCycle\n        gaugeCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n\n        gaugeToken = _gaugeToken;\n\n        minter = _minter;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GAUGE REWARDS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function queueRewardsForCycle() external returns (uint256 totalQueuedForCycle) {\n        /// @dev Update minter cycle and queue rewars if needed.\n        /// This will make this call fail if it is a new epoch, because the minter calls this function, the first call would fail with \"CycleError()\".\n        /// Should be called through Minter to kickoff new epoch.\n        minter.updatePeriod();\n\n        // next cycle is always the next even divisor of the cycle length above current block timestamp.\n        uint32 currentCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n        uint32 lastCycle = gaugeCycle;\n\n        // ensure new cycle has begun\n        if (currentCycle <= lastCycle) revert CycleError();\n\n        gaugeCycle = currentCycle;\n\n        // queue the rewards stream and sanity check the tokens were received\n        uint256 balanceBefore = rewardToken.balanceOf(address(this));\n        totalQueuedForCycle = minter.getRewards();\n        require(rewardToken.balanceOf(address(this)) - balanceBefore >= totalQueuedForCycle);\n\n        // include uncompleted cycle\n        totalQueuedForCycle += nextCycleQueuedRewards;\n\n        // iterate over all gauges and update the rewards allocations\n        address[] memory gauges = gaugeToken.gauges();\n\n        _queueRewards(gauges, currentCycle, lastCycle, totalQueuedForCycle);\n\n        nextCycleQueuedRewards = 0;\n        paginationOffset = 0;\n\n        emit CycleStart(currentCycle, totalQueuedForCycle);\n    }\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function queueRewardsForCyclePaginated(uint256 numRewards) external {\n        /// @dev Update minter cycle and queue rewars if needed.\n        /// This will make this call fail if it is a new epoch, because the minter calls this function, the first call would fail with \"CycleError()\".\n        /// Should be called through Minter to kickoff new epoch.\n        minter.updatePeriod();\n\n        // next cycle is always the next even divisor of the cycle length above current block timestamp.\n        uint32 currentCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n        uint32 lastCycle = gaugeCycle;\n\n        // ensure new cycle has begun\n        if (currentCycle <= lastCycle) revert CycleError();\n\n        if (currentCycle > nextCycle) {\n            nextCycle = currentCycle;\n            paginationOffset = 0;\n        }\n\n        uint32 offset = paginationOffset;\n\n        // important to only calculate the reward amount once to prevent each page from having a different reward amount\n        if (offset == 0) {\n            // queue the rewards stream and sanity check the tokens were received\n            uint256 balanceBefore = rewardToken.balanceOf(address(this));\n            uint256 newRewards = minter.getRewards();\n            require(rewardToken.balanceOf(address(this)) - balanceBefore >= newRewards);\n            require(newRewards <= type(uint112).max); // safe cast\n            nextCycleQueuedRewards += uint112(newRewards); // in case a previous incomplete cycle had rewards, add on\n        }\n\n        uint112 queued = nextCycleQueuedRewards;\n\n        uint256 remaining = gaugeToken.numGauges() - offset;\n\n        // Important to do non-strict inequality to include the case where the numRewards is just enough to complete the cycle\n        if (remaining <= numRewards) {\n            numRewards = remaining;\n            gaugeCycle = currentCycle;\n            nextCycleQueuedRewards = 0;\n            paginationOffset = 0;\n            emit CycleStart(currentCycle, queued);\n        } else {\n            paginationOffset = offset + numRewards.toUint32();\n        }\n\n        // iterate over all gauges and update the rewards allocations\n        address[] memory gauges = gaugeToken.gauges(offset, numRewards);\n\n        _queueRewards(gauges, currentCycle, lastCycle, queued);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        FLYWHEEL CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Queues the rewards for the next cycle for each given gauge.\n     * @param gauges array of gauges addresses to queue rewards for.\n     * @param currentCycle timestamp representing the beginning of the new cycle.\n     * @param lastCycle timestamp representing the end of the of the last cycle.\n     * @param totalQueuedForCycle total number of rewards queued for the next cycle.\n     */\n    function _queueRewards(address[] memory gauges, uint32 currentCycle, uint32 lastCycle, uint256 totalQueuedForCycle)\n        internal\n    {\n        uint256 size = gauges.length;\n\n        if (size == 0) revert EmptyGaugesError();\n\n        for (uint256 i = 0; i < size; i++) {\n            ERC20 gauge = ERC20(gauges[i]);\n\n            QueuedRewards memory queuedRewards = gaugeQueuedRewards[gauge];\n\n            // Cycle queue already started\n            require(queuedRewards.storedCycle < currentCycle);\n            assert(queuedRewards.storedCycle == 0 || queuedRewards.storedCycle >= lastCycle);\n\n            uint112 completedRewards = queuedRewards.storedCycle == lastCycle ? queuedRewards.cycleRewards : 0;\n            uint256 nextRewards = gaugeToken.calculateGaugeAllocation(address(gauge), totalQueuedForCycle);\n            require(nextRewards <= type(uint112).max); // safe cast\n\n            gaugeQueuedRewards[gauge] = QueuedRewards({\n                priorCycleRewards: queuedRewards.priorCycleRewards + completedRewards,\n                cycleRewards: uint112(nextRewards),\n                storedCycle: currentCycle\n            });\n\n            emit QueueRewards(address(gauge), currentCycle, nextRewards);\n        }\n    }\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function getAccruedRewards() external returns (uint256 accruedRewards) {\n        /// @dev Update minter cycle and queue rewars if needed.\n        minter.updatePeriod();\n\n        QueuedRewards memory queuedRewards = gaugeQueuedRewards[ERC20(msg.sender)];\n\n        uint32 cycle = gaugeCycle;\n        bool incompleteCycle = queuedRewards.storedCycle > cycle;\n\n        // no rewards\n        if (queuedRewards.priorCycleRewards == 0 && (queuedRewards.cycleRewards == 0 || incompleteCycle)) {\n            return 0;\n        }\n\n        // if stored cycle != 0 it must be >= the last queued cycle\n        assert(queuedRewards.storedCycle >= cycle);\n\n        // always accrue prior rewards\n        accruedRewards = queuedRewards.priorCycleRewards;\n        uint112 cycleRewardsNext = queuedRewards.cycleRewards;\n\n        if (incompleteCycle) {\n            // If current cycle queue incomplete, do nothing to current cycle rewards or accrued\n        } else {\n            accruedRewards += cycleRewardsNext;\n            cycleRewardsNext = 0;\n        }\n\n        gaugeQueuedRewards[ERC20(msg.sender)] = QueuedRewards({\n            priorCycleRewards: 0,\n            cycleRewards: cycleRewardsNext,\n            storedCycle: queuedRewards.storedCycle\n        });\n\n        if (accruedRewards > 0) rewardToken.safeTransfer(msg.sender, accruedRew"
    }
  ]
}