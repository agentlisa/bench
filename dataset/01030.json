{
  "Title": "Meta_pool doesn't allow base_pools with len(coins) > 3",
  "Content": "##### Description\nThe current implementation of the meta_pool doesn't allow base_pools with more than 3 tokens https://github.com/curvefi/stableswap-ng/blob/8c78731ed43c22e6bcdcb5d39b0a7d02f8cb0386/contracts/main/CurveStableSwapMetaNG.vy#L64-L68 but such base_pools can be added in the factory. If meta_pool will be created with base_pool with more than 3 tokens, part of the meta_pool functionality will not work.\n\n##### Recommendation\nWe recommend adding a check in the constructor that `BASE_N_COINS < 4`.\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/main/CurveStableSwapMetaNG.vy",
      "content": "# @version 0.3.9\n\"\"\"\n@title CurveStableSwapMetaNG\n@author Curve.Fi\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\n@notice Stableswap Metapool implementation for 2 coins. Supports pegged assets.\n@dev Metapools are pools where the coin on index 1 is a liquidity pool token\n     of another pool. This exposes methods such as exchange_underlying, which\n     exchanges token 0 <> token b1, b2, .. bn, where b is base pool and bn is the\n     nth coin index of the base pool.\n     Asset Types:\n        0. Standard ERC20 token with no additional features\n        1. Oracle - token with rate oracle (e.g. wstETH)\n        2. Rebasing - token with rebase (e.g. stETH)\n     Supports:\n        1. ERC20 support for return True/revert, return True/False, return None\n        2. ERC20 tokens can have arbitrary decimals (<=18).\n        3. ERC20 tokens that rebase (either positive or fee on transfer)\n        4. ERC20 tokens that have a rate oracle (e.g. wstETH, cbETH, sDAI, etc.)\n           Note: Oracle precision _must_ be 10**18.\n     Additional features include:\n        1. Adds oracles based on AMM State Price (and _not_ last traded price).\n           State prices are calculated _after_ liquidity operations, using bonding\n           curve math. Also adds an exponential moving average oracle for D.\n        2. `exchange_received`: swaps that expect an ERC20 transfer to have occurred\n           prior to executing the swap.\n           Note: a. If pool contains rebasing tokens and one of the `asset_types` is 2 (Rebasing)\n                    then calling `exchange_received` will REVERT.\n                 b. If pool contains rebasing token and `asset_types` does not contain 2 (Rebasing)\n                    then this is an incorrect implementation and rebases can be\n                    stolen.\n        3. Adds `get_dx`, `get_dx_underlying`: Similar to `get_dy` which returns an expected output\n           of coin[j] for given `dx` amount of coin[i], `get_dx` returns expected\n           input of coin[i] for an output amount of coin[j].\n        4. Fees are dynamic: AMM will charge a higher fee if pool depegs.\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\nimplements: ERC20\n\n# ------------------------------- Interfaces ---------------------------------\n\ninterface Factory:\n    def fee_receiver() -> address: view\n    def admin() -> address: view\n    def views_implementation() -> address: view\n\ninterface ERC1271:\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes32: view\n\ninterface StableSwapViews:\n    def get_dx(i: int128, j: int128, dy: uint256, pool: address) -> uint256: view\n    def get_dy(i: int128, j: int128, dy: uint256, pool: address) -> uint256: view\n    def get_dx_underlying(i: int128, j: int128, dy: uint256, pool: address) -> uint256: view\n    def get_dy_underlying(i: int128, j: int128, dy: uint256, pool: address) -> uint256: view\n    def dynamic_fee(i: int128, j: int128, pool: address) -> uint256: view\n    def calc_token_amount(\n        _amounts: DynArray[uint256, MAX_COINS],\n        _is_deposit: bool,\n        _pool: address\n    ) -> uint256: view\n\ninterface StableSwap2:\n    def add_liquidity(amounts: uint256[2], min_mint_amount: uint256): nonpayable\n\ninterface StableSwap3:\n    def add_liquidity(amounts: uint256[3], min_mint_amount: uint256): nonpayable\n\ninterface StableSwap:\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256): nonpayable\n    def exchange(i: int128, j: int128, dx: uint256, min_dy: uint256): nonpayable\n    def get_virtual_price() -> uint256: view\n\ninterface Math:\n    def get_y(\n        i: int128,\n        j: int128,\n        x: uint256,\n        xp: DynArray[uint256, MAX_COINS],\n        _amp: uint256,\n        _D: uint256,\n        _n_coins: uint256\n    ) -> uint256: view\n    def get_y_D(\n        A: uint256,\n        i: int128,\n        xp: DynArray[uint256, MAX_COINS],\n        D: uint256,\n        _n_coins: uint256\n    ) -> uint256: view\n    def get_D(\n        _xp: DynArray[uint256, MAX_COINS],\n        _amp: uint256,\n        _n_coins: uint256\n    ) -> uint256: view\n    def exp(x: int256) -> uint256: view\n\n# --------------------------------- Events -----------------------------------\n\nevent Transfer:\n    sender: indexed(address)\n    receiver: indexed(address)\n    value: uint256\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    value: uint256\n\nevent TokenExchange:\n    buyer: indexed(address)\n    sold_id: int128\n    tokens_sold: uint256\n    bought_id: int128\n    tokens_bought: uint256\n\nevent TokenExchangeUnderlying:\n    buyer: indexed(address)\n    sold_id: int128\n    tokens_sold: uint256\n    bought_id: int128\n    tokens_bought: uint256\n\nevent AddLiquidity:\n    provider: indexed(address)\n    token_amounts: DynArray[uint256, MAX_COINS]\n    fees: DynArray[uint256, MAX_COINS]\n    invariant: uint256\n    token_supply: uint256\n\nevent RemoveLiquidity:\n    provider: indexed(address)\n    token_amounts: DynArray[uint256, MAX_COINS]\n    fees: DynArray[uint256, MAX_COINS]\n    token_supply: uint256\n\nevent RemoveLiquidityOne:\n    provider: indexed(address)\n    token_id: int128\n    token_amount: uint256\n    coin_amount: uint256\n    token_supply: uint256\n\nevent RemoveLiquidityImbalance:\n    provider: indexed(address)\n    token_amounts: DynArray[uint256, MAX_COINS]\n    fees: DynArray[uint256, MAX_COINS]\n    invariant: uint256\n    token_supply: uint256\n\nevent RampA:\n    old_A: uint256\n    new_A: uint256\n    initial_time: uint256\n    future_time: uint256\n\nevent StopRampA:\n    A: uint256\n    t: uint256\n\nevent ApplyNewFee:\n    fee: uint256\n    offpeg_fee_multiplier: uint256\n\n\nMAX_COINS: constant(uint256) = 8  # max coins is 8 in the factory\nMAX_COINS_128: constant(int128) = 8\nMAX_METAPOOL_COIN_INDEX: constant(int128) = 1\n\n# ---------------------------- Pool Variables --------------------------------\n\nN_COINS: public(constant(uint256)) = 2\nN_COINS_128: constant(int128) = 2\nPRECISION: constant(uint256) = 10 ** 18\n\nBASE_POOL: public(immutable(address))\nBASE_N_COINS: public(immutable(uint256))\nBASE_COINS: public(immutable(DynArray[address, MAX_COINS]))\n\nmath: immutable(Math)\nfactory: immutable(Factory)\ncoins: public(immutable(DynArray[address, MAX_COINS]))\nstored_balances: DynArray[uint256, MAX_COINS]\nasset_types: immutable(DynArray[uint8, MAX_COINS])\n\n# Fee specific vars\nFEE_DENOMINATOR: constant(uint256) = 10 ** 10\nfee: public(uint256)  # fee * 1e10\noffpeg_fee_multiplier: public(uint256)  # * 1e10\nadmin_fee: public(constant(uint256)) = 5000000000\nMAX_FEE: constant(uint256) = 5 * 10 ** 9\n\n# ---------------------- Pool Amplification Parameters -----------------------\n\nA_PRECISION: constant(uint256) = 100\nMAX_A: constant(uint256) = 10 ** 6\nMAX_A_CHANGE: constant(uint256) = 10\n\ninitial_A: public(uint256)\nfuture_A: public(uint256)\ninitial_A_time: public(uint256)\nfuture_A_time: public(uint256)\n\n# ---------------------------- Admin Variables -------------------------------\n\nMIN_RAMP_TIME: constant(uint256) = 86400\nadmin_balances: public(DynArray[uint256, MAX_COINS])\n\n# ----------------------- Oracle Specific vars -------------------------------\n\nrate_multipliers: immutable(DynArray[uint256, MAX_COINS])\n# [bytes4 method_id][bytes8 <empty>][bytes20 oracle]\noracles: DynArray[uint256, MAX_COINS]\n\nlast_prices_packed: DynArray[uint256, MAX_COINS]  #  packing: last_price, ma_price\nlast_D_packed: uint256                            #  packing: last_D, ma_D\nma_exp_time: public(uint256)\nma_last_time: public(uint256)\n\n# shift(2**32 - 1, 224)\nORACLE_BIT_MASK: constant(uint256) = (2**32 - 1) * 256**28\n\n# --------------------------- ERC20 Specific Vars ----------------------------\n\nname: public(immutable(String[64]))\nsymbol: public(immutable(String[32]))\ndecimals: public(constant(uint8)) = 18\nversion: public(constant(String[8])) = \"v7.0.0\"\n\nbalanceOf: public(HashMap[address, uint256])\nallowance: public(HashMap[address, HashMap[address, uint256]])\ntotal_supply: uint256\nnonces: public(HashMap[address, uint256])\n\n# keccak256(\"isValidSignature(bytes32,bytes)\")[:4] << 224\nERC1271_MAGIC_VAL: constant(bytes32) = 0x1626ba7e00000000000000000000000000000000000000000000000000000000\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\")\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n\nVERSION_HASH: constant(bytes32) = keccak256(version)\nNAME_HASH: immutable(bytes32)\nCACHED_CHAIN_ID: immutable(uint256)\nsalt: public(immutable(bytes32))\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\n\n\n# ------------------------------ AMM Setup -----------------------------------\n\n\n@external\ndef __init__(\n    _name: String[32],\n    _symbol: String[10],\n    _A: uint256,\n    _fee: uint256,\n    _offpeg_fee_multiplier: uint256,\n    _ma_exp_time: uint256,\n    _math_implementation: address,\n    _base_pool: address,\n    _coins: DynArray[address, MAX_COINS],\n    _base_coins: DynArray[address, MAX_COINS],\n    _rate_multipliers: DynArray[uint256, MAX_COINS],\n    _asset_types: DynArray[uint8, MAX_COINS],\n    _method_ids: DynArray[bytes4, MAX_COINS],\n    _oracles: DynArray[address, MAX_COINS],\n):\n    \"\"\"\n    @notice Initialize the pool contract\n    @param _name Name of the new plain pool.\n    @param _symbol Symbol for the new plain pool.\n    @param _A Amplification co-efficient - a lower value here means\n              less tolerance for imbalance within the pool's assets.\n              Suggested values include:\n               * Uncollateralized algorithmic stablecoins: 5-10\n               * Non-redeemable, collateralized assets: 100\n               * Redeemable assets: 200-400\n    @param _fee Trade fee, given as an integer with 1e10 precision. The\n                the maximum is 1% (100000000).\n                50% of the fee is distributed to veCRV holders.\n    @param _offpeg_fee_multiplier A multiplier that determines how much to increase\n                                  Fees by when assets in the AMM depeg. Example: 20000000000\n    @param _ma_exp_time Averaging window of oracle. Set as time_in_seconds / ln(2)\n                        Example: for 10 minute EMA, _ma_exp_time is 600 / ln(2) ~= 866\n    @param _math_implementation Contract containing Math methods\n    @param _base_pool The underlying AMM of the LP token _coins[0] is paired against\n    @param _coins List of addresses of the coins being used in the pool. For metapool this is\n                  the coin (say LUSD) vs (say) 3crv as: [LUSD, 3CRV]. Length is always 2.\n    @param _base_coins coins in the underlying base pool.\n    @param _rate_multipliers Rate multipliers of the individual coins. For Metapools it is:\n                              [10 ** (36 - _coins[0].decimals()), 10 ** 18].\n    @param _asset_types Array of uint8 representing tokens in pool\n    @param _method_ids Array of first four bytes of the Keccak-256 hash of the function signatures\n                       of the oracle addresses that gives rate oracles.\n                       Calculated as: keccak(text=event_signature.replace(\" \", \"\"))[:4]\n    @param _oracles Array of rate oracle addresses.\n    \"\"\"\n\n    math = Math(_math_implementation)\n    BASE_POOL = _base_pool\n    BASE_COINS = _base_coins\n    BASE_N_COINS = len(_base_coins)\n    coins = _coins\n    rate_multipliers = _rate_multipliers\n    asset_types = _asset_types  # contains asset types for all pool tokens including base pool tokens\n\n    for i in range(MAX_COINS):\n        if i < BASE_N_COINS:\n            # Approval needed for add_liquidity operation on base pool in _exchange_underlying\n            ERC20(_base_coins[i]).approve(BASE_POOL, max_value(uint256))\n\n    self.last_prices_packed.append(self.pack_prices(10**18, 10**18))\n\n    # ----------------- Parameters independent of pool type ------------------\n\n    factory = Factory(msg.sender)\n\n    A: uint256 = _A * A_PRECISION\n    self.initial_A = A\n    self.future_A = A\n    self.fee = _fee\n    self.offpeg_fee_multiplier = _offpeg_fee_multiplier\n\n    assert _ma_exp_time != 0\n    self.ma_exp_time = _ma_exp_time\n    self.ma_last_time = block.timestamp\n\n    for i in range(N_COINS_128):\n\n        self.oracles.append(convert(_method_ids[i], uint256) * 2**224 | convert(_oracles[i], uint256))\n        self.admin_balances.append(0)  # <--- this initialises storage for admin balances\n        self.stored_balances.append(0)\n\n    # --------------------------- ERC20 stuff ----------------------------\n\n    name = _name\n    symbol = _symbol\n\n    # EIP712 related params -----------------\n    NAME_HASH = keccak256(name)\n    salt = block.prevhash\n    CACHED_CHAIN_ID = chain.id\n    CACHED_DOMAIN_SEPARATOR = keccak256(\n        _abi_encode(\n            EIP712_TYPEHASH,\n            NAME_HASH,\n            VERSION_HASH,\n            chain.id,\n            self,\n            salt,\n        )\n    )\n\n    # ------------------------ Fire a transfer event -------------------------\n\n    log Transfer(empty(address), msg.sender, 0)\n\n\n# ------------------ Token transfers in and out of the AMM -------------------\n\n\n@internal\ndef _transfer_in(\n    coin_metapool_idx: int128,\n    coin_basepool_idx: int128,\n    dx: uint256,\n    dy: uint256,\n    sender: address,\n    receiver: address,\n    expect_optimistic_transfer: bool,\n) -> uint256:\n    \"\"\"\n    @notice Contains all logic to handle ERC20 token transfers.\n    @param _coin address of the coin to transfer in.\n    @param dx amount of `_coin` to transfer into the pool.\n    @param dy amount of `_coin` to transfer out of the pool.\n    @param sender address to transfer `_coin` from.\n    @param receiver address to transfer `_coin` to.\n    @param expect_optimistic_transfer True if contract expects an optimistic coin transfer\n    \"\"\"\n    _input_coin: ERC20 = ERC20(coins[coin_metapool_idx])\n    _incoming_coin_asset_type: uint8 = asset_types[coin_metapool_idx]\n    _stored_balance: uint256 = self.stored_balances[coin_metapool_idx]\n\n    if coin_basepool_idx >= 0 and coin_metapool_idx == 1:  # self._exchange_underlying\n\n        _input_coin = ERC20(BASE_COINS[coin_basepool_idx])\n        _incoming_coin_asset_type = asset_types[coin_basepool_idx + 2]\n        _stored_balance = 0\n\n    _dx: uint256 = _input_coin.balanceOf(self)\n\n    # ------------------------- Handle Transfers -----------------------------\n\n    if expect_optimistic_transfer:\n\n        assert _incoming_coin_asset_type != 2  # dev: rebasing coins not supported\n        _dx -= _stored_balance  # <--- for base_pool coins, stored balance is 0.\n\n    else:\n\n        assert _input_coin.transferFrom(sender, self, dx, default_return_value=True)\n        _dx = _input_coin.balanceOf(self) - _dx\n\n    # --------------------------- Check Transfer -----------------------------\n\n    if _incoming_coin_asset_type == 2:\n        assert _dx > 0  # dev: pool did not receive tokens for swap\n    else:\n        assert dx == _dx  # dev: pool did not receive tokens for swap\n\n    # ----------------------- Update Stored Balances -------------------------\n\n    self.stored_balances[coin_metapool_idx] += _dx\n\n    return _dx\n\n\n@internal\ndef _transfer_out(\n    _coin_idx: int128, _amount: uint256, receiver: address\n):\n    \"\"\"\n    @notice Transfer a single token from the pool to receiver.\n    @dev This function is called by `remove_liquidity` and\n         `remove_liquidity_one` and `_exchange` methods.\n    @param _coin Address of the token to transfer out\n    @param _amount Amount of token to transfer out\n    @param receiver Address to send the tokens to\n    \"\"\"\n\n    # ------------------------- Handle Transfers -----------------------------\n\n    assert ERC20(coins[_coin_idx]).transfer(\n        receiver, _amount, default_return_value=True\n    )\n\n    # ----------------------- Update Stored Balances -------------------------\n\n    self.stored_balances[_coin_idx] -= _amount\n\n\n# -------------------------- AMM Special Methods -----------------------------\n\n\n@view\n@internal\ndef _stored_rates() -> DynArray[uint256, MAX_COINS]:\n    \"\"\"\n    @notice Gets rate multipliers for each coin.\n    @dev If the coin has a rate oracle that has been properly initialised,\n         this method queries that rate by static-calling an external\n         contract.\n    \"\"\"\n    rates: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\n    if BASE_POOL != empty(address):\n        rates = [rate_multipliers[0], StableSwap(BASE_POOL).get_virtual_price()]\n    else:\n        rates = rate_multipliers\n\n    oracles: DynArray[uint256, MAX_COINS] = self.oracles\n\n    for i in range(N_COINS_128):\n\n        if oracles[i] == 0:\n            continue\n\n        # NOTE: assumed that response is of precision 10**18\n        response: Bytes[32] = raw_call(\n            convert(oracles[i] % 2**160, address),\n            _abi_encode(oracles[i] & ORACLE_BIT_MASK),\n            max_outsize=32,\n            is_static_call=True,\n        )\n\n        assert len(response) != 0\n\n        # rates[i] * convert(response, uint256) / PRECISION\n        rates[i] = unsafe_div(rates[i] * convert(response, uint256), PRECISION)\n\n    return rates\n\n\n@view\n@internal\ndef _balances() -> DynArray[uint256, MAX_COINS]:\n    \"\"\"\n    @notice Calculates the pool's balances _excluding_ the admin's balances.\n    @dev This method ensures LPs keep all rebases and admin only claims swap fees.\n    \"\"\"\n    result: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\n    for i in range(N_COINS_128):\n        result.append(ERC20(coins[i]).balanceOf(self) - self.admin_balances[i])\n\n    return result\n\n\n# -------------------------- AMM Main Functions ------------------------------\n\n\n@external\n@nonreentrant('lock')\ndef exchange(\n    i: int128,\n    j: int128,\n    _dx: uint256,\n    _min_dy: uint256,\n    _receiver: address = msg.sender,\n) -> uint256:\n    \"\"\"\n    @notice Perform an exchange between two coins\n    @dev Index values can be found via the `coins` public getter method\n    @param i Index value for the coin to send\n    @param j Index valie of the coin to recieve\n    @param _dx Amount of `i` being exchanged\n    @param _min_dy Minimum amount of `j` to receive\n    @return Actual amount of `j` received\n    \"\"\"\n    return self._exchange(\n        msg.sender,\n        i,\n        j,\n        _dx,\n        _min_dy,\n        _receiver,\n        False\n    )\n\n\n@external\n@nonreentrant('lock')\ndef exchange_received(\n    i: int128,\n    j: int128,\n    _dx: uint256,\n    _min_dy: uint256,\n    _receiver: address,\n) -> uint256:\n    \"\"\"\n    @notice Perform an exchange between two coins without transferring token in\n    @dev The contract swaps tokens based on a change in balance of coin[i]. The\n         dx = ERC20(coin[i]).balanceOf(self) - self.stored_balances[i]. Users of\n         this method are dex aggregators, arbitrageurs, or other users who do not\n         wish to grant approvals to the contract: they would instead send tokens\n         directly to the contract and call `exchange_received`.\n    @param i Index value for the coin to send\n    @param j Index valie of the coin to recieve\n    @param _dx Amount of `i` being exchanged\n    @param _min_dy Minimum amount of `j` to receive\n    @return Actual amount of `j` received\n    \"\"\"\n    return self._exchange(\n        msg.sender,\n        i,\n        j,\n        _dx,\n        _min_dy,\n        _receiver,\n        True,  # <--------------------------------------- swap optimistically.\n    )\n\n\n@external\n@nonreentrant('lock')\ndef exchange_underlying(\n    i: int128,\n    j: int128,\n    _dx: uint256,\n    _min_dy: uint256,\n    _receiver: address = msg.sender,\n) -> uint256:\n    \"\"\"\n    @notice Perform an exchange between two underlying coins\n    @param i Index value for the underlying coin to send\n    @param j Index value of the underlying coin to receive\n    @param _dx Amount of `i` being exchanged\n    @param _min_dy Minimum amount of `j` to receive\n    @param _receiver Address that receives `j`\n    @return Actual amount of `j` received\n    \"\"\"\n    return self._exchange_underlying(\n        msg.sender,\n        i,\n        j,\n        _dx,\n        _min_dy,\n        _receiver,\n        False\n    )\n\n\n@external\n@nonreentrant('lock')\ndef exchange_underlying_received(\n    i: int128,\n    j: int128,\n    _dx: uint256,\n    _min_dy: uint256,\n    _receiver: address,\n) -> uint256:\n    \"\"\"\n    @notice Perform an exchange between two underlying coins\n    @param i Index value for the underlying coin to send\n    @param j Index value of the underlying coin to receive\n    @param _dx Amount of `i` being exchanged\n    @param _min_dy Minimum amount of `j` to receive\n    @param _receiver Address that receives `j`\n    @return Actual amount of `j` received\n    \"\"\"\n    return self._exchange_underlying(\n        msg.sender,\n        i,\n        j,\n        _dx,\n        _min_dy,\n        _receiver,\n        True\n    )\n\n\n@external\n@nonreentrant('lock')\ndef add_liquidity(\n    _amounts: DynArray[uint256, MAX_COINS],\n    _min_mint_amount: uint256,\n    _receiver: address = msg.sender\n) -> uint256:\n    \"\"\"\n    @notice Deposit coins into the pool\n    @param _amounts List of amounts of coins to deposit\n    @param _min_mint_amount Minimum amount of LP tokens to mint from the deposit\n    @param _receiver Address that owns the minted LP tokens\n    @return Amount of LP tokens received by depositing\n    \"\"\"\n    amp: uint256 = self._A()\n    old_balances: DynArray[uint256, MAX_COINS] = self._balances()\n    rates: DynArray[uint256, MAX_COINS] = self._stored_rates()\n\n    # Initial invariant\n    D0: uint256 = self.get_D_mem(rates, old_balances, amp)\n\n    total_supply: uint256 = self.total_supply\n    new_balances: DynArray[uint256, MAX_COINS] = old_balances\n\n    # -------------------------- Do Transfers In -----------------------------\n\n    for i in range(N_COINS_128):\n\n        if _amounts[i] > 0:\n\n            new_balances[i] += self._transfer_in(\n                i,\n                -1,  # <--- we're not handling underlying coins here\n                _amounts[i],\n                0,\n                msg.sender,\n                empty(address),\n                False,  # expect_optimistic_transfer\n            )\n\n        else:\n\n            assert total_supply != 0  # dev: initial deposit requires all coins\n\n    # ------------------------------------------------------------------------\n\n    # Invariant after change\n    D1: uint256 = self.get_D_mem(rates, new_balances, amp)\n    assert D1 > D0\n\n    # We need to recalculate the invariant accounting for fees\n    # to calculate fair user's share\n    fees: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\n    mint_amount: uint256 = 0\n\n    if total_supply > 0:\n\n        ideal_balance: uint256 = 0\n        difference: uint256 = 0\n        new_balance: uint256 = 0\n\n        ys: uint256 = (D0 + D1) / N_COINS\n        xs: uint256 = 0\n        _dynamic_fee_i: uint256 = 0\n\n        # Only account for fees if we are not the first to deposit\n        base_fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))\n\n        for i in range(N_COINS_128):\n\n            ideal_balance = D1 * old_balances[i] / D0\n            new_balance = new_balances[i]\n\n            if ideal_balance > new_balance:\n                difference = ideal_balance - new_balance\n            else:\n                difference = new_balance - ideal_balance\n\n            # fee[i] = _dynamic_fee(i, j) * difference / FEE_DENOMINATOR\n            xs = old_balances[i] + new_balance\n            _dynamic_fee_i = self._dynamic_fee(xs, ys, base_fee)\n            fees.append(\n                unsafe_div(\n                    _dynamic_fee_i * difference,\n                    FEE_DENOMINATOR\n                )\n            )\n\n            # fees[i] * admin_fee / FEE_DENOMINATOR\n            self.admin_balances[i] += unsafe_div(fees[i] * admin_fee, FEE_DENOMINATOR)\n            new_balances[i] -= fees[i]\n\n        xp: DynArray[uint256, MAX_COINS] = self._xp_mem(rates, new_balances)\n        D2: uint256 = math.get_D(xp, amp, N_COINS)\n        mint_amount = total_supply * (D2 - D0) / D0\n        self.upkeep_oracles(xp, amp, D2)\n\n    else:\n\n        mint_amount = D1  # Take the dust if there was any\n\n        # (re)instantiate D oracle if totalSupply is zero.\n        self.last_D_packed = self.pack_prices(D1, D1)\n\n    assert mint_amount >= _min_mint_amount, \"Slippage screwed you\"\n\n    # Mint pool tokens\n    total_supply += mint_amount\n    self.balanceOf[_receiver] += mint_amount\n    self.total_supply = total_supply\n    log Transfer(empty(address), _receiver, mint_amount)\n\n    log AddLiquidity(msg.sender, _amounts, fees, D1, total_supply)\n\n    return mint_amount\n\n\n@external\n@nonreentrant('lock')\ndef remove_liquidity_one_coin(\n    _burn_amount: uint256,\n    i: int128,\n    _min_received: uint256,\n    _receiver: address = msg.sender,\n) -> uint256:\n    \"\"\"\n    @notice Withdraw a single coin from the pool\n    @param _burn_amount Amount of LP tokens to burn in the withdrawal\n    @param i Index value of the coin to withdraw\n    @param _min_received Minimum amount of coin to receive\n    @param _receiver Address that receives the withdrawn coins\n    @return Amount of coin received\n    \"\"\"\n    dy: uint256 = 0\n    fee: uint256 = 0\n    xp: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\n    amp: uint256 = empty(uint256)\n    D: uint256 = empty(uint256)\n\n    dy, fee, xp, amp, D = self._calc_withdraw_one_coin(_burn_amount, i)\n    assert dy >= _min_received, \"Not enough coins removed\"\n\n    # fee * admin_fee / FEE_DENOMINATOR\n    self.admin_balances[i] += unsafe_div(fee * admin_fee, FEE_DENOMINATOR)\n\n    self._burnFrom(msg.sender, _burn_amount)\n\n    log Transfer(msg.sender, empty(address), _burn_amount)\n\n    self._transfer_out(i, dy, _receiver)\n\n    log RemoveLiquidityOne(msg.sender, i, _burn_amount, dy, self.total_supply)\n\n    self.upkeep_oracles(xp, amp, D)\n\n    return dy\n\n\n@external\n@nonreentrant('lock')\ndef remove_liquidity_imbalance(\n    _amounts: DynArray[uint256, MAX_COINS],\n    _max_burn_amount: uint256,\n    _receiver: address = msg.sender\n) -> uint256:\n    \"\"\"\n    @notice Withdraw coins from the pool in an imbalanced amount\n    @param _amounts List of amounts of underlying coins to withdraw\n    @param _max_burn_amount Maximum amount of LP token to burn in the withdrawal\n    @param _receiver Address that receives the withdrawn coins\n    @return Actual amount of the LP token burned in the withdrawal\n    \"\"\"\n    amp: uint256 = self._A()\n    rates: DynArray[uint256, MAX_COINS] = self._stored_rates()\n    old_balances: DynArray[uint256, MAX_COINS] = self._balances()\n    D0: uint256 = self.get_D_mem(rates, old_balances, amp)\n    new_balances: DynArray[uint256, MAX_COINS] = old_balances\n\n    for i in range(N_COINS_128):\n\n        if _amounts[i] != 0:\n            new_balances[i] -= _amounts[i]\n            self._transfer_out(i, _amounts[i], _receiver)\n\n    D1: uint256 = self.get_D_mem(rates, new_balances, amp)\n    base_fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))\n    ys: uint256 = (D0 + D1) / N_COINS\n\n    fees: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\n    dynamic_fee: uint256 = 0\n    xs: uint256 = 0\n    ideal_balance: uint256 = 0\n    difference: uint256 = 0\n    new_balance: uint256 = 0\n\n    for i in range(N_COINS_128):\n\n        ideal_balance = D1 * old_balances[i] / D0\n        new_balance = new_balances[i]\n\n        if ideal_balance > new_balance:\n            difference = ideal_balance - new_balance\n        else:\n            difference = new_balance - ideal_balance\n\n        # base_fee * difference / FEE_DENOMINATOR\n        xs = new_balance + old_balances[i]\n        dynamic_fee = self._dynamic_fee(xs, ys, base_fee)\n        fees.append(unsafe_div(dynamic_fee * difference, FEE_DENOMINATOR))\n\n        # fees[i] * admin_fee / FEE_DENOMINATOR\n        self.admin_balances[i] += unsafe_div(fees[i] * admin_fee, FEE_DENOMINATOR)\n\n        new_balances[i] -= fees[i]\n\n    D2: uint256 = self.get_D_mem(rates, new_balances, amp)\n\n    self.upkeep_oracles(new_balances, amp, D2)\n\n    total_supply: uint256 = self.total_supply\n    burn_amount: uint256 = ((D0 - D2) * total_supply / D0) + 1\n    assert burn_amount > 1  # dev: zero tokens burned\n    assert burn_amount <= _max_burn_amount, \"Slippage screwed you\"\n\n    self._burnFrom(msg.sender, burn_amount)\n\n    log RemoveLiquidityImbalance(msg.sender, _amounts, fees, D1, total_supply)\n\n    return burn_amount\n\n\n@external\n@nonreentrant('lock')\ndef remove_liquidity(\n    _burn_amount: uint256,\n    _min_amounts: DynArray[uint256, MAX_COINS],\n    _receiver: address = msg.sender,\n    _claim_admin_fees: bool = True,\n) -> DynArray[uint256, MAX_COINS]:\n    \"\"\"\n    @notice Withdraw coins from the pool\n    @dev Withdrawal amounts are based on current deposit ratios\n    @param _burn_amount Quantity of LP tokens to burn in the withdrawal\n    @param _min_amounts Minimum amounts of underlying coins to receive\n    @param _receiver Address that receives the withdrawn coins\n    @return List of amounts of coins that were withdrawn\n    \"\"\"\n    total_supply: uint256 = self.total_supply\n    amounts: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\n    balances: DynArray[uint256, MAX_COINS] = self._balances()\n\n    value: uint256 = 0\n\n    for i in range(N_COINS_128):\n\n        value = balances[i] * _burn_amount / total_supply\n        assert value >= _min_amounts[i], \"Withdrawal resulted in fewer coins than expected\"\n        amounts.append(value)\n        self._transfer_out(i, value, _receiver)\n\n    self._burnFrom(msg.sender, _burn_amount)  # dev: insufficient funds\n\n    log RemoveLiquidity(msg.sender, amounts, empty(DynArray[uint256, MAX_COINS]), total_supply)\n\n    # Withdraw admin fees if _claim_admin_fees is set to True. Helps automate.\n    if _claim_admin_fees:\n        self._withdraw_admin_fees()\n\n    return amounts\n\n\n@external\ndef withdraw_admin_fees():\n    \"\"\"\n    @notice Claim admin fees. Callable by anyone.\n    \"\"\"\n    self._withdraw_admin_fees()\n\n\n# ------------------------ AMM Internal Functions ----------------------------\n\n\n@view\n@internal\ndef _dynamic_fee(xpi: uint256, xpj: uint256, _fee: uint256) -> uint256:\n\n    _offpeg_fee_multiplier: uint256 = self.offpeg_fee_multiplier\n    if _offpeg_fee_multiplier <= FEE_DENOMINATOR:\n        return _fee\n\n    xps2: uint256 = (xpi + xpj) ** 2\n    return (\n        (_offpeg_fee_multiplier * _fee) /\n        ((_offpeg_fee_multiplier - FEE_DENOMINATOR) * 4 * xpi * xpj / xps2 + FEE_DENOMINATOR)\n    )\n\n\n@internal\ndef __exchange(\n    dx: uint256,\n    x: uint256,\n    _xp: DynArray[uint256, MAX_COINS],\n    rates: DynArray[uint256, MAX_COINS],\n    i: int128,\n    j: int128,\n) -> uint256:\n\n    amp: uint256 = self._A()\n    D: uint256 = math.get_D(_xp, amp, N_COINS)\n    y: uint256 = math.get_y(i, j, x, _xp, amp, D, N_COINS)\n\n    dy: uint256 = _xp[j] - y - 1  # -1 just in case there were some rounding errors\n    dy_fee: uint256 = dy * self._dynamic_fee((_xp[i] + x) / 2, (_xp[j] + y) / 2, self.fee) / FEE_DENOMINATOR\n\n    # Convert all to real units\n    dy = (dy - dy_fee) * PRECISION / rates[j]\n\n    self.admin_balances[j] += (\n        unsafe_div(dy_fee * admin_fee, FEE_DENOMINATOR)  # dy_fee * admin_fee / FEE_DENOMINATOR\n    ) * PRECISION / rates[j]\n\n    # Calculate and store state prices:\n    xp: DynArray[uint256, MAX_COINS] = _xp\n    xp[i] = x\n    xp[j] = y\n    # D is not changed because we did not apply a fee\n    self.upkeep_oracles(xp, amp, D)\n\n    return dy\n\n\n@internal\ndef _exchange(\n    sender: address,\n    i: int128,\n    j: int128,\n    _dx: uint256,\n    _min_dy: uint256,\n    receiver: address,\n    expect_optimistic_transfer: bool\n) -> uint256:\n\n    assert i != j  # dev: coin index out of range\n    assert _dx > 0  # dev: do not exchange 0 coins\n\n    rates: DynArray[uint256, MAX_COINS] = self._stored_rates()\n    old_balances: DynArray[uint256, MAX_COINS] = self._balances()\n    xp: DynArray[uint256, MAX_COINS] = self._xp_mem(rates, old_balances)\n\n    # --------------------------- Do Transfer in -----------------------------\n\n    # `dx` is whatever the pool received after ERC20 transfer:\n    dx: uint256 = self._transfer_in(\n        i,\n        -1,  # <----- we're not handling underlying coins here.\n        _dx,\n        _min_dy,\n        sender,\n        receiver,\n        expect_optimistic_transfer\n    )\n\n    # ------------------------------- Exchange -------------------------------\n\n    # xp[i] + dx * rates[i] / PRECISION\n    x: uint256 = xp[i] + unsafe_div(dx * rates[i], PRECISION)\n    dy: uint256 = self.__exchange(dx, x, xp, rates, i, j)\n    assert dy >= _min_dy, \"Exchange resulted in fewer coins than expected\"\n\n    # --------------------------- Do Transfer out ----------------------------\n\n    self._transfer_out(j, dy, receiver)\n\n    # ------------------------------------"
    }
  ]
}