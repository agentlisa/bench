{
  "Title": "H-9: Scaling factor of the wrapped token is incorrect",
  "Content": "# Issue H-9: Scaling factor of the wrapped token is incorrect \n\nSource: https://github.com/sherlock-audit/2022-12-notional-judging/issues/9 \n\n## Found by \nJeiwan, xiaoming90\n\n## Summary\n\nThe scaling factor of the wrapped token within the Boosted3Token leverage vault is incorrect. Thus, all the computations within the leverage vault will be incorrect. This leads to an array of issues such as users being liquidated prematurely or users being able to borrow more than they are allowed to.\n\n## Vulnerability Detail\n\nIn Line 120, it calls the `getScalingFactors` function of the LinearPool to fetch the scaling factors of the LinearPool.\n\nIn Line 123, it computes the final scaling factor of the wrapped token by multiplying the main token's decimal scaling factor with the wrapped token rate, which is incorrect.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/mixins/Boosted3TokenPoolMixin.sol#L109\n\n```solidity\nFile: Boosted3TokenPoolMixin.sol\n109:     function _underlyingPoolContext(ILinearPool underlyingPool) private view returns (UnderlyingPoolContext memory) {\n110:         (uint256 lowerTarget, uint256 upperTarget) = underlyingPool.getTargets();\n111:         uint256 mainIndex = underlyingPool.getMainIndex();\n112:         uint256 wrappedIndex = underlyingPool.getWrappedIndex();\n113: \n114:         (\n115:             /* address[] memory tokens */,\n116:             uint256[] memory underlyingBalances,\n117:             /* uint256 lastChangeBlock */\n118:         ) = Deployments.BALANCER_VAULT.getPoolTokens(underlyingPool.getPoolId());\n119: \n120:         uint256[] memory underlyingScalingFactors = underlyingPool.getScalingFactors();\n121:         // The wrapped token's scaling factor is not constant, but increases over time as the wrapped token increases in\n122:         // value.\n123:         uint256 wrappedScaleFactor = underlyingScalingFactors[mainIndex] * underlyingPool.getWrappedTokenRate() /\n124:             BalancerConstants.BALANCER_PRECISION;\n125: \n126:         return UnderlyingPoolContext({\n127:             mainScaleFactor: underlyingScalingFactors[mainIndex],\n128:             mainBalance: underlyingBalances[mainIndex],\n129:             wrappedScaleFactor: wrappedScaleFactor,\n130:             wrappedBalance: underlyingBalances[wrappedIndex],\n131:             virtualSupply: underlyingPool.getVirtualSupply(),\n132:             fee: underlyingPool.getSwapFeePercentage(),\n133:             lowerTarget: lowerTarget,\n134:             upperTarget: upperTarget    \n135:         });\n136:     }\n```\n\nFollowing is the source code of LinearPool taken from Balancer - https://github.com/balancer-labs/balancer-v2-monorepo/blob/master/pkg/pool-linear/contracts/LinearPool.sol\n\nThe correct way of calculating the final scaling factor of the wrapped token is to multiply the wrapped token's decimal scaling factor by the wrapped token rate as shown below:\n\n```solidity\nscalingFactors[_wrappedIndex] = _scalingFactorWrappedToken.mulDown(_getWrappedTokenRate());\n```\n\nThe `_scalingFactorWrappedToken` is the scaling factor that, when multiplied to a token amount, normalizes its balance as if it had 18 decimals. The `_getWrappedTokenRate` function returns the wrapped token rate.\n\nIt is important to note that the decimal scaling factor of the main and wrapped tokens are not always the same. Thus, they cannot be used interchangeably.\n\nhttps://github.com/balancer-labs/balancer-v2-monorepo/blob/c3479e35f01e690fb71b2bf6b38a15cb92128586/pkg/pool-linear/contracts/LinearPool.sol#L504\n\nhttps://github.com/balancer-labs/balancer-v2-monorepo/blob/c3479e35f01e690fb71b2bf6b38a15cb92128586/pkg/pool-linear/contracts/LinearPool.sol#L521\n\n```solidity\n    // Scaling factors\n\n    function _scalingFactor(IERC20 token) internal view virtual returns (uint256) {\n        if (token == _mainToken) {\n            return _scalingFactorMainToken;\n        } else if (token == _wrappedToken) {\n            // The wrapped token's scaling factor is not constant, but increases over time as the wrapped token\n            // increases in value.\n            return _scalingFactorWrappedToken.mulDown(_getWrappedTokenRate());\n        } else if (token == this) {\n            return FixedPoint.ONE;\n        } else {\n            _revert(Errors.INVALID_TOKEN);\n        }\n    }\n\n    /**\n     * @notice Return the scaling factors for all tokens, including the BPT.\n     */\n    function getScalingFactors() public view virtual override returns (uint256[] memory) {\n        uint256[] memory scalingFactors = new uint256[](_TOTAL_TOKENS);\n\n        // The wrapped token's scaling factor is not constant, but increases over time as the wrapped token increases in\n        // value.\n        scalingFactors[_mainIndex] = _scalingFactorMainToken;\n        scalingFactors[_wrappedIndex] = _scalingFactorWrappedToken.mulDown(_getWrappedTokenRate());\n        scalingFactors[_BPT_INDEX] = FixedPoint.ONE;\n\n        return scalingFactors;\n    }\n```\n\n## Impact\n\nWithin the Boosted 3 leverage vault, the balances are scaled before passing them to the stable math function for computation since the stable math function only works with balances that have been normalized to 18 decimals. If the scaling factor is incorrect, all the computations within the leverage vault will be incorrect, which affects almost all the vault functions.\n\nFor instance, the `Boosted3TokenAuraVault.convertStrategyToUnderlying` function relies on the wrapped scaling factor for its computation under the hood. This function is utilized by Notional's `VaultConfiguration.calculateCollateralRatio` function to determine the value of the vault share when computing the collateral ratio. If the underlying result is wrong, the collateral ratio will be wrong too, and this leads to an array of issues such as users being liquidated prematurely or users being able to borrow more than they are allowed to.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/mixins/Boosted3TokenPoolMixin.sol#L109\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere is no need to manually calculate the final scaling factor of the wrapped token again within the code. This is because the wrapped token scaling factor returned by the `LinearPool.getScalingFactors()` function already includes the token rate. Refer to the Balancer's source code above for referen\n\n```diff\nfunction _underlyingPoolContext(ILinearPool underlyingPool) private view returns (UnderlyingPoolContext memory) {\n    (uint256 lowerTarget, uint256 upperTarget) = underlyingPool.getTargets();\n    uint256 mainIndex = underlyingPool.getMainIndex();\n    uint256 wrappedIndex = underlyingPool.getWrappedIndex();\n\n    (\n        /* address[] memory tokens */,\n        uint256[] memory underlyingBalances,\n        /* uint256 lastChangeBlock */\n    ) = Deployments.BALANCER_VAULT.getPoolTokens(underlyingPool.getPoolId());\n\n    uint256[] memory underlyingScalingFactors = underlyingPool.getScalingFactors();\n-   // The wrapped token's scaling factor is not constant, but increases over time as the wrapped token increases in\n-   // value.\n-   uint256 wrappedScaleFactor = underlyingScalingFactors[mainIndex] * underlyingPool.getWrappedTokenRate() /\n-       BalancerConstants.BALANCER_PRECISION;\n\n    return UnderlyingPoolContext({\n        mainScaleFactor: underlyingScalingFactors[mainIndex],\n        mainBalance: underlyingBalances[mainIndex],\n-       wrappedScaleFactor: wrappedScaleFactor,\n+       wrappedScaleFactor: underlyingScalingFactors[wrappedIndex],        \n        wrappedBalance: underlyingBalances[wrappedIndex],\n        virtualSupply: underlyingPool.getVirtualSupply(),\n        fee: underlyingPool.getSwapFeePercentage(),\n        lowerTarget: lowerTarget,\n        upperTarget: upperTarget    \n    });\n}\n```\n\n## Discussion\n\n**weitianjie2000**\n\nvalid, will fix\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/31",
  "Code": [
    {
      "filename": "contracts/vaults/balancer/mixins/Boosted3TokenPoolMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    ThreeTokenPoolContext, \n    TwoTokenPoolContext, \n    BoostedOracleContext,\n    UnderlyingPoolContext,\n    AuraVaultDeploymentParams,\n    Boosted3TokenAuraStrategyContext,\n    StrategyContext,\n    AuraStakingContext\n} from \"../BalancerVaultTypes.sol\";\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\nimport {BalancerConstants} from \"../internal/BalancerConstants.sol\";\nimport {IBalancerPool, IBoostedPool, ILinearPool} from \"../../../../interfaces/balancer/IBalancerPool.sol\";\nimport {BalancerUtils} from \"../internal/pool/BalancerUtils.sol\";\nimport {Deployments} from \"../../../global/Deployments.sol\";\nimport {PoolMixin} from \"./PoolMixin.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\nimport {StableMath} from \"../internal/math/StableMath.sol\";\n\nabstract contract Boosted3TokenPoolMixin is PoolMixin {\n\n    error InvalidPrimaryToken(address token);\n\n    uint8 internal constant NOT_FOUND = type(uint8).max;\n\n    IERC20 internal immutable PRIMARY_TOKEN;\n    IERC20 internal immutable SECONDARY_TOKEN;\n    IERC20 internal immutable TERTIARY_TOKEN;\n    uint8 internal immutable PRIMARY_INDEX;\n    uint8 internal immutable SECONDARY_INDEX;\n    uint8 internal immutable TERTIARY_INDEX;\n    uint8 internal immutable BPT_INDEX;\n    uint8 internal immutable PRIMARY_DECIMALS;\n    uint8 internal immutable SECONDARY_DECIMALS;\n    uint8 internal immutable TERTIARY_DECIMALS;\n\n    constructor(\n        NotionalProxy notional_, \n        AuraVaultDeploymentParams memory params\n    ) PoolMixin(notional_, params) {\n        address primaryAddress = BalancerUtils.getTokenAddress(\n            _getNotionalUnderlyingToken(params.baseParams.primaryBorrowCurrencyId)\n        );\n        \n        // prettier-ignore\n        (\n            address[] memory tokens,\n            /* uint256[] memory balances */,\n            /* uint256 lastChangeBlock */\n        ) = Deployments.BALANCER_VAULT.getPoolTokens(params.baseParams.balancerPoolId);\n\n        // Boosted pools contain 4 tokens (3 LinearPool LP tokens + 1 BoostedPool LP token)\n        require(tokens.length == 4);\n\n        uint8 primaryIndex = NOT_FOUND;\n        uint8 secondaryIndex = NOT_FOUND;\n        uint8 tertiaryIndex = NOT_FOUND;\n        uint8 bptIndex = NOT_FOUND;\n        for (uint256 i; i < 4; i++) {\n            // Skip pool token\n            if (tokens[i] == address(BALANCER_POOL_TOKEN)) {\n                bptIndex = uint8(i);\n            } else if (ILinearPool(tokens[i]).getMainToken() == primaryAddress) {\n                primaryIndex = uint8(i);\n            } else {\n                if (secondaryIndex == NOT_FOUND) {\n                    secondaryIndex = uint8(i);\n                } else {\n                    tertiaryIndex = uint8(i);\n                }\n            }\n        }\n\n        require(primaryIndex != NOT_FOUND);\n\n        PRIMARY_INDEX = primaryIndex;\n        SECONDARY_INDEX = secondaryIndex;\n        TERTIARY_INDEX = tertiaryIndex;\n        BPT_INDEX = bptIndex;\n\n        PRIMARY_TOKEN = IERC20(tokens[PRIMARY_INDEX]);\n        SECONDARY_TOKEN = IERC20(tokens[SECONDARY_INDEX]);\n        TERTIARY_TOKEN = IERC20(tokens[TERTIARY_INDEX]);\n\n        uint256 primaryDecimals = IERC20(ILinearPool(address(PRIMARY_TOKEN)).getMainToken()).decimals();\n\n        // Do not allow decimal places greater than 18\n        require(primaryDecimals <= 18);\n        PRIMARY_DECIMALS = uint8(primaryDecimals);\n\n        // If the SECONDARY_TOKEN is ETH, it will be rewritten as WETH\n        uint256 secondaryDecimals = IERC20(ILinearPool(address(SECONDARY_TOKEN)).getMainToken()).decimals();\n\n        // Do not allow decimal places greater than 18\n        require(secondaryDecimals <= 18);\n        SECONDARY_DECIMALS = uint8(secondaryDecimals);\n        \n        // If the TERTIARY_TOKEN is ETH, it will be rewritten as WETH\n        uint256 tertiaryDecimals = IERC20(ILinearPool(address(TERTIARY_TOKEN)).getMainToken()).decimals();\n\n        // Do not allow decimal places greater than 18\n        require(tertiaryDecimals <= 18);\n        TERTIARY_DECIMALS = uint8(tertiaryDecimals);\n    }\n\n    function _underlyingPoolContext(ILinearPool underlyingPool) private view returns (UnderlyingPoolContext memory) {\n        (uint256 lowerTarget, uint256 upperTarget) = underlyingPool.getTargets();\n        uint256 mainIndex = underlyingPool.getMainIndex();\n        uint256 wrappedIndex = underlyingPool.getWrappedIndex();\n\n        (\n            /* address[] memory tokens */,\n            uint256[] memory underlyingBalances,\n            /* uint256 lastChangeBlock */\n        ) = Deployments.BALANCER_VAULT.getPoolTokens(underlyingPool.getPoolId());\n\n        uint256[] memory underlyingScalingFactors = underlyingPool.getScalingFactors();\n        // The wrapped token's scaling factor is not constant, but increases over time as the wrapped token increases in\n        // value.\n        uint256 wrappedScaleFactor = underlyingScalingFactors[mainIndex] * underlyingPool.getWrappedTokenRate() /\n            BalancerConstants.BALANCER_PRECISION;\n\n        return UnderlyingPoolContext({\n            mainScaleFactor: underlyingScalingFactors[mainIndex],\n            mainBalance: underlyingBalances[mainIndex],\n            wrappedScaleFactor: wrappedScaleFactor,\n            wrappedBalance: underlyingBalances[wrappedIndex],\n            virtualSupply: underlyingPool.getVirtualSupply(),\n            fee: underlyingPool.getSwapFeePercentage(),\n            lowerTarget: lowerTarget,\n            upperTarget: upperTarget    \n        });\n    }\n\n    function _boostedOracleContext(uint256[] memory balances) \n        internal view returns (BoostedOracleContext memory boostedPoolContext) {\n        IBoostedPool pool = IBoostedPool(address(BALANCER_POOL_TOKEN));\n\n        (\n            uint256 value,\n            /* bool isUpdating */,\n            uint256 precision\n        ) = pool.getAmplificationParameter();\n        require(precision == StableMath._AMP_PRECISION);\n\n        boostedPoolContext = BoostedOracleContext({\n            ampParam: value,\n            bptBalance: balances[BPT_INDEX],\n            swapFeePercentage: pool.getSwapFeePercentage(),\n            underlyingPools: new UnderlyingPoolContext[](3)\n        });\n\n        boostedPoolContext.underlyingPools[0] = _underlyingPoolContext(ILinearPool(address(PRIMARY_TOKEN)));\n        boostedPoolContext.underlyingPools[1] = _underlyingPoolContext(ILinearPool(address(SECONDARY_TOKEN)));\n        boostedPoolContext.underlyingPools[2] = _underlyingPoolContext(ILinearPool(address(TERTIARY_TOKEN)));\n    }\n\n    function _threeTokenPoolContext(uint256[] memory balances, uint256[] memory scalingFactors) \n        internal view returns (ThreeTokenPoolContext memory) {\n        return ThreeTokenPoolContext({\n            tertiaryToken: address(TERTIARY_TOKEN),\n            tertiaryIndex: TERTIARY_INDEX,\n            tertiaryDecimals: TERTIARY_DECIMALS,\n            tertiaryBalance: balances[TERTIARY_INDEX],\n            tertiaryScaleFactor: scalingFactors[TERTIARY_INDEX],\n            basePool: TwoTokenPoolContext({\n                primaryToken: address(PRIMARY_TOKEN),\n                secondaryToken: address(SECONDARY_TOKEN),\n                primaryIndex: PRIMARY_INDEX,\n                secondaryIndex: SECONDARY_INDEX,\n                primaryDecimals: PRIMARY_DECIMALS,\n                secondaryDecimals: SECONDARY_DECIMALS,\n                primaryBalance: balances[PRIMARY_INDEX],\n                secondaryBalance: balances[SECONDARY_INDEX],\n                primaryScaleFactor: scalingFactors[PRIMARY_INDEX],\n                secondaryScaleFactor: scalingFactors[SECONDARY_INDEX],\n                basePool: _poolContext()\n            })\n        });\n    }\n\n    function _strategyContext() internal view returns (Boosted3TokenAuraStrategyContext memory) {\n        (uint256[] memory balances, uint256[] memory scalingFactors) = _getBalancesAndScaleFactors();\n\n        BoostedOracleContext memory oracleContext = _boostedOracleContext(balances);\n\n        return Boosted3TokenAuraStrategyContext({\n            poolContext: _threeTokenPoolContext(balances, scalingFactors),\n            oracleContext: oracleContext,\n            stakingContext: _auraStakingContext(),\n            baseStrategy: _baseStrategyContext()\n        });\n    }\n\n    function _getBalancesAndScaleFactors() internal view returns (uint256[] memory balances, uint256[] memory scalingFactors) {\n        (\n            /* address[] memory tokens */,\n            balances,\n            /* uint256 lastChangeBlock */\n        ) = Deployments.BALANCER_VAULT.getPoolTokens(BALANCER_POOL_ID);\n\n        scalingFactors = IBalancerPool(address(BALANCER_POOL_TOKEN)).getScalingFactors();\n    }\n\n    uint256[40] private __gap; // Storage gap for future potential upgrades\n}"
    },
    {
      "filename": "pkg/pool-linear/contracts/LinearPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol\";\nimport \"@balancer-labs/v2-interfaces/contracts/pool-utils/BasePoolUserData.sol\";\nimport \"@balancer-labs/v2-interfaces/contracts/pool-utils/IRateProvider.sol\";\nimport \"@balancer-labs/v2-interfaces/contracts/pool-linear/ILinearPool.sol\";\nimport \"@balancer-labs/v2-interfaces/contracts/vault/IGeneralPool.sol\";\n\nimport \"@balancer-labs/v2-pool-utils/contracts/NewBasePool.sol\";\nimport \"@balancer-labs/v2-pool-utils/contracts/rates/PriceRateCache.sol\";\nimport \"@balancer-labs/v2-pool-utils/contracts/lib/PoolRegistrationLib.sol\";\n\nimport \"@balancer-labs/v2-solidity-utils/contracts/helpers/ERC20Helpers.sol\";\nimport \"@balancer-labs/v2-solidity-utils/contracts/helpers/ScalingHelpers.sol\";\nimport \"@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol\";\n\nimport \"./LinearMath.sol\";\n\n/**\n * @dev Linear Pools are designed to hold two assets: \"main\" and \"wrapped\" tokens that have an equal value underlying\n * token (e.g., DAI and waDAI). There must be an external feed available to provide an exact, non-manipulable exchange\n * rate between the tokens. In particular, any reversible manipulation (e.g. causing the rate to increase and then\n * decrease) can lead to severe issues and loss of funds.\n *\n * The Pool will register three tokens in the Vault however: the two assets and the BPT itself,\n * so that BPT can be exchanged (effectively joining and exiting) via swaps.\n *\n * Despite inheriting from BasePool, much of the basic behavior changes. This Pool does not support regular joins\n * and exits, as the initial BPT supply is 'preminted' during initialization. No further BPT can be minted, and BPT can\n * only be burned if governance enables Recovery Mode and LPs use it to exit proportionally.\n *\n * Unlike most other Pools, this one does not attempt to create revenue by charging fees: value is derived by holding\n * the wrapped, yield-bearing asset. However, the 'swap fee percentage' value is still used, albeit with a different\n * meaning. This Pool attempts to hold a certain amount of \"main\" tokens, between a lower and upper target value.\n * The pool charges fees on trades that move the balance outside that range, which are then paid back as incentives to\n * traders whose swaps return the balance to the desired region.\n *\n * The net revenue via fees is expected to be zero: all collected fees are used to pay for this 'rebalancing'.\n * Accordingly, this Pool does not pay any protocol fees.\n */\nabstract contract LinearPool is ILinearPool, IGeneralPool, IRateProvider, NewBasePool {\n    using WordCodec for bytes32;\n    using FixedPoint for uint256;\n    using PriceRateCache for bytes32;\n    using BasePoolUserData for bytes;\n\n    uint256 private constant _TOTAL_TOKENS = 3; // Main token, wrapped token, BPT\n\n    // This is the maximum token amount the Vault can hold. In regular operation, the total BPT supply remains constant\n    // and equal to _INITIAL_BPT_SUPPLY, but most of it remains in the Pool, waiting to be exchanged for tokens. The\n    // actual amount of BPT in circulation is the total supply minus the amount held by the Pool, and is known as the\n    // 'virtual supply'.\n    // The total supply can only change if recovery mode is enabled and recovery mode exits are processed, resulting in\n    // BPT being burned. This BPT can never be minted again, so it is technically possible for the preminted supply to\n    // run out, but a) this process is controlled by Governance via enabling and disabling recovery mode, and b) the\n    // initial supply is so large that it would take a huge number of interactions to acquire sufficient tokens to join\n    // the Pool, and then burn the acquired BPT, resulting in prohibitively large gas costs.\n    uint256 private constant _INITIAL_BPT_SUPPLY = 2**(112) - 1;\n\n    // 1e18 corresponds to 1.0, or a 100% fee\n    uint256 private constant _MIN_SWAP_FEE_PERCENTAGE = 1e12; // 0.0001%\n    uint256 private constant _MAX_SWAP_FEE_PERCENTAGE = 1e17; // 10%\n\n    IERC20 private immutable _mainToken;\n    IERC20 private immutable _wrappedToken;\n\n    // The indices of each token when registered, which can then be used to access the balances array.\n    uint256 private immutable _mainIndex;\n    uint256 private immutable _wrappedIndex;\n\n    // Both BPT and the main token have a regular, constant scaling factor (equal to FixedPoint.ONE for BPT, and\n    // dependent on the number of decimals for the main token). However, the wrapped token's scaling factor has two\n    // components: the usual token decimal scaling factor, and an externally provided rate used to convert wrapped\n    // tokens to an equivalent main token amount. This external rate is expected to be ever increasing, reflecting the\n    // fact that the wrapped token appreciates in value over time (e.g. because it is accruing interest).\n    uint256 private immutable _scalingFactorMainToken;\n    uint256 private immutable _scalingFactorWrappedToken;\n\n    // The lower and upper targets are stored in the pool state field, along with the swap fee percentage and recovery\n    // mode flag, which together take up 64 bits).\n    bytes32 private _poolState;\n\n    // The targets are already scaled by the main token's scaling factor (which makes the token behave as if it had 18\n    // decimals), but we only store the integer part: the targets must be multiplied by 1e18 before being used.\n    // This means the targets' resolution does not include decimal places in the main token (so e.g. a target of 500.1\n    // DAI is impossible). Since targets are expected to be relatively large, this is a non-issue. With 32 bits per\n    // target, we can represent values as high as ~4 billion (2^32).\n    // [   1 bit  |  63 bits  |    32 bits   |    32 bits    | 128 bits ]\n    // [ recovery | swap  fee | upper target |  lower target | reserved ]\n    // [ MSB                                                        LSB ]\n\n    uint256 private constant _TARGET_SCALING = 1e18;\n\n    uint256 private constant _TARGET_BITS = 32;\n\n    uint256 private constant _LOWER_TARGET_OFFSET = 32;\n    uint256 private constant _UPPER_TARGET_OFFSET = 64;\n    uint256 private constant _SWAP_FEE_PERCENTAGE_OFFSET = 192;\n    uint256 private constant _RECOVERY_MODE_BIT_OFFSET = 255;\n\n    // A fee can never be larger than FixedPoint.ONE, which fits in 60 bits, so 63 is more than enough.\n    uint256 private constant _SWAP_FEE_PERCENTAGE_BIT_LENGTH = 63;\n\n    uint256 private constant _MAX_UPPER_TARGET = (2**(32) - 1) * _TARGET_SCALING;\n\n    // Composable Pool registration will put the BPT at index 0, with the main/wrapped following in sorted order.\n    uint256 private constant _BPT_INDEX = 0;\n\n    event SwapFeePercentageChanged(uint256 swapFeePercentage);\n    event TargetsSet(IERC20 indexed token, uint256 lowerTarget, uint256 upperTarget);\n\n    constructor(\n        IVault vault,\n        string memory name,\n        string memory symbol,\n        IERC20 mainToken,\n        IERC20 wrappedToken,\n        uint256 upperTarget,\n        address[] memory assetManagers,\n        uint256 swapFeePercentage,\n        uint256 pauseWindowDuration,\n        uint256 bufferPeriodDuration,\n        address owner\n    )\n        NewBasePool(\n            vault,\n            PoolRegistrationLib.registerComposablePool(\n                vault,\n                IVault.PoolSpecialization.GENERAL,\n                _sortTokens(mainToken, wrappedToken),\n                assetManagers\n            ),\n            name,\n            symbol,\n            pauseWindowDuration,\n            bufferPeriodDuration,\n            owner\n        )\n    {\n        // Set tokens\n        _mainToken = mainToken;\n        _wrappedToken = wrappedToken;\n\n        // Set token indexes. BPT is always 0; other tokens follow in sorted order.\n        _mainIndex = mainToken < wrappedToken ? 1 : 2;\n        _wrappedIndex = mainToken < wrappedToken ? 2 : 1;\n\n        // Set scaling factors\n        _scalingFactorMainToken = _computeScalingFactor(mainToken);\n        _scalingFactorWrappedToken = _computeScalingFactor(wrappedToken);\n\n        // Set initial targets. The lower target must be set to zero because initially there are no accumulated fees.\n        // Otherwise the pool would owe fees from the start, which would make the rate manipulable.\n        uint256 lowerTarget = 0;\n        _setTargets(mainToken, lowerTarget, upperTarget);\n\n        // Set the initial swap fee percentage.\n        _setSwapFeePercentage(swapFeePercentage);\n    }\n\n    /**\n     * @notice Return the main token address as an IERC20.\n     */\n    function getMainToken() public view override returns (IERC20) {\n        return _mainToken;\n    }\n\n    /**\n     * @notice Return the wrapped token address as an IERC20.\n     */\n    function getWrappedToken() public view override returns (IERC20) {\n        return _wrappedToken;\n    }\n\n    /**\n     * @notice Return the index of the BPT token.\n     * @dev Note that this is an index into the registered token list (with 3 tokens).\n     */\n    function getBptIndex() public pure override returns (uint256) {\n        return _BPT_INDEX;\n    }\n\n    /**\n     * @notice Return the index of the main token.\n     * @dev Note that this is an index into the registered token list, which includes the BPT token.\n     */\n    function getMainIndex() external view override returns (uint256) {\n        return _mainIndex;\n    }\n\n    /**\n     * @notice Return the index of the wrapped token.\n     * @dev Note that this is an index into the registered token list, which includes the BPT token.\n     */\n    function getWrappedIndex() external view override returns (uint256) {\n        return _wrappedIndex;\n    }\n\n    /**\n     * @dev Finishes initialization of the Linear Pool: it is unusable before calling this function as no BPT will\n     * have been minted.\n     *\n     * Since Linear Pools have preminted BPT stored in the Vault, they require an initial join to deposit said BPT as\n     * their balance. Unfortunately, this cannot be performed during construction, as a join involves calling the\n     * `onJoinPool` function on the Pool, and the Pool will not have any code until construction finishes. Therefore,\n     * this must happen in a separate call.\n     *\n     * It is highly recommended to create Linear pools using the LinearPoolFactory, which calls `initialize`\n     * automatically.\n     */\n    function initialize() external {\n        bytes32 poolId = getPoolId();\n        (IERC20[] memory tokens, , ) = getVault().getPoolTokens(poolId);\n\n        // Joins typically involve the Pool receiving tokens in exchange for newly-minted BPT. In this case however, the\n        // Pool will mint the entire BPT supply to itself, and join itself with it.\n        uint256[] memory maxAmountsIn = new uint256[](_TOTAL_TOKENS);\n        maxAmountsIn[_BPT_INDEX] = _INITIAL_BPT_SUPPLY;\n\n        // The first time this executes, it will call `_onInitializePool` (as the BPT supply will be zero). Future calls\n        // will be routed to `_onJoinPool`, which always reverts, meaning `initialize` will only execute once.\n        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({\n            assets: _asIAsset(tokens),\n            maxAmountsIn: maxAmountsIn,\n            userData: \"\",\n            fromInternalBalance: false\n        });\n\n        getVault().joinPool(poolId, address(this), address(this), request);\n    }\n\n    /**\n     * @dev Implement the BasePool hook for a general swap (see `IGeneralPool`).\n     */\n    function _onSwapGeneral(\n        SwapRequest memory request,\n        uint256[] memory balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) internal view override returns (uint256) {\n        // In most Pools, swaps involve exchanging one token held by the Pool for another. In this case however, since\n        // one of the three tokens is the BPT itself, a swap might also be a join (main/wrapped for BPT) or an exit\n        // (BPT for main/wrapped).\n        // All three swap types (swaps, joins and exits) are fully disabled if the emergency pause is enabled. Under\n        // these circumstances, the Pool can only be exited using Recovery Mode, if it is enabled.\n\n        // Sanity check: this is not entirely necessary as the Vault's interface enforces the indices to be valid, but\n        // the check is cheap to perform.\n        _require(indexIn < _TOTAL_TOKENS && indexOut < _TOTAL_TOKENS, Errors.OUT_OF_BOUNDS);\n\n        // Note that we already know the indices of the main token, wrapped token and BPT, so there is no need to pass\n        // these indices to the inner functions.\n\n        // Upscale balances by the scaling factors (taking into account the wrapped token rate)\n        uint256[] memory scalingFactors = getScalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 lowerTarget, uint256 upperTarget) = getTargets();\n        LinearMath.Params memory params = LinearMath.Params({\n            fee: getSwapFeePercentage(),\n            lowerTarget: lowerTarget,\n            upperTarget: upperTarget\n        });\n\n        if (request.kind == IVault.SwapKind.GIVEN_IN) {\n            // The amount given is for token in, the amount calculated is for token out\n            request.amount = _upscale(request.amount, scalingFactors[indexIn]);\n            uint256 amountOut = _onSwapGivenIn(request, balances, params);\n\n            // amountOut tokens are exiting the Pool, so we round down.\n            return _downscaleDown(amountOut, scalingFactors[indexOut]);\n        } else {\n            // The amount given is for token out, the amount calculated is for token in\n            request.amount = _upscale(request.amount, scalingFactors[indexOut]);\n            uint256 amountIn = _onSwapGivenOut(request, balances, params);\n\n            // amountIn tokens are entering the Pool, so we round up.\n            return _downscaleUp(amountIn, scalingFactors[indexIn]);\n        }\n    }\n\n    function _onSwapGivenIn(\n        SwapRequest memory request,\n        uint256[] memory balances,\n        LinearMath.Params memory params\n    ) internal view returns (uint256) {\n        if (request.tokenIn == this) {\n            return _swapGivenBptIn(request, balances, params);\n        } else if (request.tokenIn == _mainToken) {\n            return _swapGivenMainIn(request, balances, params);\n        } else if (request.tokenIn == _wrappedToken) {\n            return _swapGivenWrappedIn(request, balances, params);\n        } else {\n            _revert(Errors.INVALID_TOKEN);\n        }\n    }\n\n    function _swapGivenBptIn(\n        SwapRequest memory request,\n        uint256[] memory balances,\n        LinearMath.Params memory params\n    ) internal view returns (uint256) {\n        _require(request.tokenOut == _mainToken || request.tokenOut == _wrappedToken, Errors.INVALID_TOKEN);\n        return\n            (request.tokenOut == _mainToken ? LinearMath._calcMainOutPerBptIn : LinearMath._calcWrappedOutPerBptIn)(\n                request.amount,\n                balances[_mainIndex],\n                balances[_wrappedIndex],\n                _getVirtualSupply(balances[_BPT_INDEX]),\n                params\n            );\n    }\n\n    function _swapGivenMainIn(\n        SwapRequest memory request,\n        uint256[] memory balances,\n        LinearMath.Params memory params\n    ) internal view returns (uint256) {\n        _require(request.tokenOut == _wrappedToken || request.tokenOut == this, Errors.INVALID_TOKEN);\n        return\n            request.tokenOut == this\n                ? LinearMath._calcBptOutPerMainIn(\n                    request.amount,\n                    balances[_mainIndex],\n                    balances[_wrappedIndex],\n                    _getVirtualSupply(balances[_BPT_INDEX]),\n                    params\n                )\n                : LinearMath._calcWrappedOutPerMainIn(request.amount, balances[_mainIndex], params);\n    }\n\n    function _swapGivenWrappedIn(\n        SwapRequest memory request,\n        uint256[] memory balances,\n        LinearMath.Params memory params\n    ) internal view returns (uint256) {\n        _require(request.tokenOut == _mainToken || request.tokenOut == this, Errors.INVALID_TOKEN);\n        return\n            request.tokenOut == this\n                ? LinearMath._calcBptOutPerWrappedIn(\n                    request.amount,\n                    balances[_mainIndex],\n                    balances[_wrappedIndex],\n                    _getVirtualSupply(balances[_BPT_INDEX]),\n                    params\n                )\n                : LinearMath._calcMainOutPerWrappedIn(request.amount, balances[_mainIndex], params);\n    }\n\n    function _onSwapGivenOut(\n        SwapRequest memory request,\n        uint256[] memory balances,\n        LinearMath.Params memory params\n    ) internal view returns (uint256) {\n        if (request.tokenOut == this) {\n            return _swapGivenBptOut(request, balances, params);\n        } else if (request.tokenOut == _mainToken) {\n            return _swapGivenMainOut(request, balances, params);\n        } else if (request.tokenOut == _wrappedToken) {\n            return _swapGivenWrappedOut(request, balances, params);\n        } else {\n            _revert(Errors.INVALID_TOKEN);\n        }\n    }\n\n    function _swapGivenBptOut(\n        SwapRequest memory request,\n        uint256[] memory balances,\n        LinearMath.Params memory params\n    ) internal view returns (uint256) {\n        _require(request.tokenIn == _mainToken || request.tokenIn == _wrappedToken, Errors.INVALID_TOKEN);\n        return\n            (request.tokenIn == _mainToken ? LinearMath._calcMainInPerBptOut : LinearMath._calcWrappedInPerBptOut)(\n                request.amount,\n                balances[_mainIndex],\n                balances[_wrappedIndex],\n                _getVirtualSupply(balances[_BPT_INDEX]),\n                params\n            );\n    }\n\n    function _swapGivenMainOut(\n        SwapRequest memory request,\n        uint256[] memory balances,\n        LinearMath.Params memory params\n    ) internal view returns (uint256) {\n        _require(request.tokenIn == _wrappedToken || request.tokenIn == this, Errors.INVALID_TOKEN);\n        return\n            request.tokenIn == this\n                ? LinearMath._calcBptInPerMainOut(\n                    request.amount,\n                    balances[_mainIndex],\n                    balances[_wrappedIndex],\n                    _getVirtualSupply(balances[_BPT_INDEX]),\n                    params\n                )\n                : LinearMath._calcWrappedInPerMainOut(request.amount, balances[_mainIndex], params);\n    }\n\n    function _swapGivenWrappedOut(\n        SwapRequest memory request,\n        uint256[] memory balances,\n        LinearMath.Params memory params\n    ) internal view returns (uint256) {\n        _require(request.tokenIn == _mainToken || request.tokenIn == this, Errors.INVALID_TOKEN);\n        return\n            request.tokenIn == this\n                ? LinearMath._calcBptInPerWrappedOut(\n                    request.amount,\n                    balances[_mainIndex],\n                    balances[_wrappedIndex],\n                    _getVirtualSupply(balances[_BPT_INDEX]),\n                    params\n                )\n                : LinearMath._calcMainInPerWrappedOut(request.amount, balances[_mainIndex], params);\n    }\n\n    function _onInitializePool(\n        address sender,\n        address recipient,\n        bytes memory\n    ) internal view override returns (uint256, uint256[] memory) {\n        // Linear Pools can only be initialized by the Pool performing the initial join via the `initialize` function.\n        _require(sender == address(this), Errors.INVALID_INITIALIZATION);\n        _require(recipient == address(this), Errors.INVALID_INITIALIZATION);\n\n        // The full BPT supply will be minted and deposited in the Pool. Note that there is no need to approve the Vault\n        // as it already has infinite BPT allowance.\n        uint256 bptAmountOut = _INITIAL_BPT_SUPPLY;\n\n        uint256[] memory amountsIn = new uint256[](_TOTAL_TOKENS);\n        amountsIn[_BPT_INDEX] = _INITIAL_BPT_SUPPLY;\n\n        return (bptAmountOut, amountsIn);\n    }\n\n    function _onSwapMinimal(\n        SwapRequest memory,\n        uint256,\n        uint256\n    ) internal pure override returns (uint256) {\n        _revert(Errors.UNIMPLEMENTED);\n    }\n\n    function _onJoinPool(\n        address,\n        uint256[] memory,\n        bytes memory\n    ) internal pure override returns (uint256, uint256[] memory) {\n        _revert(Errors.UNIMPLEMENTED);\n    }\n\n    function _onExitPool(\n        address,\n        uint256[] memory,\n        bytes memory\n    ) internal pure override returns (uint256, uint256[] memory) {\n        _revert(Errors.UNIMPLEMENTED);\n    }\n\n    function _doRecoveryModeExit(\n        uint256[] memory registeredBalances,\n        uint256,\n        bytes memory userData\n    ) internal view override returns (uint256, uint256[] memory) {\n        uint256 bptAmountIn = userData.recoveryModeExit();\n        uint256[] memory amountsOut = new uint256[](registeredBalances.length);\n\n        uint256 bptIndex = getBptIndex();\n\n        uint256 virtualSupply = _getVirtualSupply(registeredBalances[bptIndex]);\n        uint256 bptRatio = bptAmountIn.divDown(virtualSupply);\n\n        for (uint256 i = 0; i < registeredBalances.length; i++) {\n            amountsOut[i] = i != bptIndex ? registeredBalances[i].mulDown(bptRatio) : 0;\n        }\n\n        return (bptAmountIn, amountsOut);\n    }\n\n    function _getMinimumBpt() internal pure override returns (uint256) {\n        // Linear Pools don't lock any BPT, as the total supply will already be forever non-zero due to the preminting\n        // mechanism, ensuring initialization only occurs once.\n        return 0;\n    }\n\n    // Scaling factors\n\n    function _scalingFactor(IERC20 token) internal view virtual returns (uint256) {\n        if (token == _mainToken) {\n            return _scalingFactorMainToken;\n        } else if (token == _wrappedToken) {\n            // The wrapped token's scaling factor is not constant, but increases over time as the wrapped token\n            // increases in value.\n            return _scalingFactorWrappedToken.mulDown(_getWrappedTokenRate());\n        } else if (token == this) {\n            return FixedPoint.ONE;\n        } else {\n            _revert(Errors.INVALID_TOKEN);\n        }\n    }\n\n    /**\n     * @notice Return the scaling factors for all tokens, including the BPT.\n     */\n    function getScalingFactors() public view virtual override returns (uint256[] memory) {\n        uint256[] memory scalingFactors = new uint256[](_TOTAL_TOKENS);\n\n        // The wrapped token's scaling factor is not constant, but increases over time as the wrapped token increases in\n        // value.\n        scalingFactors[_mainIndex] = _scalingFactorMainToken;\n        scalingFactors[_wrappedIndex] = _scalingFactorWrappedToken.mulDown(_getWrappedTokenRate());\n        scalingFactors[_BPT_INDEX] = FixedPoint.ONE;\n\n        return scalingFactors;\n    }\n\n    // Price rates\n\n    /**\n     * @dev For a Linear Pool, the rate"
    }
  ]
}