{
  "Title": "Missing docstrings [core and samples]",
  "Content": "Throughout the [codebase](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/) there are several parts that do not have docstrings. For instance:\n\n\n* [Line 24](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol#L23-L24) in [`BLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol)\n* [Line 39](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol#L38-L39) in [`BLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol)\n* [Line 44](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol#L43-L44) in [`BLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol)\n* [Line 48](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol#L47-L48) in [`BLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol)\n* [Line 20](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L19-L20) in [`BLSSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol)\n* [Line 48](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L46-L48) in [`BLSSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol)\n* [Line 106](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L105-L106) in [`BLSSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol)\n* [Line 10](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/IBLSAccount.sol#L10) in [`IBLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/IBLSAccount.sol)\n* [Line 24](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol#L23-L24) in [`BasePaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol)\n* [Line 29](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol#L27-L29) in [`BasePaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol)\n* [Line 31](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol#L30-L31) in [`BasePaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol)\n* [Line 167](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L166-L167) in [`EntryPoint.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol)\n* [Line 18](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/StakeManager.sol#L17-L18) in [`StakeManager.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/StakeManager.sol)\n* [Line 11](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Fallback.sol#L10-L11) in [`EIP4337Fallback.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Fallback.sol)\n* [Line 23](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/GnosisAccountFactory.sol#L22-L23) in [`GnosisAccountFactory.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/GnosisAccountFactory.sol)\n* [Line 67](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L66-L67) in [`IStakeManager.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol)\n* [Line 34](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/UserOperation.sol#L33-L34) in [`UserOperation.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/UserOperation.sol)\n* [Line 73](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/DepositPaymaster.sol#L72-L73) in [`DepositPaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/DepositPaymaster.sol)\n* [Line 27](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L26-L27) in [`SimpleAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol)\n* [Line 31](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L30-L31) in [`SimpleAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol)\n* [Line 23](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestAggregatedAccount.sol#L22-L23) in [`TestAggregatedAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestAggregatedAccount.sol)\n* [Line 34](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestAggregatedAccount.sol#L33-L34) in [`TestAggregatedAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestAggregatedAccount.sol)\n* [Line 16](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol#L15-L16) in [`TestSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol)\n* [Line 28](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol#L26-L28) in [`TestSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol)\n* [Line 43](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol#L42-L43) in [`TestSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol)\n* [Line 40](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TokenPaymaster.sol#L37-L40) in [`TokenPaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TokenPaymaster.sol)\n* [Line 6](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/utils/Exec.sol#L3-L6) in [`Exec.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/utils/Exec.sol)\n\n\nConsider thoroughly documenting all functions and their parameters, especially public APIs. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Partially resolved in [pull request #212](https://github.com/eth-infinitism/account-abstraction/pull/212) and merged at commit [`eeb93b2`](https://github.com/eth-infinitism/account-abstraction/commit/eeb93b25804a748519245df34c4162fddf9a8fd1). The recommended changes to `GnosisAccountFactory.sol` were not implemented.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/bls/BLSAccount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"../samples/SimpleAccount.sol\";\nimport \"./IBLSAccount.sol\";\n\n/**\n * Minimal BLS-based account that uses an aggregated signature.\n * The account must maintain its own BLS public-key, and expose its trusted signature aggregator.\n * Note that unlike the \"standard\" SimpleAccount, this account can't be called directly\n * (normal SimpleAccount uses its \"signer\" address as both the ecrecover signer, and as a legitimate\n * Ethereum sender address. Obviously, a BLS public is not a valid Ethereum sender address.)\n */\ncontract BLSAccount is SimpleAccount, IBLSAccount {\n    address public immutable aggregator;\n    uint256[4] private publicKey;\n\n    // The constructor is used only for the \"implementation\" and only sets immutable values.\n    // Mutable values slots for proxy accounts are set by the 'initialize' function.\n    constructor(IEntryPoint anEntryPoint, address anAggregator) SimpleAccount(anEntryPoint)  {\n        aggregator = anAggregator;\n    }\n\n    function initialize(uint256[4] memory aPublicKey) public virtual initializer {\n        super._initialize(address(0));\n        publicKey = aPublicKey;\n    }\n\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address userOpAggregator)\n    internal override view returns (uint256 sigTimeRange) {\n\n        (userOp, userOpHash);\n        require(userOpAggregator == aggregator, \"BLSAccount: wrong aggregator\");\n        return 0;\n    }\n\n    event PublicKeyChanged(uint256[4] oldPublicKey, uint256[4] newPublicKey);\n\n    function setBlsPublicKey(uint256[4] memory newPublicKey) external onlyOwner {\n        emit PublicKeyChanged(publicKey, newPublicKey);\n        publicKey = newPublicKey;\n    }\n\n    function getAggregator() external view returns (address) {\n        return aggregator;\n    }\n\n    function getBlsPublicKey() external override view returns (uint256[4] memory) {\n        return publicKey;\n    }\n}"
    },
    {
      "filename": "contracts/bls/BLSAccount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"../samples/SimpleAccount.sol\";\nimport \"./IBLSAccount.sol\";\n\n/**\n * Minimal BLS-based account that uses an aggregated signature.\n * The account must maintain its own BLS public-key, and expose its trusted signature aggregator.\n * Note that unlike the \"standard\" SimpleAccount, this account can't be called directly\n * (normal SimpleAccount uses its \"signer\" address as both the ecrecover signer, and as a legitimate\n * Ethereum sender address. Obviously, a BLS public is not a valid Ethereum sender address.)\n */\ncontract BLSAccount is SimpleAccount, IBLSAccount {\n    address public immutable aggregator;\n    uint256[4] private publicKey;\n\n    // The constructor is used only for the \"implementation\" and only sets immutable values.\n    // Mutable values slots for proxy accounts are set by the 'initialize' function.\n    constructor(IEntryPoint anEntryPoint, address anAggregator) SimpleAccount(anEntryPoint)  {\n        aggregator = anAggregator;\n    }\n\n    function initialize(uint256[4] memory aPublicKey) public virtual initializer {\n        super._initialize(address(0));\n        publicKey = aPublicKey;\n    }\n\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address userOpAggregator)\n    internal override view returns (uint256 sigTimeRange) {\n\n        (userOp, userOpHash);\n        require(userOpAggregator == aggregator, \"BLSAccount: wrong aggregator\");\n        return 0;\n    }\n\n    event PublicKeyChanged(uint256[4] oldPublicKey, uint256[4] newPublicKey);\n\n    function setBlsPublicKey(uint256[4] memory newPublicKey) external onlyOwner {\n        emit PublicKeyChanged(publicKey, newPublicKey);\n        publicKey = newPublicKey;\n    }\n\n    function getAggregator() external view returns (address) {\n        return aggregator;\n    }\n\n    function getBlsPublicKey() external override view returns (uint256[4] memory) {\n        return publicKey;\n    }\n}"
    },
    {
      "filename": "contracts/bls/BLSAccount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"../samples/SimpleAccount.sol\";\nimport \"./IBLSAccount.sol\";\n\n/**\n * Minimal BLS-based account that uses an aggregated signature.\n * The account must maintain its own BLS public-key, and expose its trusted signature aggregator.\n * Note that unlike the \"standard\" SimpleAccount, this account can't be called directly\n * (normal SimpleAccount uses its \"signer\" address as both the ecrecover signer, and as a legitimate\n * Ethereum sender address. Obviously, a BLS public is not a valid Ethereum sender address.)\n */\ncontract BLSAccount is SimpleAccount, IBLSAccount {\n    address public immutable aggregator;\n    uint256[4] private publicKey;\n\n    // The constructor is used only for the \"implementation\" and only sets immutable values.\n    // Mutable values slots for proxy accounts are set by the 'initialize' function.\n    constructor(IEntryPoint anEntryPoint, address anAggregator) SimpleAccount(anEntryPoint)  {\n        aggregator = anAggregator;\n    }\n\n    function initialize(uint256[4] memory aPublicKey) public virtual initializer {\n        super._initialize(address(0));\n        publicKey = aPublicKey;\n    }\n\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address userOpAggregator)\n    internal override view returns (uint256 sigTimeRange) {\n\n        (userOp, userOpHash);\n        require(userOpAggregator == aggregator, \"BLSAccount: wrong aggregator\");\n        return 0;\n    }\n\n    event PublicKeyChanged(uint256[4] oldPublicKey, uint256[4] newPublicKey);\n\n    function setBlsPublicKey(uint256[4] memory newPublicKey) external onlyOwner {\n        emit PublicKeyChanged(publicKey, newPublicKey);\n        publicKey = newPublicKey;\n    }\n\n    function getAggregator() external view returns (address) {\n        return aggregator;\n    }\n\n    function getBlsPublicKey() external override view returns (uint256[4] memory) {\n        return publicKey;\n    }\n}"
    },
    {
      "filename": "contracts/bls/BLSAccount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"../samples/SimpleAccount.sol\";\nimport \"./IBLSAccount.sol\";\n\n/**\n * Minimal BLS-based account that uses an aggregated signature.\n * The account must maintain its own BLS public-key, and expose its trusted signature aggregator.\n * Note that unlike the \"standard\" SimpleAccount, this account can't be called directly\n * (normal SimpleAccount uses its \"signer\" address as both the ecrecover signer, and as a legitimate\n * Ethereum sender address. Obviously, a BLS public is not a valid Ethereum sender address.)\n */\ncontract BLSAccount is SimpleAccount, IBLSAccount {\n    address public immutable aggregator;\n    uint256[4] private publicKey;\n\n    // The constructor is used only for the \"implementation\" and only sets immutable values.\n    // Mutable values slots for proxy accounts are set by the 'initialize' function.\n    constructor(IEntryPoint anEntryPoint, address anAggregator) SimpleAccount(anEntryPoint)  {\n        aggregator = anAggregator;\n    }\n\n    function initialize(uint256[4] memory aPublicKey) public virtual initializer {\n        super._initialize(address(0));\n        publicKey = aPublicKey;\n    }\n\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address userOpAggregator)\n    internal override view returns (uint256 sigTimeRange) {\n\n        (userOp, userOpHash);\n        require(userOpAggregator == aggregator, \"BLSAccount: wrong aggregator\");\n        return 0;\n    }\n\n    event PublicKeyChanged(uint256[4] oldPublicKey, uint256[4] newPublicKey);\n\n    function setBlsPublicKey(uint256[4] memory newPublicKey) external onlyOwner {\n        emit PublicKeyChanged(publicKey, newPublicKey);\n        publicKey = newPublicKey;\n    }\n\n    function getAggregator() external view returns (address) {\n        return aggregator;\n    }\n\n    function getBlsPublicKey() external override view returns (uint256[4] memory) {\n        return publicKey;\n    }\n}"
    },
    {
      "filename": "contracts/bls/BLSSignatureAggregator.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4 <0.9.0;\npragma abicoder v2;\n\nimport \"../interfaces/IAggregator.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport {BLSOpen} from  \"./lib/BLSOpen.sol\";\nimport \"./IBLSAccount.sol\";\nimport \"./BLSHelper.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * A BLS-based signature aggregator, to validate aggregated signature of multiple UserOps if BLSAccount\n */\ncontract BLSSignatureAggregator is IAggregator {\n    using UserOperationLib for UserOperation;\n\n    bytes32 public constant BLS_DOMAIN = keccak256(\"eip4337.bls.domain\");\n\n    function getUserOpPublicKey(UserOperation memory userOp) public view returns (uint256[4] memory publicKey) {\n        bytes memory initCode = userOp.initCode;\n        if (initCode.length > 0) {\n            publicKey = getTrailingPublicKey(initCode);\n        } else {\n            return IBLSAccount(userOp.sender).getBlsPublicKey();\n        }\n    }\n\n    /**\n     * return the trailing 4 words of input data\n     */\n    function getTrailingPublicKey(bytes memory data) public pure returns (uint256[4] memory publicKey) {\n        uint len = data.length;\n        require(len > 32 * 4, \"data to short for sig\");\n\n        /* solhint-disable-next-line no-inline-assembly */\n        assembly {\n        // actual buffer starts at data+32, so last 128 bytes start at data+32+len-128 = data+len-96\n            let ofs := sub(add(data, len), 96)\n            mstore(publicKey, mload(ofs))\n            mstore(add(publicKey, 32), mload(add(ofs, 32)))\n            mstore(add(publicKey, 64), mload(add(ofs, 64)))\n            mstore(add(publicKey, 96), mload(add(ofs, 96)))\n        }\n    }\n\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature)\n    external view override {\n        require(signature.length == 64, \"BLS: invalid signature\");\n        (uint256[2] memory blsSignature) = abi.decode(signature, (uint256[2]));\n\n        uint userOpsLen = userOps.length;\n        uint256[4][] memory blsPublicKeys = new uint256[4][](userOpsLen);\n        uint256[2][] memory messages = new uint256[2][](userOpsLen);\n        for (uint256 i = 0; i < userOpsLen; i++) {\n\n            UserOperation memory userOp = userOps[i];\n            IBLSAccount blsAccount = IBLSAccount(userOp.sender);\n\n            blsPublicKeys[i] = blsAccount.getBlsPublicKey{gas : 30000}();\n\n            messages[i] = _userOpToMessage(userOp, keccak256(abi.encode(blsPublicKeys[i])));\n        }\n        require(BLSOpen.verifyMultiple(blsSignature, blsPublicKeys, messages), \"BLS: validateSignatures failed\");\n    }\n\n    /**\n     * get a hash of userOp\n     * NOTE: this hash is not the same as UserOperation.hash()\n     *  (slightly less efficient, since it uses memory userOp)\n     */\n    function internalUserOpHash(UserOperation memory userOp) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n                userOp.sender,\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.callGasLimit,\n                userOp.verificationGasLimit,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas,\n                keccak256(userOp.paymasterAndData)\n            ));\n    }\n\n    /**\n     * return the BLS \"message\" for the given UserOp.\n     * the account checks the signature over this value  using its public-key\n     */\n    function userOpToMessage(UserOperation memory userOp) public view returns (uint256[2] memory) {\n        bytes32 hashPublicKey = _getUserOpPubkeyHash(userOp);\n        return _userOpToMessage(userOp, hashPublicKey);\n    }\n\n    function _userOpToMessage(UserOperation memory userOp, bytes32 publicKeyHash) internal view returns (uint256[2] memory) {\n        bytes32 userOpHash = _getUserOpHash(userOp, publicKeyHash);\n        return BLSOpen.hashToPoint(BLS_DOMAIN, abi.encodePacked(userOpHash));\n    }\n\n    //return the public-key hash of a userOp.\n    function _getUserOpPubkeyHash(UserOperation memory userOp) internal view returns (bytes32 hashPublicKey) {\n        return keccak256(abi.encode(getUserOpPublicKey(userOp)));\n    }\n\n    function getUserOpHash(UserOperation memory userOp) public view returns (bytes32) {\n        bytes32 hashPublicKey = _getUserOpPubkeyHash(userOp);\n        return _getUserOpHash(userOp, hashPublicKey);\n    }\n\n    function _getUserOpHash(UserOperation memory userOp, bytes32 hashPublicKey) internal view returns (bytes32) {\n        return keccak256(abi.encode(internalUserOpHash(userOp), hashPublicKey, address(this), block.chainid));\n    }\n\n    /**\n     * validate signature of a single userOp\n     * This method is called after EntryPoint.simulateUserOperation() returns an aggregator.\n     * First it validates the signature over the userOp. then it return data to be used when creating the handleOps:\n     * @param userOp the userOperation received from the user.\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\n     */\n    function validateUserOpSignature(UserOperation calldata userOp)\n    external view returns (bytes memory sigForUserOp) {\n        uint256[2] memory signature = abi.decode(userOp.signature, (uint256[2]));\n        uint256[4] memory pubkey = getUserOpPublicKey(userOp);\n        uint256[2] memory message = userOpToMessage(userOp);\n\n        require(BLSOpen.verifySingle(signature, pubkey, message), \"BLS: wrong sig\");\n        return \"\";\n    }\n\n    //copied from BLS.sol\n    uint256 public  constant N = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    /**\n     * aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation\n     * @param userOps array of UserOperations to collect the signatures from.\n     * @return aggregatesSignature the aggregated signature\n     */\n    function aggregateSignatures(UserOperation[] calldata userOps) external pure returns (bytes memory aggregatesSignature) {\n        BLSHelper.XY[] memory points = new BLSHelper.XY[](userOps.length);\n        for (uint i = 0; i < points.length; i++) {\n            (uint x, uint y) = abi.decode(userOps[i].signature, (uint, uint));\n            points[i] = BLSHelper.XY(x, y);\n        }\n        BLSHelper.XY memory sum = BLSHelper.sum(points, N);\n        return abi.encode(sum.x, sum.y);\n    }\n\n    /**\n     * allow staking for this aggregator\n     * there is no limit on stake  or delay, but it is not a problem, since it is a permissionless\n     * signature aggregator, which doesn't support unstaking.\n     */\n    function addStake(IEntryPoint entryPoint, uint32 delay) external payable {\n        entryPoint.addStake{value : msg.value}(delay);\n    }\n}"
    },
    {
      "filename": "contracts/bls/BLSSignatureAggregator.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4 <0.9.0;\npragma abicoder v2;\n\nimport \"../interfaces/IAggregator.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport {BLSOpen} from  \"./lib/BLSOpen.sol\";\nimport \"./IBLSAccount.sol\";\nimport \"./BLSHelper.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * A BLS-based signature aggregator, to validate aggregated signature of multiple UserOps if BLSAccount\n */\ncontract BLSSignatureAggregator is IAggregator {\n    using UserOperationLib for UserOperation;\n\n    bytes32 public constant BLS_DOMAIN = keccak256(\"eip4337.bls.domain\");\n\n    function getUserOpPublicKey(UserOperation memory userOp) public view returns (uint256[4] memory publicKey) {\n        bytes memory initCode = userOp.initCode;\n        if (initCode.length > 0) {\n            publicKey = getTrailingPublicKey(initCode);\n        } else {\n            return IBLSAccount(userOp.sender).getBlsPublicKey();\n        }\n    }\n\n    /**\n     * return the trailing 4 words of input data\n     */\n    function getTrailingPublicKey(bytes memory data) public pure returns (uint256[4] memory publicKey) {\n        uint len = data.length;\n        require(len > 32 * 4, \"data to short for sig\");\n\n        /* solhint-disable-next-line no-inline-assembly */\n        assembly {\n        // actual buffer starts at data+32, so last 128 bytes start at data+32+len-128 = data+len-96\n            let ofs := sub(add(data, len), 96)\n            mstore(publicKey, mload(ofs))\n            mstore(add(publicKey, 32), mload(add(ofs, 32)))\n            mstore(add(publicKey, 64), mload(add(ofs, 64)))\n            mstore(add(publicKey, 96), mload(add(ofs, 96)))\n        }\n    }\n\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature)\n    external view override {\n        require(signature.length == 64, \"BLS: invalid signature\");\n        (uint256[2] memory blsSignature) = abi.decode(signature, (uint256[2]));\n\n        uint userOpsLen = userOps.length;\n        uint256[4][] memory blsPublicKeys = new uint256[4][](userOpsLen);\n        uint256[2][] memory messages = new uint256[2][](userOpsLen);\n        for (uint256 i = 0; i < userOpsLen; i++) {\n\n            UserOperation memory userOp = userOps[i];\n            IBLSAccount blsAccount = IBLSAccount(userOp.sender);\n\n            blsPublicKeys[i] = blsAccount.getBlsPublicKey{gas : 30000}();\n\n            messages[i] = _userOpToMessage(userOp, keccak256(abi.encode(blsPublicKeys[i])));\n        }\n        require(BLSOpen.verifyMultiple(blsSignature, blsPublicKeys, messages), \"BLS: validateSignatures failed\");\n    }\n\n    /**\n     * get a hash of userOp\n     * NOTE: this hash is not the same as UserOperation.hash()\n     *  (slightly less efficient, since it uses memory userOp)\n     */\n    function internalUserOpHash(UserOperation memory userOp) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n                userOp.sender,\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.callGasLimit,\n                userOp.verificationGasLimit,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas,\n                keccak256(userOp.paymasterAndData)\n            ));\n    }\n\n    /**\n     * return the BLS \"message\" for the given UserOp.\n     * the account checks the signature over this value  using its public-key\n     */\n    function userOpToMessage(UserOperation memory userOp) public view returns (uint256[2] memory) {\n        bytes32 hashPublicKey = _getUserOpPubkeyHash(userOp);\n        return _userOpToMessage(userOp, hashPublicKey);\n    }\n\n    function _userOpToMessage(UserOperation memory userOp, bytes32 publicKeyHash) internal view returns (uint256[2] memory) {\n        bytes32 userOpHash = _getUserOpHash(userOp, publicKeyHash);\n        return BLSOpen.hashToPoint(BLS_DOMAIN, abi.encodePacked(userOpHash));\n    }\n\n    //return the public-key hash of a userOp.\n    function _getUserOpPubkeyHash(UserOperation memory userOp) internal view returns (bytes32 hashPublicKey) {\n        return keccak256(abi.encode(getUserOpPublicKey(userOp)));\n    }\n\n    function getUserOpHash(UserOperation memory userOp) public view returns (bytes32) {\n        bytes32 hashPublicKey = _getUserOpPubkeyHash(userOp);\n        return _getUserOpHash(userOp, hashPublicKey);\n    }\n\n    function _getUserOpHash(UserOperation memory userOp, bytes32 hashPublicKey) internal view returns (bytes32) {\n        return keccak256(abi.encode(internalUserOpHash(userOp), hashPublicKey, address(this), block.chainid));\n    }\n\n    /**\n     * validate signature of a single userOp\n     * This method is called after EntryPoint.simulateUserOperation() returns an aggregator.\n     * First it validates the signature over the userOp. then it return data to be used when creating the handleOps:\n     * @param userOp the userOperation received from the user.\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\n     */\n    function validateUserOpSignature(UserOperation calldata userOp)\n    external view returns (bytes memory sigForUserOp) {\n        uint256[2] memory signature = abi.decode(userOp.signature, (uint256[2]));\n        uint256[4] memory pubkey = getUserOpPublicKey(userOp);\n        uint256[2] memory message = userOpToMessage(userOp);\n\n        require(BLSOpen.verifySingle(signature, pubkey, message), \"BLS: wrong sig\");\n        return \"\";\n    }\n\n    //copied from BLS.sol\n    uint256 public  constant N = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    /**\n     * aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation\n     * @param userOps array of UserOperations to collect the signatures from.\n     * @return aggregatesSignature the aggregated signature\n     */\n    function aggregateSignatures(UserOperation[] calldata userOps) external pure returns (bytes memory aggregatesSignature) {\n        BLSHelper.XY[] memory points = new BLSHelper.XY[](userOps.length);\n        for (uint i = 0; i < points.length; i++) {\n            (uint x, uint y) = abi.decode(userOps[i].signature, (uint, uint));\n            points[i] = BLSHelper.XY(x, y);\n        }\n        BLSHelper.XY memory sum = BLSHelper.sum(points, N);\n        return abi.encode(sum.x, sum.y);\n    }\n\n    /**\n     * allow staking for this aggregator\n     * there is no limit on stake  or delay, but it is not a problem, since it is a permissionless\n     * signature aggregator, which doesn't support unstaking.\n     */\n    function addStake(IEntryPoint entryPoint, uint32 delay) external payable {\n        entryPoint.addStake{value : msg.value}(delay);\n    }\n}"
    },
    {
      "filename": "contracts/bls/BLSSignatureAggregator.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4 <0.9.0;\npragma abicoder v2;\n\nimport \"../interfaces/IAggregator.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport {BLSOpen} from  \"./lib/BLSOpen.sol\";\nimport \"./IBLSAccount.sol\";\nimport \"./BLSHelper.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * A BLS-based signature aggregator, to validate aggregated signature of multiple UserOps if BLSAccount\n */\ncontract BLSSignatureAggregator is IAggregator {\n    using UserOperationLib for UserOperation;\n\n    bytes32 public constant BLS_DOMAIN = keccak256(\"eip4337.bls.domain\");\n\n    function getUserOpPublicKey(UserOperation memory userOp) public view returns (uint256[4] memory publicKey) {\n        bytes memory initCode = userOp.initCode;\n        if (initCode.length > 0) {\n            publicKey = getTrailingPublicKey(initCode);\n        } else {\n            return IBLSAccount(userOp.sender).getBlsPublicKey();\n        }\n    }\n\n    /**\n     * return the trailing 4 words of input data\n     */\n    function getTrailingPublicKey(bytes memory data) public pure returns (uint256[4] memory publicKey) {\n        uint len = data.length;\n        require(len > 32 * 4, \"data to short for sig\");\n\n        /* solhint-disable-next-line no-inline-assembly */\n        assembly {\n        // actual buffer starts at data+32, so last 128 bytes start at data+32+len-128 = data+len-96\n            let ofs := sub(add(data, len), 96)\n            mstore(publicKey, mload(ofs))\n            mstore(add(publicKey, 32), mload(add(ofs, 32)))\n            mstore(add(publicKey, 64), mload(add(ofs, 64)))\n            mstore(add(publicKey, 96), mload(add(ofs, 96)))\n        }\n    }\n\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature)\n    external view override {\n        require(signature.length == 64, \"BLS: invalid signature\");\n        (uint256[2] memory blsSignature) = abi.decode(signature, (uint256[2]));\n\n        uint userOpsLen = userOps.length;\n        uint256[4][] memory blsPublicKeys = new uint256[4][](userOpsLen);\n        uint256[2][] memory messages = new uint256[2][](userOpsLen);\n        for (uint256 i = 0; i < userOpsLen; i++) {\n\n            UserOperation memory userOp = userOps[i];\n            IBLSAccount blsAccount = IBLSAccount(userOp.sender);\n\n            blsPublicKeys[i] = blsAccount.getBlsPublicKey{gas : 30000}();\n\n            messages[i] = _userOpToMessage(userOp, keccak256(abi.encode(blsPublicKeys[i])));\n        }\n        require(BLSOpen.verifyMultiple(blsSignature, blsPublicKeys, messages), \"BLS: validateSignatures failed\");\n    }\n\n    /**\n     * get a hash of userOp\n     * NOTE: this hash is not the same as UserOperation.hash()\n     *  (slightly less efficient, since it uses memory userOp)\n     */\n    function internalUserOpHash(UserOperation memory userOp) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n                userOp.sender,\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.callGasLimit,\n                userOp.verificationGasLimit,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas,\n                keccak256(userOp.paymasterAndData)\n            ));\n    }\n\n    /**\n     * return the BLS \"message\" for the given UserOp.\n     * the account checks the signature over this value  using its public-key\n     */\n    function userOpToMessage(UserOperation memory userOp) public view returns (uint256[2] memory) {\n        bytes32 hashPublicKey = _getUserOpPubkeyHash(userOp);\n        return _userOpToMessage(userOp, hashPublicKey);\n    }\n\n    function _userOpToMessage(UserOperation memory userOp, bytes32 publicKeyHash) internal view returns (uint256[2] memory) {\n        bytes32 userOpHash = _getUserOpHash(userOp, publicKeyHash);\n        return BLSOpen.hashToPoint(BLS_DOMAIN, abi.encodePacked(userOpHash));\n    }\n\n    //return the public-key hash of a userOp.\n    function _getUserOpPubkeyHash(UserOperation memory userOp) internal view returns (bytes32 hashPublicKey) {\n        return keccak256(abi.encode(getUserOpPublicKey(userOp)));\n    }\n\n    function getUserOpHash(UserOperation memory userOp) public view returns (bytes32) {\n        bytes32 hashPublicKey = _getUserOpPubkeyHash(userOp);\n        return _getUserOpHash(userOp, hashPublicKey);\n    }\n\n    function _getUserOpHash(UserOperation memory userOp, bytes32 hashPublicKey) internal view returns (bytes32) {\n        return keccak256(abi.encode(internalUserOpHash(userOp), hashPublicKey, address(this), block.chainid));\n    }\n\n    /**\n     * validate signature of a single userOp\n     * This method is called after EntryPoint.simulateUserOperation() returns an aggregator.\n     * First it validates the signature over the userOp. then it return data to be used when creating the handleOps:\n     * @param userOp the userOperation received from the user.\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\n     */\n    function validateUserOpSignature(UserOperation calldata userOp)\n    external view returns (bytes memory sigForUserOp) {\n        uint256[2] memory signature = abi.decode(userOp.signature, (uint256[2]));\n        uint256[4] memory pubkey = getUserOpPublicKey(userOp);\n        uint256[2] memory message = userOpToMessage(userOp);\n\n        require(BLSOpen.verifySingle(signature, pubkey, message), \"BLS: wrong sig\");\n        return \"\";\n    }\n\n    //copied from BLS.sol\n    uint256 public  constant N = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    /**\n     * aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation\n     * @param userOps array of UserOperations to collect the signatures from.\n     * @return aggregatesSignature the aggregated signature\n     */\n    function aggregateSignatures(UserOperation[] calldata userOps) external pure returns (bytes memory aggregatesSignature) {\n        BLSHelper.XY[] memory points = new BLSHelper.XY[](userOps.length);\n        for (uint i = 0; i < points.length; i++) {\n            (uint x, uint y) = abi.decode(userOps[i].signature, (uint, uint));\n            points[i] = BLSHelper.XY(x, y);\n        }\n        BLSHelper.XY memory sum = BLSHelper.sum(points, N);\n        return abi.encode(sum.x, sum.y);\n    }\n\n    /**\n     * allow staking for this aggregator\n     * there is no limit on stake  or delay, but it is not a problem, since it is a permissionless\n     * signature aggregator, which doesn't support unstaking.\n     */\n    function addStake(IEntryPoint entryPoint, uint32 delay) external payable {\n        entryPoint.addStake{value : msg.value}(delay);\n    }\n}"
    },
    {
      "filename": "contracts/bls/IBLSAccount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.6;\n\nimport \"../interfaces/IAggregatedAccount.sol\";\n\n/**\n * a BLS account should expose its own public key.\n */\ninterface IBLSAccount is IAggregatedAccount {\n    function getBlsPublicKey() external view returns (uint256[4] memory);\n}"
    },
    {
      "filename": "contracts/core/BasePaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\n\n/**\n * Helper class for creating a paymaster.\n * provides helper methods for staking.\n * validates that the postOp is called only by the entryPoint\n */\nabstract contract BasePaymaster is IPaymaster, Ownable {\n\n    IEntryPoint public entryPoint;\n\n    constructor(IEntryPoint _entryPoint) {\n        setEntryPoint(_entryPoint);\n    }\n\n    function setEntryPoint(IEntryPoint _entryPoint) public onlyOwner {\n        entryPoint = _entryPoint;\n    }\n\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\n    external virtual override returns (bytes memory context, uint256 sigTimeRange);\n\n    function postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external override {\n        _requireFromEntryPoint();\n        _postOp(mode, context, actualGasCost);\n    }\n\n    /**\n     * post-operation handler.\n     * (verified to be called only through the entryPoint)\n     * @dev if subclass returns a non-empty context from validatePaymasterUserOp, it must also implement this method.\n     * @param mode enum with the following options:\n     *      opSucceeded - user operation succeeded.\n     *      opReverted  - user op reverted. still has to pay for gas.\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\n     * @param context - the context value returned by validatePaymasterUserOp\n     * @param actualGasCost - actual gas used so far (without this postOp call).\n     */\n    function _postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) internal virtual {\n\n        (mode,context,actualGasCost); // unused params\n        // subclass must override this method if validatePaymasterUserOp returns a context\n        revert(\"must override\");\n    }\n\n    /**\n     * add a deposit for this paymaster, used for paying for transaction fees\n     */\n    function deposit() public payable {\n        entryPoint.depositTo{value : msg.value}(address(this));\n    }\n\n    /**\n     * withdraw value from the deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n    /**\n     * add stake for this paymaster.\n     * This method can also carry eth value to add to the current stake.\n     * @param unstakeDelaySec - the unstake delay for this paymaster. Can only be increased.\n     */\n    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\n        entryPoint.addStake{value : msg.value}(unstakeDelaySec);\n    }\n\n    /**\n     * return current paymaster's deposit on the entryPoint.\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint.balanceOf(address(this));\n    }\n\n    /**\n     * unlock the stake, in order to withdraw it.\n     * The paymaster can't serve requests once unlocked, until it calls addStake a"
    }
  ]
}