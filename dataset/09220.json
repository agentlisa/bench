{
  "Title": "[M-11] [gALCX.sol] Attacker can make the contract unusable when totalSupply is 0",
  "Content": "_Submitted by TerrierLover_\n\nAn attacker can make the contract unusable when totalSupply is 0. Specifically,  `bumpExchangeRate` function does not work correctly which results in making `stake`, `unstake` and `migrateSource` functions that do not work as expected.\n\n### Proof of Concept\n\nHere are steps on how the `gALCX` contract can be unusable.\n\n1.  `gALCX` contract is deployed\n\n2.  The attacker sends the `ALCX` token to the deployed `gALCX` contract directly instead of using `stake` function so that the following `balance` variable has value.\n\n[gALCX.sol#L73-L75](https://github.com/code-423n4/2022-05-alchemix/blob/main/contracts-hardhat/gALCX.sol#L73-L75)<br>\n    uint balance = alcx.balanceOf(address(this));\n\n    if (balance > 0) {\n\n3.  Since the `ALCX` token is given to the `gALCX` contract directly, `totalSupply == 0` and `alcx.balanceOf(address(this)) > 0` becomes true.\n\n[gALCX.sol#L76](https://github.com/code-423n4/2022-05-alchemix/blob/main/contracts-hardhat/gALCX.sol#L76)<br>\n\n    exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n\n4.  Non attackers try to call `stake` function, but `bumpExchangeRate` function fails because of `(balance * exchangeRatePrecision) / totalSupply` when totalSupply is 0.\n\n5.  Owner cannot call `migrateSource` function since `bumpExchangeRate` will be in the same situation mentioned in the step4 above\n\n### Recommended Mitigation Steps\n\nAdd handling when `totalSupply` is 0 but `alcx.balanceOf(address(this))` is more than 0.\n\n**[0xfoobar (Alchemix) acknowledged and commented](https://github.com/code-423n4/2022-05-alchemix-findings/issues/198#issuecomment-1133996854):**\n > Given that the gALCX deployment has 412 unique tokenholders on mainnet, this series of events is extraordinarily unlikely to occur. But we will keep it in mind for future deployments.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-05-alchemix-findings/issues/198#issuecomment-1146895463):**\n > Nice find! Early stakers can DoS new contract deployments, making it impossible for other users to participate in the protocol. As this does not lead to lost funds and is recoverable through redeployment, I believe medium severity to be justified by the warden.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-alchemix-contest",
  "Code": [
    {
      "filename": "contracts-hardhat/gALCX.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\nimport {IALCXSource} from \"./interfaces/IALCXSource.sol\";\n\n/// @title A wrapper for single-sided ALCX staking\ncontract gALCX is ERC20 {\n\n    IERC20 public alcx = IERC20(0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF);\n    IALCXSource public pools = IALCXSource(0xAB8e74017a8Cc7c15FFcCd726603790d26d7DeCa);\n    uint public poolId = 1;\n    uint public constant exchangeRatePrecision = 1e18;\n    uint public exchangeRate = exchangeRatePrecision;\n    address public owner;\n\n    event ExchangeRateChange(uint _exchangeRate);\n    event Stake(address _from, uint _gAmount, uint _amount);\n    event Unstake(address _from, uint _gAmount, uint _amount);\n\n    /// @param _name The token name\n    /// @param _symbol The token symbol\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        owner = msg.sender;\n        reApprove();\n    }\n\n    // OWNERSHIP\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    /// @notice Transfer contract ownership\n    /// @param _owner The new owner address\n    function transferOwnership(address _owner) external onlyOwner {\n        owner = _owner;\n    }\n\n    /// @notice Set a new staking pool address and migrate funds there\n    /// @param _pools The new pool address\n    /// @param _poolId The new pool id\n    function migrateSource(address _pools, uint _poolId) external onlyOwner {\n        // Withdraw ALCX\n        bumpExchangeRate();\n\n        uint poolBalance = pools.getStakeTotalDeposited(address(this), poolId);\n        pools.withdraw(poolId, poolBalance);\n        // Update staking pool address and id\n        pools = IALCXSource(_pools);\n        poolId = _poolId;\n        // Deposit ALCX\n        uint balance = alcx.balanceOf(address(this));\n        reApprove();\n        pools.deposit(poolId, balance);\n    }\n\n    /// @notice Approve the staking pool to move funds in this address, can be called by anyone\n    function reApprove() public {\n        bool success = alcx.approve(address(pools), type(uint).max);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Claim and autocompound rewards\n    function bumpExchangeRate() public {\n        // Claim from pool\n        pools.claim(poolId);\n        // Bump exchange rate\n        uint balance = alcx.balanceOf(address(this));\n\n        if (balance > 0) {\n            exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n            emit ExchangeRateChange(exchangeRate);\n            // Restake\n            pools.deposit(poolId, balance);\n        }\n    }\n\n    /// @notice Deposit new funds into the staking pool\n    /// @param amount The amount of ALCX to deposit\n    function stake(uint amount) external {\n        // Get current exchange rate between ALCX and gALCX\n        bumpExchangeRate();\n        // Then receive new deposits\n        bool success = alcx.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n        pools.deposit(poolId, amount);\n        // gAmount always <= amount\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n        _mint(msg.sender, gAmount);\n        emit Stake(msg.sender, gAmount, amount);\n    }\n\n    /// @notice Withdraw funds from the staking pool\n    /// @param gAmount the amount of gALCX to withdraw\n    function unstake(uint gAmount) external {\n        bumpExchangeRate();\n        uint amount = gAmount * exchangeRate / exchangeRatePrecision;\n        _burn(msg.sender, gAmount);\n        // Withdraw ALCX and send to user\n        pools.withdraw(poolId, amount);\n        bool success = alcx.transfer(msg.sender, amount); // Should return true or revert, but doesn't hurt\n        require(success, \"Transfer failed\"); \n        emit Unstake(msg.sender, gAmount, amount);\n    }\n}"
    },
    {
      "filename": "contracts-hardhat/gALCX.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\nimport {IALCXSource} from \"./interfaces/IALCXSource.sol\";\n\n/// @title A wrapper for single-sided ALCX staking\ncontract gALCX is ERC20 {\n\n    IERC20 public alcx = IERC20(0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF);\n    IALCXSource public pools = IALCXSource(0xAB8e74017a8Cc7c15FFcCd726603790d26d7DeCa);\n    uint public poolId = 1;\n    uint public constant exchangeRatePrecision = 1e18;\n    uint public exchangeRate = exchangeRatePrecision;\n    address public owner;\n\n    event ExchangeRateChange(uint _exchangeRate);\n    event Stake(address _from, uint _gAmount, uint _amount);\n    event Unstake(address _from, uint _gAmount, uint _amount);\n\n    /// @param _name The token name\n    /// @param _symbol The token symbol\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        owner = msg.sender;\n        reApprove();\n    }\n\n    // OWNERSHIP\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    /// @notice Transfer contract ownership\n    /// @param _owner The new owner address\n    function transferOwnership(address _owner) external onlyOwner {\n        owner = _owner;\n    }\n\n    /// @notice Set a new staking pool address and migrate funds there\n    /// @param _pools The new pool address\n    /// @param _poolId The new pool id\n    function migrateSource(address _pools, uint _poolId) external onlyOwner {\n        // Withdraw ALCX\n        bumpExchangeRate();\n\n        uint poolBalance = pools.getStakeTotalDeposited(address(this), poolId);\n        pools.withdraw(poolId, poolBalance);\n        // Update staking pool address and id\n        pools = IALCXSource(_pools);\n        poolId = _poolId;\n        // Deposit ALCX\n        uint balance = alcx.balanceOf(address(this));\n        reApprove();\n        pools.deposit(poolId, balance);\n    }\n\n    /// @notice Approve the staking pool to move funds in this address, can be called by anyone\n    function reApprove() public {\n        bool success = alcx.approve(address(pools), type(uint).max);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Claim and autocompound rewards\n    function bumpExchangeRate() public {\n        // Claim from pool\n        pools.claim(poolId);\n        // Bump exchange rate\n        uint balance = alcx.balanceOf(address(this));\n\n        if (balance > 0) {\n            exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n            emit ExchangeRateChange(exchangeRate);\n            // Restake\n            pools.deposit(poolId, balance);\n        }\n    }\n\n    /// @notice Deposit new funds into the staking pool\n    /// @param amount The amount of ALCX to deposit\n    function stake(uint amount) external {\n        // Get current exchange rate between ALCX and gALCX\n        bumpExchangeRate();\n        // Then receive new deposits\n        bool success = alcx.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n        pools.deposit(poolId, amount);\n        // gAmount always <= amount\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n        _mint(msg.sender, gAmount);\n        emit Stake(msg.sender, gAmount, amount);\n    }\n\n    /// @notice Withdraw funds from the staking pool\n    /// @param gAmount the amount of gALCX to withdraw\n    function unstake(uint gAmount) external {\n        bumpExchangeRate();\n        uint amount = gAmount * exchangeRate / exchangeRatePrecision;\n        _burn(msg.sender, gAmount);\n        // Withdraw ALCX and send to user\n        pools.withdraw(poolId, amount);\n        bool success = alcx.transfer(msg.sender, amount); // Should return true or revert, but doesn't hurt\n        require(success, \"Transfer failed\"); \n        emit Unstake(msg.sender, gAmount, amount);\n    }\n}"
    }
  ]
}