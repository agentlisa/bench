{
  "Title": "[G-03] State variables should be cached in stack variables rather than re-reading them from storage",
  "Content": "\nThe instances below point to the second access of a state variable within a function. Caching will replace each Gwarmaccess (100 gas) with a much cheaper stack read.<br>\nLess obvious optimizations include having local storage variables of mappings within state variable mappings or mappings within state variable structs, having local storage variables of structs within mappings, or having local caches of state variable contracts/addresses.\n\n1.  File: contracts/PhuturePriceOracle.sol (line [84](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/PhuturePriceOracle.sol#L84))\n\n```solidity\n        return IPriceOracle(priceOracleOf[_asset]).refreshedAssetPerBaseInUQ(_asset);\n```\n\n2.  File: contracts/PhuturePriceOracle.sol (line [94](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/PhuturePriceOracle.sol#L94))\n\n```solidity\n        return IPriceOracle(priceOracleOf[_asset]).lastAssetPerBaseInUQ(_asset);\n```\n\n3.  File: contracts/UniswapV2PathPriceOracle.sol (line [35](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/UniswapV2PathPriceOracle.sol#L35))\n\n(save `asset` pointer for next iteration of the loop)\n\n```solidity\n            address asset = path[i + 1];\n```\n\n4.  File: contracts/UniswapV2PathPriceOracle.sol (line [50](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/UniswapV2PathPriceOracle.sol#L50))\n\n(save `asset` pointer for next iteration of the loop)\n\n```solidity\n            address asset = path[i + 1];\n```\n\n5.  File: contracts/UniswapV2PriceOracle.sol (line [51](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/UniswapV2PriceOracle.sol#L51))\n\n```solidity\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n```\n\n6.  File: contracts/vToken.sol (line [219](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/vToken.sol#L219))\n\n```solidity\n        IERC20(asset).safeTransfer(_recipient, Math.min(_amount, balance));\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-04-phuture-finance-contest",
  "Code": [
    {
      "filename": "contracts/PhuturePriceOracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"./libraries/FixedPoint112.sol\";\n\nimport \"./interfaces/IPriceOracle.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\nimport \"./interfaces/IPhuturePriceOracle.sol\";\n\n/// @title Phuture price oracle\n/// @notice Aggregates all price oracles and works with them through IPriceOracle interface\ncontract PhuturePriceOracle is IPhuturePriceOracle {\n    using ERC165Checker for address;\n\n    /// @notice Role allows configure asset related data/components\n    bytes32 private constant ASSET_MANAGER_ROLE = keccak256(\"ASSET_MANAGER_ROLE\");\n\n    /// @notice Base asset address\n    address public base;\n\n    /// @notice Index registry address\n    address public registry;\n\n    /// @inheritdoc IPhuturePriceOracle\n    mapping(address => address) public override priceOracleOf;\n\n    /// @notice Decimals of base asset\n    uint8 private baseDecimals;\n\n    /// @notice Requires msg.sender to have `_role` role\n    /// @param _role Required role\n    modifier onlyRole(bytes32 _role) {\n        require(IAccessControl(registry).hasRole(_role, msg.sender), \"PhuturePriceOracle: FORBIDDEN\");\n        _;\n    }\n\n    constructor(address _registry, address _base) {\n        bytes4[] memory interfaceIds = new bytes4[](2);\n        interfaceIds[0] = type(IAccessControl).interfaceId;\n        interfaceIds[1] = type(IIndexRegistry).interfaceId;\n        require(_registry.supportsAllInterfaces(interfaceIds), \"PhuturePriceOracle: INTERFACE\");\n        require(_base != address(0), \"PhuturePriceOracle: ZERO\");\n\n        base = _base;\n        baseDecimals = IERC20Metadata(_base).decimals();\n        registry = _registry;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function setOracleOf(address _asset, address _oracle) external override onlyRole(ASSET_MANAGER_ROLE) {\n        require(_oracle.supportsInterface(type(IPriceOracle).interfaceId), \"PhuturePriceOracle: INTERFACE\");\n\n        priceOracleOf[_asset] = _oracle;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function removeOracleOf(address _asset) external override onlyRole(ASSET_MANAGER_ROLE) {\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        delete priceOracleOf[_asset];\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function convertToIndex(uint _baseAmount, uint8 _indexDecimals) external view override returns (uint) {\n        return (_baseAmount * 10**_indexDecimals) / 10**baseDecimals;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function containsOracleOf(address _asset) external view override returns (bool) {\n        return priceOracleOf[_asset] != address(0) || _asset == base;\n    }\n\n    /// @inheritdoc IPriceOracle\n    function refreshedAssetPerBaseInUQ(address _asset) public override returns (uint) {\n        if (_asset == base) {\n            return FixedPoint112.Q112;\n        }\n\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        return IPriceOracle(priceOracleOf[_asset]).refreshedAssetPerBaseInUQ(_asset);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function lastAssetPerBaseInUQ(address _asset) public view override returns (uint) {\n        if (_asset == base) {\n            return FixedPoint112.Q112;\n        }\n\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        return IPriceOracle(priceOracleOf[_asset]).lastAssetPerBaseInUQ(_asset);\n    }\n}"
    },
    {
      "filename": "contracts/PhuturePriceOracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"./libraries/FixedPoint112.sol\";\n\nimport \"./interfaces/IPriceOracle.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\nimport \"./interfaces/IPhuturePriceOracle.sol\";\n\n/// @title Phuture price oracle\n/// @notice Aggregates all price oracles and works with them through IPriceOracle interface\ncontract PhuturePriceOracle is IPhuturePriceOracle {\n    using ERC165Checker for address;\n\n    /// @notice Role allows configure asset related data/components\n    bytes32 private constant ASSET_MANAGER_ROLE = keccak256(\"ASSET_MANAGER_ROLE\");\n\n    /// @notice Base asset address\n    address public base;\n\n    /// @notice Index registry address\n    address public registry;\n\n    /// @inheritdoc IPhuturePriceOracle\n    mapping(address => address) public override priceOracleOf;\n\n    /// @notice Decimals of base asset\n    uint8 private baseDecimals;\n\n    /// @notice Requires msg.sender to have `_role` role\n    /// @param _role Required role\n    modifier onlyRole(bytes32 _role) {\n        require(IAccessControl(registry).hasRole(_role, msg.sender), \"PhuturePriceOracle: FORBIDDEN\");\n        _;\n    }\n\n    constructor(address _registry, address _base) {\n        bytes4[] memory interfaceIds = new bytes4[](2);\n        interfaceIds[0] = type(IAccessControl).interfaceId;\n        interfaceIds[1] = type(IIndexRegistry).interfaceId;\n        require(_registry.supportsAllInterfaces(interfaceIds), \"PhuturePriceOracle: INTERFACE\");\n        require(_base != address(0), \"PhuturePriceOracle: ZERO\");\n\n        base = _base;\n        baseDecimals = IERC20Metadata(_base).decimals();\n        registry = _registry;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function setOracleOf(address _asset, address _oracle) external override onlyRole(ASSET_MANAGER_ROLE) {\n        require(_oracle.supportsInterface(type(IPriceOracle).interfaceId), \"PhuturePriceOracle: INTERFACE\");\n\n        priceOracleOf[_asset] = _oracle;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function removeOracleOf(address _asset) external override onlyRole(ASSET_MANAGER_ROLE) {\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        delete priceOracleOf[_asset];\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function convertToIndex(uint _baseAmount, uint8 _indexDecimals) external view override returns (uint) {\n        return (_baseAmount * 10**_indexDecimals) / 10**baseDecimals;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function containsOracleOf(address _asset) external view override returns (bool) {\n        return priceOracleOf[_asset] != address(0) || _asset == base;\n    }\n\n    /// @inheritdoc IPriceOracle\n    function refreshedAssetPerBaseInUQ(address _asset) public override returns (uint) {\n        if (_asset == base) {\n            return FixedPoint112.Q112;\n        }\n\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        return IPriceOracle(priceOracleOf[_asset]).refreshedAssetPerBaseInUQ(_asset);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function lastAssetPerBaseInUQ(address _asset) public view override returns (uint) {\n        if (_asset == base) {\n            return FixedPoint112.Q112;\n        }\n\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        return IPriceOracle(priceOracleOf[_asset]).lastAssetPerBaseInUQ(_asset);\n    }\n}"
    },
    {
      "filename": "contracts/UniswapV2PathPriceOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"./libraries/FullMath.sol\";\nimport \"./libraries/FixedPoint112.sol\";\n\nimport \"./interfaces/IUniswapV2PriceOracle.sol\";\nimport \"./interfaces/IUniswapV2PathPriceOracle.sol\";\n\n/// @title Uniswap path price oracle\n/// @notice Contains logic for price calculation of asset which doesn't have a pair with a base asset\ncontract UniswapV2PathPriceOracle is IUniswapV2PathPriceOracle, ERC165 {\n    using FullMath for uint;\n\n    /// @notice List of assets to compose exchange pairs, where first element is input asset\n    address[] private path;\n    /// @notice List of corresponding price oracles for provided path\n    address[] private oracles;\n\n    constructor(address[] memory _path, address[] memory _oracles) {\n        require(_path.length >= 2, \"UniswapV2PathPriceOracle: PATH\");\n        require(_oracles.length == _path.length - 1, \"UniswapV2PathPriceOracle: ORACLES\");\n\n        path = _path;\n        oracles = _oracles;\n    }\n\n    /// @inheritdoc IPriceOracle\n    function refreshedAssetPerBaseInUQ(address _asset) external override returns (uint currentAssetPerBaseInUQ) {\n        currentAssetPerBaseInUQ = FixedPoint112.Q112;\n        for (uint i = 0; i < path.length - 1; i++) {\n            address asset = path[i + 1];\n            currentAssetPerBaseInUQ = currentAssetPerBaseInUQ.mulDiv(\n                IUniswapV2PriceOracle(oracles[i]).refreshedAssetPerBaseInUQ(asset),\n                FixedPoint112.Q112\n            );\n            if (_asset == asset) {\n                break;\n            }\n        }\n    }\n\n    /// @inheritdoc IPriceOracle\n    function lastAssetPerBaseInUQ(address _asset) external view override returns (uint currentAssetPerBaseInUQ) {\n        currentAssetPerBaseInUQ = FixedPoint112.Q112;\n        for (uint i = 0; i < path.length - 1; i++) {\n            address asset = path[i + 1];\n            currentAssetPerBaseInUQ = currentAssetPerBaseInUQ.mulDiv(\n                IUniswapV2PriceOracle(oracles[i]).lastAssetPerBaseInUQ(asset),\n                FixedPoint112.Q112\n            );\n            if (_asset == asset) {\n                break;\n            }\n        }\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IUniswapV2PathPriceOracle).interfaceId ||\n            _interfaceId == type(IPriceOracle).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IUniswapV2PathPriceOracle\n    function anatomy() public view virtual override returns (address[] memory _path, address[] memory _oracles) {\n        _path = path;\n        _oracles = oracles;\n    }\n}"
    },
    {
      "filename": "contracts/UniswapV2PathPriceOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"./libraries/FullMath.sol\";\nimport \"./libraries/FixedPoint112.sol\";\n\nimport \"./interfaces/IUniswapV2PriceOracle.sol\";\nimport \"./interfaces/IUniswapV2PathPriceOracle.sol\";\n\n/// @title Uniswap path price oracle\n/// @notice Contains logic for price calculation of asset which doesn't have a pair with a base asset\ncontract UniswapV2PathPriceOracle is IUniswapV2PathPriceOracle, ERC165 {\n    using FullMath for uint;\n\n    /// @notice List of assets to compose exchange pairs, where first element is input asset\n    address[] private path;\n    /// @notice List of corresponding price oracles for provided path\n    address[] private oracles;\n\n    constructor(address[] memory _path, address[] memory _oracles) {\n        require(_path.length >= 2, \"UniswapV2PathPriceOracle: PATH\");\n        require(_oracles.length == _path.length - 1, \"UniswapV2PathPriceOracle: ORACLES\");\n\n        path = _path;\n        oracles = _oracles;\n    }\n\n    /// @inheritdoc IPriceOracle\n    function refreshedAssetPerBaseInUQ(address _asset) external override returns (uint currentAssetPerBaseInUQ) {\n        currentAssetPerBaseInUQ = FixedPoint112.Q112;\n        for (uint i = 0; i < path.length - 1; i++) {\n            address asset = path[i + 1];\n            currentAssetPerBaseInUQ = currentAssetPerBaseInUQ.mulDiv(\n                IUniswapV2PriceOracle(oracles[i]).refreshedAssetPerBaseInUQ(asset),\n                FixedPoint112.Q112\n            );\n            if (_asset == asset) {\n                break;\n            }\n        }\n    }\n\n    /// @inheritdoc IPriceOracle\n    function lastAssetPerBaseInUQ(address _asset) external view override returns (uint currentAssetPerBaseInUQ) {\n        currentAssetPerBaseInUQ = FixedPoint112.Q112;\n        for (uint i = 0; i < path.length - 1; i++) {\n            address asset = path[i + 1];\n            currentAssetPerBaseInUQ = currentAssetPerBaseInUQ.mulDiv(\n                IUniswapV2PriceOracle(oracles[i]).lastAssetPerBaseInUQ(asset),\n                FixedPoint112.Q112\n            );\n            if (_asset == asset) {\n                break;\n            }\n        }\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IUniswapV2PathPriceOracle).interfaceId ||\n            _interfaceId == type(IPriceOracle).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IUniswapV2PathPriceOracle\n    function anatomy() public view virtual override returns (address[] memory _path, address[] memory _oracles) {\n        _path = path;\n        _oracles = oracles;\n    }\n}"
    },
    {
      "filename": "contracts/UniswapV2PriceOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\";\n\nimport \"./interfaces/IUniswapV2PriceOracle.sol\";\n\n/// @title Uniswap V2 price oracle\n/// @notice Contains logic for price calculation of asset using Uniswap V2 Pair\n/// @dev Oracle works through base asset which is set in initialize function\ncontract UniswapV2PriceOracle is IUniswapV2PriceOracle, ERC165 {\n    using UniswapV2OracleLibrary for address;\n\n    /// @notice Minimum oracle update interval\n    /// @dev If min update interval hasn't passed (24h) before update, previously cached value is returned\n    uint private constant MIN_UPDATE_INTERVAL = 24 hours;\n\n    IUniswapV2Pair immutable pair;\n    /// @inheritdoc IUniswapV2PriceOracle\n    address public immutable override asset0;\n    /// @inheritdoc IUniswapV2PriceOracle\n    address public immutable override asset1;\n\n    uint private price0CumulativeLast;\n    uint private price1CumulativeLast;\n    uint32 private blockTimestampLast;\n    uint private price0Average;\n    uint private price1Average;\n\n    constructor(\n        address _factory,\n        address _assetA,\n        address _assetB\n    ) {\n        IUniswapV2Pair _pair = IUniswapV2Pair(IUniswapV2Factory(_factory).getPair(_assetA, _assetB));\n        pair = _pair;\n        asset0 = _pair.token0();\n        asset1 = _pair.token1();\n\n        uint112 reserve0;\n        uint112 reserve1;\n        (reserve0, reserve1, blockTimestampLast) = _pair.getReserves();\n        require(reserve0 != 0 && reserve1 != 0, \"UniswapV2PriceOracle: RESERVES\");\n\n        uint _price0CumulativeLast = _pair.price0CumulativeLast();\n        uint _price1CumulativeLast = _pair.price1CumulativeLast();\n        (uint price0Cml, uint price1Cml, uint32 blockTimestamp) = address(_pair).currentCumulativePrices();\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n        price0CumulativeLast = _price0CumulativeLast;\n        price1CumulativeLast = _price1CumulativeLast;\n        price0Average = (price0Cml - _price0CumulativeLast) / timeElapsed;\n        price1Average = (price1Cml - _price1CumulativeLast) / timeElapsed;\n    }\n\n    /// @inheritdoc IPriceOracle\n    /// @dev Updates and returns cumulative price value\n    /// @dev If min update interval hasn't passed (24h), previously cached value is returned\n    function refreshedAssetPerBaseInUQ(address _asset) external override returns (uint) {\n        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) = address(pair).currentCumulativePrices();\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n\n        if (timeElapsed >= MIN_UPDATE_INTERVAL) {\n            price0Average = (price0Cumulative - price0CumulativeLast) / timeElapsed;\n            price1Average = (price1Cumulative - price1CumulativeLast) / timeElapsed;\n\n            price0CumulativeLast = price0Cumulative;\n            price1CumulativeLast = price1Cumulative;\n            blockTimestampLast = blockTimestamp;\n        }\n\n        return lastAssetPerBaseInUQ(_asset);\n    }\n\n    /// @inheritdoc IPriceOracle\n    /// @dev Returns cumulative price value cached during last refresh call\n    function lastAssetPerBaseInUQ(address _asset) public view override returns (uint) {\n        if (_asset == asset0) {\n            return price1Average;\n        } else {\n            require(_asset == asset1, \"UniswapV2PriceOracle: UNKNOWN\");\n            return price0Average;\n        }\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IUniswapV2PriceOracle).interfaceId ||\n            _interfaceId == type(IPriceOracle).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/vToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\nimport \"./libraries/BP.sol\";\nimport \"./libraries/NAV.sol\";\n\nimport \"./interfaces/IvToken.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\n\n/// @title Vault token\n/// @notice Contains logic for index's asset management\ncontract vToken is IvToken, Initializable, ReentrancyGuardUpgradeable, ERC165Upgradeable {\n    using NAV for NAV.Data;\n    using SafeERC20 for IERC20;\n    using ERC165CheckerUpgradeable for address;\n\n    /// @notice Index role\n    bytes32 private constant INDEX_ROLE = keccak256(\"INDEX_ROLE\");\n    /// @notice Oracle role\n    bytes32 private constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    /// @notice Orderer role\n    bytes32 private constant ORDERER_ROLE = keccak256(\"ORDERER_ROLE\");\n    /// @notice Role allows configure reserve related data/components\n    bytes32 private constant RESERVE_MANAGER_ROLE = keccak256(\"RESERVE_MANAGER_ROLE\");\n\n    /// @inheritdoc IvToken\n    address public override asset;\n    /// @inheritdoc IvToken\n    address public override registry;\n\n    /// @notice NAV library used to track contract shares between indexes\n    NAV.Data internal _NAV;\n\n    /// @notice Requires msg.sender to have `_role` role\n    /// @param _role Required role\n    modifier onlyRole(bytes32 _role) {\n        require(IAccessControl(registry).hasRole(_role, msg.sender), \"vToken: FORBIDDEN\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc IvToken\n    /// @dev also sets initial values for public variables\n    function initialize(address _asset, address _registry) external override initializer {\n        bytes4[] memory interfaceIds = new bytes4[](2);\n        interfaceIds[0] = type(IAccessControl).interfaceId;\n        interfaceIds[1] = type(IIndexRegistry).interfaceId;\n        require(_registry.supportsAllInterfaces(interfaceIds), \"vToken: INTERFACE\");\n        require(_asset != address(0), \"vToken: ZERO\");\n\n        __ERC165_init();\n        __ReentrancyGuard_init();\n\n        asset = _asset;\n        registry = _registry;\n    }\n\n    /// @inheritdoc IvToken\n    function transferAsset(address _recipient, uint _amount) external override nonReentrant {\n        require(msg.sender == IIndexRegistry(registry).orderer(), \"vToken: FORBIDDEN\");\n        _transferAsset(_recipient, _amount);\n    }\n\n    /// @inheritdoc IvToken\n    function transfer(address _recipient, uint _amount) external override nonReentrant {\n        _transfer(msg.sender, _recipient, _amount);\n    }\n\n    /// @inheritdoc IvToken\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _shares\n    ) external override nonReentrant onlyRole(ORDERER_ROLE) {\n        _transfer(_from, _to, _shares);\n    }\n\n    /// @inheritdoc IvToken\n    function mint() external override nonReentrant onlyRole(INDEX_ROLE) returns (uint shares) {\n        return _mint(msg.sender);\n    }\n\n    /// @inheritdoc IvToken\n    function burn(address _recipient) external override nonReentrant onlyRole(INDEX_ROLE) returns (uint amount) {\n        return _burn(_recipient);\n    }\n\n    /// @inheritdoc IvToken\n    function mintFor(address _recipient) external override nonReentrant onlyRole(ORDERER_ROLE) returns (uint) {\n        return _mint(_recipient);\n    }\n\n    /// @inheritdoc IvToken\n    function burnFor(address _recipient) external override nonReentrant onlyRole(ORDERER_ROLE) returns (uint) {\n        return _burn(_recipient);\n    }\n\n    /// @inheritdoc IvToken\n    function sync() external override nonReentrant {\n        _NAV.sync(totalAssetSupply());\n    }\n\n    /// @inheritdoc IvToken\n    function balanceOf(address _account) external view override returns (uint) {\n        return _NAV.balanceOf[_account];\n    }\n\n    /// @inheritdoc IvToken\n    function lastBalance() external view override returns (uint) {\n        return _NAV.lastBalance;\n    }\n\n    /// @inheritdoc IvToken\n    function mintableShares(uint _amount) external view override returns (uint) {\n        return _NAV.mintableShares(_amount);\n    }\n\n    /// @inheritdoc IvToken\n    function totalSupply() external view override returns (uint) {\n        return _NAV.totalSupply;\n    }\n\n    /// @inheritdoc IvToken\n    function lastAssetBalanceOf(address _account) external view override returns (uint) {\n        return _NAV.assetBalanceForShares(_NAV.balanceOf[_account], _NAV.lastBalance);\n    }\n\n    /// @inheritdoc IvToken\n    function assetBalanceOf(address _account) external view override returns (uint) {\n        return _NAV.assetBalanceForShares(_NAV.balanceOf[_account], totalAssetSupply());\n    }\n\n    /// @inheritdoc IvToken\n    function assetDataOf(address _account, uint _shares) external view override returns (AssetData memory) {\n        _shares = Math.min(_shares, _NAV.balanceOf[_account]);\n        uint amountInAsset = _NAV.assetBalanceForShares(_shares, totalAssetSupply());\n        return AssetData({ maxShares: _shares, amountInAsset: amountInAsset });\n    }\n\n    /// @inheritdoc IvToken\n    function shareChange(address _account, uint _amountInAsset)\n        external\n        view\n        override\n        returns (uint newShares, uint oldShares)\n    {\n        oldShares = _NAV.balanceOf[_account];\n        uint _totalSupply = _NAV.totalSupply;\n        if (_totalSupply > 0) {\n            uint _balance = _NAV.balanceOf[_account];\n            uint _assetBalance = totalAssetSupply();\n            uint availableAssets = (_balance * _assetBalance) / _totalSupply;\n            newShares = (_amountInAsset * (_totalSupply - oldShares)) / (_assetBalance - availableAssets);\n        } else {\n            newShares = _amountInAsset < NAV.INITIAL_QUANTITY ? 0 : _amountInAsset - NAV.INITIAL_QUANTITY;\n        }\n    }\n\n    /// @inheritdoc IvToken\n    function totalAssetSupply() public view override returns (uint) {\n        return IERC20(asset).balanceOf(address(this));\n    }\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IvToken).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Mints shares to `_recipient` address\n    /// @param _recipient Shares recipient\n    /// @return shares Amount of minted shares\n    function _mint(address _recipient) internal returns (uint shares) {\n        uint _totalAssetSupply = totalAssetSupply();\n        shares = _NAV.mint(_totalAssetSupply, _recipient);\n        _NAV.sync(_totalAssetSupply);\n        emit VTokenTransfer(address(0), _recipient, shares);\n    }\n\n    /// @notice Burns shares from `_recipient` address\n    /// @param _recipient Recipient of assets from burnt shares\n    /// @return amount Amount of asset for burnt shares\n    function _burn(address _recipient) internal returns (uint amount) {\n        uint shares = _NAV.balanceOf[address(this)];\n        amount = _NAV.burn(totalAssetSupply());\n        _transferAsset(_recipient, amount);\n        _NAV.sync(totalAssetSupply());\n        emit VTokenTransfer(_recipient, address(0), shares);\n    }\n\n    /// @notice Transfers `_amount` of shares from one address to another\n    /// @param _from Address to transfer shares from\n    /// @param _to Address to transfer shares to\n    /// @param _amount Amount of shares to transfer\n    function _transfer(\n        address _from,\n        address _to,\n        uint _amount\n    ) internal {\n        _NAV.transfer(_from, _to, _amount);\n        emit VTokenTransfer(_from, _to, _amount);\n    }\n\n    /// @notice Transfers `_amount` of asset to `_recipient` address\n    /// @param _recipient Recipient of assets\n    /// @param _amount Amount of assets to transfer\n    function _transferAsset(address _recipient, uint _amount) internal {\n        uint balance = IERC20(asset).balanceOf(address(this));\n        IERC20(asset).safeTransfer(_recipient, Math.min(_amount, balance));\n    }\n\n    uint256[42] private __gap;\n}"
    }
  ]
}