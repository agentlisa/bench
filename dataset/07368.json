{
  "Title": "[M-05] Orders may not be fillable due to missing approvals",
  "Content": "\nNot all `IERC20` implementations `revert()` when there's a failure in `approve()`. If one of these tokens returns false, there is no check for whether this has happened during the order listing validation, so it will only be detected when the order is attempted.\n\n### Impact\n\nIf the approval failure isn't detected, the listing will never be fillable, because the funds won't be able to be pulled from the opensea conduit. Once this happens, and if it's detected, the only way to fix it is to create a counter-listing at a lower price (which may be below the market value of the tokens), waiting for the order to expire (which it may never), or by buying out all of the Rae to cancel the order (very expensive and defeats the purpose of pooling funds in the first place).\n\n### Proof of Concept\n\nThe return value of `approve()` isn't checked, so the order will be allowed to be listed without having approved the conduit:\n\n```solidity\n// File: src/seaport/targets/SeaportLister.sol : SeaportLister.validateListing()   #1\n\n29                for (uint256 i; i < ordersLength; ++i) {\n30                    uint256 offerLength = _orders[i].parameters.offer.length;\n31                    for (uint256 j; j < offerLength; ++j) {\n32                        OfferItem memory offer = _orders[i].parameters.offer[j];\n33                        address token = offer.token;\n34                        ItemType itemType = offer.itemType;\n35                        if (itemType == ItemType.ERC721)\n36                            IERC721(token).setApprovalForAll(conduit, true);\n37                        if (itemType == ItemType.ERC1155)\n38                            IERC1155(token).setApprovalForAll(conduit, true);\n39                        if (itemType == ItemType.ERC20)\n40 @>                         IERC20(token).approve(conduit, type(uint256).max);\n41                    }\n42                }\n43            }\n44            // Validates the order on-chain so no signature is required to fill it\n45            assert(ConsiderationInterface(_consideration).validate(_orders));\n46:       }\n```\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/targets/SeaportLister.sol#L29-L46>\n\n### Recommended Mitigation Steps\n\nUse OpenZeppelin's `safeApprove()`, which checks the return code and reverts if it's not success.\n\n**[mehtaculous (Tessera) disputed and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/36#issuecomment-1370195907):**\n > Disagree with validity. The listing would just need to be canceled and a new order would be created (without the ERC20 token that is not able to be approved)\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/36#issuecomment-1378847444):**\n > `cancel()` can only be performed by the proposer, or through `rejectActive()`:\n> > or by buying out all of the Rae to cancel the order (very expensive and defeats the purpose of pooling funds in the first place).\n> \n> While unlikely, it is an attack vector to hold user funds hostage.\n\n**[stevennevins (Tessera) acknowledged](https://github.com/code-423n4/2022-12-tessera-findings/issues/36)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-tessera-versus-contest",
  "Code": [
    {
      "filename": "src/seaport/targets/SeaportLister.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IERC721} from \"../../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\n\nimport {ConsiderationInterface} from \"seaport/interfaces/ConsiderationInterface.sol\";\nimport {ItemType, OfferItem} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {ISeaportLister, Order, OrderComponents} from \"../interfaces/ISeaportLister.sol\";\n\n/// @title SeaportLister\n/// @author Tessera\n/// @notice Target contract for executing the listing and delisting of orders on Seaport\ncontract SeaportLister is ISeaportLister {\n    /// @notice Address of the conduit that is approved to spend the items\n    address public immutable conduit;\n\n    constructor(address _conduit) {\n        conduit = _conduit;\n    }\n\n    /// @notice Approves the conduit to list the offer items\n    /// @param _consideration Address of the Consideration contract (Seaport)\n    /// @param _orders List of orders being validated\n    function validateListing(address _consideration, Order[] memory _orders) external {\n        uint256 ordersLength = _orders.length;\n        unchecked {\n            for (uint256 i; i < ordersLength; ++i) {\n                uint256 offerLength = _orders[i].parameters.offer.length;\n                for (uint256 j; j < offerLength; ++j) {\n                    OfferItem memory offer = _orders[i].parameters.offer[j];\n                    address token = offer.token;\n                    ItemType itemType = offer.itemType;\n                    if (itemType == ItemType.ERC721)\n                        IERC721(token).setApprovalForAll(conduit, true);\n                    if (itemType == ItemType.ERC1155)\n                        IERC1155(token).setApprovalForAll(conduit, true);\n                    if (itemType == ItemType.ERC20)\n                        IERC20(token).approve(conduit, type(uint256).max);\n                }\n            }\n        }\n        // Validates the order on-chain so no signature is required to fill it\n        assert(ConsiderationInterface(_consideration).validate(_orders));\n    }\n\n    /// @notice Cancels the listing of all offer items\n    /// @param _consideration Address of the Consideration contract (Seaport)\n    /// @param _orders List of orders being canceled\n    function cancelListing(address _consideration, OrderComponents[] memory _orders) external {\n        assert(ConsiderationInterface(_consideration).cancel(_orders));\n    }\n}"
    }
  ]
}