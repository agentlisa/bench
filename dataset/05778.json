{
  "Title": "[M-04] `addGlobalToken()` `localAdress` could be overwritten",
  "Content": "\n`CoreBranchRouter.addGlobalToken()` is used to set the local token of chains.\n\nWhen `CoreBranchRouter.addGlobalToken(_dstChainId = ftm)`, it will execute follow step:\n1. `[root]CoreRootRouter.\\_addGlobalToken()`\n    - 1.1 check `isGlobalAddress(\\_globalAddress)`\n    - 1.2 check not `isGlobalToken(\\_globalAddress, \\_dstChainId)`\n2. `[branch]CoreBranchRouter.\\_receiveAddGlobalToken()`\n    - 2.1 `[remote:ftm]  CoreBranchRouter.\\_receiveAddGlobalToken()`\n    - 2.1.1 New Local Token address\n3. `[root]CoreRootRouter.\\_setLocalToken()`\n    - 3.1 check not `isLocalToken` (new Local token)\n    - 3.2 `rootPort.setLocalAddress` (`globalGlobal`, new Local token, `fmtChainId`)\n\nCall sequence `[root]->[branch]->[root]`, with asynchronous calls via layerzero.\nSince it is asynchronous, in the case of concurrency, the check in step `1.2` is invalid because step `3.2` is executed after a certain amount of time.\n\nConsider the following scenarios:\n\n1. Alice executes `addGlobalToken(ftm)` through Steps 1 and 2, and generates `alice_LocalTokenAddress = 0x01`.\n2. Bob executes `addGlobalToken(ftm)` through Steps 1 and 1, and generates `bob_LocalTokenAddress = 0x02` at the same time.\n3. After a while, layerzero executes Alice's request and will pass step `3.1`, because `alice_LocalTokenAddress` is new.\n4. After a while, layerzero executes Bob's request and will pass step `3.1`, because `bob_LocalTokenAddress` is new.\n\nSo `bob_LocalTokenAddress` will override `alice_LocalTokenAddress`.\n\nThe main problem here, is that the check in step `3.1` is wrong because the local token is a regenerated address, so `isLocalToken()` is always false. It should be checking `isGlobalToken(_globalAddress, _dstChainId))`.\n\n```solidity\n    function _setLocalToken(address _globalAddress, address _localAddress, uint16 _dstChainId) internal {\n        // Verify if the token already added\n@>      if (IPort(rootPortAddress).isLocalToken(_localAddress, _dstChainId)) revert TokenAlreadyAdded();\n\n        // Set the global token's new branch chain address\n        IPort(rootPortAddress).setLocalAddress(_globalAddress, _localAddress, _dstChainId);\n    }\n```\n\n### Impact\n\nIn the case of concurrency, the second local token will overwrite the first local token. Before overwriting, the first local token is still valid. If someone exchanges the first local token and waits until after overwriting, then the first local token will be invalidated and the user will lose the corresponding token.\n\n### Proof of Concept\n\nThe following code demonstrates that with layerzero asynchronous and due to `_setLocalToken()` error checking, it may cause the second `localToken` to overwrite the first `localToken`; the layerzero call is simplified.\n\nAdd to `CoreRootBridgeAgentTest.t.sol`\n\n```solidity\n    function testAddGlobalTokenOverride() public {\n        //1. new global token\n        GasParams memory gasParams = GasParams(0, 0);\n        arbitrumCoreRouter.addLocalToken(address(arbAssetToken), gasParams);\n        newGlobalAddress = RootPort(rootPort).getLocalTokenFromUnderlying(address(arbAssetToken), rootChainId);\n        console2.log(\"New Global Token Address: \", newGlobalAddress);\n\n        //2.1 new first local token\n        gasParams = GasParams(1 ether, 1 ether);        \n        GasParams[] memory remoteGas = new GasParams[](2);\n        remoteGas[0] = GasParams(0.0001 ether, 0.00005 ether);\n        remoteGas[1] = GasParams(0.0001 ether, 0.00005 ether);\n        bytes memory data = abi.encode(ftmCoreBridgeAgentAddress, newGlobalAddress, ftmChainId,remoteGas);\n        bytes memory packedData = abi.encodePacked(bytes1(0x01), data);\n        encodeCallNoDeposit(\n            payable(ftmCoreBridgeAgentAddress),\n            payable(address(coreBridgeAgent)),\n            chainNonce[ftmChainId]++,\n            packedData,\n            gasParams,\n            ftmChainId\n        );\n        //2.2 new second local token\n\n        data = abi.encode(ftmCoreBridgeAgentAddress, newGlobalAddress, ftmChainId,remoteGas);\n        packedData = abi.encodePacked(bytes1(0x01), data);\n        encodeCallNoDeposit(\n            payable(ftmCoreBridgeAgentAddress),\n            payable(address(coreBridgeAgent)),\n            chainNonce[ftmChainId]++,\n            packedData,\n            gasParams,\n            ftmChainId\n        );        \n        //3.1 wait some time ,lz execute first local token\n        address newLocalToken = address(0xFA111111);\n        data = abi.encode(newGlobalAddress, newLocalToken, \"UnderLocal Coin\", \"UL\");\n        packedData = abi.encodePacked(bytes1(0x03), data);\n        encodeSystemCall(\n            payable(ftmCoreBridgeAgentAddress),\n            payable(address(coreBridgeAgent)),\n            chainNonce[ftmChainId]++,\n            packedData,\n            gasParams,\n            ftmChainId\n        );\n        //3.1.1 show first local token address\n        address ftmLocalToken = RootPort(rootPort).getLocalTokenFromGlobal(newGlobalAddress,ftmChainId);\n        console2.log(\"loal Token Address(first): \", ftmLocalToken);\n\n        //3.2 wait some time ,lz execute second local token\n        gasParams = GasParams(0.0001 ether, 0.00005 ether);\n        newLocalToken = address(0xFA222222);\n        data = abi.encode(newGlobalAddress, newLocalToken, \"UnderLocal Coin\", \"UL\");\n        packedData = abi.encodePacked(bytes1(0x03), data);\n        encodeSystemCall(\n            payable(ftmCoreBridgeAgentAddress),\n            payable(address(coreBridgeAgent)),\n            chainNonce[ftmChainId]++,\n            packedData,\n            gasParams,\n            ftmChainId\n        );\n        //3.2.1 show second local token address\n        ftmLocalToken = RootPort(rootPort).getLocalTokenFromGlobal(newGlobalAddress,ftmChainId);\n        console2.log(\"loal Token Address(override): \", ftmLocalToken);        \n    }    \n```\n\n```console\n$ forge test -vvv --match-contract CoreRootBridgeAgentTest  --match-test testAddGlobalTokenOverride\n\n[PASS] testAddGlobalTokenOverride() (gas: 1846078)\nLogs:\n  New Global Token Address:  0x12Cd3f6571aF11e01137d294866C5fFd1369Bbe9\n  loal Token Address(first):  0x00000000000000000000000000000000Fa111111\n  loal Token Address(override):  0x00000000000000000000000000000000fA222222\n```\n\n### Recommended Mitigation\n\nCheck `isGlobalToken()` should replace check `isLocalToken()`.\n\n```diff\n    function _setLocalToken(address _globalAddress, address _localAddress, uint16 _dstChainId) internal {\n        // Verify if the token already added\n-      if (IPort(rootPortAddress).isLocalToken(_localAddress, _dstChainId)) revert TokenAlreadyAdded();\n+       if (IPort(rootPortAddress).isGlobalToken(_globalAddress, _dstChainId)) {\n+            revert TokenAlreadyAdded();\n+       }\n        // Set the global token's new branch chain address\n        IPort(rootPortAddress).setLocalAddress(_globalAddress, _localAddress, _dstChainId);\n    }\n```\n\n### Assessed type\n\nContext\n\n**[0xBugsy (Maia) disputed and commented via duplicate issue #822](https://github.com/code-423n4/2023-09-maia-findings/issues/822#issuecomment-1767084423):**\n> This has already been checked in the `_addGlobalToken` step of this execution flow.\n\n**[alcueca (judge) commented via duplicate issue #822](https://github.com/code-423n4/2023-09-maia-findings/issues/822#issuecomment-1779380288):**\n> > Many issues around `addGlobalToken` due to lack of input validation when linking a global token to local token - [#860](https://github.com/code-423n4/2023-09-maia-findings/issues/860).\n> \n> Would you please point out where? I can't find where the `_localAddress` is obtained.\n\n**[0xBugsy (Maia) commented via duplicate issue #822](https://github.com/code-423n4/2023-09-maia-findings/issues/822#issuecomment-1767084423):**\n> After calling `addGlobalToken` - requesting a new local token representation in a new chain for an existing global token - we perform these steps:\n> \n> 1. https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/CoreRootRouter.sol#L406 (where we check if the global token exists and if it has already been added to the destination chain).\n> \n> 2. https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/CoreBranchRouter.sol#L166 (creation of the new branch hToken for the existing root/global hToken) `_localAddress is deployed in this step`.\n>\n> 3. https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/CoreRootRouter.sol#L481 (check if we have not added the new local token t.o system already and request update to root port)\n> \n> 4. Ends here: https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootPort.sol#L259  (updating the root port token mapping namely `getLocalTokenFromGlobal`).\n\n**[alcueca (judge) commented via duplicate issue #822](https://github.com/code-423n4/2023-09-maia-findings/issues/822#issuecomment-1780649914):**\n> As a rule, you should validate the arguments in internal functions, that when those arguments change state in the same function, some values of those arguments could break the logic represented by that state.\n\n**[alcueca (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-09-maia-findings/issues/610#issuecomment-1780919290):**\n > From the sponsor:\n> \n> > [What the submission] is saying has no impact on users in any way, since there is no way to acquire the asset on the origin branch before token addition execution is confirmed on root; it would simply revert and the user would be able to redeem the deposited assets. In addition, the issue seems to revolve around the misuse of this function `IPort(rootPortAddress).isLocalToken(_localAddress, _dstChainId)` in `_setLocalToken` - but this is intended so as to prevent overwriting this mapping after it already being added. \n>\n>> Furthermore, the suggested funciton  `IPort(rootPortAddress).isGlobalToken(_globalAddress, _dstChainId)` is always updated in tandem with the one currently being used, so it's the same thing as doing the checks we currently have in place.\n\n**[bin2chen (warden) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/610#issuecomment-1786267341):**\n > @alcueca -\n> ```\n> since there is no way to acquire the asset on the origin branch before token addition execution is confirmed on root\n> ```\n> \n> Is it possible to look again?  Both will be confirmed at root. Please see poc's \"`3.1.1` show first local token address\".\n> \n> The address has been printed out from root:\n> \n> ```\n> Logs:\n>   New Global Token Address:  0x12Cd3f6571aF11e01137d294866C5fFd1369Bbe9\n>   loal Token Address(first):  0x00000000000000000000000000000000Fa111111\n>   loal Token Address(override):  0x00000000000000000000000000000000fA222222\n> ```\n>\n> The problem describes that both `addGlobalToken()`all work. The second `addGlobalToken()` overrides the first.\n> \n> Since these operations are asynchronous (cross-chain), the first step check can be skipped. Because the third step incorrectly uses `isLocalToken()` to check for legitimacy, the override becomes possible.\n\n**[alcueca (judge) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/610#issuecomment-1793352300):**\n > I explained the issue more clearly to the sponsor, and is now confirmed:\n> \n> > Really apologize for my misunderstanding, I was not interpreting the issue correctly, seems that during the time between `_addGlobalToken` and `_setLocalToken`, multiple tokens can be requested; although, this is to be expected, only the last one created from these requests will be retained in the system instead of the first  one.\n> >\n> > Due to this, during the time period between the first `_setLocalToken` execution and the last, the submission of `bridgeOut` requests would lead to the loss of the deposited tokens. Although, this is a very specific time frame to be possible (the 2 layer zero hops in question), it is a very important situation to be addressed as someone could loose access to their tokens under these circumstances. \n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/610#issuecomment-1807197068):**\n > Addressed [here](https://github.com/Maia-DAO/2023-09-maia-remediations/commit/545af70d5c405523f2eb2468bccbe9be918202ed).\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-09-maia-findings/issues/610).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/CoreRootRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC20hTokenRootFactory as IFactory} from \"./interfaces/IERC20hTokenRootFactory.sol\";\nimport {IRootRouter} from \"./interfaces/IRootRouter.sol\";\nimport {\n    DepositParams,\n    DepositMultipleParams,\n    GasParams,\n    IRootBridgeAgent as IBridgeAgent\n} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IRootPort as IPort} from \"./interfaces/IRootPort.sol\";\n\n/**\n * 2\n * @title  Core Root Router Contract\n * @author MaiaDAO\n * @notice Core Root Router implementation for Root Environment deployment.\n *         This contract is responsible for permissionlessly adding new\n *         tokens or Bridge Agents to the system as well as key governance\n *         enabled system functions (i.e. `toggleBranchBridgeAgentFactory`).\n * @dev    Func IDs for calling these functions through messaging layer:\n *\n *         CROSS-CHAIN MESSAGING FUNCIDs\n *         -----------------------------\n *         FUNC ID      | FUNC NAME\n *         -------------+---------------\n *         0x01         | addGlobalToken\n *         0x02         | addLocalToken\n *         0x03         | setLocalToken\n *         0x04         | syncBranchBridgeAgent\n *\n */\ncontract CoreRootRouter is IRootRouter, Ownable {\n    /*///////////////////////////////////////////////////////////////\n                    CORE ROOT ROUTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Boolean to indicate if the contract is in set up mode.\n    bool internal _setup;\n\n    /// @notice Root Chain Layer Zero Identifier.\n    uint256 public immutable rootChainId;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are kept\n    ///         managed and supplied to different Port Strategies.\n    address public immutable rootPortAddress;\n\n    /// @notice Bridge Agent to manage remote execution and cross-chain assets.\n    address payable public bridgeAgentAddress;\n\n    /// @notice Bridge Agent Executor Address.\n    address public bridgeAgentExecutorAddress;\n\n    /// @notice ERC20 hToken Root Factory Address.\n    address public hTokenFactoryAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Core Root Router.\n     * @param _rootChainId layer zero root chain id.\n     * @param _rootPortAddress address of the Root Port.\n     */\n    constructor(uint256 _rootChainId, address _rootPortAddress) {\n        rootChainId = _rootChainId;\n        rootPortAddress = _rootPortAddress;\n\n        _initializeOwner(msg.sender);\n        _setup = true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function initialize(address _bridgeAgentAddress, address _hTokenFactory) external onlyOwner {\n        require(_setup, \"Contract is already initialized\");\n        _setup = false;\n        bridgeAgentAddress = payable(_bridgeAgentAddress);\n        bridgeAgentExecutorAddress = IBridgeAgent(_bridgeAgentAddress).bridgeAgentExecutorAddress();\n        hTokenFactoryAddress = _hTokenFactory;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT MANAGEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Add a new Chain (Branch Bridge Agent and respective Router) to a Root Bridge Agent.\n     * @param _branchBridgeAgentFactory Address of the branch Bridge Agent Factory.\n     * @param _newBranchRouter Address of the new branch router.\n     * @param _refundee Address of the excess gas receiver.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function addBranchToBridgeAgent(\n        address _rootBridgeAgent,\n        address _branchBridgeAgentFactory,\n        address _newBranchRouter,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams[2] calldata _gParams\n    ) external payable {\n        // Check if msg.sender is the Bridge Agent Manager\n        if (msg.sender != IPort(rootPortAddress).getBridgeAgentManager(_rootBridgeAgent)) {\n            revert UnauthorizedCallerNotManager();\n        }\n\n        // Check if valid chain\n        if (!IPort(rootPortAddress).isChainId(_dstChainId)) revert InvalidChainId();\n\n        // Check if chain already added to bridge agent\n        if (IBridgeAgent(_rootBridgeAgent).getBranchBridgeAgent(_dstChainId) != address(0)) revert InvalidChainId();\n\n        // Check if Branch Bridge Agent is allowed by Root Bridge Agent\n        if (!IBridgeAgent(_rootBridgeAgent).isBranchBridgeAgentAllowed(_dstChainId)) revert UnauthorizedChainId();\n\n        // Encode CallData\n        bytes memory params = abi.encode(\n            _newBranchRouter,\n            _branchBridgeAgentFactory,\n            _rootBridgeAgent,\n            IBridgeAgent(_rootBridgeAgent).factoryAddress(),\n            _refundee,\n            _gParams[1]\n        );\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x02), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams[0]\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                GOVERNANCE / ADMIN EXTERNAL FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Add or Remove a Branch Bridge Agent Factory.\n     * @param _rootBridgeAgentFactory Address of the root Bridge Agent Factory.\n     * @param _branchBridgeAgentFactory Address of the branch Bridge Agent Factory.\n     * @param _refundee Receiver of any leftover execution gas upon reaching the destination network.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function toggleBranchBridgeAgentFactory(\n        address _rootBridgeAgentFactory,\n        address _branchBridgeAgentFactory,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable onlyOwner {\n        if (!IPort(rootPortAddress).isBridgeAgentFactory(_rootBridgeAgentFactory)) {\n            revert UnrecognizedBridgeAgentFactory();\n        }\n\n        // Encode CallData\n        bytes memory params = abi.encode(_branchBridgeAgentFactory);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x03), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams\n        );\n    }\n\n    /**\n     * @notice Remove a Branch Bridge Agent.\n     * @param _branchBridgeAgent Address of the Branch Bridge Agent to be updated.\n     * @param _refundee Receiver of any leftover execution gas upon reaching destination network.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function removeBranchBridgeAgent(\n        address _branchBridgeAgent,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable onlyOwner {\n        //Encode CallData\n        bytes memory params = abi.encode(_branchBridgeAgent);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x04), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams\n        );\n    }\n\n    /**\n     * @notice Add or Remove a Strategy Token.\n     * @param _underlyingToken Address of the underlying token to be added for use in Branch strategies.\n     * @param _minimumReservesRatio Minimum Branch Port reserves ratio for the underlying token.\n     * @param _refundee Receiver of any leftover execution gas upon reaching destination network.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function manageStrategyToken(\n        address _underlyingToken,\n        uint256 _minimumReservesRatio,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable onlyOwner {\n        // Encode CallData\n        bytes memory params = abi.encode(_underlyingToken, _minimumReservesRatio);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x05), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams\n        );\n    }\n\n    /**\n     * @notice Add, Remove or update a Port Strategy.\n     * @param _portStrategy Address of the Port Strategy to be added for use in Branch strategies.\n     * @param _underlyingToken Address of the underlying token to be added for use in Branch strategies.\n     * @param _dailyManagementLimit Daily management limit of the given token for the Port Strategy.\n     * @param _isUpdateDailyLimit Boolean to safely indicate if the Port Strategy is being updated and not deactivated.\n     * @param _refundee Receiver of any leftover execution gas upon reaching destination network.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function managePortStrategy(\n        address _portStrategy,\n        address _underlyingToken,\n        uint256 _dailyManagementLimit,\n        bool _isUpdateDailyLimit,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable onlyOwner {\n        // Encode CallData\n        bytes memory params = abi.encode(_portStrategy, _underlyingToken, _dailyManagementLimit, _isUpdateDailyLimit);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x06), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams\n        );\n    }\n\n    /**\n     * @notice Set the Core Branch Router and Bridge Agent.\n     * @param _refundee Receiver of any leftover execution gas upon reaching destination network.\n     * @param _coreBranchRouter Address of the Core Branch Router.\n     * @param _coreBranchBridgeAgent Address of the Core Branch Bridge Agent.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function setCoreBranch(\n        address _refundee,\n        address _coreBranchRouter,\n        address _coreBranchBridgeAgent,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable {\n        // Check caller is root port\n        require(msg.sender == rootPortAddress, \"Only root port can call\");\n\n        // Encode CallData\n        bytes memory params = abi.encode(_coreBranchRouter, _coreBranchBridgeAgent);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x07), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        LAYERZERO FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootRouter\n    function executeResponse(bytes calldata _encodedData, uint16 _srcChainId)\n        external\n        payable\n        override\n        requiresExecutor\n    {\n        // Parse funcId\n        bytes1 funcId = _encodedData[0];\n\n        ///  FUNC ID: 2 (_addLocalToken)\n        if (funcId == 0x02) {\n            (address underlyingAddress, address localAddress, string memory name, string memory symbol, uint8 decimals)\n            = abi.decode(_encodedData[1:], (address, address, string, string, uint8));\n\n            _addLocalToken(underlyingAddress, localAddress, name, symbol, decimals, _srcChainId);\n\n            /// FUNC ID: 3 (_setLocalToken)\n        } else if (funcId == 0x03) {\n            (address globalAddress, address localAddress) = abi.decode(_encodedData[1:], (address, address));\n\n            _setLocalToken(globalAddress, localAddress, _srcChainId);\n\n            /// FUNC ID: 4 (_syncBranchBridgeAgent)\n        } else if (funcId == 0x04) {\n            (address newBranchBridgeAgent, address rootBridgeAgent) = abi.decode(_encodedData[1:], (address, address));\n\n            _syncBranchBridgeAgent(newBranchBridgeAgent, rootBridgeAgent, _srcChainId);\n\n            /// Unrecognized Function Selector\n        } else {\n            revert UnrecognizedFunctionId();\n        }\n    }\n\n    /// @inheritdoc IRootRouter\n    function execute(bytes calldata _encodedData, uint16) external payable override requiresExecutor {\n        // Parse funcId\n        bytes1 funcId = _encodedData[0];\n\n        /// FUNC ID: 1 (_addGlobalToken)\n        if (funcId == 0x01) {\n            (address refundee, address globalAddress, uint16 dstChainId, GasParams[2] memory gasParams) =\n                abi.decode(_encodedData[1:], (address, address, uint16, GasParams[2]));\n\n            _addGlobalToken(refundee, globalAddress, dstChainId, gasParams);\n\n            /// Unrecognized Function Selector\n        } else {\n            revert UnrecognizedFunctionId();\n        }\n    }\n\n    /// @inheritdoc IRootRouter\n    function executeDepositSingle(bytes memory, DepositParams memory, uint16)\n        external\n        payable\n        override\n        requiresExecutor\n    {\n        revert();\n    }\n\n    /// @inheritdoc IRootRouter\n    function executeDepositMultiple(bytes calldata, DepositMultipleParams memory, uint16)\n        external\n        payable\n        override\n        requiresExecutor\n    {\n        revert();\n    }\n\n    /// @inheritdoc IRootRouter\n    function executeSigned(bytes memory, address, uint16) external payable override requiresExecutor {\n        revert();\n    }\n\n    /// @inheritdoc IRootRouter\n    function executeSignedDepositSingle(bytes memory, DepositParams memory, address, uint16)\n        external\n        payable\n        override\n        requiresExecutor\n    {\n        revert();\n    }\n\n    /// @inheritdoc IRootRouter\n    function executeSignedDepositMultiple(bytes memory, DepositMultipleParams memory, address, uint16)\n        external\n        payable\n        override\n        requiresExecutor\n    {\n        revert();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT INTERNAL FUNCTIONS\n    ////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function to add a global token to a specific chain. Must be called from a branch.\n     *   @param _refundee Address of the excess gas receiver.\n     *   @param _globalAddress global token to be added.\n     *   @param _dstChainId chain to which the Global Token will be added.\n     *   @param _gParams Gas parameters for remote execution.\n     *\n     */\n    function _addGlobalToken(\n        address _refundee,\n        address _globalAddress,\n        uint16 _dstChainId,\n        GasParams[2] memory _gParams\n    ) internal {\n        if (_dstChainId == rootChainId) revert InvalidChainId();\n\n        if (!IPort(rootPortAddress).isGlobalAddress(_globalAddress)) {\n            revert UnrecognizedGlobalToken();\n        }\n\n        // Verify that it does not exist\n        if (IPort(rootPortAddress).isGlobalToken(_globalAddress, _dstChainId)) {\n            revert TokenAlreadyAdded();\n        }\n\n        // Encode CallData\n        bytes memory params = abi.encode(\n            _globalAddress,\n            ERC20(_globalAddress).name(),\n            ERC20(_globalAddress).symbol(),\n            ERC20(_globalAddress).decimals(),\n            _refundee,\n            _gParams[1]\n        );\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x01), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams[0]\n        );\n    }\n\n    /**\n     * @notice Function to add a new local to the global environment. Called from branch chain.\n     *   @param _underlyingAddress the token's underlying/native chain address.\n     *   @param _localAddress the token's address.\n     *   @param _name the token's name.\n     *   @param _symbol the token's symbol.\n     *   @param _decimals the token's decimals.\n     *   @param _srcChainId the token's origin chain Id.\n     *\n     */\n    function _addLocalToken(\n        address _underlyingAddress,\n        address _localAddress,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint16 _srcChainId\n    ) internal {\n        // Verify if the underlying address is already known by the branch or root chain\n        if (IPort(rootPortAddress).isGlobalAddress(_underlyingAddress)) revert TokenAlreadyAdded();\n        if (IPort(rootPortAddress).isLocalToken(_underlyingAddress, _srcChainId)) revert TokenAlreadyAdded();\n        if (IPort(rootPortAddress).isUnderlyingToken(_underlyingAddress, _srcChainId)) revert TokenAlreadyAdded();\n\n        //Create a new global token\n        address newToken = address(IFactory(hTokenFactoryAddress).createToken(_name, _symbol, _decimals));\n\n        // Update Registry\n        IPort(rootPortAddress).setAddresses(\n            newToken, (_srcChainId == rootChainId) ? newToken : _localAddress, _underlyingAddress, _srcChainId\n        );\n    }\n\n    /**\n     * @notice Internal function to set the local token on a specific chain for a global token.\n     *   @param _globalAddress global token to be updated.\n     *   @param _localAddress local token to be added.\n     *   @param _dstChainId local token's chain.\n     *\n     */\n    function _setLocalToken(address _globalAddress, address _localAddress, uint16 _dstChainId) internal {\n        // Verify if the token already added\n        if (IPort(rootPortAddress).isLocalToken(_localAddress, _dstChainId)) revert TokenAlreadyAdded();\n\n        // Set the global token's new branch chain address\n        IPort(rootPortAddress).setLocalAddress(_globalAddress, _localAddress, _dstChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                BRIDGE AGENT MANAGEMENT INTERNAL FUNCTIONS\n    ////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev Internal function sync a Root Bridge Agent with a newly created BRanch Bridge Agent.\n     *   @param _newBranchBridgeAgent new branch bridge agent address\n     *   @param _rootBridgeAgent new branch bridge agent address\n     *   @param _srcChainId branch chain id.\n     *\n     */\n    function _syncBranchBridgeAgent(address _newBranchBridgeAgent, address _rootBridgeAgent, uint256 _srcChainId)\n        internal\n    {\n        IPort(rootPortAddress).syncBranchBridgeAgentWithRoot(_newBranchBridgeAgent, _rootBridgeAgent, _srcChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MODIFIERS\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier verifies the caller is the Bridge Agent Executor.\n    modifier requiresExecutor() {\n        if (msg.sender != bridgeAgentExecutorAddress) revert UnrecognizedBridgeAgentExecutor();\n        _;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                ERRORS\n    ///////////////////////////////////////////////////////////////*/\n\n    error InvalidChainId();\n\n    error UnauthorizedChainId();\n\n    error UnauthorizedCallerNotManager();\n\n    error TokenAlreadyAdded();\n\n    error UnrecognizedGlobalToken();\n\n    error UnrecognizedBridgeAgentFactory();\n}"
    },
    {
      "filename": "src/CoreBranchRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IBranchPort as IPort} from \"./interfaces/IBranchPort.sol\";\nimport {IBranchBridgeAgent as IBridgeAgent, GasParams} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IBranchBridgeAgentFactory as IBridgeAgentFactory} from \"./interfaces/IBranchBridgeAgentFactory.sol\";\nimport {IBranchRouter} from \"./interfaces/IBranchRouter.sol\";\nimport {ICoreBranchRouter} from \"./interfaces/ICoreBranchRouter.sol\";\nimport {IERC20hTokenBranchFactory as ITokenFactory} from \"./interfaces/IERC20hTokenBranchFactory.sol\";\n\nimport {BaseBranchRouter} from \"./BaseBranchRouter.sol\";\nimport {ERC20hTokenBranch as ERC20hToken} from \"./token/ERC20hTokenBranch.sol\";\n\n/// @title Core Branch Router Contract\n/// @author MaiaDAO\ncontract CoreBranchRouter is ICoreBranchRouter, BaseBranchRouter {\n    /// @notice hToken Factory Address.\n    address public immutable hTokenFactoryAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Core Branch Router.\n     * @param _hTokenFactoryAddress Branch hToken Factory Address.\n     */\n    constructor(address _hTokenFactoryAddress) BaseBranchRouter() {\n        hTokenFactoryAddress = _hTokenFactoryAddress;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                 TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice This function is used to add a global token to a branch.\n     * @param _globalAddress Address of the token to be added.\n     * @param _dstChainId Chain Id of the chain to which the deposit is being added.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function addGlobalToken(address _globalAddress, uint256 _dstChainId, GasParams[3] calldata _gParams)\n        external\n        payable\n    {\n        // Encode Call Data\n        bytes memory params = abi.encode(msg.sender, _globalAddress, _dstChainId, [_gParams[1], _gParams[2]]);\n\n        // Pack FuncId\n        bytes memory payload = abi.encodePacked(bytes1(0x01), params);\n\n        // Send Cross-Chain request (System Response/Request)\n        IBridgeAgent(localBridgeAgentAddress).callOut{value: msg.value}(payable(msg.sender), payload, _gParams[0]);\n    }\n\n    /**\n     * @notice This function is used to add a local token to the system.\n     * @param _underlyingAddress Address of the underlying token to be added.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function addLocalToken(address _underlyingAddress, GasParams calldata _gParams) external payable virtual {\n        //Get Token Info\n        uint8 decimals = ERC20(_underlyingAddress).decimals();\n\n        //Create Token\n        ERC20hToken newToken = ITokenFactory(hTokenFactoryAddress).createToken(\n            ERC20(_underlyingAddress).name(), ERC20(_underlyingAddress).symbol(), decimals, true\n        );\n\n        //Encode Data\n        bytes memory params = abi.encode(_underlyingAddress, newToken, newToken.name(), newToken.symbol(), decimals);\n\n        // Pack FuncId\n        bytes memory payload = abi.encodePacked(bytes1(0x02), params);\n\n        //Send Cross-Chain request (System Response/Request)\n        IBridgeAgent(localBridgeAgentAddress).callOutSystem{value: msg.value}(payable(msg.sender), payload, _gParams);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LAYERZERO EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    function executeNoSettlement(bytes calldata _params) external payable virtual override requiresAgentExecutor {\n        /// _receiveAddGlobalToken\n        if (_params[0] == 0x01) {\n            (\n                address globalAddress,\n                string memory name,\n                string memory symbol,\n                uint8 decimals,\n                address refundee,\n                GasParams memory gParams\n            ) = abi.decode(_params[1:], (address, string, string, uint8, address, GasParams));\n\n            _receiveAddGlobalToken(globalAddress, name, symbol, decimals, refundee, gParams);\n            /// _receiveAddBridgeAgent\n        } else if (_params[0] == 0x02) {\n            (\n                address newBranchRouter,\n                address branchBridgeAgentFactory,\n                address rootBridgeAgent,\n                address rootBridgeAgentFactory,\n                address refundee,\n                GasParams memory gParams\n            ) = abi.decode(_params[1:], (address, address, address, address, address, GasParams));\n\n            _receiveAddBridgeAgent(\n                newBranchRouter, branchBridgeAgentFactory, rootBridgeAgent, rootBridgeAgentFactory, refundee, gParams\n            );\n\n            /// _toggleBranchBridgeAgentFactory\n        } else if (_params[0] == 0x03) {\n            (address bridgeAgentFactoryAddress) = abi.decode(_params[1:], (address));\n\n            _toggleBranchBridgeAgentFactory(bridgeAgentFactoryAddress);\n\n            /// _removeBranchBridgeAgent\n        } else if (_params[0] == 0x04) {\n            (address branchBridgeAgent) = abi.decode(_params[1:], (address));\n\n            _removeBranchBridgeAgent(branchBridgeAgent);\n\n            /// _manageStrategyToken\n        } else if (_params[0] == 0x05) {\n            (address underlyingToken, uint256 minimumReservesRatio) = abi.decode(_params[1:], (address, uint256));\n\n            _manageStrategyToken(underlyingToken, minimumReservesRatio);\n\n            /// _managePortStrategy\n        } else if (_params[0] == 0x06) {\n            (address portStrategy, address underlyingToken, uint256 dailyManagementLimit, bool isUpdateDailyLimit) =\n                abi.decode(_params[1:], (address, address, uint256, bool));\n\n            _managePortStrategy(portStrategy, underlyingToken, dailyManagementLimit, isUpdateDailyLimit);\n\n            /// _setCoreBranchRouter\n        } else if (_params[0] == 0x07) {\n            (address coreBranchRouter, address coreBranchBridgeAgent) = abi.decode(_params[1:], (address, address));\n\n            IPort(localPortAddress).setCoreBranchRouter(coreBranchRouter, coreBranchBridgeAgent);\n\n            /// Unrecognized Function Selector\n        } else {\n            revert UnrecognizedFunctionId();\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                 TOKEN MANAGEMENT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to deploy/add a token already active in the global environment in the Root Chain.\n     *         Must be called from another chain.\n     *  @param _globalAddress the address of the global virtualized token.\n     *  @param _name token name.\n     *  @param _symbol token symbol.\n     *  @param _refundee the address of the excess gas receiver.\n     *  @param _gParams Gas parameters for remote execution.\n     *  @dev FUNC ID: 1\n     *  @dev all hTokens have 18 decimals.\n     */\n    function _receiveAddGlobalToken(\n        address _globalAddress,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _refundee,\n        GasParams memory _gParams\n    ) internal {\n        //Create Token\n        ERC20hToken newToken = ITokenFactory(hTokenFactoryAddress).createToken(_name, _symbol, _decimals, false);\n\n        // Encode Data\n        bytes memory params = abi.encode(_globalAddress, newToken);\n\n        // Pack FuncId\n        bytes memory payload = abi.encodePacked(bytes1(0x03), params);\n\n        //Send Cross-Chain request\n        IBridgeAgent(localBridgeAgentAddress).callOutSystem{value: msg.value}(payable(_refundee), payload, _gParams);\n    }\n\n    /**\n     * @notice Function to deploy/add a token already active in the global environment in the Root Chain.\n     *         Must be called from another chain.\n     *    @param _newBranchRouter the address of the new branch router.\n     *    @param _branchBridgeAgentFactory the address of the branch bridge agent factory.\n     *    @param _rootBridgeAgent the address of the root bridge agent.\n     *    @param _rootBridgeAgentFactory the address of the root bridge agent factory.\n     *    @param _refundee the address of the excess gas receiver.\n     *    @param _gParams Gas parameters for remote execution.\n     *    @dev FUNC ID: 2\n     *    @dev all hTokens have 18 decimals.\n     */\n    function _receiveAddBridgeAgent(\n        address _newBranchRouter,\n        address _branchBridgeAgentFactory,\n        address _rootBridgeAgent,\n        address _rootBridgeAgentFactory,\n        address _refundee,\n        GasParams memory _gParams\n    ) internal virtual {\n        // Save Port Address to memory\n        address _localPortAddress = localPortAddress;\n\n        // Check if msg.sender is a valid BridgeAgentFactory\n        if (!IPort(_localPortAddress).isBridgeAgentFactory(_branchBridgeAgentFactory)) {\n            revert UnrecognizedBridgeAgentFactory();\n        }\n\n        // Create BridgeAgent\n        address newBridgeAgent = IBridgeAgentFactory(_branchBridgeAgentFactory).createBridgeAgent(\n            _newBranchRouter, _rootBridgeAgent, _rootBridgeAgentFactory\n        );\n\n        // Check BridgeAgent Address\n        if (!IPort(_localPortAddress).isBridgeAgent(newBridgeAgent)) {\n            revert UnrecognizedBridgeAgent();\n        }\n\n        // Encode Data\n        bytes memory params = abi.encode(newBridgeAgent, _rootBridgeAgent);\n\n        // Pack FuncId\n        bytes memory payload = abi.encodePacked(bytes1(0x04), params);\n\n        //Send Cross-Chain request\n        IBridgeAgent(localBridgeAgentAddress).callOutSystem{value: msg.value}(payable(_refundee), payload, _gParams);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                 BRIDGE AGENT MANAGEMENT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to add/deactivate a Branch Bridge Agent Factory.\n     *  @param _newBridgeAgentFactoryAddress the address of the new local bridge agent factory.\n     *  @dev FUNC ID: 3\n     */\n    function _toggleBranchBridgeAgentFactory(address _newBridgeAgentFactoryAddress) internal {\n        // Save Port Address to memory\n        address _localPortAddress = localPortAddress;\n\n        // Check if BridgeAgentFactory is active\n        if (IPort(_localPortAddress).isBridgeAgentFactory(_newBridgeAgentFactoryAddress)) {\n            // If so, disable it.\n            IPort(_localPortAddress).toggleBridgeAgentFactory(_newBridgeAgentFactoryAddress);\n        } else {\n            // If not, add it.\n            IPort(_localPortAddress).addBridgeAgentFactory(_newBridgeAgentFactoryAddress);\n        }\n    }\n\n    /**\n     * @notice Function to remove an active Branch Bridge Agent from the system.\n     *  @param _branchBridgeAgent the address of the local Bridge Agent to be removed.\n     *  @dev FUNC ID: 4\n     */\n    function _removeBranchBridgeAgent(address _branchBridgeAgent) internal {\n        // Save Port Address to memory\n        address _localPortAddress = localPortAddress;\n\n        // Revert if it is not an active BridgeAgent\n        if (!IPort(_localPortAddress).isBridgeAgent(_branchBridgeAgent)) revert UnrecognizedBridgeAgent();\n\n        // Remove BridgeAgent\n        IPort(_localPortAddress).toggleBridgeAgent(_branchBridgeAgent);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                 PORT STRATEGIES INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to add/remove a token to be used by Port Strategies.\n     *  @param _underlyingToken the address of the underlying token."
    }
  ]
}