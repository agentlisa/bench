{
  "Title": "Linearity assumption on the royalty can lead to denial of service",
  "Content": "**Description:**\n`VeryFastRouter::swap` relies on the internal functions [`VeryFastRouter::_findMaxFillableAmtForSell`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L556) and [`VeryFastRouter::_findMaxFillableAmtForBuy`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L503) to find the maximum possible amount of tokens to be swapped via binary search as below:\n\n```solidity\nVeryFastRouter.sol\n576:         // Perform binary search\n577:         while (start <= end) {\n578:             // We check the price to sell index + 1\n579:             (\n580:                 CurveErrorCodes.Error error,\n581:                 /* newSpotPrice */\n582:                 ,\n583:                 /* newDelta */\n584:                 ,\n585:                 uint256 currentOutput,\n586:                 /* tradeFee */\n587:                 ,\n588:                 /* protocolFee */\n589:             ) = pair.bondingCurve().getSellInfo(\n590:                 spotPrice,\n591:                 // get delta from deltaAndFeeMultiplier\n592:                 uint128(deltaAndFeeMultiplier >> 96),\n593:                 (start + end) / 2,\n594:                 // get feeMultiplier from deltaAndFeeMultiplier\n595:                 uint96(deltaAndFeeMultiplier),\n596:                 protocolFeeMultiplier\n597:             );\n598:             currentOutput -= currentOutput * royaltyAmount / BASE;//@audit-info assumes royalty amount is linear\n599:             // If the bonding curve has a math error, or\n600:             // if the current output is too low relative to our max output, or\n601:             // if the current output is greater than the pair's token balance,\n602:             // then we recurse on the left half (i.e. less items)\n603:             if (\n604:                 error != CurveErrorCodes.Error.OK || currentOutput < minOutputPerNumNFTs[(start + end) / 2 - 1] /* this is the max cost we are willing to pay, zero-indexed */\n605:                     || currentOutput > pairTokenBalance\n606:             ) {\n607:                 end = (start + end) / 2 - 1;\n608:             }\n609:             // Otherwise, we recurse on the right half (i.e. more items)\n610:             else {\n611:                 numItemsToFill = (start + end) / 2;\n612:                 start = (start + end) / 2 + 1;\n613:                 priceToFillAt = currentOutput;\n614:             }\n615:         }\n```\nThe protocol is designed to integrate various royalty info providers. Line 598 assumes the royalty amount is linear; however, this assumption can be violated, especially in the case of external royalty info providers who could be malicious and return a non-linear royalty amount.\nFor example, the royalty amount can be a function of the number of tokens to be swapped (e.g. greater/fewer royalties for a larger/smaller sale amount).\nIn this case, line 598 will be violated, and the max fillable functions will return incorrect `priceToFillAt` and `numItemsToFill`.\n\nFor example, `KODAV2` royalty calculation is NOT accurately linear to the input amount due to roundings.\n\n```solidity\n    function getKODAV2RoyaltyInfo(address _tokenAddress, uint256 _id, uint256 _amount)\n        external\n        view\n        override\n        returns (address payable[] memory receivers, uint256[] memory amounts)\n    {\n        // Get the edition the token is part of\n        uint256 _editionNumber = IKODAV2(_tokenAddress).editionOfTokenId(_id);\n        require(_editionNumber > 0, \"Edition not found for token ID\");\n\n        // Get existing artist commission\n        (address artistAccount, uint256 artistCommissionRate) = IKODAV2(_tokenAddress).artistCommission(_editionNumber);\n\n        // work out the expected royalty payment\n        uint256 totalRoyaltyToPay = (_amount / modulo) * creatorRoyaltiesFee;\n\n        // Get optional commission set against the edition and work out the expected commission\n        (uint256 optionalCommissionRate, address optionalCommissionRecipient) =\n            IKODAV2(_tokenAddress).editionOptionalCommission(_editionNumber);\n        if (optionalCommissionRate > 0) {\n            receivers = new address payable[](2);\n            amounts = new uint256[](2);\n\n            uint256 totalCommission = artistCommissionRate + optionalCommissionRate;\n\n            // Add the artist and commission\n            receivers[0] = payable(artistAccount);\n            amounts[0] = (totalRoyaltyToPay / totalCommission) * artistCommissionRate;//@audit-info rounding occurs here\n\n            // Add optional splits\n            receivers[1] = payable(optionalCommissionRecipient);\n            amounts[1] = (totalRoyaltyToPay / totalCommission) * optionalCommissionRate;//@audit-info rounding occurs here\n        } else {\n            receivers = new address payable[](1);\n            amounts = new uint256[](1);\n\n            // Add the artist and commission\n            receivers[0] = payable(artistAccount);\n            amounts[0] = totalRoyaltyToPay;\n        }\n\n        return (receivers, amounts);\n    }\n```\n\nIf the royalty info provider returned higher royalty for a larger sale amount, the `priceToFillAt` will be higher than the actual sale.\nNote that the `priceToFillAt` value calculated with the linearity assumption is used as a [minimum expected output parameter](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L351) for the function `ILSSVMPairERC721::swapNFTsForToken` within the swap sell logic. Similar reasoning holds for the swap-buy logic.\n\n```solidity\nVeryFastRouter.sol\n345:                 // If we can sell at least 1 item...\n346:                 if (numItemsToFill != 0) {\n347:                     // If property checking is needed, do the property check swap\n348:                     if (order.doPropertyCheck) {\n349:                         outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n350:                             order.nftIds[:numItemsToFill],\n351:                             priceToFillAt,//@audit-info min expected output\n352:                             swapOrder.tokenRecipient,\n353:                             true,\n354:                             msg.sender,\n355:                             order.propertyCheckParams\n356:                         );\n357:                     }\n358:                     // Otherwise do a normal sell swap\n359:                     else {\n360:                         // Get subarray if ERC721\n361:                         if (order.isERC721) {\n362:                             outputAmount = order.pair.swapNFTsForToken(\n363:                                 order.nftIds[:numItemsToFill], priceToFillAt, swapOrder.tokenRecipient, true, msg.sender\n364:                             );\n365:                         }\n366:                         // For 1155 swaps, wrap as number\n367:                         else {\n368:                             outputAmount = order.pair.swapNFTsForToken(\n369:                                 _wrapUintAsArray(numItemsToFill),\n370:                                 priceToFillAt,\n371:                                 swapOrder.tokenRecipient,\n372:                                 true,\n373:                                 msg.sender\n374:                             );\n375:                         }\n376:                     }\n377:                 }\n```\nThus, the swap will fail if the `priceToFillAt` is calculated to be greater than the actual sale.\n\nThe Cyfrin team acknowledges that Sudoswap expects all collections to be ERC-2981 compliant, and EIP-2981 states that the royalty amount should be linear to the amount.\nHowever, tokens can use a royalty lookup that is not compliant with EIP-2981 and can be abused to prevent honest users' valid transactions, so the protocol should not rely on the assumption that the royalty amount is linear.\n\n**Impact:**\nThe linearity assumption can be violated, especially in the case of external royalty info providers (possibly malicious), and this can lead to protocol failing to behave as expected, as legitimate swaps will fail.\nDue to these incorrect assumptions affecting the core functions, we evaluate the severity to HIGH.\n\n**Recommended Mitigation:**\nWhile we understand the protocol team intended to reduce gas costs by using the linearity assumption, we recommend using the actual royalty amount to calculate `priceToFillAt` and `numItemsToFill`.\n\n**Sudoswap:**\nAcknowledged. It is expected that the majority of NFTs will be ERC-2981 compliant.\n\n**Cyfrin:**\nAcknowledged.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/VeryFastRouter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport {LSSVMPair} from \"./LSSVMPair.sol\";\nimport {LSSVMPairERC20} from \"./LSSVMPairERC20.sol\";\nimport {ILSSVMPairERC721} from \"./erc721/ILSSVMPairERC721.sol\";\nimport {LSSVMPairERC1155} from \"./erc1155/LSSVMPairERC1155.sol\";\nimport {ILSSVMPairFactoryLike} from \"./ILSSVMPairFactoryLike.sol\";\nimport {CurveErrorCodes} from \"./bonding-curves/CurveErrorCodes.sol\";\n\n/**\n * @dev Full-featured router to handle all swap types, with partial fill support\n */\ncontract VeryFastRouter {\n    using SafeTransferLib for address payable;\n    using SafeTransferLib for ERC20;\n\n    uint256 constant BASE = 1e18;\n\n    ILSSVMPairFactoryLike public immutable factory;\n\n    struct BuyOrderWithPartialFill {\n        LSSVMPair pair;\n        bool isERC721;\n        uint256[] nftIds;\n        uint256 maxInputAmount;\n        uint256 ethAmount;\n        uint256 expectedSpotPrice;\n        uint256[] maxCostPerNumNFTs; // @dev This is zero-indexed, so maxCostPerNumNFTs[x] = max price we're willing to pay to buy x+1 NFTs\n    }\n\n    struct SellOrderWithPartialFill {\n        LSSVMPair pair;\n        bool isETHSell;\n        bool isERC721;\n        uint256[] nftIds;\n        bool doPropertyCheck;\n        bytes propertyCheckParams;\n        uint128 expectedSpotPrice;\n        uint256 minExpectedOutput;\n        uint256[] minExpectedOutputPerNumNFTs;\n    }\n\n    struct Order {\n        BuyOrderWithPartialFill[] buyOrders;\n        SellOrderWithPartialFill[] sellOrders;\n        address payable tokenRecipient;\n        address nftRecipient;\n        bool recycleETH;\n    }\n\n    struct PartialFillSellArgs {\n        LSSVMPair pair;\n        uint128 spotPrice;\n        uint256 maxNumNFTs;\n        uint256[] minOutputPerNumNFTs;\n        uint256 protocolFeeMultiplier;\n        uint256 nftId;\n    }\n\n    struct PartialFillSellHelperArgs {\n        LSSVMPair pair;\n        uint256[] minOutputPerNumNFTs;\n        uint256 protocolFeeMultiplier;\n        uint256 nftId;\n        uint256 start;\n        uint256 end;\n        uint128 delta;\n        uint128 spotPrice;\n        uint256 feeMultiplier;\n        uint256 pairTokenBalance;\n        uint256 royaltyAmount;\n        uint256 numItemsToFill;\n        uint256 priceToFillAt;\n    }\n\n    error VeryFastRouter__InvalidPair();\n    error VeryFastRouter__BondingCurveQuoteError();\n\n    constructor(ILSSVMPairFactoryLike _factory) {\n        factory = _factory;\n    }\n\n    /* @dev Meant to be used as a client-side utility\n     * Given a pair and a number of items to buy, calculate the max price paid for 1 up to numNFTs to buy\n     */\n    function getNFTQuoteForBuyOrderWithPartialFill(\n        LSSVMPair pair,\n        uint256 numNFTs,\n        uint256 slippageScaling,\n        uint256 assetId\n    ) external view returns (uint256[] memory) {\n        uint256[] memory prices = new uint256[](numNFTs);\n\n        for (uint256 i; i < numNFTs;) {\n            uint128 newSpotPrice = pair.spotPrice();\n            uint128 newDelta = pair.delta();\n\n            // Assume that i items have been bought and get the new params\n            if (i != 0) {\n                (newSpotPrice, newDelta) = _getNewPoolParamsAfterBuying(pair, i);\n            }\n\n            // Calculate price to purchase the remaining numNFTs - i items\n            uint256 price = _getHypotheticalNewPoolParamsAfterBuying(pair, newSpotPrice, newDelta, numNFTs - i);\n\n            (,, uint256 royaltyTotal) = pair.calculateRoyaltiesView(assetId, price);\n            price += royaltyTotal;\n\n            // Set the price to buy numNFT - i items\n            prices[numNFTs - i - 1] = price;\n\n            unchecked {\n                ++i;\n            }\n        }\n        // Scale up by slippage amount\n        if (slippageScaling != 0) {\n            for (uint256 i = 0; i < prices.length;) {\n                prices[i] = prices[i] + (prices[i] * slippageScaling / 1e18);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        return prices;\n    }\n\n    function _getNewPoolParamsAfterBuying(LSSVMPair pair, uint256 i)\n        internal\n        view\n        returns (uint128 newSpotPrice, uint128 newDelta)\n    {\n        CurveErrorCodes.Error errorCode;\n        (errorCode, newSpotPrice, newDelta,,,) = pair.bondingCurve().getBuyInfo(\n            pair.spotPrice(), pair.delta(), i, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n        if (errorCode != CurveErrorCodes.Error.OK) {\n            revert VeryFastRouter__BondingCurveQuoteError();\n        }\n    }\n\n    function _getHypotheticalNewPoolParamsAfterBuying(\n        LSSVMPair pair,\n        uint128 newSpotPrice,\n        uint128 newDelta,\n        uint256 num\n    ) internal view returns (uint256 output) {\n        CurveErrorCodes.Error errorCode;\n        (errorCode,,, output,,) = pair.bondingCurve().getBuyInfo(\n            newSpotPrice, newDelta, num, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n        if (errorCode != CurveErrorCodes.Error.OK) {\n            revert VeryFastRouter__BondingCurveQuoteError();\n        }\n    }\n\n    function getPairBaseQuoteTokenBalance(LSSVMPair pair) public view returns (uint256 balance) {\n        ILSSVMPairFactoryLike.PairVariant variant = pair.pairVariant();\n        if (\n            variant == ILSSVMPairFactoryLike.PairVariant.ERC721_ETH\n                || variant == ILSSVMPairFactoryLike.PairVariant.ERC1155_ETH\n        ) {\n            balance = address(pair).balance;\n        } else {\n            balance = ERC20(LSSVMPairERC20(address(pair)).token()).balanceOf(address(pair));\n        }\n    }\n\n    function _wrapUintAsArray(uint256 valueToWrap) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](1);\n        arr[0] = valueToWrap;\n        return arr;\n    }\n\n    /* @dev Meant to be used as a client-side utility\n     * Given a pair and a number of items to sell, calculate the mininum output for selling 1 to numNFTs\n     */\n    function getNFTQuoteForSellOrderWithPartialFill(\n        LSSVMPair pair,\n        uint256 numNFTs,\n        uint256 slippageScaling,\n        uint256 nftId\n    ) external view returns (uint256[] memory) {\n        uint256[] memory outputAmounts = new uint256[](numNFTs);\n\n        for (uint256 i; i < numNFTs;) {\n            uint128 newSpotPrice = pair.spotPrice();\n            uint128 newDelta = pair.delta();\n\n            // Assume that i items have been sold and get the new params\n            if (i != 0) {\n                (newSpotPrice, newDelta) = _getNewPoolParamsAfterSelling(pair, i);\n            }\n\n            // Calculate output to sell the remaining numNFTs - i items, factoring in royalties\n            uint256 output = _getHypotheticalNewPoolParamsAfterSelling(pair, newSpotPrice, newDelta, numNFTs - i);\n            (,, uint256 royaltyTotal) = pair.calculateRoyaltiesView(nftId, output);\n            output -= royaltyTotal;\n\n            outputAmounts[numNFTs - i - 1] = output;\n\n            unchecked {\n                ++i;\n            }\n        }\n        // Scale down by slippage amount\n        if (slippageScaling != 0) {\n            for (uint256 i = 0; i < outputAmounts.length;) {\n                outputAmounts[i] = outputAmounts[i] - (outputAmounts[i] * slippageScaling / 1e18);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        return outputAmounts;\n    }\n\n    function _getNewPoolParamsAfterSelling(LSSVMPair pair, uint256 i)\n        internal\n        view\n        returns (uint128 newSpotPrice, uint128 newDelta)\n    {\n        CurveErrorCodes.Error errorCode;\n        (errorCode, newSpotPrice, newDelta,,,) = pair.bondingCurve().getSellInfo(\n            pair.spotPrice(), pair.delta(), i, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n        if (errorCode != CurveErrorCodes.Error.OK) {\n            revert VeryFastRouter__BondingCurveQuoteError();\n        }\n    }\n\n    function _getHypotheticalNewPoolParamsAfterSelling(\n        LSSVMPair pair,\n        uint128 newSpotPrice,\n        uint128 newDelta,\n        uint256 num\n    ) internal view returns (uint256 output) {\n        CurveErrorCodes.Error errorCode;\n        (errorCode,,, output,,) = pair.bondingCurve().getSellInfo(\n            newSpotPrice, newDelta, num, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n        if (errorCode != CurveErrorCodes.Error.OK) {\n            revert VeryFastRouter__BondingCurveQuoteError();\n        }\n    }\n\n    /**\n     * @dev Performs a batch of sells and buys, avoids performing swaps where the price is beyond\n     * Handles selling NFTs for tokens or ETH\n     * Handles buying NFTs with tokens or ETH,\n     * @param swapOrder The struct containing all the swaps to be executed\n     * @return results Indices [0..swapOrder.sellOrders.length-1] contain the actual output amounts of the\n     * sell orders, indices [swapOrder.sellOrders.length..swapOrder.sellOrders.length+swapOrder.buyOrders.length-1]\n     * contain the actual input amounts of the buy orders.\n     */\n    function swap(Order calldata swapOrder) external payable returns (uint256[] memory results) {\n        uint256 ethAmount = msg.value;\n\n        // Get protocol to reduce gas on the _findMaxFillableAmtForSell/_findMaxFillableAmtForBuy calls\n        uint256 protocolFeeMultiplier = factory.protocolFeeMultiplier();\n\n        results = new uint256[](swapOrder.buyOrders.length + swapOrder.sellOrders.length);\n\n        // Go through each sell order\n        for (uint256 i; i < swapOrder.sellOrders.length;) {\n            SellOrderWithPartialFill calldata order = swapOrder.sellOrders[i];\n            uint128 pairSpotPrice = order.pair.spotPrice();\n            uint256 outputAmount;\n\n            // If the spot price parameter seen is what we expect it to be...\n            if (pairSpotPrice == order.expectedSpotPrice) {\n                // If the pair is an ETH pair and we opt into recycling ETH, add the output to our total accrued\n                if (order.isETHSell && swapOrder.recycleETH) {\n                    // Pass in params for property checking if needed\n                    // Then do the swap with the same minExpectedTokenOutput amount\n                    if (order.doPropertyCheck) {\n                        outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n                            order.nftIds,\n                            order.minExpectedOutput,\n                            payable(address(this)),\n                            true,\n                            msg.sender,\n                            order.propertyCheckParams\n                        );\n                    } else {\n                        outputAmount = order.pair.swapNFTsForToken(\n                            order.nftIds, order.minExpectedOutput, payable(address(this)), true, msg.sender\n                        );\n                    }\n\n                    // Accumulate ETH amount\n                    ethAmount += outputAmount;\n                }\n                // Otherwise, all tokens or ETH received from the sale go to the token recipient\n                else {\n                    // Pass in params for property checking if needed\n                    // Then do the swap with the same minExpectedTokenOutput amount\n                    if (order.doPropertyCheck) {\n                        outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n                            order.nftIds,\n                            order.minExpectedOutput,\n                            swapOrder.tokenRecipient,\n                            true,\n                            msg.sender,\n                            order.propertyCheckParams\n                        );\n                    } else {\n                        outputAmount = order.pair.swapNFTsForToken(\n                            order.nftIds, order.minExpectedOutput, swapOrder.tokenRecipient, true, msg.sender\n                        );\n                    }\n                }\n            }\n            // Otherwise we need to do some partial fill calculations first\n            else {\n                uint256 numItemsToFill;\n                uint256 priceToFillAt;\n\n                {\n                    // Grab royalty for calc in _findMaxFillableAmtForSell\n                    (,, uint256 royaltyAmount) = order.pair.calculateRoyaltiesView(\n                        order.isERC721 ? order.nftIds[0] : LSSVMPairERC1155(address(order.pair)).nftId(), BASE\n                    );\n\n                    // Calculate the max number of items we can sell\n                    (numItemsToFill, priceToFillAt) = _findMaxFillableAmtForSell(\n                        order.pair,\n                        pairSpotPrice,\n                        order.minExpectedOutputPerNumNFTs,\n                        protocolFeeMultiplier,\n                        royaltyAmount\n                    );\n                }\n\n                // If we can sell at least 1 item...\n                if (numItemsToFill != 0) {\n                    // If property checking is needed, do the property check swap\n                    if (order.doPropertyCheck) {\n                        outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n                            order.nftIds[:numItemsToFill],\n                            priceToFillAt,\n                            swapOrder.tokenRecipient,\n                            true,\n                            msg.sender,\n                            order.propertyCheckParams\n                        );\n                    }\n                    // Otherwise do a normal sell swap\n                    else {\n                        // Get subarray if ERC721\n                        if (order.isERC721) {\n                            outputAmount = order.pair.swapNFTsForToken(\n                                order.nftIds[:numItemsToFill], priceToFillAt, swapOrder.tokenRecipient, true, msg.sender\n                            );\n                        }\n                        // For 1155 swaps, wrap as number\n                        else {\n                            outputAmount = order.pair.swapNFTsForToken(\n                                _wrapUintAsArray(numItemsToFill),\n                                priceToFillAt,\n                                swapOrder.tokenRecipient,\n                                true,\n                                msg.sender\n                            );\n                        }\n                    }\n                }\n            }\n            results[i] = outputAmount;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Go through each buy order\n        for (uint256 i; i < swapOrder.buyOrders.length;) {\n            BuyOrderWithPartialFill calldata order = swapOrder.buyOrders[i];\n\n            // @dev We use inputAmount to store the spot price temporarily before it's overwritten\n            // (yes, it's gross)\n            uint256 inputAmount = order.pair.spotPrice();\n\n            // If the spot price parameter seen is what we expect it to be...\n            if (inputAmount == order.expectedSpotPrice) {\n                // Then do a direct swap for all items we want\n                inputAmount = order.pair.swapTokenForSpecificNFTs{value: order.ethAmount}(\n                    order.nftIds, order.maxInputAmount, swapOrder.nftRecipient, true, msg.sender\n                );\n\n                // Deduct ETH amount if it's an ETH swap\n                if (order.ethAmount != 0) {\n                    ethAmount -= inputAmount;\n                }\n            }\n            // Otherwise, we need to do some partial fill calculations first\n            else {\n                uint256 numItemsToFill;\n                uint256 priceToFillAt;\n\n                {\n                    (,, uint256 royaltyAmount) = order.pair.calculateRoyaltiesView(\n                        order.isERC721 ? order.nftIds[0] : LSSVMPairERC1155(address(order.pair)).nftId(), BASE\n                    );\n\n                    // uint128(inputAmount) is safe because order.pair.spotPrice() returns uint128\n                    (numItemsToFill, priceToFillAt) = _findMaxFillableAmtForBuy(\n                        order.pair, uint128(inputAmount), order.maxCostPerNumNFTs, protocolFeeMultiplier, royaltyAmount\n                    );\n                }\n\n                // Set inputAmount to be 0 (assuming we don't fully meet all criteria for a swap)\n                inputAmount = 0;\n\n                // Continue if we can fill at least 1 item\n                if (numItemsToFill != 0) {\n                    // Set ETH amount to send (is 0 if it's an ERC20 swap)\n                    uint256 ethToSendForBuy;\n                    if (order.ethAmount != 0) {\n                        ethToSendForBuy = priceToFillAt;\n                    }\n\n                    // If ERC721 swap\n                    if (order.isERC721) {\n                        // Get list of actually valid ids to buy\n                        uint256[] memory availableIds = _findAvailableIds(order.pair, numItemsToFill, order.nftIds);\n\n                        // Only swap if there are valid IDs to buy\n                        if (availableIds.length != 0) {\n                            inputAmount = order.pair.swapTokenForSpecificNFTs{value: ethToSendForBuy}(\n                                availableIds, priceToFillAt, swapOrder.nftRecipient, true, msg.sender\n                            );\n                        }\n                    }\n                    // If ERC1155 swap\n                    else {\n                        // The amount to buy is the min(numItemsToFill, erc1155.balanceOf(pair))\n                        {\n                            uint256 availableNFTs = IERC1155(order.pair.nft()).balanceOf(\n                                address(order.pair), LSSVMPairERC1155(address(order.pair)).nftId()\n                            );\n                            numItemsToFill = numItemsToFill < availableNFTs ? numItemsToFill : availableNFTs;\n                        }\n\n                        // Only continue if we can fill for nonzero amount of items\n                        if (numItemsToFill != 0) {\n                            // Do the 1155 swap, with the modified amount to buy\n                            inputAmount = order.pair.swapTokenForSpecificNFTs{value: ethToSendForBuy}(\n                                _wrapUintAsArray(numItemsToFill),\n                                priceToFillAt,\n                                swapOrder.nftRecipient,\n                                true,\n                                msg.sender\n                            );\n                        }\n                    }\n\n                    // Deduct ETH amount if it's an ETH swap\n                    if (order.ethAmount != 0) {\n                        ethAmount -= inputAmount;\n                    }\n                }\n            }\n            // Store inputAmount in results\n            results[i + swapOrder.sellOrders.length] = inputAmount;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Send excess ETH back to token recipient\n        if (ethAmount != 0) {\n            payable(swapOrder.tokenRecipient).safeTransferETH(ethAmount);\n        }\n    }\n\n    receive() external payable {}\n\n    /**\n     * Internal helper functions\n     */\n\n    /**\n     *   @dev Performs a binary search to find the largest value where maxCostPerNumNFTs is still greater than\n     *   the pair's bonding curve's getBuyInfo() value.\n     *   @param pair The pair to calculate partial fill values for\n     *   @param maxCostPerNumNFTs The user's specified maximum price to pay for filling a number of NFTs\n     *   @param protocolFeeMultiplier The % set as protocol fee\n     *   @param royaltyAmount Royalty amount assuming a cost of BASE, used for cheaper royalty calc\n     *   @dev Note that maxPricesPerNumNFTs is 0-indexed\n     */\n    function _findMaxFillableAmtForBuy(\n        LSSVMPair pair,\n        uint128 spotPrice,\n        uint256[] memory maxCostPerNumNFTs,\n        uint256 protocolFeeMultiplier,\n        uint256 royaltyAmount\n    ) internal view returns (uint256 numItemsToFill, uint256 priceToFillAt) {\n        // Set start and end indices\n        uint256 start = 1;\n        uint256 end = maxCostPerNumNFTs.length;\n\n        // Cache current pair values\n        uint128 delta = pair.delta();\n        uint256 feeMultiplier = pair.fee();\n\n        // Perform binary search\n        while (start <= end) {\n            // uint256 numItems = (start + end)/2; (but we hard-code it below to avoid stack too deep)\n\n            // We check the price to buy index + 1\n            (\n                CurveErrorCodes.Error error,\n                /* newSpotPrice */\n                ,\n                /* newDelta */\n                ,\n                uint256 currentCost,\n                /* tradeFee */\n                ,\n                /* protocolFee */\n            ) = pair.bondingCurve().getBuyInfo(\n                spotPrice, delta, (start + end) / 2, feeMultiplier, protocolFeeMultiplier\n            );\n\n            currentCost += currentCost * royaltyAmount / BASE;\n\n            // If the bonding curve has a math error, or\n            // If the current price is too expensive relative to our max cost,\n            // then we recurse on the left half (i.e. less items)\n            if (\n                error != CurveErrorCodes.Error.OK || currentCost > maxCostPerNumNFTs[(start + end) / 2 - 1] /* this is the max cost we are willing to pay, zero-indexed */\n            ) {\n                end = (start + end) / 2 - 1;\n            }\n            // Otherwise, we recurse on the right half (i.e. more items)\n            else {\n                numItemsToFill = (start + end) / 2;\n                start = (start + end) / 2 + 1;\n                priceToFillAt = currentCost;\n            }\n        }\n    }\n\n    function _findMaxFillableAmtForSell(\n        LSSVMPair pair,\n        uint128 spotPrice,\n        uint256[] memory minOutputPerNumNFTs,\n        uint256 protocolFeeMultiplier,\n        uint256 royaltyAmount\n    ) internal view returns (uint256 numItemsToFill, uint256 priceToFillAt) {\n        // Set start and end indices\n        uint256 start = 1;\n        uint256 end = minOutputPerNumNFTs.length;\n\n        // Cache current pair values\n        uint256 deltaAndFeeMultiplier;\n        {\n            uint128 delta = pair.delta();\n            uint96 feeMultiplier = pair.fee();\n            deltaAndFeeMultiplier = uint256(delta) << 96 | feeMultiplier;\n        }\n        uint256 pairTokenBalance = getPairBaseQuoteTokenBalance(pair);\n\n        // Perform binary search\n        while (start <= end) {\n            // We check the price to sell index + 1\n            (\n                CurveErrorCodes.Error error,\n                /* newSpotPrice */\n                ,\n                /* newDelta */\n                ,\n                uint256 currentOutput,\n                /* tradeFee */\n                ,\n                /* protocolFee */\n            ) = pair.bondingCurve().getSellInfo(\n                spotPrice,\n                // get delta from deltaAndFeeMultiplier\n                uint128(deltaAndFeeMultiplier >> 96),\n                (start + end) / 2,\n                // get feeMultiplier from deltaAndFeeMultiplier\n                uint96(deltaAndFeeMultiplier),\n                protocolFeeMultiplier\n            );\n            currentOutput -= currentOutput * royaltyAmount / BASE;\n            // If the bonding curve has a math error, or\n            // if the current output is too low relative to our max output, or\n            // if the current output is greater than the pair's token balance,\n            // then we recurse on the left half (i.e. less items)\n            if (\n                error != CurveErrorCodes.Error.OK || currentOutput < minOutputPerNumNFTs[(start + end) / 2 - 1] /* this is the max cost we are willing to pay, zero-indexed */\n                    || currentOutput > pairTokenBalance\n            ) {\n                end = (start + end) / 2 - 1;\n            }\n            // Otherwise, we recurse on the right half (i.e. more items)\n            else {\n                numItemsToFill = (start + end) / 2;\n                start = (start + end) / 2 + 1;\n                priceToFillAt = currentOutput;\n            }\n        }\n    }\n\n    /**\n     *   @dev Checks ownership of all desired NFT IDs to see which ones are still fillable\n     *   @param pair The pair to check for ownership\n     *   @param maxIdsNeeded The maximum amount of NFTs we want, guaranteed to be up to potentialIds.length, but could be less\n     *   @param potentialIds The possible NFT IDs that the pair could own\n     *   @return idsToBuy Actual NFT IDs owned by the pair, guaranteed to be up to maxIdsNeeded length, but could be less\n     */\n    function _findAvailableIds(LSSVMPair pair, uint256 maxIdsNeeded, uint256[] memory potentialIds)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        IERC721 nft = IERC721(pair.nft());\n        uint256[] memory idsThatExist = new uint256[](maxIdsNeeded);\n        uint256 numIdsFound = 0;\n\n        // Go through each potential ID, and check to see if it's still owned by the pair\n        // If it is, record the ID\n        for (uint256 i; i < maxIdsNeeded;) {\n            if (nft.ownerOf(potentialIds[i]) == address(pair)) {\n                idsThatExist[numIdsFound] = potentialIds[i];\n                numIdsFound += 1;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        // If all ids were found, return the full id list\n        if (numIdsFound == maxIdsNeeded) {\n            return idsThatExist;\n        }\n        // Otherwise, we didn't find enough IDs, so we need to return a subset\n        if (numIdsFound < maxIdsNeeded) {\n            uint256[] memory allIdsFound = new uint256[](numIdsFound);\n            for (uint256 i; i < numIdsFound;) {\n                allIdsFound[i] = idsThatExist[i];\n\n                unchecked {\n                    ++i;\n                }\n            }\n            return allIdsFound;\n        }\n        uint256[] memory emptyArr = new uint256[](0);\n        return emptyArr;\n    }\n\n    /**\n     * Restricted functions\n     */\n\n    /**\n     * @dev Allows an ERC20 pair contract to transfer ERC20 tokens directly from\n     *     the sender, in order to minimize the number of token transfers. Only callable by an ERC20 pair.\n     *     @param token The ERC20 token to transfer\n     *     @param from The address to transfer tokens from\n     *     @param to The address to transfer tokens to\n     *     @param amount The amount of tokens to transfer\n     */\n    function pairTransferERC20From(ERC20 token, address from, address to, uint256 amount) external {\n        // verify caller is a trusted ERC20 pair contract\n        if (\n            !(\n                factory.isValidPair(msg.sender)\n                    && factory.getPairTokenType(msg.sender) == ILSSVMPairFactoryLike.PairTokenType.ERC20\n            )\n        ) {\n            revert VeryFastRouter__InvalidPair();\n        }\n\n        // transfer tokens to pair\n        token.safeTransferFrom(from, to, amount);\n    }\n\n    /**\n     * @dev Allows a pair contract to transfer ERC721 NFTs directly from\n     *     the sender, in order to minimize the number of token transfers. Only callable by a pair.\n     *     @param nft The ERC721 NFT to transfer\n     *     @param from The address to transfer tokens from\n     *     @param to The address to transfer tokens to\n     *     @param id The ID of the NFT to transfer\n     */\n    function pairTransferNFTFrom(IERC721 nft, address from, address to, uint256 id) external {\n        // verify caller is a trusted pair contract\n        if (\n            !(\n                factory.isValidPair(msg.sender)\n                    && factory.getPairNFTType(msg.sender) == ILSSVMPairFactoryLike.PairNFTType.ERC721\n            )\n        ) {\n            revert VeryFastRouter__InvalidPair();\n        }\n\n        // transfer NFTs to pair\n        nft.transferFrom(from, to, id);\n    }\n\n    /**\n     * @dev Allows a pair contract to transfer ERC1155 NFTs directly from\n     *     the sender, in order to minimize the number of token transfers. Only callable by a pair.\n     *     @param nft The ERC1155 NFT to transfer\n     *     @param from The address to transfer tokens from\n     *     @param to The address to transfer tokens to\n     *     @param ids The IDs of the NFT to transfer\n     *     @param amounts The amount of each ID to transfer\n     */\n    function pairTransferERC1155From(\n        IERC1155 nft,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        // verify caller is a trusted pair contract\n        if (\n            !(\n                factory.isValidPair(msg.sender)\n                    && factory.getPairNFTType(msg.sender) == ILSSVMPairFactoryLike.PairNFTType.ERC1155\n            )\n        ) {\n            revert VeryFastRouter__InvalidPair();\n        }\n\n        // transfer NFTs to pair\n        nft.safeBatchTransferFrom(from, to, ids, amounts, bytes(\"\"));\n    }\n}"
    },
    {
      "filename": "src/VeryFastRouter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport {LSSVMPair} from \"./LSSVMPair.sol\";\nimport {LSSVMPairERC20} from \"./LSSVMPairERC20.sol\";\nimport {ILSSVMPairERC721} from \"./erc721/ILSSVMPairERC721.sol\";\nimport {LSSVMPairERC1155} from \"./erc1155/LSSVMPairERC1155.sol\";\nimport {ILSSVMPairFactoryLike} from \"./ILSSVMPairFactoryLike.sol\";\nimport {CurveErrorCodes} from \"./bonding-curves/CurveErrorCodes.sol\";\n\n/**\n * @dev Full-featured router to handle all swap types, with partial fill support\n */\ncontract VeryFastRouter {\n    using SafeTransferLib for address payable;\n    using SafeTransferLib for ERC20;\n\n    uint256 constant BASE = 1e18;\n\n    ILSSVMPairFactoryLike public immutable factory;\n\n    struct BuyOrderWithPartialFill {\n        LSSVMPair pair;\n        bool isERC721;\n        uint256[] nftIds;\n        uint256 maxInputAmount;\n        uint256 ethAmount;\n        uint256 expectedSpotPrice;\n        uint256[] maxCostPerNumNFTs; // @dev This is zero-indexed, so maxCostPerNumNFTs[x] = max price we're willing to pay to buy x+1 NFTs\n    }\n\n    struct SellOrderWithPartialFill {\n        LSSVMPair pair;\n        bool isETHSell;\n        bool isERC721;\n        uint256[] nftIds;\n        bool doPropertyCheck;\n        bytes propertyCheckParams;\n        uint128 expectedSpotPrice;\n        uint256 minExpectedOutput;\n        uint256[] minExpectedOutputPerNumNFTs;\n    }\n\n    struct Order {\n        BuyOrderWithPartialFill[] buyOrders;\n        SellOrderWithPartialFill[] sellOrders;\n        address payable tokenRecipient;\n        address nftRecipient;\n        bool recycleETH;\n    }\n\n    struct PartialFillSellArgs {\n        LSSVMPair pair;\n        uint128 spotPrice;\n        uint256 maxNumNFTs;\n        uint256[] minOutputPerNumNFTs;\n        uint256 protocolFeeMultiplier;\n        uint256 nftId;\n    }\n\n    struct PartialFillSellHelperArgs {\n        LSSVMPair pair;\n        uint256[] minOutputPerNumNFTs;\n        uint256 protocolFeeMultiplier;\n        uint256 nftId;\n        uint256 start;\n        uint256 end;\n        uint128 delta;\n        uint128 spotPrice;\n        uint256 feeMultiplier;\n        uint256 pairTokenBalance;\n        uint256 royaltyAmount;\n        uint256 numItemsToFill;\n        uint256 priceToFillAt;\n    }\n\n    error VeryFastRouter__InvalidPair();\n    error VeryFastRouter__BondingCurveQuoteError();\n\n    constructor(ILSSVMPairFactoryLike _factory) {\n        factory = _factory;\n    }\n\n    /* @dev Meant to be used as a client-side utility\n     * Given a pair and a number of items to buy, calculate the max price paid for 1 up to numNFTs to buy\n     */\n    function getNFTQuoteForBuyOrderWithPartialFill(\n        LSSVMPair pair,\n        uint256 numNFTs,\n        uint256 slippageScaling,\n        uint256 assetId\n    ) external view returns (uint256[] memory) {\n        uint256[] memory prices = new uint256[](numNFTs);\n\n        for (uint256 i; i < numNFTs;) {\n            uint128 newSpotPrice = pair.spotPrice();\n            uint128 newDelta = pair.delta();\n\n            // Assume that i items"
    }
  ]
}