{
  "Title": "[M01] Expired attestations lock funds",
  "Content": "The [`Attestation`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L22) contract allows users to request an attestation that they own a specific telephone number. To do so, a user must call the [`request` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L145-L188), [transferring funds from their ERC20 account to the `Attestation` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L155-L158).\n\n\nFor the flow to be completed, the user must call the `selectIssuers` function and, after receiving the attestation via SMS, call the `complete` function before the [`attestationExpiryBlocks` amount of blocks](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L80) have passed.\n\n\nIf the user was not able to complete this request, or if the issuers have any problem sending the attestation to the user’s SMS within the time it took the network to produce the `attestationExpiryBlocks`, users’ funds will be locked forever in the `Attestation` contract. The [`validateAttestationCode` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L496), which is called by [the `complete` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L221), will revert on [line 514](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L514) once the attestation has expired.\n\n\nConsider implementing specific functionality to let users withdraw their money in case the attestation could not be completed.\n\n\n****Update:*** Not an issue.  \n\nThe implemented behavior is correct according to the specification. [Pull request #3437](https://github.com/celo-org/celo-monorepo/pull/3437/files) adds a comment to make this clearer. cLabs’ statement for this issue:*\n\n\n\n> \n> The loss of the attestation fee in the event of an incomplete attestation is a necessary requirement for the security of the protocol. There are two negative consequences that would result from the ability for users to withdraw their funds:  \n> \n> – Most importantly, it would allow malicious validators to spam other validators and cause them to send text messages for which they would not be able to be compensated through the completion of the attestation at virtually no cost to the attacker. Only without the fee being recoverable can the protocol incur a cost to the attacker.  \n> \n> – It would reduce the cost for attackers to just request a lot of attestations, but only complete the ones that they can control validators for. For the remaining ones, they would just refund themselves with the attestation fee.  \n> \n> Thus M01 is not a bug, but a deliberate protocol design decision.\n> \n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/identity/Attestations.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAttestations.sol\";\nimport \"./interfaces/IRandom.sol\";\nimport \"../common/interfaces/IERC20Token.sol\";\nimport \"../common/interfaces/IAccounts.sol\";\nimport \"../governance/interfaces/IValidators.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/SafeCast.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n/**\n * @title Contract mapping identifiers to accounts\n */\ncontract Attestations is\n  IAttestations,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  ReentrancyGuard,\n  UsingPrecompiles\n{\n  using SafeMath for uint256;\n  using SafeCast for uint256;\n\n  enum AttestationStatus { None, Incomplete, Complete }\n\n  struct Attestation {\n    AttestationStatus status;\n    // For outstanding attestations, this is the block number of the request.\n    // For completed attestations, this is the block number of the attestation completion.\n    uint32 blockNumber;\n    // The token with which attestation request fees were paid.\n    address attestationRequestFeeToken;\n  }\n\n  // Stores attestations state for a single (identifier, account address) pair.\n  struct AttestedAddress {\n    // Total number of requested attestations.\n    uint32 requested;\n    // Total number of completed attestations.\n    uint32 completed;\n    // List of selected issuers responsible for attestations. The length of this list\n    // might be smaller than `requested` (which represents the total number of requested\n    // attestations) if users are not calling `selectIssuers` on unselected requests.\n    address[] selectedIssuers;\n    // State of each attestation keyed by issuer.\n    mapping(address => Attestation) issuedAttestations;\n  }\n\n  struct UnselectedRequest {\n    // The block at which the attestations were requested.\n    uint32 blockNumber;\n    // The number of attestations that were requested.\n    uint32 attestationsRequested;\n    // The token with which attestation request fees were paid in this request.\n    address attestationRequestFeeToken;\n  }\n\n  struct IdentifierState {\n    // All account addresses associated with this identifier.\n    address[] accounts;\n    // Keeps the state of attestations for account addresses for this identifier.\n    mapping(address => AttestedAddress) attestations;\n    // Temporarily stores attestation requests for which issuers should be selected by the account.\n    mapping(address => UnselectedRequest) unselectedRequests;\n  }\n\n  mapping(bytes32 => IdentifierState) identifiers;\n\n  // The duration in blocks in which an attestation can be completed from the block in which the\n  // attestation was requested.\n  uint256 public attestationExpiryBlocks;\n\n  // The duration to wait until selectIssuers can be called for an attestation request.\n  uint256 public selectIssuersWaitBlocks;\n\n  // The fees that are associated with attestations for a particular token.\n  mapping(address => uint256) public attestationRequestFees;\n\n  // Maps a token and attestation issuer to the amount that they're owed.\n  mapping(address => mapping(address => uint256)) public pendingWithdrawals;\n\n  event AttestationsRequested(\n    bytes32 indexed identifier,\n    address indexed account,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationIssuerSelected(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationCompleted(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer\n  );\n\n  event Withdrawal(address indexed account, address indexed token, uint256 amount);\n  event AttestationExpiryBlocksSet(uint256 value);\n  event AttestationRequestFeeSet(address indexed token, uint256 value);\n  event SelectIssuersWaitBlocksSet(uint256 value);\n\n  function initialize(\n    address registryAddress,\n    uint256 _attestationExpiryBlocks,\n    uint256 _selectIssuersWaitBlocks,\n    address[] calldata attestationRequestFeeTokens,\n    uint256[] calldata attestationRequestFeeValues\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setAttestationExpiryBlocks(_attestationExpiryBlocks);\n    setSelectIssuersWaitBlocks(_selectIssuersWaitBlocks);\n\n    require(\n      attestationRequestFeeTokens.length > 0 &&\n        attestationRequestFeeTokens.length == attestationRequestFeeValues.length,\n      \"attestationRequestFeeTokens specification was invalid\"\n    );\n    for (uint256 i = 0; i < attestationRequestFeeTokens.length; i = i.add(1)) {\n      setAttestationRequestFee(attestationRequestFeeTokens[i], attestationRequestFeeValues[i]);\n    }\n  }\n\n  /**\n   * @notice Commit to the attestation request of a hashed identifier.\n   * @param identifier The hash of the identifier to be attested.\n   * @param attestationsRequested The number of requested attestations for this request.\n   * @param attestationRequestFeeToken The address of the token with which the attestation fee will\n   * be paid.\n   */\n  function request(\n    bytes32 identifier,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  ) external nonReentrant {\n    require(\n      attestationRequestFees[attestationRequestFeeToken] > 0,\n      \"Invalid attestationRequestFeeToken\"\n    );\n    require(\n      IERC20Token(attestationRequestFeeToken).transferFrom(\n        msg.sender,\n        address(this),\n        attestationRequestFees[attestationRequestFeeToken].mul(attestationsRequested)\n      ),\n      \"Transfer of attestation request fees failed\"\n    );\n\n    require(attestationsRequested > 0, \"You have to request at least 1 attestation\");\n\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber == 0 ||\n        isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber) ||\n        !isAttestationRequestSelectable(state.unselectedRequests[msg.sender].blockNumber),\n      \"There exists an unexpired, unselected attestation request\"\n    );\n\n    state.unselectedRequests[msg.sender].blockNumber = block.number.toUint32();\n    state.unselectedRequests[msg.sender].attestationsRequested = attestationsRequested.toUint32();\n    state.unselectedRequests[msg.sender].attestationRequestFeeToken = attestationRequestFeeToken;\n\n    state.attestations[msg.sender].requested = uint256(state.attestations[msg.sender].requested)\n      .add(attestationsRequested)\n      .toUint32();\n\n    emit AttestationsRequested(\n      identifier,\n      msg.sender,\n      attestationsRequested,\n      attestationRequestFeeToken\n    );\n  }\n\n  /**\n   * @notice Selects the issuers for the most recent attestation request.\n   * @param identifier The hash of the identifier to be attested.\n   */\n  function selectIssuers(bytes32 identifier) external {\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber > 0,\n      \"No unselected attestation request to select issuers for\"\n    );\n\n    require(\n      !isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber),\n      \"The attestation request has expired\"\n    );\n\n    addIncompleteAttestations(identifier);\n    delete state.unselectedRequests[msg.sender];\n  }\n\n  /**\n   * @notice Submit the secret message sent by the issuer to complete the attestation request.\n   * @param identifier The hash of the identifier for this attestation.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Throws if there is no matching outstanding attestation request.\n   * @dev Throws if the attestation window has passed.\n   */\n  function complete(bytes32 identifier, uint8 v, bytes32 r, bytes32 s) external {\n    address issuer = validateAttestationCode(identifier, msg.sender, v, r, s);\n\n    Attestation storage attestation = identifiers[identifier].attestations[msg.sender]\n      .issuedAttestations[issuer];\n\n    address token = attestation.attestationRequestFeeToken;\n\n    // solhint-disable-next-line not-rely-on-time\n    attestation.blockNumber = block.number.toUint32();\n    attestation.status = AttestationStatus.Complete;\n    delete attestation.attestationRequestFeeToken;\n    identifiers[identifier].attestations[msg.sender].completed++;\n\n    pendingWithdrawals[token][issuer] = pendingWithdrawals[token][issuer].add(\n      attestationRequestFees[token]\n    );\n\n    IdentifierState storage state = identifiers[identifier];\n    if (identifiers[identifier].attestations[msg.sender].completed == 1) {\n      state.accounts.push(msg.sender);\n    }\n\n    emit AttestationCompleted(identifier, msg.sender, issuer);\n  }\n\n  /**\n   * @notice Revokes an account for an identifier.\n   * @param identifier The identifier for which to revoke.\n   * @param index The index of the account in the accounts array.\n   */\n  function revoke(bytes32 identifier, uint256 index) external {\n    uint256 numAccounts = identifiers[identifier].accounts.length;\n    require(index < numAccounts, \"Index is invalid\");\n    require(\n      msg.sender == identifiers[identifier].accounts[index],\n      \"Index does not match msg.sender\"\n    );\n\n    uint256 newNumAccounts = numAccounts.sub(1);\n    if (index != newNumAccounts) {\n      identifiers[identifier].accounts[index] = identifiers[identifier].accounts[newNumAccounts];\n    }\n    identifiers[identifier].accounts[newNumAccounts] = address(0x0);\n    identifiers[identifier].accounts.length--;\n  }\n\n  /**\n   * @notice Allows issuers to withdraw accumulated attestation rewards.\n   * @param token The address of the token that will be withdrawn.\n   * @dev Throws if msg.sender does not have any rewards to withdraw.\n   */\n  function withdraw(address token) external {\n    uint256 value = pendingWithdrawals[token][msg.sender];\n    require(value > 0, \"value was negative/zero\");\n    pendingWithdrawals[token][msg.sender] = 0;\n    require(IERC20Token(token).transfer(msg.sender, value), \"token transfer failed\");\n    emit Withdrawal(msg.sender, token, value);\n  }\n\n  /**\n   * @notice Returns the unselected attestation request for an identifier/account pair, if any.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return [\n   *           Block number at which was requested,\n   *           Number of unselected requests,\n   *           Address of the token with which this attestation request was paid for\n   *         ]\n   */\n  function getUnselectedRequest(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32, uint32, address)\n  {\n    return (\n      identifiers[identifier].unselectedRequests[account].blockNumber,\n      identifiers[identifier].unselectedRequests[account].attestationsRequested,\n      identifiers[identifier].unselectedRequests[account].attestationRequestFeeToken\n    );\n  }\n\n  /**\n   * @notice Returns selected attestation issuers for a identifier/account pair.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return Addresses of the selected attestation issuers.\n   */\n  function getAttestationIssuers(bytes32 identifier, address account)\n    external\n    view\n    returns (address[] memory)\n  {\n    return identifiers[identifier].attestations[account].selectedIssuers;\n  }\n\n  /**\n   * @notice Returns attestation stats for a identifier/account pair.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return [Number of completed attestations, Number of total requested attestations]\n   */\n  function getAttestationStats(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32, uint32)\n  {\n    return (\n      identifiers[identifier].attestations[account].completed,\n      identifiers[identifier].attestations[account].requested\n    );\n  }\n\n  /**\n   * @notice Batch lookup function to determine attestation stats for a list of identifiers.\n   * @param identifiersToLookup Array of n identifiers.\n   * @return [0] Array of number of matching accounts per identifier.\n   * @return [1] Array of sum([0]) matching walletAddresses.\n   * @return [2] Array of sum([0]) numbers indicating the completions for each account.\n   * @return [3] Array of sum([0]) numbers indicating the total number of requested\n                 attestations for each account.\n   */\n  function batchGetAttestationStats(bytes32[] calldata identifiersToLookup)\n    external\n    view\n    returns (uint256[] memory, address[] memory, uint64[] memory, uint64[] memory)\n  {\n    require(identifiersToLookup.length > 0, \"You have to pass at least one identifier\");\n\n    uint256[] memory matches;\n    address[] memory addresses;\n\n    (matches, addresses) = batchlookupAccountsForIdentifier(identifiersToLookup);\n\n    uint64[] memory completed = new uint64[](addresses.length);\n    uint64[] memory total = new uint64[](addresses.length);\n\n    uint256 currentIndex = 0;\n    for (uint256 i = 0; i < identifiersToLookup.length; i++) {\n      address[] memory addrs = identifiers[identifiersToLookup[i]].accounts;\n      for (uint256 matchIndex = 0; matchIndex < matches[i]; matchIndex++) {\n        addresses[currentIndex] = getAccounts().getWalletAddress(addrs[matchIndex]);\n        completed[currentIndex] = identifiers[identifiersToLookup[i]]\n          .attestations[addrs[matchIndex]]\n          .completed;\n        total[currentIndex] = identifiers[identifiersToLookup[i]].attestations[addrs[matchIndex]]\n          .requested;\n\n        currentIndex++;\n      }\n    }\n\n    return (matches, addresses, completed, total);\n  }\n\n  /**\n   * @notice Returns the state of a specific attestation.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @param issuer Address of the issuer.\n   * @return [\n   *           Status of the attestation,\n   *           Block number of request/completion the attestation,\n   *           Address of the token with which this attestation request was paid for\n   *         ]\n   */\n  function getAttestationState(bytes32 identifier, address account, address issuer)\n    external\n    view\n    returns (uint8, uint32, address)\n  {\n    Attestation storage attestation = identifiers[identifier].attestations[account]\n      .issuedAttestations[issuer];\n    return (\n      uint8(attestation.status),\n      attestation.blockNumber,\n      attestation.attestationRequestFeeToken\n    );\n\n  }\n\n  /**\n    * @notice Returns the state of all attestations that are completable\n    * @param identifier Hash of the identifier.\n    * @param account Address of the account.\n    * @return ( blockNumbers[] - Block number of request/completion the attestation,\n    *           issuers[] - Address of the issuer,\n    *           stringLengths[] - The length of each metadataURL string for each issuer,\n    *           stringData - All strings concatenated\n    *         )\n    */\n  function getCompletableAttestations(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32[] memory, address[] memory, uint256[] memory, bytes memory)\n  {\n    AttestedAddress storage state = identifiers[identifier].attestations[account];\n    address[] storage issuers = state.selectedIssuers;\n\n    uint256 num = 0;\n    for (uint256 i = 0; i < issuers.length; i = i.add(1)) {\n      if (isAttestationCompletable(state.issuedAttestations[issuers[i]])) {\n        num = num.add(1);\n      }\n    }\n\n    uint32[] memory blockNumbers = new uint32[](num);\n    address[] memory completableIssuers = new address[](num);\n\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < issuers.length; i = i.add(1)) {\n      if (isAttestationCompletable(state.issuedAttestations[issuers[i]])) {\n        blockNumbers[pointer] = state.issuedAttestations[issuers[i]].blockNumber;\n        completableIssuers[pointer] = issuers[i];\n        pointer = pointer.add(1);\n      }\n    }\n\n    uint256[] memory stringLengths;\n    bytes memory stringData;\n    (stringLengths, stringData) = getAccounts().batchGetMetadataURL(completableIssuers);\n    return (blockNumbers, completableIssuers, stringLengths, stringData);\n  }\n\n  /**\n   * @notice Returns the fee set for a particular token.\n   * @param token Address of the attestationRequestFeeToken.\n   * @return The fee.\n   */\n  function getAttestationRequestFee(address token) external view returns (uint256) {\n    return attestationRequestFees[token];\n  }\n\n  /**\n   * @notice Updates the fee  for a particular token.\n   * @param token The address of the attestationRequestFeeToken.\n   * @param fee The fee in 'token' that is required for each attestation.\n   */\n  function setAttestationRequestFee(address token, uint256 fee) public onlyOwner {\n    require(fee > 0, \"You have to specify a fee greater than 0\");\n    attestationRequestFees[token] = fee;\n    emit AttestationRequestFeeSet(token, fee);\n  }\n\n  /**\n   * @notice Updates 'attestationExpiryBlocks'.\n   * @param _attestationExpiryBlocks The new limit on blocks allowed to come between requesting\n   * an attestation and completing it.\n   */\n  function setAttestationExpiryBlocks(uint256 _attestationExpiryBlocks) public onlyOwner {\n    require(_attestationExpiryBlocks > 0, \"attestationExpiryBlocks has to be greater than 0\");\n    attestationExpiryBlocks = _attestationExpiryBlocks;\n    emit AttestationExpiryBlocksSet(_attestationExpiryBlocks);\n  }\n\n  /**\n   * @notice Updates 'selectIssuersWaitBlocks'.\n   * @param _selectIssuersWaitBlocks The wait period in blocks to call selectIssuers on attestation\n   *                                 requests.\n   */\n  function setSelectIssuersWaitBlocks(uint256 _selectIssuersWaitBlocks) public onlyOwner {\n    require(_selectIssuersWaitBlocks > 0, \"selectIssuersWaitBlocks has to be greater than 0\");\n    selectIssuersWaitBlocks = _selectIssuersWaitBlocks;\n    emit SelectIssuersWaitBlocksSet(_selectIssuersWaitBlocks);\n  }\n\n  /**\n   * @notice Validates the given attestation code.\n   * @param identifier The hash of the identifier to be attested.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The issuer of the corresponding attestation.\n   * @dev Throws if there is no matching outstanding attestation request.\n   * @dev Throws if the attestation window has passed.\n   */\n  function validateAttestationCode(\n    bytes32 identifier,\n    address account,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 codehash = keccak256(abi.encodePacked(identifier, account));\n    address signer = Signatures.getSignerOfMessageHash(codehash, v, r, s);\n    address issuer = getAccounts().attestationSignerToAccount(signer);\n\n    Attestation storage attestation = identifiers[identifier].attestations[account]\n      .issuedAttestations[issuer];\n\n    require(\n      attestation.status == AttestationStatus.Incomplete,\n      \"Attestation code does not match any outstanding attestation\"\n    );\n    require(!isAttestationExpired(attestation.blockNumber), \"Attestation timed out\");\n\n    return issuer;\n  }\n\n  function lookupAccountsForIdentifier(bytes32 identifier)\n    external\n    view\n    returns (address[] memory)\n  {\n    return identifiers[identifier].accounts;\n  }\n\n  /**\n   * @notice Helper function for batchGetAttestationStats to calculate the\n             total number of addresses that have >0 complete attestations for the identifiers.\n   * @param identifiersToLookup Array of n identifiers.\n   * @return Array of n numbers that indicate the number of matching addresses per identifier\n   *         and array of addresses preallocated for total number of matches.\n   */\n  function batchlookupAccountsForIdentifier(bytes32[] memory identifiersToLookup)\n    internal\n    view\n    returns (uint256[] memory, address[] memory)\n  {\n    require(identifiersToLookup.length > 0, \"You have to pass at least one identifier\");\n    uint256 totalAddresses = 0;\n    uint256[] memory matches = new uint256[](identifiersToLookup.length);\n\n    for (uint256 i = 0; i < identifiersToLookup.length; i++) {\n      uint256 count = identifiers[identifiersToLookup[i]].accounts.length;\n\n      totalAddresses = totalAddresses + count;\n      matches[i] = count;\n    }\n\n    return (matches, new address[](totalAddresses));\n  }\n\n  /**\n   * @notice Adds additional attestations given the current randomness.\n   * @param identifier The hash of the identifier to be attested.\n   */\n  function addIncompleteAttestations(bytes32 identifier) internal {\n    AttestedAddress storage state = identifiers[identifier].attestations[msg.sender];\n    UnselectedRequest storage unselectedRequest = identifiers[identifier].unselectedRequests[msg\n      .sender];\n\n    bytes32 seed = getRandom().getBlockRandomness(\n      uint256(unselectedRequest.blockNumber).add(selectIssuersWaitBlocks)\n    );\n    uint256 numberValidators = numberValidatorsInCurrentSet();\n\n    uint256 currentIndex = 0;\n    address validator;\n    address issuer;\n\n    while (currentIndex < unselectedRequest.attestationsRequested) {\n      seed = keccak256(abi.encodePacked(seed));\n      validator = validatorSignerAddressFromCurrentSet(uint256(seed) % numberValidators);\n      issuer = getAccounts().validatorSignerToAccount(validator);\n      Attestation storage attestation = state.issuedAttestations[issuer];\n\n      // Attestation issuers can only be added if they haven't been already.\n      if (attestation.status != AttestationStatus.None) {\n        continue;\n      }\n\n      currentIndex = currentIndex.add(1);\n      attestation.status = AttestationStatus.Incomplete;\n      attestation.blockNumber = unselectedRequest.blockNumber;\n      attestation.attestationRequestFeeToken = unselectedRequest.attestationRequestFeeToken;\n      state.selectedIssuers.push(issuer);\n\n      emit AttestationIssuerSelected(\n        identifier,\n        msg.sender,\n        issuer,\n        unselectedRequest.attestationRequestFeeToken\n      );\n    }\n  }\n\n  function isAttestationExpired(uint128 attestationRequestBlock) internal view returns (bool) {\n    return block.number >= uint256(attestationRequestBlock).add(attestationExpiryBlocks);\n  }\n\n  function isAttestationCompletable(Attestation storage attestation) internal view returns (bool) {\n    return (attestation.status == AttestationStatus.Incomplete &&\n      !isAttestationExpired(attestation.blockNumber));\n  }\n\n  function isAttestationRequestSelectable(uint256 attestationRequestBlock)\n    internal\n    view\n    returns (bool)\n  {\n    return block.number < attestationRequestBlock.add(getRandom().randomnessBlockRetentionWindow());\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/identity/Attestations.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAttestations.sol\";\nimport \"./interfaces/IRandom.sol\";\nimport \"../common/interfaces/IERC20Token.sol\";\nimport \"../common/interfaces/IAccounts.sol\";\nimport \"../governance/interfaces/IValidators.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/SafeCast.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n/**\n * @title Contract mapping identifiers to accounts\n */\ncontract Attestations is\n  IAttestations,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  ReentrancyGuard,\n  UsingPrecompiles\n{\n  using SafeMath for uint256;\n  using SafeCast for uint256;\n\n  enum AttestationStatus { None, Incomplete, Complete }\n\n  struct Attestation {\n    AttestationStatus status;\n    // For outstanding attestations, this is the block number of the request.\n    // For completed attestations, this is the block number of the attestation completion.\n    uint32 blockNumber;\n    // The token with which attestation request fees were paid.\n    address attestationRequestFeeToken;\n  }\n\n  // Stores attestations state for a single (identifier, account address) pair.\n  struct AttestedAddress {\n    // Total number of requested attestations.\n    uint32 requested;\n    // Total number of completed attestations.\n    uint32 completed;\n    // List of selected issuers responsible for attestations. The length of this list\n    // might be smaller than `requested` (which represents the total number of requested\n    // attestations) if users are not calling `selectIssuers` on unselected requests.\n    address[] selectedIssuers;\n    // State of each attestation keyed by issuer.\n    mapping(address => Attestation) issuedAttestations;\n  }\n\n  struct UnselectedRequest {\n    // The block at which the attestations were requested.\n    uint32 blockNumber;\n    // The number of attestations that were requested.\n    uint32 attestationsRequested;\n    // The token with which attestation request fees were paid in this request.\n    address attestationRequestFeeToken;\n  }\n\n  struct IdentifierState {\n    // All account addresses associated with this identifier.\n    address[] accounts;\n    // Keeps the state of attestations for account addresses for this identifier.\n    mapping(address => AttestedAddress) attestations;\n    // Temporarily stores attestation requests for which issuers should be selected by the account.\n    mapping(address => UnselectedRequest) unselectedRequests;\n  }\n\n  mapping(bytes32 => IdentifierState) identifiers;\n\n  // The duration in blocks in which an attestation can be completed from the block in which the\n  // attestation was requested.\n  uint256 public attestationExpiryBlocks;\n\n  // The duration to wait until selectIssuers can be called for an attestation request.\n  uint256 public selectIssuersWaitBlocks;\n\n  // The fees that are associated with attestations for a particular token.\n  mapping(address => uint256) public attestationRequestFees;\n\n  // Maps a token and attestation issuer to the amount that they're owed.\n  mapping(address => mapping(address => uint256)) public pendingWithdrawals;\n\n  event AttestationsRequested(\n    bytes32 indexed identifier,\n    address indexed account,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationIssuerSelected(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationCompleted(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer\n  );\n\n  event Withdrawal(address indexed account, address indexed token, uint256 amount);\n  event AttestationExpiryBlocksSet(uint256 value);\n  event AttestationRequestFeeSet(address indexed token, uint256 value);\n  event SelectIssuersWaitBlocksSet(uint256 value);\n\n  function initialize(\n    address registryAddress,\n    uint256 _attestationExpiryBlocks,\n    uint256 _selectIssuersWaitBlocks,\n    address[] calldata attestationRequestFeeTokens,\n    uint256[] calldata attestationRequestFeeValues\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setAttestationExpiryBlocks(_attestationExpiryBlocks);\n    setSelectIssuersWaitBlocks(_selectIssuersWaitBlocks);\n\n    require(\n      attestationRequestFeeTokens.length > 0 &&\n        attestationRequestFeeTokens.length == attestationRequestFeeValues.length,\n      \"attestationRequestFeeTokens specification was invalid\"\n    );\n    for (uint256 i = 0; i < attestationRequestFeeTokens.length; i = i.add(1)) {\n      setAttestationRequestFee(attestationRequestFeeTokens[i], attestationRequestFeeValues[i]);\n    }\n  }\n\n  /**\n   * @notice Commit to the attestation request of a hashed identifier.\n   * @param identifier The hash of the identifier to be attested.\n   * @param attestationsRequested The number of requested attestations for this request.\n   * @param attestationRequestFeeToken The address of the token with which the attestation fee will\n   * be paid.\n   */\n  function request(\n    bytes32 identifier,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  ) external nonReentrant {\n    require(\n      attestationRequestFees[attestationRequestFeeToken] > 0,\n      \"Invalid attestationRequestFeeToken\"\n    );\n    require(\n      IERC20Token(attestationRequestFeeToken).transferFrom(\n        msg.sender,\n        address(this),\n        attestationRequestFees[attestationRequestFeeToken].mul(attestationsRequested)\n      ),\n      \"Transfer of attestation request fees failed\"\n    );\n\n    require(attestationsRequested > 0, \"You have to request at least 1 attestation\");\n\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber == 0 ||\n        isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber) ||\n        !isAttestationRequestSelectable(state.unselectedRequests[msg.sender].blockNumber),\n      \"There exists an unexpired, unselected attestation request\"\n    );\n\n    state.unselectedRequests[msg.sender].blockNumber = block.number.toUint32();\n    state.unselectedRequests[msg.sender].attestationsRequested = attestationsRequested.toUint32();\n    state.unselectedRequests[msg.sender].attestationRequestFeeToken = attestationRequestFeeToken;\n\n    state.attestations[msg.sender].requested = uint256(state.attestations[msg.sender].requested)\n      .add(attestationsRequested)\n      .toUint32();\n\n    emit AttestationsRequested(\n      identifier,\n      msg.sender,\n      attestationsRequested,\n      attestationRequestFeeToken\n    );\n  }\n\n  /**\n   * @notice Selects the issuers for the most recent attestation request.\n   * @param identifier The hash of the identifier to be attested.\n   */\n  function selectIssuers(bytes32 identifier) external {\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber > 0,\n      \"No unselected attestation request to select issuers for\"\n    );\n\n    require(\n      !isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber),\n      \"The attestation request has expired\"\n    );\n\n    addIncompleteAttestations(identifier);\n    delete state.unselectedRequests[msg.sender];\n  }\n\n  /**\n   * @notice Submit the secret message sent by the issuer to complete the attestation request.\n   * @param identifier The hash of the identifier for this attestation.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Throws if there is no matching outstanding attestation request.\n   * @dev Throws if the attestation window has passed.\n   */\n  function complete(bytes32 identifier, uint8 v, bytes32 r, bytes32 s) external {\n    address issuer = validateAttestationCode(identifier, msg.sender, v, r, s);\n\n    Attestation storage attestation = identifiers[identifier].attestations[msg.sender]\n      .issuedAttestations[issuer];\n\n    address token = attestation.attestationRequestFeeToken;\n\n    // solhint-disable-next-line not-rely-on-time\n    attestation.blockNumber = block.number.toUint32();\n    attestation.status = AttestationStatus.Complete;\n    delete attestation.attestationRequestFeeToken;\n    identifiers[identifier].attestations[msg.sender].completed++;\n\n    pendingWithdrawals[token][issuer] = pendingWithdrawals[token][issuer].add(\n      attestationRequestFees[token]\n    );\n\n    IdentifierState storage state = identifiers[identifier];\n    if (identifiers[identifier].attestations[msg.sender].completed == 1) {\n      state.accounts.push(msg.sender);\n    }\n\n    emit AttestationCompleted(identifier, msg.sender, issuer);\n  }\n\n  /**\n   * @notice Revokes an account for an identifier.\n   * @param identifier The identifier for which to revoke.\n   * @param index The index of the account in the accounts array.\n   */\n  function revoke(bytes32 identifier, uint256 index) external {\n    uint256 numAccounts = identifiers[identifier].accounts.length;\n    require(index < numAccounts, \"Index is invalid\");\n    require(\n      msg.sender == identifiers[identifier].accounts[index],\n      \"Index does not match msg.sender\"\n    );\n\n    uint256 newNumAccounts = numAccounts.sub(1);\n    if (index != newNumAccounts) {\n      identifiers[identifier].accounts[index] = identifiers[identifier].accounts[newNumAccounts];\n    }\n    identifiers[identifier].accounts[newNumAccounts] = address(0x0);\n    identifiers[identifier].accounts.length--;\n  }\n\n  /**\n   * @notice A"
    }
  ]
}