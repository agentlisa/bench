{
  "Title": "[M-09] Bio NFT incorrectly breaks SVG lines and doesn't support more than 120 characters effectively",
  "Content": "\nAccording to the docs\n\n> \"Any user can mint a Bio NFT by calling Bio.mint and passing his biography. It needs to be shorter than 200 characters.\"\n\nLet's take two strings and pass them to create an NFT. The first one is 200 characters long, and the second one is 120 characters long.\n\n`aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaWaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaWaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaWaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaWaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaW`\n\n`aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaWaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaWaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaW`\n\nThis is how they will look like. As you can see they look identical.\n![image](https://i.ibb.co/Cvw62Rz/Screenshot-from-2023-03-19-12-20-26.png)\n\nNext, lets take this text for which we create nft. I took it from a test and double. `012345678901234567890123456789012345678üë®‚Äçüë©‚Äçüëß‚Äçüëß012345678901234567890123456789012345678üë®‚Äçüë©‚Äçüëß‚Äçüëß`\n\nHere is on the left how it looks now vs how it suppose to be. As you can see the line breaking doesn't work. I did enlarge viewBox so you can see the difference.\n\n![image](https://i.ibb.co/XDNxLWx/Screenshot-from-2023-03-19-12-28-42.png)\n\nThe problem is in this part of the code, where `(i > 0 && (i + 1) % 40 == 0)` doesn't handle properly because you want to include emojis, so length will be more than 40 (`40 + length(emoji)`)\n\n```solidity\ncanto-bio-protocol/src/Bio.sol#L56\n        for (uint i; i < lengthInBytes; ++i) {\n            bytes1 character = bioTextBytes[i];\n            bytesLines[bytesOffset] = character;\n            bytesOffset++;\n            if ((i > 0 && (i + 1) % 40 == 0) || prevByteWasContinuation || i == lengthInBytes - 1) {\n                bytes1 nextCharacter;\n```\n\n[canto-bio-protocol/src/Bio.sol#L56](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-bio-protocol/src/Bio.sol#L56)\n\nLastly, the NFT doesn't center-align text, but I believe it should. I took text from a test and on the left is how it currently appears, while on the right is how I think it should be.\n![image](https://i.ibb.co/8r1jMhc/Screenshot-from-2023-03-18-13-43-21.png)\n\nHere is the code. dy doesn't apply correctly; it should be 0 for the first line.\n\n```solidity\n canto-bio-protocol/src/Bio.sol#L104\n        for (uint i; i < lines; ++i) {\n            text = string.concat(text, '<tspan x=\"50%\" dy=\"20\">', strLines[i], \"</tspan>\");\n        }\n```\n\n[canto-bio-protocol/src/Bio.sol#L104](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-bio-protocol/src/Bio.sol#L104)\n\n### Recommended Mitigation Steps\n\nEnlarge viewBox so it will support 200 length or restrict to 120 characters.\n\nHere is a complete code with correct line breaking and center text. I'm sorry that I didn't add `differ` to code because there will be too many lines. It does pass tests and fix current issues.\n\n```solidity\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (_ownerOf[_id] == address(0)) revert TokenNotMinted(_id);\n        string memory bioText = bio[_id];\n        bytes memory bioTextBytes = bytes(bioText);\n        uint lengthInBytes = bioTextBytes.length;\n        // Insert a new line after 40 characters, taking into account unicode character\n        uint lines = (lengthInBytes - 1) / 40 + 1;\n        string[] memory strLines = new string[](lines);\n        bool prevByteWasContinuation;\n        uint256 insertedLines;\n        // Because we do not split on zero-width joiners, line in bytes can technically be much longer. Will be shortened to the needed length afterwards\n        bytes memory bytesLines = new bytes(80);\n        uint bytesOffset;\n        uint j;\n        for (uint i; i < lengthInBytes; ++i) {\n            bytesLines[bytesOffset] = bytes1(bioTextBytes[i]);\n            bytesOffset++;\n            j+=1;\n            if ((j>=40) || prevByteWasContinuation || i == lengthInBytes - 1) {\n                bytes1 nextCharacter;\n                if (i != lengthInBytes - 1) {\n                    nextCharacter = bioTextBytes[i + 1];\n                }\n                if (nextCharacter & 0xC0 == 0x80) {\n                    // Unicode continuation byte, top two bits are 10\n                    prevByteWasContinuation = true;\n                    continue;\n                } else {\n                    // Do not split when the prev. or next character is a zero width joiner. Otherwise, üë®‚Äçüëß‚Äçüë¶ could become üë®>‚Äçüëß‚Äçüë¶\n                    // Furthermore, do not split when next character is skin tone modifier to avoid ü§¶‚Äç‚ôÇÔ∏è\\nüèª\n                    if (\n                        // Note that we do not need to check i < lengthInBytes - 4, because we assume that it's a valid UTF8 string and these prefixes imply that another byte follows\n                        (nextCharacter == 0xE2 && bioTextBytes[i + 2] == 0x80 && bioTextBytes[i + 3] == 0x8D) ||\n                        (nextCharacter == 0xF0 &&\n                            bioTextBytes[i + 2] == 0x9F &&\n                            bioTextBytes[i + 3] == 0x8F &&\n                            uint8(bioTextBytes[i + 4]) >= 187 &&\n                            uint8(bioTextBytes[i + 4]) <= 191) ||\n                        (i >= 2 &&\n                            bioTextBytes[i - 2] == 0xE2 &&\n                            bioTextBytes[i - 1] == 0x80 &&\n                            bioTextBytes[i] == 0x8D)\n                    ) {\n                        prevByteWasContinuation = true;\n                        continue;\n                    }\n                }\n\n                assembly {\n                    mstore(bytesLines, bytesOffset)\n                }\n                strLines[insertedLines++] = string(bytesLines);\n                bytesLines = new bytes(80);\n                prevByteWasContinuation = false;\n                bytesOffset = 0;\n                j=0;\n            }\n        }\n        string\n            memory svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 400 100\"><style>text { font-family: sans-serif; font-size: 12px; }</style>';\n        string memory text = '<text x=\"50%\" y=\"50%\" dominant-baseline=\"middle\" text-anchor=\"middle\">';\n        text = string.concat(text, '<tspan x=\"50%\" dy=\"0\">', strLines[0], \"</tspan>\");// center first line and than add dy\n        for (uint i=1; i < lines; ++i) {\n            text = string.concat(text, '<tspan x=\"50%\" dy=\"20\">', strLines[i], \"</tspan>\");\n        }\n        string memory json = Base64.encode(\n            bytes(\n                string.concat(\n                    '{\"name\": \"Bio #',\n                    LibString.toString(_id),\n                    '\", \"description\": \"',\n                    bioText,\n                    '\", \"image\": \"data:image/svg+xml;base64,',\n                    Base64.encode(bytes(string.concat(svg, text, \"</text></svg>\"))),\n                    '\"}'\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n```\n\n**[OpenCoreCH (Canto Identity) confirmed and commented](https://github.com/code-423n4/2023-03-canto-identity-findings/issues/59#issuecomment-1489315542):**\n > Yeah the line break generally happened approx. after 40 bytes, which results in somewhat weird results for these huge emojis. Should be fixed when the tokenURI is refactored, see [`#87`](https://github.com/code-423n4/2023-03-canto-identity-findings/issues/87). \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-03-canto-identity-subprotocols-contest",
  "Code": [
    {
      "filename": "canto-bio-protocol/src/Bio.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport \"../interface/Turnstile.sol\";\n\ncontract Bio is ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of tokens minted\n    uint256 public numMinted;\n\n    /// @notice Stores the bio value per NFT\n    mapping(uint256 => string) public bio;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event BioAdded(address indexed minter, uint256 indexed nftID, string indexed bio);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error InvalidBioLength(uint256 length);\n\n    /// @notice Initiates CSR on mainnet\n    constructor() ERC721(\"Biography\", \"Bio\") {\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @dev Generates an on-chain SVG with a new line after 40 bytes. Line splitting generally supports UTF-8 multibyte characters and emojis, but is not tested for arbitrary UTF-8 characters\n    /// @param _id ID to query for\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (_ownerOf[_id] == address(0)) revert TokenNotMinted(_id);\n        string memory bioText = bio[_id];\n        bytes memory bioTextBytes = bytes(bioText);\n        uint lengthInBytes = bioTextBytes.length;\n        // Insert a new line after 40 characters, taking into account unicode character\n        uint lines = (lengthInBytes - 1) / 40 + 1;\n        string[] memory strLines = new string[](lines);\n        bool prevByteWasContinuation;\n        uint256 insertedLines;\n        // Because we do not split on zero-width joiners, line in bytes can technically be much longer. Will be shortened to the needed length afterwards\n        bytes memory bytesLines = new bytes(80);\n        uint bytesOffset;\n        for (uint i; i < lengthInBytes; ++i) {\n            bytes1 character = bioTextBytes[i];\n            bytesLines[bytesOffset] = character;\n            bytesOffset++;\n            if ((i > 0 && (i + 1) % 40 == 0) || prevByteWasContinuation || i == lengthInBytes - 1) {\n                bytes1 nextCharacter;\n                if (i != lengthInBytes - 1) {\n                    nextCharacter = bioTextBytes[i + 1];\n                }\n                if (nextCharacter & 0xC0 == 0x80) {\n                    // Unicode continuation byte, top two bits are 10\n                    prevByteWasContinuation = true;\n                } else {\n                    // Do not split when the prev. or next character is a zero width joiner. Otherwise, üë®‚Äçüëß‚Äçüë¶ could become üë®>‚Äçüëß‚Äçüë¶\n                    // Furthermore, do not split when next character is skin tone modifier to avoid ü§¶‚Äç‚ôÇÔ∏è\\nüèª\n                    if (\n                        // Note that we do not need to check i < lengthInBytes - 4, because we assume that it's a valid UTF8 string and these prefixes imply that another byte follows\n                        (nextCharacter == 0xE2 && bioTextBytes[i + 2] == 0x80 && bioTextBytes[i + 3] == 0x8D) ||\n                        (nextCharacter == 0xF0 &&\n                            bioTextBytes[i + 2] == 0x9F &&\n                            bioTextBytes[i + 3] == 0x8F &&\n                            uint8(bioTextBytes[i + 4]) >= 187 &&\n                            uint8(bioTextBytes[i + 4]) <= 191) ||\n                        (i >= 2 &&\n                            bioTextBytes[i - 2] == 0xE2 &&\n                            bioTextBytes[i - 1] == 0x80 &&\n                            bioTextBytes[i] == 0x8D)\n                    ) {\n                        prevByteWasContinuation = true;\n                        continue;\n                    }\n                    assembly {\n                        mstore(bytesLines, bytesOffset)\n                    }\n                    strLines[insertedLines++] = string(bytesLines);\n                    bytesLines = new bytes(80);\n                    prevByteWasContinuation = false;\n                    bytesOffset = 0;\n                }\n            }\n        }\n        string\n            memory svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 400 100\"><style>text { font-family: sans-serif; font-size: 12px; }</style>';\n        string memory text = '<text x=\"50%\" y=\"50%\" dominant-baseline=\"middle\" text-anchor=\"middle\">';\n        for (uint i; i < lines; ++i) {\n            text = string.concat(text, '<tspan x=\"50%\" dy=\"20\">', strLines[i], \"</tspan>\");\n        }\n        string memory json = Base64.encode(\n            bytes(\n                string.concat(\n                    '{\"name\": \"Bio #',\n                    LibString.toString(_id),\n                    '\", \"description\": \"',\n                    bioText,\n                    '\", \"image\": \"data:image/svg+xml;base64,',\n                    Base64.encode(bytes(string.concat(svg, text, \"</text></svg>\"))),\n                    '\"}'\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice Mint a new Bio NFT\n    /// @param _bio The text to add\n    function mint(string calldata _bio) external {\n        // We check the length in bytes, so will be higher for UTF-8 characters. But sufficient for this check\n        if (bytes(_bio).length == 0 || bytes(_bio).length > 200) revert InvalidBioLength(bytes(_bio).length);\n        uint256 tokenId = ++numMinted;\n        bio[tokenId] = _bio;\n        _mint(msg.sender, tokenId);\n        emit BioAdded(msg.sender, tokenId, _bio);\n    }\n}"
    },
    {
      "filename": "canto-bio-protocol/src/Bio.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport \"../interface/Turnstile.sol\";\n\ncontract Bio is ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of tokens minted\n    uint256 public numMinted;\n\n    /// @notice Stores the bio value per NFT\n    mapping(uint256 => string) public bio;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event BioAdded(address indexed minter, uint256 indexed nftID, string indexed bio);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error InvalidBioLength(uint256 length);\n\n    /// @notice Initiates CSR on mainnet\n    constructor() ERC721(\"Biography\", \"Bio\") {\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @dev Generates an on-chain SVG with a new line after 40 bytes. Line splitting generally supports UTF-8 multibyte characters and emojis, but is not tested for arbitrary UTF-8 characters\n    /// @param _id ID to query for\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (_ownerOf[_id] == address(0)) revert TokenNotMinted(_id);\n        string memory bioText = bio[_id];\n        bytes memory bioTextBytes = bytes(bioText);\n        uint lengthInBytes = bioTextBytes.length;\n        // Insert a new line after 40 characters, taking into account unicode character\n        uint lines = (lengthInBytes - 1) / 40 + 1;\n        string[] memory strLines = new string[](lines);\n        bool prevByteWasContinuation;\n        uint256 insertedLines;\n        // Because we do not split on zero-width joiners, line in bytes can technically be much longer. Will be shortened to the needed length afterwards\n        bytes memory bytesLines = new bytes(80);\n        uint bytesOffset;\n        for (uint i; i < lengthInBytes; ++i) {\n            bytes1 character = bioTextBytes[i];\n            bytesLines[bytesOffset] = character;\n            bytesOffset++;\n            if ((i > 0 && (i + 1) % 40 == 0) || prevByteWasContinuation || i == lengthInBytes - 1) {\n                bytes1 nextCharacter;\n                if (i != lengthInBytes - 1) {\n                    nextCharacter = bioTextBytes[i + 1];\n                }\n                if (nextCharacter & 0xC0 == 0x80) {\n                    // Unicode continuation byte, top two bits are 10\n                    prevByteWasContinuation = true;\n                } else {\n                    // Do not split when the prev. or next character is a zero width joiner. Otherwise, üë®‚Äçüëß‚Äçüë¶ could become üë®>‚Äçüëß‚Äçüë¶\n                    // Furthermore, do not split when next character is skin tone modifier to avoid ü§¶‚Äç‚ôÇÔ∏è\\nüèª\n                    if (\n                        // Note that we do not need to check i < lengthInBytes - 4, because we assume that it's a valid UTF8 string and these prefixes imply that another byte follows\n                        (nextCharacter == 0xE2 && bioTextBytes[i + 2] == 0x80 && bioTextBytes[i + 3] == 0x8D) ||\n                        (nextCharacter == 0xF0 &&\n                            bioTextBytes[i + 2] == 0x9F &&\n                            bioTextBytes[i + 3] == 0x8F &&\n                            uint8(bioTextBytes[i + 4]) >= 187 &&\n                            uint8(bioTextBytes[i + 4]) <= 191) ||\n                        (i >= 2 &&\n                            bioTextBytes[i - 2] == 0xE2 &&\n                            bioTextBytes[i - 1] == 0x80 &&\n                            bioTextBytes[i] == 0x8D)\n                    ) {\n                        prevByteWasContinuation = true;\n                        continue;\n                    }\n                    assembly {\n                        mstore(bytesLines, bytesOffset)\n                    }\n                    strLines[insertedLines++] = string(bytesLines);\n                    bytesLines = new bytes(80);\n                    prevByteWasContinuation = false;\n                    bytesOffset = 0;\n                }\n            }\n        }\n        string\n            memory svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 400 100\"><style>text { font-family: sans-serif; font-size: 12px; }</style>';\n        string memory text = '<text x=\"50%\" y=\"50%\" dominant-baseline=\"middle\" text-anchor=\"middle\">';\n        for (uint i; i < lines; ++i) {\n            text = string.concat(text, '<tspan x=\"50%\" dy=\"20\">', strLines[i], \"</tspan>\");\n        }\n        string memory json = Base64.encode(\n            bytes(\n                string.concat(\n                    '{\"name\": \"Bio #',\n                    LibString.toString(_id),\n                    '\", \"description\": \"',\n                    bioText,\n                    '\", \"image\": \"data:image/svg+xml;base64,',\n                    Base64.encode(bytes(string.concat(svg, text, \"</text></svg>\"))),\n                    '\"}'\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice Mint a new Bio NFT\n    /// @param _bio The text to add\n    function mint(string calldata _bio) external {\n        // We check the length in bytes, so will be higher for UTF-8 characters. But sufficient for this check\n        if (bytes(_bio).length == 0 || bytes(_bio).length > 200) revert InvalidBioLength(bytes(_bio).length);\n        uint256 tokenId = ++numMinted;\n        bio[tokenId] = _bio;\n        _mint(msg.sender, tokenId);\n        emit BioAdded(msg.sender, tokenId, _bio);\n    }\n}"
    }
  ]
}