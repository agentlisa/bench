{
  "Title": "[G-06]  Use a more recent version of Solidity",
  "Content": "\nUse a Solidity version of at least 0.8.2 to get simple compiler automatic inlining.\n\nUse a Solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads.\n\nUse a Solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings.\n\nUse a Solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value.\n\n*There are 10 instances of this issue:*\n\n```solidity\nFile: src/interfaces/IFundingRateController.sol\n\n2:    pragma solidity >=0.8.0;\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/interfaces/IFundingRateController.sol#L2\n\n```solidity\nFile: src/interfaces/IPaprController.sol\n\n2:    pragma solidity >=0.8.0;\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/interfaces/IPaprController.sol#L2\n\n```solidity\nFile: src/interfaces/IUniswapOracleFundingRateController.sol\n\n2:    pragma solidity >=0.8.0;\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/interfaces/IUniswapOracleFundingRateController.sol#L2\n\n```solidity\nFile: src/libraries/OracleLibrary.sol\n\n2:    pragma solidity >=0.8.0;\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/libraries/OracleLibrary.sol#L2\n\n```solidity\nFile: src/libraries/PoolAddress.sol\n\n4:    pragma solidity >=0.8.0;\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/libraries/PoolAddress.sol#L4\n\n```solidity\nFile: src/libraries/UniswapHelpers.sol\n\n2:    pragma solidity >=0.8.0;\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/libraries/UniswapHelpers.sol#L2\n\n```solidity\nFile: src/NFTEDA/extensions/NFTEDAStarterIncentive.sol\n\n2:    pragma solidity >=0.8.0;\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/NFTEDA/extensions/NFTEDAStarterIncentive.sol#L2\n\n```solidity\nFile: src/NFTEDA/interfaces/INFTEDA.sol\n\n2:    pragma solidity >=0.8.0;\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/NFTEDA/interfaces/INFTEDA.sol#L2\n\n```solidity\nFile: src/NFTEDA/libraries/EDAPrice.sol\n\n2:    pragma solidity >=0.8.0;\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/NFTEDA/libraries/EDAPrice.sol#L2\n\n```solidity\nFile: src/NFTEDA/NFTEDA.sol\n\n2:    pragma solidity >=0.8.0;\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/NFTEDA/NFTEDA.sol#L2\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-12-backed",
  "Code": [
    {
      "filename": "src/interfaces/IFundingRateController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\ninterface IFundingRateController {\n    /// @notice emitted when target is updated\n    /// @param newTarget the new target value\n    event UpdateTarget(uint256 newTarget);\n\n    event SetFundingPeriod(uint256 fundingPeriod);\n\n    error AlreadyInitialized();\n    error FundingPeriodTooShort();\n    error FundingPeriodTooLong();\n\n    /// @notice Updates target and returns new target\n    /// @dev if block.timestamp == lastUpdated() then just returns target()\n    /// @return Target the new target value\n    function updateTarget() external returns (uint256);\n\n    /// @notice The timestamp at which target was last updated\n    /// @return lastUpdated the timestamp (in seconds) at which target was last updated\n    function lastUpdated() external view returns (uint256);\n\n    /// @notice The target value of one whole unit of papr in underlying units.\n    /// @dev Target represents the 0% funding rate value. If mark() is equal to this\n    /// value, then funding rates are 0 and newTarget() will equal target().\n    /// @return target The value of one whole unit of papr in underlying units.\n    /// Example: if papr has 18 decimals and underlying 6 decimals, then\n    ///  target = 1e6 means 1e18 papr is worth 1e6 underlying, according to target\n    function target() external view returns (uint256);\n\n    /// @notice The value of new value of target() if updateTarget() were called right now\n    /// @dev If mark() > target(), newTarget() will be less than target(), positive funding/negative interest\n    /// @dev If mark() < target(), newTarget() will be greater than target(), negative funding/positive interest\n    /// @return newTarget The up to date target value for this block\n    function newTarget() external view returns (uint256);\n\n    /// @notice The market value of a whole unit of papr in underlying units\n    /// @return mark market papr price, quoted in underlying\n    function mark() external view returns (uint256);\n\n    /// @notice The papr token, the value of which is intended to\n    /// reflect in-kind funding payments via target() changing in value\n    /// @return papr the ERC20 token (address)\n    function papr() external view returns (ERC20);\n\n    /// @notice The underlying token that is used to quote the value of papr\n    /// @return underlying the ERC20 token (address)\n    function underlying() external view returns (ERC20);\n\n    /// @notice The period over which funding is paid\n    /// @dev a shorter funding period means volatility has a greater impact\n    /// on funding => target, longer period means the inverse\n    /// @return fundingPeriod in seconds over which funding is paid\n    function fundingPeriod() external view returns (uint256);\n}"
    },
    {
      "filename": "src/interfaces/IPaprController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ReservoirOracleUnderwriter} from \"src/ReservoirOracleUnderwriter.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {INFTEDA} from \"src/NFTEDA/extensions/NFTEDAStarterIncentive.sol\";\n\ninterface IPaprController {\n    /// @notice collateral for a vault\n    struct Collateral {\n        /// @dev address of the collateral, cast to ERC721\n        ERC721 addr;\n        /// @dev tokenId of the collateral\n        uint256 id;\n    }\n\n    /// @notice vault information for a vault\n    struct VaultInfo {\n        /// @dev number of collateral tokens in the vault\n        uint16 count;\n        /// @dev start time of last auction the vault underwent, 0 if no auction has been started\n        uint40 latestAuctionStartTime;\n        /// @dev debt of the vault, expressed in papr token units\n        uint200 debt;\n    }\n\n    /// @notice parameters describing a swap\n    /// @dev increaseDebtAndSell has the input token as papr and output token as the underlying\n    /// @dev buyAndReduceDebt has the input token as the underlying and output token as papr\n    struct SwapParams {\n        /// @dev amount of input token to swap\n        uint256 amount;\n        /// @dev minimum amount of output token to be received\n        uint256 minOut;\n        /// @dev sqrt price limit for the swap\n        uint160 sqrtPriceLimitX96;\n        /// @dev optional address to receive swap fees\n        address swapFeeTo;\n        /// @dev optional swap fee in bips\n        uint256 swapFeeBips;\n    }\n\n    /// @notice parameters to be encoded in safeTransferFrom collateral addition\n    struct OnERC721ReceivedArgs {\n        /// @dev address to send proceeds to if minting debt or swapping\n        address proceedsTo;\n        /// @dev debt is ignored in favor of `swapParams.amount` of minOut > 0\n        uint256 debt;\n        /// @dev optional swapParams\n        SwapParams swapParams;\n        /// @dev oracle information associated with collateral being sent\n        ReservoirOracleUnderwriter.OracleInfo oracleInfo;\n    }\n\n    /// @notice parameters to change what collateral addresses can be used for a vault\n    struct CollateralAllowedConfig {\n        address collateral;\n        bool allowed;\n    }\n\n    /// @notice emitted when an address increases the debt balance of their vault\n    /// @param account address increasing their debt\n    /// @param collateralAddress address of the collateral token\n    /// @param amount amount of debt added\n    /// @dev vaults are uniquely identified by the address of the vault owner and the address of the collateral token used in the vault\n    event IncreaseDebt(address indexed account, ERC721 indexed collateralAddress, uint256 amount);\n\n    /// @notice emitted when a user adds collateral to their vault\n    /// @param account address adding collateral\n    /// @param collateralAddress contract address of the ERC721 collateral added\n    /// @param tokenId token id of the ERC721 collateral added\n    event AddCollateral(address indexed account, ERC721 indexed collateralAddress, uint256 indexed tokenId);\n\n    /// @notice emitted when a user removes collateral from their vault\n    /// @param account address removing collateral\n    /// @param collateralAddress contract address of the ERC721 collateral removed\n    /// @param tokenId token id of the ERC721 collateral removed\n    event RemoveCollateral(address indexed account, ERC721 indexed collateralAddress, uint256 indexed tokenId);\n\n    /// @notice emitted when a user reduces the debt balance of their vault\n    /// @param account address reducing their debt\n    /// @param collateralAddress address of the collateral token\n    /// @param amount amount of debt removed\n    event ReduceDebt(address indexed account, ERC721 indexed collateralAddress, uint256 amount);\n\n    /// @notice emitted when the owner sets whether a token address is allowed to serve as collateral for a vault\n    /// @param collateral address of the collateral token\n    /// @param isAllowed whether the collateral is allowed\n    event AllowCollateral(address indexed collateral, bool isAllowed);\n\n    /// @param vaultDebt how much debt the vault has\n    /// @param maxDebt the max debt the vault is allowed to have\n    error ExceedsMaxDebt(uint256 vaultDebt, uint256 maxDebt);\n\n    error InvalidCollateral();\n\n    error MinAuctionSpacing();\n\n    error NotLiquidatable();\n\n    error InvalidCollateralAccountPair();\n\n    error AccountHasNoDebt();\n\n    error OnlyCollateralOwner();\n\n    error DebtAmountExceedsUint200();\n\n    error CollateralAddressesDoNotMatch();\n\n    error LiquidationsLocked();\n\n    /// @notice adds collateral to msg.senders vault for collateral.addr\n    /// @dev use safeTransferFrom to save gas if only sending one NFT\n    /// @param collateral collateral to add\n    function addCollateral(IPaprController.Collateral[] calldata collateral) external;\n\n    /// @notice removes collateral from msg.senders vault\n    /// @dev all collateral must be from same contract address\n    /// @dev oracleInfo price must be type LOWER\n    /// @param sendTo address to send the collateral to when removed\n    /// @param collateralArr array of IPaprController.Collateral to be removed\n    /// @param oracleInfo oracle information for the collateral being removed\n    function removeCollateral(\n        address sendTo,\n        IPaprController.Collateral[] calldata collateralArr,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external;\n\n    /// @notice increases debt balance of the vault uniquely identified by msg.sender and the collateral address\n    /// @dev oracleInfo price must be type LOWER\n    /// @param mintTo address to mint the debt to\n    /// @param asset address of the collateral token used to mint the debt\n    /// @param amount amount of debt to mint\n    /// @param oracleInfo oracle information for the collateral being used to mint debt\n    function increaseDebt(\n        address mintTo,\n        ERC721 asset,\n        uint256 amount,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external;\n\n    /// @notice removes and burns debt from the vault uniquely identified by account and the collateral address\n    /// @param account address reducing their debt\n    /// @param asset address of the collateral token the user would like to remove debt from\n    /// @param amount amount of debt to remove\n    function reduceDebt(address account, ERC721 asset, uint256 amount) external;\n\n    /// @notice mints debt and swaps the debt for the controller's underlying token on Uniswap\n    /// @dev oracleInfo price must be type LOWER\n    /// @param proceedsTo address to send the proceeds to\n    /// @param collateralAsset address of the collateral token used to mint the debt\n    /// @param params parameters for the swap\n    /// @param oracleInfo oracle information for the collateral being used to mint debt\n    /// @return amount amount of underlying token received by the user\n    function increaseDebtAndSell(\n        address proceedsTo,\n        ERC721 collateralAsset,\n        IPaprController.SwapParams calldata params,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external returns (uint256);\n\n    /// @notice removes debt from a vault and burns it by buying it on Uniswap in exchange for the controller's underlying token\n    /// @param account address reducing their debt\n    /// @param collateralAsset address of the collateral token the user would like to remove debt from\n    /// @param params parameters for the swap\n    /// @return amount amount of debt received from the swap and burned\n    function buyAndReduceDebt(address account, ERC721 collateralAsset, IPaprController.SwapParams calldata params)\n        external\n        returns (uint256);\n\n    /// @notice purchases a liquidation auction with the controller's papr token\n    /// @dev oracleInfo price must be type TWAP\n    /// @param auction auction to purchase\n    /// @param maxPrice maximum price to pay for the auction\n    /// @param sendTo address to send the collateral to if auction is won\n    function purchaseLiquidationAuctionNFT(\n        INFTEDA.Auction calldata auction,\n        uint256 maxPrice,\n        address sendTo,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external;\n\n    /// @notice starts a liquidation auction for a vault if it is liquidatable\n    /// @dev oracleInfo price must be type TWAP\n    /// @param account address of the user who's vault to liquidate\n    /// @param collateral collateral to liquidate\n    /// @param oracleInfo oracle information for the collateral being liquidated\n    /// @return auction auction that was started\n    function startLiquidationAuction(\n        address account,\n        IPaprController.Collateral calldata collateral,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external returns (INFTEDA.Auction memory auction);\n\n    /// @notice sets the Uniswap V3 pool that is used to determine mark\n    /// @dev owner function\n    /// @param _pool address of the Uniswap V3 pool\n    function setPool(address _pool) external;\n\n    /// @notice sets the funding period for interest payments\n    /// @param _fundingPeriod new funding period in seconds\n    function setFundingPeriod(uint256 _fundingPeriod) external;\n\n    /// @notice sets value of liquidationsLocked\n    /// @dev owner function for use in emergencies\n    /// @param locked new value for liquidationsLocked\n    function setLiquidationsLocked(bool locked) external;\n\n    /// @notice sets whether a collateral is allowed to be used to mint debt\n    /// @dev owner function\n    /// @param collateralConfigs configuration settings indicating whether a collateral is allowed or not\n    function setAllowedCollateral(IPaprController.CollateralAllowedConfig[] calldata collateralConfigs) external;\n\n    /// @notice transfers papr tokens held in controller from auction fees\n    /// @dev owner function\n    /// @param to address to send papr tokens to\n    /// @param amount amount of papr to send\n    /// @dev only controller owner will be able to execute this function\n    function sendPaprFromAuctionFees(address to, uint256 amount) external;\n\n    /// @notice burns papr tokens held in controller from auction fees\n    /// @param amount amount of papr to burn\n    /// @dev only controller owner will be able to execute this function\n    function burnPaprFromAuctionFees(uint256 amount) external;\n\n    /// @notice returns who owns a collateral token in a vault\n    /// @param collateral address of the collateral\n    /// @param tokenId tokenId of the collateral\n    function collateralOwner(ERC721 collateral, uint256 tokenId) external view returns (address);\n\n    /// @notice returns whether a token address is allowed to serve as collateral for a vault\n    /// @param collateral address of the collateral token\n    function isAllowed(address collateral) external view returns (bool);\n\n    /// @notice if liquidations are currently locked, meaning startLiquidationAuciton will revert\n    /// @dev for use in case of emergencies\n    /// @return liquidationsLocked whether liquidations are locked\n    function liquidationsLocked() external view returns (bool);\n\n    /// @notice boolean indicating whether token0 in pool is the underlying token\n    function token0IsUnderlying() external view returns (bool);\n\n    /// @notice maximum LTV a vault can have, expressed as a decimal scaled by 1e18\n    function maxLTV() external view returns (uint256);\n\n    /// @notice minimum time that must pass before consecutive collateral is liquidated from the same vault\n    function liquidationAuctionMinSpacing() external view returns (uint256);\n\n    /// @notice amount the price of an auction decreases by per auctionDecayPeriod, expressed as a decimal scaled by 1e18\n    function perPeriodAuctionDecayWAD() external view returns (uint256);\n\n    /// @notice amount of time that perPeriodAuctionDecayWAD is applied to, expressed in seconds\n    function auctionDecayPeriod() external view returns (uint256);\n\n    /// @notice the multiplier for the starting price of an auction, applied to the current price of the collateral in papr tokens\n    function auctionStartPriceMultiplier() external view returns (uint256);\n\n    /// @notice fee paid by the vault owner when their vault is liquidated if there was excess debt credited to their vault, in bips\n    function liquidationPenaltyBips() external view returns (uint256);\n\n    /// @notice returns the maximum debt that can be minted for a given collateral value\n    /// @param totalCollateraValue total value of the collateral\n    /// @return maxDebt maximum debt that can be minted, expressed in terms of the papr token\n    function maxDebt(uint256 totalCollateraValue) external view returns (uint256);\n\n    /// @notice returns information about a vault\n    /// @param account address of the vault owner\n    /// @param asset address of the collateral token associated with the vault\n    /// @return vaultInfo VaultInfo struct representing information about a vault\n    function vaultInfo(address account, ERC721 asset) external view returns (IPaprController.VaultInfo memory);\n}"
    },
    {
      "filename": "src/interfaces/IUniswapOracleFundingRateController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IFundingRateController} from \"./IFundingRateController.sol\";\n\ninterface IUniswapOracleFundingRateController is IFundingRateController {\n    /// @notice emitted when pool is set\n    /// @param pool the new pool value\n    event SetPool(address indexed pool);\n\n    /// @notice emitted if _setPool is called with a pool\n    /// that's tokens do not match pool()\n    error PoolTokensDoNotMatch();\n    error InvalidUniswapV3Pool();\n\n    /// @notice The address of the Uniswap pool used for mark()\n    /// @return pool address of the pool\n    function pool() external returns (address);\n}"
    },
    {
      "filename": "src/libraries/OracleLibrary.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {TickMath} from \"fullrange/libraries/TickMath.sol\";\nimport {FullMath} from \"fullrange/libraries/FullMath.sol\";\n\nlibrary OracleLibrary {\n    /// from https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol#L49\n    function getQuoteAtTick(int24 tick, uint128 baseAmount, address baseToken, address quoteToken)\n        internal\n        pure\n        returns (uint256 quoteAmount)\n    {\n        unchecked {\n            uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n            // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n            if (sqrtRatioX96 <= type(uint128).max) {\n                uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n                quoteAmount = baseToken < quoteToken\n                    ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                    : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n            } else {\n                uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n                quoteAmount = baseToken < quoteToken\n                    ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                    : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n            }\n        }\n    }\n\n    // adapted from https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol#L30-L40\n    function timeWeightedAverageTick(int56 startTick, int56 endTick, int56 twapDuration)\n        internal\n        view\n        returns (int24 twat)\n    {\n        require(twapDuration != 0, \"BP\");\n\n        unchecked {\n            int56 delta = endTick - startTick;\n\n            twat = int24(delta / twapDuration);\n\n            // Always round to negative infinity\n            if (delta < 0 && (delta % (twapDuration) != 0)) {\n                twat--;\n            }\n\n            twat;\n        }\n    }\n\n    // adapted from https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol#L21-L28\n    function latestCumulativeTick(address pool) internal view returns (int56) {\n        uint32[] memory secondAgos = new uint32[](1);\n        secondAgos[0] = 0;\n        (int56[] memory tickCumulatives,) = IUniswapV3Pool(pool).observe(secondAgos);\n        return tickCumulatives[0];\n    }\n}"
    },
    {
      "filename": "src/libraries/PoolAddress.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// from https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/PoolAddress.sol\n// with updates for solc 8\npragma solidity >=0.8.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(address tokenA, address tokenB, uint24 fee) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                            POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}"
    },
    {
      "filename": "src/libraries/UniswapHelpers.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IUniswapV3Factory} from \"v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport {TickMath} from \"fullrange/libraries/TickMath.sol\";\nimport {FullMath} from \"fullrange/libraries/FullMath.sol\";\nimport {SafeCast} from \"v3-core/contracts/libraries/SafeCast.sol\";\n\nimport {PoolAddress} from \"./PoolAddress.sol\";\n\nlibrary UniswapHelpers {\n    using SafeCast for uint256;\n\n    /// @param minOut The minimum out amount the user wanted\n    /// @param actualOut The actual out amount the user received\n    error TooLittleOut(uint256 minOut, uint256 actualOut);\n\n    IUniswapV3Factory constant FACTORY = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n\n    /// @notice executes a swap on the Uniswap\n    /// @param pool The pool to swap on\n    /// @param recipient The address to send the output to\n    /// @param zeroForOne Whether to swap token0 for token1 or vice versa\n    /// @param amountSpecified The amount of token0 or token1 to swap\n    /// @param minOut The minimum amount of token0 or token1 to receive\n    /// @param sqrtPriceLimitX96 The price limit for the swap\n    /// @param data Any data to pass to the uniswap callback handler\n    /// @return amountOut The amount of token0 or token1 received\n    /// @return amountIn The amount of token0 or token1 sent\n    function swap(\n        address pool,\n        address recipient,\n        bool zeroForOne,\n        uint256 amountSpecified,\n        uint256 minOut,\n        uint160 sqrtPriceLimitX96,\n        bytes memory data\n    ) internal returns (uint256 amountOut, uint256 amountIn) {\n        (int256 amount0, int256 amount1) = IUniswapV3Pool(pool).swap(\n            recipient,\n            zeroForOne,\n            amountSpecified.toInt256(),\n            sqrtPriceLimitX96 == 0\n                ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                : sqrtPriceLimitX96,\n            data\n        );\n\n        if (zeroForOne) {\n            amountOut = uint256(-amount1);\n            amountIn = uint256(amount0);\n        } else {\n            amountOut = uint256(-amount0);\n            amountIn = uint256(amount1);\n        }\n\n        if (amountOut < minOut) {\n            revert TooLittleOut(amountOut, minOut);\n        }\n    }\n\n    /// @notice initializes a UniswapV3 pool with the given sqrt ratio\n    /// @param tokenA the first token in the pool\n    /// @param tokenB the second token in the pool\n    /// @param feeTier the fee tier of the pool\n    /// @param sqrtRatio the sqrt ratio to initialize the pool with\n    /// @return pool the address of the newly created pool\n    function deployAndInitPool(address tokenA, address tokenB, uint24 feeTier, uint160 sqrtRatio)\n        internal\n        returns (address)\n    {\n        IUniswapV3Pool pool = IUniswapV3Pool(FACTORY.createPool(tokenA, tokenB, feeTier));\n        pool.initialize(sqrtRatio);\n\n        return address(pool);\n    }\n\n    /// @notice returns the current price tick of a UniswapV3 pool\n    /// @param pool the address of the pool\n    /// @return tick the current price tick of the pool\n    function poolCurrentTick(address pool) internal returns (int24) {\n        (, int24 tick,,,,,) = IUniswapV3Pool(pool).slot0();\n\n        return tick;\n    }\n\n    /// @notice returns whether or not two pools have the same tokens\n    /// @param pool1 the first pool\n    /// @param pool2 the second pool\n    /// @return same whether or not the two pools have the same tokens\n    function poolsHaveSameTokens(address pool1, address pool2) internal view returns (bool) {\n        return IUniswapV3Pool(pool1).token0() == IUniswapV3Pool(pool2).token0()\n            && IUniswapV3Pool(pool1).token1() == IUniswapV3Pool(pool2).token1();\n    }\n\n    /// @notice returns whether or not a pool is a UniswapV3 pool\n    /// @param pool the address of the pool\n    /// @return isUniswapPool whether or not the pool is a UniswapV3 pool\n    function isUniswapPool(address pool) internal view returns (bool) {\n        IUniswapV3Pool p = IUniswapV3Pool(pool);\n        PoolAddress.PoolKey memory k = PoolAddress.getPoolKey(p.token0(), p.token1(), p.fee());\n        return pool == PoolAddress.computeAddress(address(FACTORY), k);\n    }\n\n    /// @notice returns the sqrt ratio at which token0 and token1 are trading at 1:1\n    /// @param token0ONE 10 ** token0.decimals()\n    /// @param token1ONE 10 ** token1.decimals()\n    /// @return sqrtRatio at which token0 and token1 are trading at 1:1\n    function oneToOneSqrtRatio(uint256 token0ONE, uint256 token1ONE) internal pure returns (uint160) {\n        return TickMath.getSqrtRatioAtTick(TickMath.getTickAtSqrtRatio(uint160((token1ONE << 96) / token0ONE)) / 2);\n    }\n}"
    },
    {
      "filename": "src/NFTEDA/extensions/NFTEDAStarterIncentive.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {INFTEDA} from \"../interfaces/INFTEDA.sol\";\nimport {NFTEDA} from \"../NFTEDA.sol\";\n\ncontract NFTEDAStarterIncentive is NFTEDA {\n    struct AuctionState {\n        /// @dev the time the auction started\n        uint96 startTime;\n        /// @dev who called to start the auction\n        address starter;\n    }\n\n    /// @notice emitted when auction creator discount is set\n    /// @param discount the new auction creator discount\n    /// expressed as a percent scaled by 1e18\n    /// i.e. 1e18 = 100%\n    event SetAuctionCreatorDiscount(uint256 discount);\n\n    /// @notice The percent discount the creator of an auction should\n    /// receive, compared to the current price\n    /// 1e18 = 100%\n    uint256 public auctionCreatorDiscountPercentWad;\n    uint256 internal _pricePercentAfterDiscount;\n\n    /// @notice returns the auction state for a given auctionID\n    /// @dev auctionID => AuctionState\n    mapping(uint256 => AuctionState) public auctionState;\n\n    constructor(uint256 _auctionCreatorDiscountPercentWad) {\n        _setCreatorDiscount(_auctionCreatorDiscountPercentWad);\n    }\n\n    /// @inheritdoc INFTEDA\n    function auctionStartTime(uint256 id) public view virtual override returns (uint256) {\n        return auctionState[id].startTime;\n    }\n\n    /// @inheritdoc NFTEDA\n    function _setAuctionStartTime(uint256 id) internal virtual override {\n        auctionState[id] = AuctionState({startTime: uint96(block.timestamp), starter: msg.sender});\n    }\n\n    /// @inheritdoc NFTEDA\n    function _clearAuctionState(uint256 id) internal virtual override {\n        delete auctionState[id];\n    }\n\n    /// @inheritdoc NFTEDA\n    function _auctionCurrentPrice(uint256 id, uint256 startTime, INFTEDA.Auction memory auction)\n        internal\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        uint256 price = super._auctionCurrentPrice(id, startTime, auction);\n\n        if (msg.sender == auctionState[id].starter) {\n            price = FixedPointMathLib.mulWadUp(price, _pricePercentAfterDiscount);\n        }\n\n        return price;\n    }\n\n    /// @notice sets the discount offered to auction creators\n    /// @param _auctionCreatorDiscountPercentWad the percent off the spot auction price the creator will be offered\n    /// scaled by 1e18, i.e. 1e18 = 1 = 100%\n    function _setCreatorDiscount(uint256 _auctionCreatorDiscountPercentWad) internal virtual {\n        auctionCreatorDiscountPercentWad = _auctionCreatorDiscountPercentWad;\n        _pricePercentAfterDiscount = FixedPointMathLib.WAD - _auctionCreatorDiscountPercentWad;\n\n        emit SetAuctionCreatorDiscount(_auctionCreatorDiscountPercentWad);\n    }\n}"
    },
    {
      "filename": "src/NFTEDA/interfaces/INFTEDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\ninterface INFTEDA {\n    /// @notice struct containing all auction info\n    /// @dev this struct is never stored, only a hash of it\n    struct Auction {\n        // the nft owner\n        address nftOwner;\n        // the nft token id\n        uint256 auctionAssetID;\n        // the nft contract address\n        ERC721 auctionAssetContract;\n        // How much the auction price will decay in each period\n        // expressed as percent scaled by 1e18, i.e. 1e18 = 100%\n        uint256 perPeriodDecayPercentWad;\n        // the number of seconds in the period over which perPeriodDecay occurs\n        uint256 secondsInPeriod;\n        // the auction start price\n        uint256 startPrice;\n        // the payment asset and quote asset for startPrice\n        ERC20 paymentAsset;\n    }\n\n    /// @notice emitted when an auction is started\n    /// @param auctionID the id of the auction that was started\n    /// @param auctionAssetID the token id of the ERC721 asset being auctioned\n    /// @param auctionAssetContract the contract address of the ERC721 asset being auctioned\n    /// @param nftOwner the owner of the ERC721 asset being auctioned\n    /// @param perPeriodDecayPercentWad How much the auction price will decay in each period\n    /// @param secondsInPeriod the number of seconds in the period over which perPeriodDecay occurs\n    /// @param startPrice the starting price of the auction\n    /// @param paymentAsset the payment asset and quote asset for startPrice\n    event StartAuction(\n        uint256 indexed auctionID,\n        uint256 indexed auctionAssetID,\n        ERC721 indexed auctionAssetContract,\n        address nftOwner,\n        uint256 perPeriodDecayPercentWad,\n        uint256 secondsInPeriod,\n        uint256 startPrice,\n        ERC20 paymentAsset\n    );\n\n    /// @param auctionID the id of the auction that has ended\n    /// @param price the price that the purchaser paid to receive the ERC721 asset being auctioned\n    event EndAuction(uint256 indexed auctionID, uint256 price);\n\n    /// @notice Returns the current price of the passed auction, reverts if no such auction exists\n    /// @param auction The auction for which the caller wants to know the current price\n    /// @return price the current amount required to purchase the NFT being sold in this auction\n    function auctionCurrentPrice(Auction calldata auction) external view returns (uint256);\n\n    /// @notice Returns a uint256 used to identify the auction\n    /// @dev Derived from the auction. Identitical auctions cannot exist simultaneously\n    /// @param auction The auction to get an ID for\n    /// @return id the id of this auction\n    function auctionID(Auction memory auction) external pure returns (uint256);\n\n    /// @notice Returns the time at which startAuction was most recently successfully called for the given auction id\n    /// @param id The id of the auction\n    function auctionStartTime(uint256 id) external view returns (uint256);\n}"
    },
    {
      "filename": "src/NFTEDA/libraries/EDAPrice.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeCast} from \"v3-core/contracts/libraries/SafeCast.sol\";\n\nlibrary EDAPrice {\n    using SafeCast for uint256;\n\n    function currentPrice(\n        uint256 startPrice,\n        uint256 secondsElapsed,\n        uint256 secondsInPeriod,\n        uint256 perPeriodDecayPercentWad\n    ) internal view returns (uint256) {\n        uint256 ratio = FixedPointMathLib.divWadDown(secondsElapsed, secondsInPeriod);\n        uint256 percentWadR"
    }
  ]
}