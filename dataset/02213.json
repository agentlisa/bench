{
  "Title": "H-1: Deposit allows for stealing underlying tokens from TruefiProvider, IdleProvider, YearnProvider, BetaProvider, CompoundProvider and AaveProvider balances",
  "Content": "# Issue H-1: Deposit allows for stealing underlying tokens from TruefiProvider, IdleProvider, YearnProvider, BetaProvider, CompoundProvider and AaveProvider balances \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/411 \n\n## Found by \nhyh\n\n## Summary\n\nTruefiProvider, IdleProvider, YearnProvider deposit() accept both underlying and yield bearing tokens from user and allow for stealing all underlying tokens from contract balances whenever there is a real yield bearing token for it.\n\n## Vulnerability Detail\n\nConsider the following, for TruefiProvider case:\n\nAttacker needs to supply fake pre-cooked `_uToken`, real `_tToken`, and `_amount = IERC20(real_uToken).balanceOf(address(this))`.\n\nFake `_uToken` will report exactly `_amount` balance increase after safeTransferFrom() call.\n\nTruefiProvider will join real `_tToken` with all balance of its own, and send all the proceeds to `msg.sender`.\n\n## Impact\n\nAny underlying tokens for which there is a market can be stolen from Provider balance.\n\nEven if all these contracts aren't supposed to hold balances, there are a spectre of cases when they end up possessing some meaningful funds (accumulated residuals, additional rewards supplied from the markets, user operational mistakes), which are attributed to protocol users, but can be stolen this way.\n\n## Code Snippet\n\nTruefiProvider's deposit():\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/TruefiProvider.sol#L19-L41\n\n```solidity\n  function deposit(\n    uint256 _amount,\n    address _tToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_tToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 tTokenBefore = ITruefi(_tToken).balanceOf(address(this));\n    ITruefi(_tToken).join(_amount);\n    uint256 tTokenAfter = ITruefi(_tToken).balanceOf(address(this));\n\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\n\n    ITruefi(_tToken).transfer(msg.sender, tTokensReceived);\n\n    return tTokensReceived;\n  }\n```\n\nSimilarly, IdleProvider's deposit() also allows for stealing balance of any token for which there exists Idle market:\n\nAttacker needs to supply fake pre-cooked `_uToken`, real `_iToken`, and `_amount = IERC20(real_uToken).balanceOf(address(this))`.\n\nFake `_uToken` will report exactly `_amount` balance increase after safeTransferFrom() call.\n\nIdleProvider will mint real `_iToken` with all `real_uToken` balance of its own (`_amount`), and send all the proceeds to `msg.sender`:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/IdleProvider.sol#L20-L42\n\n```solidity\n  function deposit(\n    uint256 _amount,\n    address _iToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_iToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 tTokenBefore = IIdle(_iToken).balanceOf(address(this));\n    // expensive mint\n    IIdle(_iToken).mintIdleToken(_amount, true, address(0));\n    uint256 tTokenAfter = IIdle(_iToken).balanceOf(address(this));\n\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\n    IIdle(_iToken).transfer(msg.sender, tTokensReceived);\n\n    return tTokensReceived;\n  }\n```\n\nSimilarly, YearnProvider's deposit() also allows for stealing balance of any token for which there exists Yearn market:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/YearnProvider.sol#L19-L36\n\n```solidity\n  function deposit(\n    uint256 _amount,\n    address _yToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_yToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 yTokenReceived = IYearn(_yToken).deposit(_amount);\n    IYearn(_yToken).transfer(msg.sender, yTokenReceived);\n\n    return yTokenReceived;\n  }\n```\n\nSame with BetaProvider deposit(), fake `_uToken` can just report current real underlying token balance of BetaProvider and real `_bToken` minted from that is sent to `msg.sender`:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/BetaProvider.sol#L19-L40\n\n```solidity\n  function deposit(\n    uint256 _amount,\n    address _bToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_bToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 tTokenBefore = IBeta(_bToken).balanceOf(address(this));\n    IBeta(_bToken).mint(address(this), _amount);\n    uint256 tTokenAfter = IBeta(_bToken).balanceOf(address(this));\n\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\n    IBeta(_bToken).transfer(msg.sender, tTokensReceived);\n\n    return tTokensReceived;\n  }\n```\n\nSame with CompoundProvider deposit(), fake `_uToken` can just report current real underlying token balance and real `_cToken` minted from that is send to `msg.sender`:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L27-L48\n\n```solidity\n  function deposit(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_cToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 cTokenBefore = ICToken(_cToken).balanceOf(address(this));\n    require(ICToken(_cToken).mint(_amount) == 0, \"Error minting Compound\");\n    uint256 cTokenAfter = ICToken(_cToken).balanceOf(address(this));\n\n    uint cTokensReceived = cTokenAfter - cTokenBefore;\n    ICToken(_cToken).transfer(msg.sender, cTokensReceived);\n\n    return cTokensReceived;\n  }\n```\n\nSame with AaveProvider deposit(), fake `_uToken` reports current real underlying token balance of AaveProvider, real `_aToken` deposits it on behalf of `msg.sender`:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/AaveProvider.sol#L20-L41\n\n```solidity\n  function deposit(\n    uint256 _amount,\n    address _aToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(address(IAToken(_aToken).POOL()), _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    IALendingPool(IAToken(_aToken).POOL()).deposit(\n      IAToken(_aToken).UNDERLYING_ASSET_ADDRESS(),\n      _amount,\n      msg.sender,\n      0\n    );\n\n    return _amount;\n  }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOne way is maintaining a whitelist mapping {underlying token -> yield bearing token -> acceptance flag}. The flag for the pair used in a call is then required to proceed.\n\nAlso, a balance check for token that is sent to a user can be useful: for attacker to benefit the token that is sent to them has to be real, so another approach is controlling its balance of the contract before and after the operation, and require that no loss of the initial balance took place.\n\nA version of that is implemented in CompoundProvider's withdraw(), where real token balance ends up controlled, as an example:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L56-L84\n\n```solidity\n  function withdraw(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\n\n    require(\n      ICToken(_cToken).transferFrom(msg.sender, address(this), _amount) == true,\n      \"Error: transferFrom\"\n    );\n    // Compound redeem: 0 on success, otherwise an Error code\n    require(ICToken(_cToken).redeem(_amount) == 0, \"Error: compound redeem\");\n\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\n\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n    require(\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\n      \"Error Withdraw: under/overflow\"\n    );\n\n    return uTokensReceived;\n  }\n```\n\n\n\n## Discussion\n\n**sjoerdsommen**\n\nno real issue cause provider never has a balance of the underlying\n\n**hrishibhat**\n\nGiven that the providers can hold some funds through secondary rewards or other operations mistakes, loss of these funds is not considered a valid high/medium based on Sherlock rules. \nConsidering this issue as low\n\n**dmitriia**\n\nEscalate for 10 USDC\nThe only requirements for token to be stolen is that it should have the market for itself. I.e. it can be a reward token that is distributed to Provider that performs the deposits, but there should be a market for it in the same Provider.\n\nThis condition is actually satisfied in Beta Finance case.\n\nThere are BETA rewards distributed to stablecoin markets on mainnet:\n\nhttps://app.betafinance.org/\n\nThe major part of yield there is BETA rewards, say it is 0.01% USDC + 2.87% BETA APY for USDC market:\n\nhttps://app.betafinance.org/deposit/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\n\nAnd there is market for BETA token:\n\nhttps://app.betafinance.org/deposit/0xbe1a001fe942f96eea22ba08783140b9dcc09d28\n\nAs mentioned in 360 comments, there is a shortcoming of the current design, that treats Vault as the destination of reward tokens, while it is Provider address interacting with the markets and Vault address has literally no link with the pools, so if the additional non-underlying rewards are due, they be due to the Provider's address.\n\nIt is assumed that `govToken` should end up being on the Vault balance:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L404-L419\n\n```solidity\n  function claimTokens() public {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n>>    bool claim = controller.claim(vaultNumber, i);\n      if (claim) {\n        address govToken = controller.getGovToken(vaultNumber, i);\n>>      uint256 tokenBalance = IERC20(govToken).balanceOf(address(this));\n        Swap.swapTokensMulti(\n          Swap.SwapInOut(tokenBalance, govToken, address(vaultCurrency)),\n          controller.getUniswapParams(),\n          false\n        );\n      }\n    }\n  }\n```\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Controller.sol#L57-L70\n\n```solidity\n  function claim(\n    uint256 _vaultNumber,\n    uint256 _protocolNumber\n  ) external override onlyVault returns (bool) {\n    if (claimable[protocolInfo[_vaultNumber][_protocolNumber].LPToken]) {\n      return\n>>      IProvider(protocolInfo[_vaultNumber][_protocolNumber].provider).claim(\n          protocolInfo[_vaultNumber][_protocolNumber].LPToken,\n>>        msg.sender  // @audit it's Vault\n        );\n    } else {\n      return false;\n    }\n  }\n```\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L131-L139\n\n```solidity\n  /// @notice Claims/harvest COMP tokens from the Comptroller\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  function claim(address _cToken, address _claimer) external override returns (bool) {\n    address[] memory cTokens = new address[](1);\n    cTokens[0] = _cToken;\n>>  comptroller.claimComp(_claimer, cTokens);\n\n    return true;\n  }\n```\n\nBut it is BetaProvider address interacts with Beta markets:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/BetaProvider.sol#L19-L40\n\n```solidity\n  function deposit(\n    uint256 _amount,\n    address _bToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n>>  IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_bToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 tTokenBefore = IBeta(_bToken).balanceOf(address(this));\n>>  IBeta(_bToken).mint(address(this), _amount);\n    uint256 tTokenAfter = IBeta(_bToken).balanceOf(address(this));\n\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\n    IBeta(_bToken).transfer(msg.sender, tTokensReceived);\n\n    return tTokensReceived;\n  }\n```\n\nAnd BetaProvider can have BETA part of the yield as the result of withdrawal:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/BetaProvider.sol#L48-L75\n\n```solidity\n  function withdraw(\n    uint256 _amount,\n    address _bToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\n\n    require(\n      IBeta(_bToken).transferFrom(msg.sender, address(this), _amount) == true,\n      \"Error: transferFrom\"\n    );\n>>  IBeta(_bToken).burn(address(this), _amount);\n\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\n\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n    require(\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\n      \"Error Withdraw: under/overflow\"\n    );\n\n    return uTokensReceived;\n  }\n```\n\nThis way the reward portion of the yield for the whole Vault can be stolen fully, as it will sit on the BetaProvider balance in the form of BETA tokens and there is a market for these tokens in Beta Finance, so this looks like valid high severity and needs to be fixed.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> The only requirements for token to be stolen is that it should have the market for itself. I.e. it can be a reward token that is distributed to Provider that performs the deposits, but there should be a market for it in the same Provider.\n> \n> This condition is actually satisfied in Beta Finance case.\n> \n> There are BETA rewards distributed to stablecoin markets on mainnet:\n> \n> https://app.betafinance.org/\n> \n> The major part of yield there is BETA rewards, say it is 0.01% USDC + 2.87% BETA APY for USDC market:\n> \n> https://app.betafinance.org/deposit/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\n> \n> And there is market for BETA token:\n> \n> https://app.betafinance.org/deposit/0xbe1a001fe942f96eea22ba08783140b9dcc09d28\n> \n> As mentioned in 360 comments, there is a shortcoming of the current design, that treats Vault as the destination of reward tokens, while it is Provider address interacting with the markets and Vault address has literally no link with the pools, so if the additional non-underlying rewards are due, they be due to the Provider's address.\n> \n> It is assumed that `govToken` should end up being on the Vault balance:\n> \n> https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L404-L419\n> \n> ```solidity\n>   function claimTokens() public {\n>     uint256 latestID = controller.latestProtocolId(vaultNumber);\n>     for (uint i = 0; i < latestID; i++) {\n>       if (currentAllocations[i] == 0) continue;\n> >>    bool claim = controller.claim(vaultNumber, i);\n>       if (claim) {\n>         address govToken = controller.getGovToken(vaultNumber, i);\n> >>      uint256 tokenBalance = IERC20(govToken).balanceOf(address(this));\n>         Swap.swapTokensMulti(\n>           Swap.SwapInOut(tokenBalance, govToken, address(vaultCurrency)),\n>           controller.getUniswapParams(),\n>           false\n>         );\n>       }\n>     }\n>   }\n> ```\n> \n> https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Controller.sol#L57-L70\n> \n> ```solidity\n>   function claim(\n>     uint256 _vaultNumber,\n>     uint256 _protocolNumber\n>   ) external override onlyVault returns (bool) {\n>     if (claimable[protocolInfo[_vaultNumber][_protocolNumber].LPToken]) {\n>       return\n> >>      IProvider(protocolInfo[_vaultNumber][_protocolNumber].provider).claim(\n>           protocolInfo[_vaultNumber][_protocolNumber].LPToken,\n> >>        msg.sender  // @audit it's Vault\n>         );\n>     } else {\n>       return false;\n>     }\n>   }\n> ```\n> \n> https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L131-L139\n> \n> ```solidity\n>   /// @notice Claims/harvest COMP tokens from the Comptroller\n>   /// @param _cToken Address of protocol LP Token eg cUSDC\n>   function claim(address _cToken, address _claimer) external override returns (bool) {\n>     address[] memory cTokens = new address[](1);\n>     cTokens[0] = _cToken;\n> >>  comptroller.claimComp(_claimer, cTokens);\n> \n>     return true;\n>   }\n> ```\n> \n> But it is BetaProvider address interacts with Beta markets:\n> \n> https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/BetaProvider.sol#L19-L40\n> \n> ```solidity\n>   function deposit(\n>     uint256 _amount,\n>     address _bToken,\n>     address _uToken\n>   ) external override returns (uint256) {\n>     uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n> \n> >>  IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n>     IERC20(_uToken).safeIncreaseAllowance(_bToken, _amount);\n> \n>     uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n>     require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n> \n>     uint256 tTokenBefore = IBeta(_bToken).balanceOf(address(this));\n> >>  IBeta(_bToken).mint(address(this), _amount);\n>     uint256 tTokenAfter = IBeta(_bToken).balanceOf(address(this));\n> \n>     uint tTokensReceived = tTokenAfter - tTokenBefore;\n>     IBeta(_bToken).transfer(msg.sender, tTokensReceived);\n> \n>     return tTokensReceived;\n>   }\n> ```\n> \n> And BetaProvider can have BETA part of the yield as the result of withdrawal:\n> \n> https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/BetaProvider.sol#L48-L75\n> \n> ```solidity\n>   function withdraw(\n>     uint256 _amount,\n>     address _bToken,\n>     address _uToken\n>   ) external override returns (uint256) {\n>     uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n> \n>     uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\n> \n>     require(\n>       IBeta(_bToken).transferFrom(msg.sender, address(this), _amount) == true,\n>       \"Error: transferFrom\"\n>     );\n> >>  IBeta(_bToken).burn(address(this), _amount);\n> \n>     uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\n>     uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\n> \n>     IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\n> \n>     uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n>     require(\n>       (balanceAfter - balanceBefore - uTokensReceived) == 0,\n>       \"Error Withdraw: under/overflow\"\n>     );\n> \n>     return uTokensReceived;\n>   }\n> ```\n> \n> This way the reward portion of the yield for the whole Vault can be stolen fully, as it will sit on the BetaProvider balance in the form of BETA tokens and there is a market for these tokens in Beta Finance, so this looks like valid high severity and needs to be fixed.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering issues #359 and #360  duplicates of this issue.\nThese issues point to different ways in which the rewards in the provider can be stolen. \nHowever, considering the fact that derby protocol optimizes yield, this issue points towards the fact that the provider could eventually end up with some additional rewards/gov tokens from different protocols(which is not expected) and they can be lost/stolen. \nConsidering this issue a valid high in this case.\n\nNote:\n@sjoerdsommen care must be taken while adding code to sweep these additional rewards to avoid attacks mentioned in this issue and its duplicates. \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering issues #359 and #369 duplicates of this issue. \n> These issues point to different ways in which the rewards in the provider can be stolen. \n> However, considering the fact that derby protocol optimizes yield, this issue points towards the fact that the provider could eventually end up with some additional rewards/gov tokens from different protocols(which is not expected) and they can be lost/stolen. \n> Considering this issue a valid high in this case.\n> \n> Note:\n> @sjoerdsommen care must be taken while adding code to sweep these additional rewards to avoid attacks mentioned in this issue and its duplicates. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**hrishibhat**\n\nNote:\nThe primary reason for considering the 3 issues collectively is that they identify the additional rewards being collected in these providers which is not originally intended. \nSo being able to steal them is not a primary issue because these providers were not supposed to have any underlying balance in the first place. \nThis is a subjective decision in this case after further discussion & consideration, and cannot be referenced for future contests. \nHowever, Sherlock will consider addressing such scenarios in the judging guide going forward. \n\n**Theezr**\n\nFix:\nhttps://github.com/derbyfinance/derby-yield-optimiser/pull/201\n\nClaiming rewards will be added on #290 \n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/Providers/TruefiProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../Interfaces/ExternalInterfaces/ITruefi.sol\";\nimport \"../Interfaces/IProvider.sol\";\n\ncontract TruefiProvider is IProvider {\n  using SafeERC20 for IERC20;\n\n  /// @notice Deposit the underlying asset in TrueFi\n  /// @dev Pulls underlying asset from Vault, deposit them in TrueFi, send tTokens back.\n  /// @param _amount Amount to deposit\n  /// @param _tToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Tokens received and sent to vault\n  function deposit(\n    uint256 _amount,\n    address _tToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_tToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 tTokenBefore = ITruefi(_tToken).balanceOf(address(this));\n    ITruefi(_tToken).join(_amount);\n    uint256 tTokenAfter = ITruefi(_tToken).balanceOf(address(this));\n\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\n\n    ITruefi(_tToken).transfer(msg.sender, tTokensReceived);\n\n    return tTokensReceived;\n  }\n\n  /// @notice Withdraw the underlying asset from TrueFi\n  /// @dev Pulls tTokens from Vault, redeem them from TrueFi, send underlying back.\n  /// @param _amount Amount to withdraw\n  /// @param _tToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Underlying tokens received and sent to vault e.g USDC\n  function withdraw(\n    uint256 _amount,\n    address _tToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\n\n    require(\n      ITruefi(_tToken).transferFrom(msg.sender, address(this), _amount) == true,\n      \"Error: transferFrom\"\n    );\n    ITruefi(_tToken).liquidExit(_amount);\n\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\n\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n    require(\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\n      \"Error Withdraw: under/overflow\"\n    );\n\n    return uTokensReceived;\n  }\n\n  /// @notice Get balance from address in underlying token\n  /// @dev balance = poolvalue * shares / totalsupply\n  /// @param _address Address to request balance from, most likely an Vault\n  /// @param _tToken Address of protocol LP Token eg cUSDC\n  /// @return balance in underlying token\n  function balanceUnderlying(\n    address _address,\n    address _tToken\n  ) public view override returns (uint256) {\n    uint256 balanceShares = balance(_address, _tToken);\n    uint256 currentBalance = (ITruefi(_tToken).poolValue() * balanceShares) /\n      ITruefi(_tToken).totalSupply();\n    return currentBalance;\n  }\n\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev shares = totalsupply * balance / poolvalue\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _tToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _tToken) external view override returns (uint256) {\n    uint256 shares = (ITruefi(_tToken).totalSupply() * _amount) / ITruefi(_tToken).poolValue();\n    return shares;\n  }\n\n  /// @notice Get balance of cToken from address\n  /// @param _address Address to request balance from\n  /// @param _tToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function balance(address _address, address _tToken) public view override returns (uint256) {\n    return ITruefi(_tToken).balanceOf(_address);\n  }\n\n  /// @notice Exchange rate of underyling protocol token\n  /// @dev returned price from compound is scaled by 1e18\n  /// @param _tToken Address of protocol LP Token eg cUSDC\n  /// @return price of LP token\n  function exchangeRate(address _tToken) public view override returns (uint256) {\n    uint256 poolValue = ITruefi(_tToken).poolValue();\n    uint256 totalSupply = ITruefi(_tToken).totalSupply();\n    return (poolValue * 1E6) / totalSupply;\n  }\n\n  function claim(address _tToken, address _claimer) external override returns (bool) {}\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/IdleProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IIdle.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\ncontract IdleProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Idle\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Idle, send tTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _iToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_iToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 tTokenBefore = IIdle(_iToken).balanceOf(address(this));\r\n    // expensive mint\r\n    IIdle(_iToken).mintIdleToken(_amount, true, address(0));\r\n    uint256 tTokenAfter = IIdle(_iToken).balanceOf(address(this));\r\n\r\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\r\n    IIdle(_iToken).transfer(msg.sender, tTokensReceived);\r\n\r\n    return tTokensReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Idle\r\n  /// @dev Pulls tTokens from Vault, redeem them from Idle, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _iToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    require(\r\n      IIdle(_iToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    IIdle(_iToken).redeemIdleToken(_amount);\r\n\r\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\r\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\r\n\r\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in underlying token\r\n  /// @dev balance = poolvalue * shares / totalsupply\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return balance in underlying token\r\n  function balanceUnderlying(\r\n    address _address,\r\n    address _iToken\r\n  ) public view override returns (uint256) {\r\n    uint256 balanceShares = balance(_address, _iToken);\r\n    uint256 price = exchangeRate(_iToken);\r\n    uint256 decimals = IERC20Metadata(IIdle(_iToken).token()).decimals();\r\n    return (balanceShares * price) / 10 ** decimals;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev shares = totalsupply * balance / poolvalue\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _iToken) external view override returns (uint256) {\r\n    uint256 decimals = IERC20Metadata(IIdle(_iToken).token()).decimals();\r\n    uint256 shares = (_amount * (10 ** decimals)) / exchangeRate(_iToken);\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of cToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _iToken) public view override returns (uint256) {\r\n    return IIdle(_iToken).balanceOf(_address);\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @param _iToken Address of protocol LP Token eg yUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _iToken) public view override returns (uint256) {\r\n    return IIdle(_iToken).tokenPrice();\r\n  }\r\n\r\n  function claim(address _iToken, address _claimer) external override returns (bool) {}\r\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/YearnProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IYearn.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\ncontract YearnProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Yearn\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Yearn, send yTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _yToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_yToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 yTokenReceived = IYearn(_yToken).deposit(_amount);\r\n    IYearn(_yToken).transfer(msg.sender, yTokenReceived);\r\n\r\n    return yTokenReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Yearn\r\n  /// @dev Pulls cTokens from Vault, redeem them from Yearn, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _yToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    require(\r\n      IYearn(_yToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error transferFrom\"\r\n    );\r\n\r\n    uint256 uAmountReceived = IYearn(_yToken).withdraw(_amount);\r\n    IERC20(_uToken).safeTransfer(msg.sender, uAmountReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uAmountReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uAmountReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in shares i.e LP tokens\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @return Balance in VaultCurrency e.g USDC\r\n  function balanceUnderlying(\r\n    address _address,\r\n    address _yToken\r\n  ) public view override returns (uint256) {\r\n    uint256 balanceShares = balance(_address, _yToken);\r\n    uint256 price = exchangeRate(_yToken);\r\n    return (balanceShares * price) / 10 ** IYearn(_yToken).decimals();\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev Yearn scales price by 1E6\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _yToken) external view override returns (uint256) {\r\n    uint256 shares = (_amount * (10 ** IYearn(_yToken).decimals())) / exchangeRate(_yToken);\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of yToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _yToken) public view override returns (uint256) {\r\n    uint256 balanceShares = IYearn(_yToken).balanceOf(_address);\r\n    return balanceShares;\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _yToken) public view override returns (uint256) {\r\n    uint256 price = IYearn(_yToken).pricePerShare();\r\n    return price;\r\n  }\r\n\r\n  function claim(address _yToken, address _claimer) public override returns (bool) {}\r\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/BetaProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IBeta.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\ncontract BetaProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Idle\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Idle, send tTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _bToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_bToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 tTokenBefore = IBeta(_bToken).balanceOf(address(this));\r\n    IBeta(_bToken).mint(address(this), _amount);\r\n    uint256 tTokenAfter = IBeta(_bToken).balanceOf(address(this));\r\n\r\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\r\n    IBeta(_bToken).transfer(msg.sender, tTokensReceived);\r\n\r\n    return tTokensReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Idle\r\n  /// @dev Pulls tTokens from Vault, redeem them from Idle, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _bToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    require(\r\n      IBeta(_bToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    IBeta(_bToken).burn(address(this), _amount);\r\n\r\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\r\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\r\n\r\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in underlying token\r\n  /// @dev balance = poolvalue * shares / totalsupply\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @return balance in underlying token\r\n  function balanceUnderlying(\r\n    address _address,\r\n    address _bToken\r\n  ) public view override returns (uint256) {\r\n    uint256 balanceShares = balance(_address, _bToken);\r\n    uint256 supply = IBeta(_bToken).totalSupply();\r\n    uint256 totalLoanable = IBeta(_bToken).totalLoanable();\r\n    uint256 totalLoan = IBeta(_bToken).totalLoan();\r\n\r\n    return (balanceShares * (totalLoanable + totalLoan)) / supply;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev shares = totalsupply * balance / poolvalue\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _bToken) external view override returns (uint256) {\r\n    uint256 supply = IBeta(_bToken).totalSupply();\r\n    uint256 totalLoanable = IBeta(_bToken).totalLoanable();\r\n    uint256 totalLoan = IBeta(_bToken).totalLoan();\r\n\r\n    return (_amount * supply) / (totalLoanable + totalLoan);\r\n  }\r\n\r\n  /// @notice Get balance of cToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _bToken) public view override returns (uint256) {\r\n    return IBeta(_bToken).balanceOf(_address);\r\n  }\r\n\r\n  /// @notice Not used for Beta\r\n  /// @param _bToken Address of protocol LP Token eg yUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _bToken) public view override returns (uint256) {\r\n    // return IBeta(_bToken).tokenPrice();\r\n  }\r\n\r\n  function claim(address _bToken, address _claimer) external override returns (bool) {}\r\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../Interfaces/ExternalInterfaces/ICToken.sol\";\nimport \"../Interfaces/ExternalInterfaces/IComptroller.sol\";\nimport \"../Interfaces/IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n  using SafeERC20 for IERC20;\n\n  IComptroller public comptroller;\n\n  constructor(address _comptroller) {\n    comptroller = IComptroller(_comptroller);\n  }\n\n  /// @notice Deposit the underlying asset in Compound\n  /// @dev Pulls underlying asset from Vault, deposit them in Compound, send cTokens back.\n  /// @param _amount Amount to deposit\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Tokens received and sent to vault\n  function deposit(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_cToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 cTokenBefore = ICToken(_cToken).balanceOf(address(this));\n    require(ICToken(_cToken).mint(_amount) == 0, \"Error minting Compound\");\n    uint256 cTokenAfter = ICToken(_cToken).balanceOf(address(this));\n\n    uint cTokensReceived = cTokenAfter - cTokenBefore;\n    ICToken(_cToken).transfer(msg.sender, cTokensReceived);\n\n    return cTokensReceived;\n  }\n\n  /// @notice Withdraw the underlying asset from Compound\n  /// @dev Pulls cTokens from Vault, redeem them from Compound, send underlying back.\n  /// @param _amount Amount to withdraw\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Underlying tokens received and sent to vault e.g USDC\n  function withdraw(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\n\n    require(\n      ICToken(_cToken).transferFrom(msg.sender, address(this), _amount) == true,\n      \"Error: transferFrom\"\n    );\n    // Compound redeem: 0 on success, otherwise an Error code\n    require(ICToken(_cToken).redeem(_amount) == 0, \"Error: compound redeem\");\n\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\n\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n    require(\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\n      \"Error Withdraw: under/overflow\"\n    );\n\n    return uTokensReceived;\n  }\n\n  /// @notice Get balance from address in underlying token\n  /// @param _address Address to request balance from, most likely a Vault\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return balance in underlying token\n  function balanceUnderlying(\n    address _address,\n    address _cToken\n  ) public view override returns (uint256) {\n    uint256 balanceShares = balance(_address, _cToken);\n    // The returned exchange rate from comp is scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\n    uint256 price = exchangeRate(_cToken);\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n\n    return (balanceShares * price) / 10 ** (10 + decimals);\n  }\n\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _cToken) external view override returns (uint256) {\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n    uint256 shares = (_amount * (10 ** (10 + decimals))) / exchangeRate(_cToken);\n    return shares;\n  }\n\n  /// @notice Get balance of cToken from address\n  /// @param _address Address to request balance from\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function balance(address _address, address _cToken) public view override returns (uint256) {\n    uint256 _balanceShares = ICToken(_cToken).balanceOf(_address);\n    return _balanceShares;\n  }\n\n  /// @notice Exchange rate of underyling protocol token\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return price of LP token\n  function exchangeRate(address _cToken) public view override returns (uint256) {\n    uint256 _price = ICToken(_cToken).exchangeRateStored();\n    return _price;\n  }\n\n  /// @notice Claims/harvest COMP tokens from the Comptroller\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  function claim(address _cToken, address _claimer) external override returns (bool) {\n    address[] memory cTokens = new address[](1);\n    cTokens[0] = _cToken;\n    comptroller.claimComp(_claimer, cTokens);\n\n    return true;\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/AaveProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IAToken.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IALendingPool.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\ncontract AaveProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Aave\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Aave, send aTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _aToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(address(IAToken(_aToken).POOL()), _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    IALendingPool(IAToken(_aToken).POOL()).deposit(\r\n      IAToken(_aToken).UNDERLYING_ASSET_ADDRESS(),\r\n      _amount,\r\n      msg.sender,\r\n      0\r\n    );\r\n\r\n    return _amount;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Aave\r\n  /// @dev Pulls cTokens from Vault, redeem them from Aave, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _aToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    require(\r\n      IAToken(_aToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    uint256 uTokensReceived = IALendingPool(IAToken(_aToken).POOL()).withdraw(\r\n      IAToken(_aToken).UNDERLYING_ASSET_ADDRESS(),\r\n      _amount,\r\n      msg.sender\r\n    );\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in shares i.e LP tokens\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balanceUnderlying(\r\n    address _address,\r\n    address _aToken\r\n  ) public view override returns (uint256) {\r\n    uint256 balanceShares = balance(_address, _aToken);\r\n    return balanceShares;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev Aave exchangeRate is 1\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _aToken) external view override returns (uint256) {\r\n    uint256 shares = _amount / exchangeRate(_aToken);\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of aToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _aToken) public view override returns (uint256) {\r\n    uint256 _balanceShares = IAToken(_aToken).balanceOf(_address);\r\n    return _balanceShares;\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @dev Aave exchangeRate is always 1\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _aToken) public pure override returns (uint256) {\r\n    return 1;\r\n  }\r\n\r\n  function claim(address _aToken, address _claimer) public override returns (bool) {}\r\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../Interfaces/ExternalInterfaces/ICToken.sol\";\nimport \"../Interfaces/ExternalInterfaces/IComptroller.sol\";\nimport \"../Interfaces/IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n  using SafeERC20 for IERC20;\n\n  IComptroller public comptroller;\n\n  constructor(address _comptroller) {\n    comptroller = IComptroller(_comptroller);\n  }\n\n  /// @notice Deposit the underlying asset in Compound\n  /// @dev Pulls underlying asset from Vault, deposit them in Compound, send cTokens back.\n  /// @param _amount Amount to deposit\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Tokens received and sent to vault\n  function deposit(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_cToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 cTokenBefore = ICToken(_cToken).balanceOf(address(this));\n    require(ICToken(_cToken).mint(_amount) == 0, \"Error minting Compound\");\n    uint256 cTokenAfter = ICToken(_cToken).balanceOf(address(this));\n\n    uint cTokensReceived = cTokenAfter - cTokenBefore;\n    ICToken(_cToken).transfer(msg.sender, cTokensReceived);\n\n    return cTokensReceived;\n  }\n\n  /// @notice Withdraw the underlying asset from Compound\n  /// @dev Pulls cTokens from Vault, redeem them from Compound, send underlying back.\n  /// @param _amount Amount to withdraw\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Underlying tokens received and sent to vault e.g USDC\n  function withdraw(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\n\n    require(\n      ICToken(_cToken).transferFrom(msg.sender, address(this), _amount) == true,\n      \"Error: transferFrom\"\n    );\n    // Compound redeem: 0 on success, otherwise an Error code\n    require(ICToken(_cToken).redeem(_amount) == 0, \"Error: compound redeem\");\n\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\n\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n    require(\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\n      \"Error Withdraw: under/overflow\"\n    );\n\n    return uTokensReceived;\n  }\n\n  /// @notice Get balance from address in underlying token\n  /// @param _address Address to request balance from, most likely a Vault\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return balance in underlying t"
    }
  ]
}