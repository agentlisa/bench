{
  "Title": "[N-01] Avoid hardcoding data in BridgedERC1155",
  "Content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L52)\n\nInstead of hardcoding the data, place it in a constant variable and assign the variables here for better maintainability.\n```solidity\nFile: BridgedERC1155.sol\n53:         LibBridgedToken.validateInputs(_srcToken, _srcChainId, \"foo\", \"foo\");\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/tokenvault/BridgedERC1155.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport \"../common/EssentialContract.sol\";\nimport \"./LibBridgedToken.sol\";\n\n/// @title BridgedERC1155\n/// @notice Contract for bridging ERC1155 tokens across different chains.\n/// @custom:security-contact security@taiko.xyz\ncontract BridgedERC1155 is EssentialContract, IERC1155MetadataURIUpgradeable, ERC1155Upgradeable {\n    /// @notice Address of the source token contract.\n    address public srcToken;\n\n    /// @notice Source chain ID where the token originates.\n    uint256 public srcChainId;\n\n    /// @dev Symbol of the bridged token.\n    string private __symbol;\n\n    /// @dev Name of the bridged token.\n    string private __name;\n\n    uint256[46] private __gap;\n\n    error BTOKEN_CANNOT_RECEIVE();\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    /// @param _srcToken Address of the source token.\n    /// @param _srcChainId Source chain ID.\n    /// @param _symbol Symbol of the bridged token.\n    /// @param _name Name of the bridged token.\n    function init(\n        address _owner,\n        address _addressManager,\n        address _srcToken,\n        uint256 _srcChainId,\n        string memory _symbol,\n        string memory _name\n    )\n        external\n        initializer\n    {\n        // Check if provided parameters are valid.\n        // The symbol and the name can be empty for ERC1155 tokens so we use some placeholder data\n        // for them instead.\n        LibBridgedToken.validateInputs(_srcToken, _srcChainId, \"foo\", \"foo\");\n        __Essential_init(_owner, _addressManager);\n        __ERC1155_init(LibBridgedToken.buildURI(_srcToken, _srcChainId));\n\n        srcToken = _srcToken;\n        srcChainId = _srcChainId;\n        __symbol = _symbol;\n        __name = _name;\n    }\n\n    /// @dev Mints tokens.\n    /// @param _to Address to receive the minted tokens.\n    /// @param _tokenId ID of the token to mint.\n    /// @param _amount Amount of tokens to mint.\n    function mint(\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount\n    )\n        public\n        nonReentrant\n        whenNotPaused\n        onlyFromNamed(\"erc1155_vault\")\n    {\n        _mint(_to, _tokenId, _amount, \"\");\n    }\n\n    /// @dev Mints tokens.\n    /// @param _to Address to receive the minted tokens.\n    /// @param _tokenIds ID of the token to mint.\n    /// @param _amounts Amount of tokens to mint.\n    function mintBatch(\n        address _to,\n        uint256[] memory _tokenIds,\n        uint256[] memory _amounts\n    )\n        public\n        nonReentrant\n        whenNotPaused\n        onlyFromNamed(\"erc1155_vault\")\n    {\n        _mintBatch(_to, _tokenIds, _amounts, \"\");\n    }\n\n    /// @dev Burns tokens.\n    /// @param _account Address from which tokens are burned.\n    /// @param _tokenId ID of the token to burn.\n    /// @param _amount Amount of tokens to burn.\n    function burn(\n        address _account,\n        uint256 _tokenId,\n        uint256 _amount\n    )\n        public\n        nonReentrant\n        whenNotPaused\n        onlyFromNamed(\"erc1155_vault\")\n    {\n        _burn(_account, _tokenId, _amount);\n    }\n\n    /// @notice Gets the name of the bridged token.\n    /// @return The name.\n    function name() public view returns (string memory) {\n        return LibBridgedToken.buildName(__name, srcChainId);\n    }\n\n    /// @notice Gets the symbol of the bridged token.\n    /// @return The symbol.\n    function symbol() public view returns (string memory) {\n        return LibBridgedToken.buildSymbol(__symbol);\n    }\n\n    function _beforeTokenTransfer(\n        address, /*_operator*/\n        address, /*_from*/\n        address _to,\n        uint256[] memory, /*_ids*/\n        uint256[] memory, /*_amounts*/\n        bytes memory /*_data*/\n    )\n        internal\n        virtual\n        override\n    {\n        if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE();\n        if (paused()) revert INVALID_PAUSE_STATUS();\n    }\n}"
    }
  ]
}