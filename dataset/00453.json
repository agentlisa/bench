{
  "Title": "M-34: mTOFT's fees cannot be paid on native wrapping",
  "Content": "# Issue M-34: mTOFT's fees cannot be paid on native wrapping \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/146 \n\n## Found by \nJohn\\_Femi, Tendency, bin2chen, hyh\n## Summary\n\nmTOFT tries to pay the fees twice on native wrapping, so these operations will fail unless some extra donation is made.\n\n## Vulnerability Detail\n\n`mintFee` is being transferred twice, which will revert the most calls. The core functionality of native tokens wrapping is unavailable.\n\nZero fee isn't feasible for production, so native token wrapping will be unavailable in production.\n\n## Impact\n\nWrapping of the native tokens into mTOFT is a base function of the protocol. Core contract functionality unavailability has high severity.\n\n## Code Snippet\n\n`_checkAndExtractFees()`, being called by `wrap()`, transfers `feeAmount = (_amount * mintFee) / 1e5` to the Vault:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/mTOFT.sol#L408-L423\n\n```solidity\n    function _checkAndExtractFees(uint256 _amount) private returns (uint256 feeAmount) {\n        feeAmount = 0;\n\n        // not on host chain; extract fee\n        // fees are used to rebalance liquidity to host chain\n        if (_getChainId() != hostEid && mintFee > 0) {\n>>          feeAmount = (_amount * mintFee) / 1e5;\n            if (feeAmount > 0) {\n                if (erc20 == address(0)) {\n>>                  vault.registerFees{value: feeAmount}(feeAmount);\n                } else {\n                    vault.registerFees(feeAmount);\n                }\n            }\n        }\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/TOFTVault.sol#L78-L82\n\n```solidity\n    /// @notice register fees for mTOFT\n>>  function registerFees(uint256 amount) external payable onlyOwner {\n        if (msg.value > 0 && msg.value != amount) revert FeesAmountNotRight();\n        _fees += amount;\n    }\n```\n\nWhen it's native wrapping immediately thereafter `wrap()` calls `_wrapNative()`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/mTOFT.sol#L287-L306\n\n```solidity\n    function wrap(address _fromAddress, address _toAddress, uint256 _amount)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (uint256 minted)\n    {\n        if (balancers[msg.sender]) revert mTOFT_BalancerNotAuthorized();\n        if (!connectedChains[_getChainId()]) revert mTOFT_NotHost();\n        if (mintCap > 0) {\n            if (totalSupply() + _amount > mintCap) revert mTOFT_CapNotValid();\n        }\n\n>>      uint256 feeAmount = _checkAndExtractFees(_amount);\n        if (erc20 == address(0)) {\n>>          _wrapNative(_toAddress, _amount, feeAmount);\n        } else {\n            if (msg.value > 0) revert mTOFT_NotNative();\n            _wrap(_fromAddress, _toAddress, _amount, feeAmount);\n        }\n```\n\nWhich tries to send the whole `_amount` to the Vault:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/BaseTOFT.sol#L78-L81\n\n```solidity\n    function _wrapNative(address _toAddress, uint256 _amount, uint256 _feeAmount) internal virtual {\n>>      vault.depositNative{value: _amount}();\n        _mint(_toAddress, _amount - _feeAmount);\n    }\n```\n\nI.e. unless `_amount + feeAmount` is present on the contract balance, the operation will revert.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSince `depositNative()` doesn't have any amount specific logic:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/TOFTVault.sol#L94-L98\n\n```solidity\n    /// @notice deposit native gas to vault\n    function depositNative() external payable onlyOwner {\n        if (!_isNative) revert NotValid();\n        if (msg.value == 0) revert ZeroAmount();\n    }\n```\n\nConsider reducing the amount attached to the deposit call, e.g.:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/BaseTOFT.sol#L78-L81\n\n```diff\n    function _wrapNative(address _toAddress, uint256 _amount, uint256 _feeAmount) internal virtual {\n-       vault.depositNative{value: _amount}();\n+       vault.depositNative{value: _amount - _feeAmount}();\n        _mint(_toAddress, _amount - _feeAmount);\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**WangAudit** commented:\n> refer to 65\n\n\n\n**cryptotechmaker**\n\nDuplicate of https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/65\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/TapiocaZ/pull/184.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/tOFT/mTOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n//LZ\nimport {IMessagingChannel} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\";\nimport {MessagingReceipt, OFTReceipt} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OAppReceiver} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol\";\nimport {Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\n\n// External\nimport {ERC20Permit, ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\n// Tapioca\nimport {\n    ITOFT,\n    TOFTInitStruct,\n    TOFTModulesInitStruct,\n    LZSendParam,\n    ERC20PermitStruct,\n    IToftVault\n} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {BaseTapiocaOmnichainEngine} from \"tapioca-periph/tapiocaOmnichainEngine/BaseTapiocaOmnichainEngine.sol\";\nimport {TapiocaOmnichainSender} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainSender.sol\";\nimport {IStargateReceiver} from \"tapioca-periph/interfaces/external/stargate/IStargateReceiver.sol\";\nimport {TOFTReceiver} from \"./modules/TOFTReceiver.sol\";\nimport {TOFTSender} from \"./modules/TOFTSender.sol\";\nimport {BaseTOFT} from \"./BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title mTOFT\n * @author TapiocaDAO\n * @notice Tapioca OFT wrapper contract that is connected with multiple chains\n * @dev It can be wrapped and unwrapped on multiple connected chains\n */\ncontract mTOFT is BaseTOFT, Pausable, ReentrancyGuard, ERC20Permit, IStargateReceiver {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice allowed chains where you can unwrap your TOFT\n     */\n    mapping(uint256 => bool) public connectedChains;\n\n    /**\n     * @notice map of approved balancers\n     * @dev a balancer can extract the underlying\n     */\n    mapping(address => bool) public balancers;\n\n    /**\n     * @notice max mTOFT mintable\n     */\n    uint256 public mintCap;\n\n    /**\n     * @notice current non-host chain mint fee\n     */\n    uint256 public mintFee;\n\n    address private _stargateRouter;\n\n    event StargateRouterUpdated(address indexed _old, address indexed _new);\n\n    /**\n     * @notice event emitted when a connected chain is reigstered or unregistered\n     */\n    event ConnectedChainStatusUpdated(uint256 indexed _chain, bool indexed _old, bool indexed _new);\n\n    /**\n     * @notice event emitted when balancer status is updated\n     */\n    event BalancerStatusUpdated(address indexed _balancer, bool indexed _bool, bool indexed _new);\n\n    /**\n     * @notice event emitted when rebalancing is performed\n     */\n    event Rebalancing(address indexed _balancer, uint256 indexed _amount, bool indexed _isNative);\n\n    error mTOFT_NotNative();\n    error mTOFT_NotHost();\n    error mTOFT_BalancerNotAuthorized();\n    error mTOFT_NotAuthorized();\n    error mTOFT_CapNotValid();\n    error mTOFT_Failed();\n\n    constructor(TOFTInitStruct memory _tOFTData, TOFTModulesInitStruct memory _modulesData, address _stgRouter)\n        BaseTOFT(_tOFTData)\n        ERC20Permit(_tOFTData.name)\n    {\n        if (_getChainId() == hostEid) {\n            connectedChains[hostEid] = true;\n        }\n\n        mintCap = 1_000_000 * 1e18; // TOFT is always in 18 decimals\n        mintFee = 5e2; // 0.5%\n\n        // Set TOFT execution modules\n        if (_modulesData.tOFTSenderModule == address(0)) revert TOFT_NotValid();\n        if (_modulesData.tOFTReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.marketReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.optionsReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.genericReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n\n        _setModule(uint8(ITOFT.Module.TOFTSender), _modulesData.tOFTSenderModule);\n        _setModule(uint8(ITOFT.Module.TOFTReceiver), _modulesData.tOFTReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTMarketReceiver), _modulesData.marketReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTOptionsReceiver), _modulesData.optionsReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTGenericReceiver), _modulesData.genericReceiverModule);\n\n        _stargateRouter = _stgRouter;\n\n        vault = IToftVault(_tOFTData.vault);\n        vault.claimOwnership();\n\n        if (address(vault._token()) != erc20) revert TOFT_VaultWrongERC20();\n    }\n\n    /**\n     * @dev Fallback function should handle calls made by endpoint, which should go to the receiver module.\n     */\n    fallback() external payable {\n        /// @dev Call the receiver module on fallback, assume it's gonna be called by endpoint.\n        _executeModule(uint8(ITOFT.Module.TOFTReceiver), msg.data, false);\n    }\n\n    receive() external payable {}\n\n    function transferFrom(address from, address to, uint256 value)\n        public\n        override(BaseTapiocaOmnichainEngine, ERC20)\n        returns (bool)\n    {\n        return BaseTapiocaOmnichainEngine.transferFrom(from, to, value);\n    }\n\n    /**\n     * @dev Slightly modified version of the OFT _lzReceive() operation.\n     * The composed message is sent to `address(this)` instead of `toAddress`.\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * @dev _executor The address of the executor.\n     * @dev _extraData Additional data.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor, // @dev unused in the default implementation.\n        bytes calldata _extraData // @dev unused in the default implementation.\n    ) public payable override {\n        // Call the internal OApp implementation of lzReceive.\n        _executeModule(\n            uint8(ITOFT.Module.TOFTReceiver),\n            abi.encodeWithSelector(OAppReceiver.lzReceive.selector, _origin, _guid, _message, _executor, _extraData),\n            false\n        );\n    }\n\n    /**\n     * @notice Execute a call to a module.\n     * @dev Example on how `_data` should be encoded:\n     *      - abi.encodeCall(IERC20.transfer, (to, amount));\n     * @dev Use abi.encodeCall to encode the function call and its parameters with type safety.\n     *\n     * @param _module The module to execute.\n     * @param _data The data to execute. Should be ABI encoded with the selector.\n     * @param _forwardRevert If true, forward the revert message from the module.\n     *\n     * @return returnData The return data from the module execution, if any.\n     */\n    function executeModule(ITOFT.Module _module, bytes memory _data, bool _forwardRevert)\n        external\n        payable\n        whenNotPaused\n        returns (bytes memory returnData)\n    {\n        return _executeModule(uint8(_module), _data, _forwardRevert);\n    }\n\n    /**\n     * @dev Slightly modified version of the OFT send() operation. Includes a `_msgType` parameter.\n     * The `_buildMsgAndOptionsByType()` appends the packet type to the message.\n     * @dev Executes the send operation.\n     * @param _lzSendParam The parameters for the send operation.\n     *      - _sendParam: The parameters for the send operation.\n     *          - dstEid::uint32: Destination endpoint ID.\n     *          - to::bytes32: Recipient address.\n     *          - amountToSendLD::uint256: Amount to send in local decimals.\n     *          - minAmountToCreditLD::uint256: Minimum amount to credit in local decimals.\n     *      - _fee: The calculated fee for the send() operation.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     *      - _extraOptions::bytes: Additional options for the send() operation.\n     *      - refundAddress::address: The address to refund the native fee to.\n     * @param _composeMsg The composed message for the send() operation. Is a combination of 1 or more TAP specific messages.\n     *\n     * @return msgReceipt The receipt for the send operation.\n     *      - guid::bytes32: The unique identifier for the sent message.\n     *      - nonce::uint64: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     * @return oftReceipt The OFT receipt information.\n     *      - amountDebitLD::uint256: Amount of tokens ACTUALLY debited in local decimals.\n     *      - amountCreditLD::uint256: Amount of tokens to be credited on the remote side.\n     */\n    function sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n        public\n        payable\n        whenNotPaused\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        (msgReceipt, oftReceipt) = abi.decode(\n            _executeModule(\n                uint8(ITOFT.Module.TOFTSender),\n                abi.encodeCall(TapiocaOmnichainSender.sendPacket, (_lzSendParam, _composeMsg)),\n                false\n            ),\n            (MessagingReceipt, OFTReceipt)\n        );\n    }\n\n    /// =====================\n    /// View\n    /// =====================\n\n    /**\n     * @dev Returns the hash of the struct used by the permit function.\n     * @param _permitData Struct containing permit data.\n     */\n    function getTypedDataHash(ERC20PermitStruct calldata _permitData) public view returns (bytes32) {\n        bytes32 permitTypeHash_ =\n            keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n        bytes32 structHash_ = keccak256(\n            abi.encode(\n                permitTypeHash_,\n                _permitData.owner,\n                _permitData.spender,\n                _permitData.value,\n                _permitData.nonce,\n                _permitData.deadline\n            )\n        );\n        return _hashTypedDataV4(structHash_);\n    }\n\n    /// =====================\n    /// External\n    /// =====================\n    /**\n     * @notice Wrap an ERC20 with a fee if existing.\n     * @dev Minted amount might be less than requested amount. see `mintFee`\n     * @param _fromAddress The address to wrap from.\n     * @param _toAddress The address to wrap the ERC20 to.\n     * @param _amount The amount of ERC20 to wrap.\n     *\n     * @return minted The mtOFT minted amount.\n     */\n    function wrap(address _fromAddress, address _toAddress, uint256 _amount)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (uint256 minted)\n    {\n        if (balancers[msg.sender]) revert mTOFT_BalancerNotAuthorized();\n        if (!connectedChains[_getChainId()]) revert mTOFT_NotHost();\n        if (mintCap > 0) {\n            if (totalSupply() + _amount > mintCap) revert mTOFT_CapNotValid();\n        }\n\n        uint256 feeAmount = _checkAndExtractFees(_amount);\n        if (erc20 == address(0)) {\n            _wrapNative(_toAddress, _amount, feeAmount);\n        } else {\n            if (msg.value > 0) revert mTOFT_NotNative();\n            _wrap(_fromAddress, _toAddress, _amount, feeAmount);\n        }\n\n        return _amount - feeAmount;\n    }\n\n    /**\n     * @notice Unwrap an ERC20/Native with a 1:1 ratio.\n     * @param _toAddress The address to wrap the ERC20 to.\n     * @param _amount The amount of tokens to unwrap.\n     */\n    function unwrap(address _toAddress, uint256 _amount) external nonReentrant whenNotPaused {\n        if (!connectedChains[_getChainId()]) revert mTOFT_NotHost();\n        if (balancers[msg.sender]) revert mTOFT_BalancerNotAuthorized();\n        _unwrap(_toAddress, _amount);\n    }\n\n    /**\n     * @notice needed for Stargate Router to receive funds from Balancer.sol contract\n     * @param amountLD Amount to deposit\n     */\n    function sgReceive(uint16, bytes memory, uint256, address, uint256 amountLD, bytes memory) external payable {\n        if (msg.sender != _stargateRouter) revert mTOFT_NotAuthorized();\n\n        if (erc20 == address(0)) {\n            vault.depositNative{value: amountLD}();\n        } else {\n            IERC20(erc20).safeTransfer(address(vault), amountLD);\n        }\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n    /**\n     * @notice rescues unused ETH from the contract\n     * @param amount the amount to rescue\n     * @param to the recipient\n     */\n    function rescueEth(uint256 amount, address to) external onlyOwner {\n        (bool success,) = to.call{value: amount}(\"\");\n        if (!success) revert mTOFT_Failed();\n    }\n\n    /**\n     * @notice sets the owner state\n     */\n    struct SetOwnerStateData {\n        address stargateRouter;\n        uint256 mintFee;\n        uint256 mintCap;\n        // connected chains\n        uint256 connectedChain;\n        bool connectedChainState;\n        // balancer\n        address balancerStateAddress;\n        bool balancerState;\n    }\n\n    function setOwnerState(SetOwnerStateData memory _data) external onlyOwner {\n        if (_stargateRouter != _data.stargateRouter) {\n            _stargateRouter = _data.stargateRouter;\n        }\n        if (mintFee != _data.mintFee) {\n            mintFee = _data.mintFee;\n        }\n        if (mintCap != _data.mintCap) {\n            if (_data.mintCap < totalSupply()) revert mTOFT_CapNotValid();\n            mintCap = _data.mintCap;\n        }\n        if (connectedChains[_data.connectedChain] != _data.connectedChainState) {\n            connectedChains[_data.connectedChain] = _data.connectedChainState;\n        }\n        if (balancers[_data.balancerStateAddress] != _data.balancerState) {\n            balancers[_data.balancerStateAddress] = _data.balancerState;\n        }\n    }\n\n    /**\n     * @notice withdraw fees from Vault.\n     * @param _to receiver; usually Balancer.sol contract\n     * @param _amount the fees amount\n     */\n    function withdrawFees(address _to, uint256 _amount) external onlyOwner {\n        vault.transferFees(_to, _amount);\n    }\n\n    /**\n     * @notice extracts the underlying token/native for rebalancing\n     * @param _amount the amount used for rebalancing\n     */\n    function extractUnderlying(uint256 _amount) external nonReentrant {\n        if (!balancers[msg.sender]) revert mTOFT_BalancerNotAuthorized();\n        if (_amount == 0) revert TOFT_NotValid();\n\n        vault.withdraw(msg.sender, _amount);\n\n        emit Rebalancing(msg.sender, _amount, erc20 == address(0));\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _checkAndExtractFees(uint256 _amount) private returns (uint256 feeAmount) {\n        feeAmount = 0;\n\n        // not on host chain; extract fee\n        // fees are used to rebalance liquidity to host chain\n        if (_getChainId() != hostEid && mintFee > 0) {\n            feeAmount = (_amount * mintFee) / 1e5;\n            if (feeAmount > 0) {\n                if (erc20 == address(0)) {\n                    vault.registerFees{value: feeAmount}(feeAmount);\n                } else {\n                    vault.registerFees(feeAmount);\n                }\n            }\n        }\n    }\n    /**\n     * @notice Return the current chain EID.\n     */\n\n    function _getChainId() internal view override returns (uint32) {\n        return IMessagingChannel(endpoint).eid();\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/tOFT/TOFTVault.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTVault\n * @author TapiocaDAO\n * @notice Holds TOFT funds\n */\ncontract TOFTVault is Ownable {\n    using SafeERC20 for IERC20;\n\n    address public _token;\n    bool private _isNative;\n    uint256 private _fees;\n\n    error NotValid();\n    error ZeroAmount();\n    error Failed();\n    error FeesAmountNotRight();\n    error AmountNotRight();\n    error OwnerSet();\n\n    constructor(address token_) {\n        _token = token_;\n        _isNative = token_ == address(0);\n\n        _transferOwnership(address(0));\n    }\n\n    /// =====================\n    /// View\n    /// =====================\n    /// @notice returns total active supply including fees\n    function viewTotalSupply() external view returns (uint256) {\n        return viewSupply() + viewFees();\n    }\n\n    /// @notice returns total active supply\n    /// @dev fees are not taken into account\n    function viewSupply() public view returns (uint256) {\n        if (_isNative) {\n            return address(this).balance - _fees;\n        }\n        return IERC20(_token).balanceOf(address(this)) - _fees;\n    }\n\n    /// @notice returns fees amount\n    function viewFees() public view returns (uint256) {\n        return _fees;\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n\n    /// @dev Intended to be called once by the TOFT contract\n    function claimOwnership() external {\n        if (owner() != address(0)) revert OwnerSet();\n        _transferOwnership(msg.sender);\n    }\n\n    /// @notice register fees for mTOFT\n    function registerFees(uint256 amount) external payable onlyOwner {\n        if (msg.value > 0 && msg.value != amount) revert FeesAmountNotRight();\n        _fees += amount;\n    }\n\n    /// @notice transfers fees out of the vault\n    /// @dev the receiver is usually the Balancer.sol contract\n    /// @param to receiver\n    /// @param amount the extracted amount\n    function transferFees(address to, uint256 amount) external onlyOwner {\n        if (amount > _fees) revert FeesAmountNotRight();\n        _fees -= amount;\n        _withdraw(to, amount);\n    }\n\n    /// @notice deposit native gas to vault\n    function depositNative() external payable onlyOwner {\n        if (!_isNative) revert NotValid();\n        if (msg.value == 0) revert ZeroAmount();\n    }\n\n    /// @notice extracts from vault\n    /// @param to receiver\n    /// @param amount the extracted amount\n    function withdraw(address to, uint256 amount) external onlyOwner {\n        _withdraw(to, amount);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _withdraw(address to, uint256 amount) private {\n        if (amount > viewSupply()) revert AmountNotRight();\n        if (_isNative) {\n            (bool success,) = to.call{value: amount}(\"\");\n            if (!success) revert Failed();\n        } else {\n            IERC20(_token).safeTransfer(to, amount);\n        }\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/tOFT/mTOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n//LZ\nimport {IMessagingChannel} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\";\nimport {MessagingReceipt, OFTReceipt} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OAppReceiver} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol\";\nimport {Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\n\n// External\nimport {ERC20Permit, ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\n// Tapioca\nimport {\n    ITOFT,\n    TOFTInitStruct,\n    TOFTModulesInitStruct,\n    LZSendParam,\n    ERC20PermitStruct,\n    IToftVault\n} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {BaseTapiocaOmnichainEngine} from \"tapioca-periph/tapiocaOmnichainEngine/BaseTapiocaOmnichainEngine.sol\";\nimport {TapiocaOmnichainSender} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainSender.sol\";\nimport {IStargateReceiver} from \"tapioca-periph/interfaces/external/stargate/IStargateReceiver.sol\";\nimport {TOFTReceiver} from \"./modules/TOFTReceiver.sol\";\nimport {TOFTSender} from \"./modules/TOFTSender.sol\";\nimport {BaseTOFT} from \"./BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title mTOFT\n * @author TapiocaDAO\n * @notice Tapioca OFT wrapper contract that is connected with multiple chains\n * @dev It can be wrapped and unwrapped on multiple connected chains\n */\ncontract mTOFT is BaseTOFT, Pausable, ReentrancyGuard, ERC20Permit, IStargateReceiver {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice allowed chains where you can unwrap your TOFT\n     */\n    mapping(uint256 => bool) public connectedChains;\n\n    /**\n     * @notice map of approved balancers\n     * @dev a balancer can extract the underlying\n     */\n    mapping(address => bool) public balancers;\n\n    /**\n     * @notice max mTOFT mintable\n     */\n    uint256 public mintCap;\n\n    /**\n     * @notice current non-host chain mint fee\n     */\n    uint256 public mintFee;\n\n    address private _stargateRouter;\n\n    event StargateRouterUpdated(address indexed _old, address indexed _new);\n\n    /**\n     * @notice event emitted when a connected chain is reigstered or unregistered\n     */\n    event ConnectedChainStatusUpdated(uint256 indexed _chain, bool indexed _old, bool indexed _new);\n\n    /**\n     * @notice event emitted when balancer status is updated\n     */\n    event BalancerStatusUpdated(address indexed _balancer, bool indexed _bool, bool indexed _new);\n\n    /**\n     * @notice event emitted when rebalancing is performed\n     */\n    event Rebalancing(address indexed _balancer, uint256 indexed _amount, bool indexed _isNative);\n\n    error mTOFT_NotNative();\n    error mTOFT_NotHost();\n    error mTOFT_BalancerNotAuthorized();\n    error mTOFT_NotAuthorized();\n    error mTOFT_CapNotValid();\n    error mTOFT_Failed();\n\n    constructor(TOFTInitStruct memory _tOFTData, TOFTModulesInitStruct memory _modulesData, address _stgRouter)\n        BaseTOFT(_tOFTData)\n        ERC20Permit(_tOFTData.name)\n    {\n        if (_getChainId() == hostEid) {\n            connectedChains[hostEid] = true;\n        }\n\n        mintCap = 1_000_000 * 1e18; // TOFT is always in 18 decimals\n        mintFee = 5e2; // 0.5%\n\n        // Set TOFT execution modules\n        if (_modulesData.tOFTSenderModule == address(0)) revert TOFT_NotValid();\n        if (_modulesData.tOFTReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.marketReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.optionsReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.genericReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n\n        _setModule(uint8(ITOFT.Module.TOFTSender), _modulesData.tOFTSenderModule);\n        _setModule(uint8(ITOFT.Module.TOFTReceiver), _modulesData.tOFTReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTMarketReceiver), _modulesData.marketReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTOptionsReceiver), _modulesData.optionsReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTGenericReceiver), _modulesData.genericReceiverModule);\n\n        _stargateRouter = _stgRouter;\n\n        vault = IToftVault(_tOFTData.vault);\n        vault.claimOwnership();\n\n        if (address(vault._token()) != erc20) revert TOFT_VaultWrongERC20();\n    }\n\n    /**\n     * @dev Fallback function should handle calls made by endpoint, which should go to the receiver module.\n     */\n    fallback() external payable {\n        /// @dev Call the receiver module on fallback, assume it's gonna be called by endpoint.\n        _executeModule(uint8(ITOFT.Module.TOFTReceiver), msg.data, false);\n    }\n\n    receive() external payable {}\n\n    function transferFrom(address from, address to, uint256 value)\n        public\n        override(BaseTapiocaOmnichainEngine, ERC20)\n        returns (bool)\n    {\n        return BaseTapiocaOmnichainEngine.transferFrom(from, to, value);\n    }\n\n    /**\n     * @dev Slightly modified version of the OFT _lzReceive() operation.\n     * The composed message is sent to `address(this)` instead of `toAddress`.\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * @dev _executor The address of the executor.\n     * @dev _extraData Additional data.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor, // @dev unused in the default implementation.\n        bytes calldata _extraData // @dev unused in the default implementation.\n    ) public payable override {\n        // Call the internal OApp implementation of lzReceive.\n        _executeModule(\n            uint8(ITOFT.Module.TOFTReceiver),\n            abi.encodeWithSelector(OAppReceiver.lzReceive.selector, _origin, _guid, _message, _executor, _extraData),\n            false\n        );\n    }\n\n    /**\n     * @notice Execute a call to a module.\n     * @dev Example on how `_data` should be encoded:\n     *      - abi.encodeCall(IERC20.transfer, (to, amount));\n     * @dev Use abi.encodeCall to encode the function call and its parameters with type safety.\n     *\n     * @param _module The module to execute.\n     * @param _data The data to execute. Should be ABI encoded with the selector.\n     * @param _forwardRevert If true, forward the revert message from the module.\n     *\n     * @return returnData The return data from the module execution, if any.\n     */\n    function executeModule(ITOFT.Module _module, bytes memory _data, bool _forwardRevert)\n        external\n        payable\n        whenNotPaused\n        returns (bytes memory returnData)\n    {\n        return _executeModule(uint8(_module), _data, _forwardRevert);\n    }\n\n    /**\n     * @dev Slightly modified version of the OFT send() operation. Includes a `_msgType` parameter.\n     * The `_buildMsgAndOptionsByType()` appends the packet type to the message.\n     * @dev Executes the send operation.\n     * @param _lzSendParam The parameters for the send operation.\n     *      - _sendParam: The parameters for the send operation.\n     *          - dstEid::uint32: Destination endpoint ID.\n     *          - to::bytes32: Recipient address.\n     *          - amountToSendLD::uint256: Amount to send in local decimals.\n     *          - minAmountToCreditLD::uint256: Minimum amount to credit in local decimals.\n     *      - _fee: The calculated fee for the send() operation.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     *      - _extraOptions::bytes: Additional options for the send() operation.\n     *      - refundAddress::address: The address to refund the native fee to.\n     * @param _composeMsg The composed message for the send() operation. Is a combination of 1 or more TAP specific messages.\n     *\n     * @return msgReceipt The receipt for the send operation.\n     *      - guid::bytes32: The unique identifier for the sent message.\n     *      - nonce::uint64: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     * @return oftReceipt The OFT receipt information.\n     *      - amountDebitLD::uint256: Amount of tokens ACTUALLY debited in local decimals.\n     *      - amountCreditLD::uint256: Amount of tokens to be credited on the remote side.\n     */\n    function sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n        public\n        payable\n        whenNotPaused\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        (msgReceipt, oftReceipt) = abi.decode(\n            _executeModule(\n                uint8(ITOFT.Module.TOFTSender),\n                abi.encodeCall(TapiocaOmnichainSender.sendPacket, (_lzSendParam, _composeMsg)),\n                false\n            ),\n            (MessagingReceipt, OFTReceipt)\n        );\n    }\n\n    /// =====================\n    /// View\n    /// =====================\n\n    /**\n     * @dev Returns the hash of the struct used by the permit function.\n     * @param _permitData Struct containing permit data.\n     */\n    function getTypedDataHash(ERC20PermitStruct calldata _permitData) public view returns (bytes32) {\n        bytes32 permitTypeHash_ =\n            keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n        bytes32 structHash_ = keccak256(\n            abi.encode(\n                permitTypeHash_,\n                _permitData.owner,\n                _permitData.spender,\n                _permitData.value,\n                _permitData.nonce,\n                _permitData.deadline\n            )\n        );\n        return _hashTypedDataV4(structHash_);\n    }\n\n    /// =====================\n    /// External\n    /// =====================\n    /**\n     * @notice Wrap an ERC20 with a fee if existing.\n     * @dev Minted amount might be less than requested amount. see `mintFee`\n     * @param _fromAddress The address to wrap from.\n     * @param _toAddress The address to wrap the ERC20 to.\n     * @param _amount The amount of ERC20 to wrap.\n     *\n     * @return minted The mtOFT minted amount.\n     */\n    function wrap(address _fromAddress, address _toAddress, uint256 _amount)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (uint256 minted)\n    {\n        if (balancers[msg.sender]) revert mTOFT_BalancerNotAuthorized();\n        if (!connectedChains[_getChainId()]) revert mTOFT_NotHost();\n        if (mintCap > 0) {\n            if (totalSupply() + _amount > mintCap) revert mTOFT_CapNotValid();\n        }\n\n        uint256 feeAmount = _checkAndExtractFees(_amount);\n        if (erc20 == address(0)) {\n            _wrapNative(_toAddress, _amount, feeAmount);\n        } else {\n            if (msg.value > 0) revert mTOFT_NotNative();\n            _wrap(_fromAddress, _toAddress, _amount, feeAmount);\n        }\n\n        return _amount - feeAmount;\n    }\n\n    /**\n     * @notice Unwrap an ERC20/Native with a 1:1 ratio.\n     * @param _toAddress The address to wrap the ERC20 to.\n     * @param _amount The amount of tokens to unwrap.\n     */\n    function unwrap(address _toAddress, uint256 _amount) external nonReentrant whenNotPaused {\n        if (!connectedChains[_getChainId()]) revert mTOFT_NotHost();\n        if (balancers[msg.sender]) revert mTOFT_BalancerNotAuthorized();\n        _unwrap(_toAddress, _amount);\n    }\n\n    /**\n     * @notice needed for Stargate Router to receive funds from Balancer.sol contract\n     * @param amountLD Amount to deposit\n     */\n    function sgReceive(uint16, bytes memory, uint256, address, uint256 amountLD, bytes memory) external payable {\n        if (msg"
    }
  ]
}