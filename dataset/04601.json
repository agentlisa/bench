{
  "Title": "Token contract creator has control over token emission and release",
  "Content": "Instead of the `Crowdsale` acting as owner of the token, as in most implementations (see [OpenZeppelin’s `Crowdsale`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/67d3a759a77f22116d8bf9c908ba856fa1fae5d4/contracts/crowdsale/Crowdsale.sol#L58), there is an account that retains ownership of the token. This allows the owners to appoint themselves as minting agents at any point during the crowdsale and emit new tokens, or release the token before the crowdsale ends. This reduces the public trust on the crowdsale mechanics. Move ownership of the token to the `Crowdsale` contract, and maintain control only over the upgrade mechanism by appointing the team as [`upgradeMaster`](https://github.com/CoinFabrik/ico/blob/142f43f3bec4afd0ffff3fce06946cf67cb0272f/contracts/UpgradeableToken.sol#L118).\n\n\n**Update:** Hubii replied *“As suggested in another issue the setup was changed to create all the contracts from a single contract. In this way, the `Crowdsale` contract is the owner of the `CrowdsaleToken`.”* Fixed in [`e9e05d7adc9efde724afee0facfc89e76db67efe`](https://github.com/CoinFabrik/ico/commit/e9e05d7adc9efde724afee0facfc89e76db67efe).\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/crowdsale/Crowdsale.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport '../token/MintableToken.sol';\nimport '../math/SafeMath.sol';\n\n/**\n * @title Crowdsale \n * @dev Crowdsale is a base contract for managing a token crowdsale.\n * Crowdsales have a start and end block, where investors can make\n * token purchases and the crowdsale will assign them tokens based\n * on a token per ETH rate. Funds collected are forwarded to a wallet \n * as they arrive.\n */\ncontract Crowdsale {\n  using SafeMath for uint256;\n\n  // The token being sold\n  MintableToken public token;\n\n  // start and end block where investments are allowed (both inclusive)\n  uint256 public startBlock;\n  uint256 public endBlock;\n\n  // address where funds are collected\n  address public wallet;\n\n  // how many token units a buyer gets per wei\n  uint256 public rate;\n\n  // amount of raised money in wei\n  uint256 public weiRaised;\n\n  /**\n   * event for token purchase logging\n   * @param purchaser who paid for the tokens\n   * @param beneficiary who got the tokens\n   * @param value weis paid for purchase\n   * @param amount amount of tokens purchased\n   */ \n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n\n  function Crowdsale(uint256 _startBlock, uint256 _endBlock, uint256 _rate, address _wallet) {\n    require(_startBlock >= block.number);\n    require(_endBlock >= _startBlock);\n    require(_rate > 0);\n    require(_wallet != 0x0);\n\n    token = createTokenContract();\n    startBlock = _startBlock;\n    endBlock = _endBlock;\n    rate = _rate;\n    wallet = _wallet;\n  }\n\n  // creates the token to be sold. \n  // override this method to have crowdsale of a specific mintable token.\n  function createTokenContract() internal returns (MintableToken) {\n    return new MintableToken();\n  }\n\n\n  // fallback function can be used to buy tokens\n  function () payable {\n    buyTokens(msg.sender);\n  }\n\n  // low level token purchase function\n  function buyTokens(address beneficiary) payable {\n    require(beneficiary != 0x0);\n    require(validPurchase());\n\n    uint256 weiAmount = msg.value;\n\n    // calculate token amount to be created\n    uint256 tokens = weiAmount.mul(rate);\n\n    // update state\n    weiRaised = weiRaised.add(weiAmount);\n\n    token.mint(beneficiary, tokens);\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n\n    forwardFunds();\n  }\n\n  // send ether to the fund collection wallet\n  // override to create custom fund forwarding mechanisms\n  function forwardFunds() internal {\n    wallet.transfer(msg.value);\n  }\n\n  // @return true if the transaction can buy tokens\n  function validPurchase() internal constant returns (bool) {\n    uint256 current = block.number;\n    bool withinPeriod = current >= startBlock && current <= endBlock;\n    bool nonZeroPurchase = msg.value != 0;\n    return withinPeriod && nonZeroPurchase;\n  }\n\n  // @return true if crowdsale event has ended\n  function hasEnded() public constant returns (bool) {\n    return block.number > endBlock;\n  }\n\n\n}"
    }
  ]
}