{
  "Title": "[L-09] Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions",
  "Content": "\nSee [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future.\n\n```solidity\nFile: contracts/LpToken.sol   #1\n\n10 contract LpToken is ILpToken, ERC20Upgradeable {\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/LpToken.sol#L10>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-04-backd-contest",
  "Code": [
    {
      "filename": "backd/contracts/LpToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"../libraries/ScaledMath.sol\";\nimport \"../interfaces/ILpToken.sol\";\nimport \"../interfaces/pool/ILiquidityPool.sol\";\nimport \"../libraries/Errors.sol\";\n\ncontract LpToken is ILpToken, ERC20Upgradeable {\n    using ScaledMath for uint256;\n\n    uint8 private _decimals;\n\n    address public override minter;\n\n    /**\n     * @notice Make a function only callable by the minter contract.\n     * @dev Fails if msg.sender is not the minter.\n     */\n    modifier onlyMinter() {\n        require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor() ERC20Upgradeable() {}\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address _minter\n    ) external override initializer returns (bool) {\n        require(_minter != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        __ERC20_init(name_, symbol_);\n        _decimals = decimals_;\n        minter = _minter;\n        return true;\n    }\n\n    /**\n     * @notice Mint tokens.\n     * @param account Account from which tokens should be burned.\n     * @param amount Amount of tokens to mint.\n     */\n    function mint(address account, uint256 amount) external override onlyMinter {\n        _mint(account, amount);\n    }\n\n    /**\n     * @notice Burns tokens of msg.sender.\n     * @param amount Amount of tokens to burn.\n     */\n    function burn(uint256 amount) external override {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @notice Burn tokens.\n     * @param owner Account from which tokens should be burned.\n     * @param burnAmount Amount of tokens to burn.\n     * @return Aamount of tokens burned.\n     */\n    function burn(address owner, uint256 burnAmount)\n        external\n        override\n        onlyMinter\n        returns (uint256)\n    {\n        _burn(owner, burnAmount);\n        return burnAmount;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev We notify that LP tokens have been transfered\n     * this is currently used to keep track of the withdrawal fees\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if (amount > 0) ILiquidityPool(minter).handleLpTokenTransfer(from, to, amount); // add check to not break 0 transfers\n    }\n}"
    }
  ]
}