{
  "Title": "[02] Lack of revert if price returned from oracle is zero",
  "Content": "\n`RiskFund._swapAsset()` will not revert if `getUnderlyingPrice` if the price return zero.\n\nThis might be intended to avoid making the loop in `RiskFund.swapPoolAssets()` revert if a single swap is not done. However, it might be beneficial to revert the entire transaction, since price zero means the price is unavailable.\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/RiskFund/RiskFund.sol#L174\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/RiskFund/RiskFund.sol#L240-L242\n\nhttps://github.com/VenusProtocol/venus-protocol/blob/e085f1194bd942c2e75de5787a0a84ec274c6dd4/contracts/Oracle/PriceOracle.sol#L13\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-venus",
  "Code": [
    {
      "filename": "contracts/RiskFund/RiskFund.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../VToken.sol\";\nimport \"../Pool/PoolRegistry.sol\";\nimport \"../IPancakeswapV2Router.sol\";\nimport \"./ReserveHelpers.sol\";\nimport \"./IRiskFund.sol\";\nimport \"../Shortfall/IShortfall.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport \"../MaxLoopsLimitHelper.sol\";\n\n/**\n * @dev This contract does not support BNB.\n */\ncontract RiskFund is\n    Ownable2StepUpgradeable,\n    AccessControlledV8,\n    ExponentialNoError,\n    ReserveHelpers,\n    MaxLoopsLimitHelper,\n    IRiskFund\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address private pancakeSwapRouter;\n    uint256 private minAmountToConvert;\n    address private convertibleBaseAsset;\n    address private shortfall;\n\n    // Store base asset's reserve for specific pool\n    mapping(address => uint256) public poolReserves;\n\n    /// @notice Emitted when pool registry address is updated\n    event PoolRegistryUpdated(address indexed oldPoolRegistry, address indexed newPoolRegistry);\n\n    /// @notice Emitted when shortfall contract address is updated\n    event ShortfallContractUpdated(address indexed oldShortfallContract, address indexed newShortfallContract);\n\n    /// @notice Emitted when PancakeSwap router contract address is updated\n    event PancakeSwapRouterUpdated(address indexed oldPancakeSwapRouter, address indexed newPancakeSwapRouter);\n\n    /// @notice Emitted when min amount out for PancakeSwap is updated\n    event AmountOutMinUpdated(uint256 oldAmountOutMin, uint256 newAmountOutMin);\n\n    /// @notice Emitted when minimum amount to convert is updated\n    event MinAmountToConvertUpdated(uint256 oldMinAmountToConvert, uint256 newMinAmountToConvert);\n\n    /// @notice Emitted when pools assets are swapped\n    event SwappedPoolsAssets(address[] markets, uint256[] amountsOutMin, uint256 totalAmount);\n\n    /// @notice Emitted when reserves are transferred for auction\n    event TransferredReserveForAuction(address comptroller, uint256 amount);\n\n    /// @dev Note that the contract is upgradeable. Use initialize() or reinitializers\n    ///      to set the state variables.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes the deployer to owner.\n     * @param pancakeSwapRouter_ Address of the PancakeSwap router\n     * @param minAmountToConvert_ Minimum amount assets must be worth to convert into base asset\n     * @param convertibleBaseAsset_ Address of the base asset\n     * @param accessControlManager_ Address of the access control contract\n     * @param loopsLimit_ Limit for the loops in the contract to avoid DOS\n     */\n    function initialize(\n        address pancakeSwapRouter_,\n        uint256 minAmountToConvert_,\n        address convertibleBaseAsset_,\n        address accessControlManager_,\n        uint256 loopsLimit_\n    ) external initializer {\n        require(pancakeSwapRouter_ != address(0), \"Risk Fund: Pancake swap address invalid\");\n        require(convertibleBaseAsset_ != address(0), \"Risk Fund: Base asset address invalid\");\n        require(minAmountToConvert_ > 0, \"Risk Fund: Invalid min amount to convert\");\n        require(loopsLimit_ > 0, \"Risk Fund: Loops limit can not be zero\");\n\n        __Ownable2Step_init();\n        __AccessControlled_init_unchained(accessControlManager_);\n\n        pancakeSwapRouter = pancakeSwapRouter_;\n        minAmountToConvert = minAmountToConvert_;\n        convertibleBaseAsset = convertibleBaseAsset_;\n\n        _setMaxLoopsLimit(loopsLimit_);\n    }\n\n    /**\n     * @dev Pool registry setter\n     * @param _poolRegistry Address of the pool registry.\n     */\n    function setPoolRegistry(address _poolRegistry) external onlyOwner {\n        require(_poolRegistry != address(0), \"Risk Fund: Pool registry address invalid\");\n        address oldPoolRegistry = poolRegistry;\n        poolRegistry = _poolRegistry;\n        emit PoolRegistryUpdated(oldPoolRegistry, _poolRegistry);\n    }\n\n    /**\n     * @dev Shortfall contract address setter\n     * @param shortfallContractAddress_ Address of the auction contract.\n     */\n    function setShortfallContractAddress(address shortfallContractAddress_) external onlyOwner {\n        require(shortfallContractAddress_ != address(0), \"Risk Fund: Shortfall contract address invalid\");\n        require(\n            IShortfall(shortfallContractAddress_).convertibleBaseAsset() == convertibleBaseAsset,\n            \"Risk Fund: Base asset doesn't match\"\n        );\n\n        address oldShortfallContractAddress = shortfall;\n        shortfall = shortfallContractAddress_;\n        emit ShortfallContractUpdated(oldShortfallContractAddress, shortfallContractAddress_);\n    }\n\n    /**\n     * @dev PancakeSwap router address setter\n     * @param pancakeSwapRouter_ Address of the PancakeSwap router.\n     */\n    function setPancakeSwapRouter(address pancakeSwapRouter_) external onlyOwner {\n        require(pancakeSwapRouter_ != address(0), \"Risk Fund: PancakeSwap address invalid\");\n        address oldPancakeSwapRouter = pancakeSwapRouter;\n        pancakeSwapRouter = pancakeSwapRouter_;\n        emit PancakeSwapRouterUpdated(oldPancakeSwapRouter, pancakeSwapRouter_);\n    }\n\n    /**\n     * @dev Min amount to convert setter\n     * @param minAmountToConvert_ Min amount to convert.\n     */\n    function setMinAmountToConvert(uint256 minAmountToConvert_) external {\n        _checkAccessAllowed(\"setMinAmountToConvert(uint256)\");\n        require(minAmountToConvert_ > 0, \"Risk Fund: Invalid min amount to convert\");\n        uint256 oldMinAmountToConvert = minAmountToConvert;\n        minAmountToConvert = minAmountToConvert_;\n        emit MinAmountToConvertUpdated(oldMinAmountToConvert, minAmountToConvert_);\n    }\n\n    /**\n     * @notice Swap array of pool assets into base asset's tokens of at least a mininum amount.\n     * @param markets Array of vTokens whose assets to swap for base asset\n     * @param amountsOutMin Minimum amount to recieve for swap\n     * @return Number of swapped tokens.\n     */\n    function swapPoolsAssets(\n        address[] calldata markets,\n        uint256[] calldata amountsOutMin,\n        address[][] calldata paths\n    ) external override returns (uint256) {\n        _checkAccessAllowed(\"swapPoolsAssets(address[],uint256[],address[][])\");\n        require(poolRegistry != address(0), \"Risk fund: Invalid pool registry.\");\n        require(markets.length == amountsOutMin.length, \"Risk fund: markets and amountsOutMin are unequal lengths\");\n        require(markets.length == paths.length, \"Risk fund: markets and paths are unequal lengths\");\n\n        uint256 totalAmount;\n        uint256 marketsCount = markets.length;\n\n        _ensureMaxLoops(marketsCount);\n\n        for (uint256 i; i < marketsCount; ++i) {\n            VToken vToken = VToken(markets[i]);\n            address comptroller = address(vToken.comptroller());\n\n            PoolRegistry.VenusPool memory pool = PoolRegistry(poolRegistry).getPoolByComptroller(comptroller);\n            require(pool.comptroller == comptroller, \"comptroller doesn't exist pool registry\");\n            require(Comptroller(comptroller).isMarketListed(vToken), \"market is not listed\");\n\n            uint256 swappedTokens = _swapAsset(vToken, comptroller, amountsOutMin[i], paths[i]);\n            poolReserves[comptroller] = poolReserves[comptroller] + swappedTokens;\n            totalAmount = totalAmount + swappedTokens;\n        }\n\n        emit SwappedPoolsAssets(markets, amountsOutMin, totalAmount);\n\n        return totalAmount;\n    }\n\n    /**\n     * @dev Transfer tokens for auction.\n     * @param comptroller Comptroller of the pool.\n     * @param amount Amount to be transferred to auction contract.\n     * @return Number reserved tokens.\n     */\n    function transferReserveForAuction(address comptroller, uint256 amount) external override returns (uint256) {\n        require(msg.sender == shortfall, \"Risk fund: Only callable by Shortfall contract\");\n        require(amount <= poolReserves[comptroller], \"Risk Fund: Insufficient pool reserve.\");\n        poolReserves[comptroller] = poolReserves[comptroller] - amount;\n        IERC20Upgradeable(convertibleBaseAsset).safeTransfer(shortfall, amount);\n\n        emit TransferredReserveForAuction(comptroller, amount);\n\n        return amount;\n    }\n\n    /**\n     * @notice Set the limit for the loops can iterate to avoid the DOS\n     * @param limit Limit for the max loops can execute at a time\n     */\n    function setMaxLoopsLimit(uint256 limit) external onlyOwner {\n        _setMaxLoopsLimit(limit);\n    }\n\n    /**\n     * @dev Update the reserve of the asset for the specific pool after transferring to risk fund.\n     * @param comptroller  Comptroller address(pool).\n     * @param asset Asset address.\n     */\n    function updateAssetsState(address comptroller, address asset) public override(IRiskFund, ReserveHelpers) {\n        super.updateAssetsState(comptroller, asset);\n    }\n\n    /**\n     * @dev Swap single asset to base asset.\n     * @param vToken VToken\n     * @param comptroller Comptroller address\n     * @param amountOutMin Minimum amount to receive for swap\n     * @return Number of swapped tokens.\n     */\n    function _swapAsset(\n        VToken vToken,\n        address comptroller,\n        uint256 amountOutMin,\n        address[] calldata path\n    ) internal returns (uint256) {\n        require(amountOutMin != 0, \"RiskFund: amountOutMin must be greater than 0 to swap vToken\");\n        require(amountOutMin >= minAmountToConvert, \"RiskFund: amountOutMin should be greater than minAmountToConvert\");\n        uint256 totalAmount;\n\n        address underlyingAsset = VTokenInterface(address(vToken)).underlying();\n        uint256 balanceOfUnderlyingAsset = poolsAssetsReserves[comptroller][underlyingAsset];\n\n        ComptrollerViewInterface(comptroller).oracle().updatePrice(address(vToken));\n\n        uint256 underlyingAssetPrice = ComptrollerViewInterface(comptroller).oracle().getUnderlyingPrice(\n            address(vToken)\n        );\n\n        if (balanceOfUnderlyingAsset > 0) {\n            Exp memory oraclePrice = Exp({ mantissa: underlyingAssetPrice });\n            uint256 amountInUsd = mul_ScalarTruncate(oraclePrice, balanceOfUnderlyingAsset);\n\n            if (amountInUsd >= minAmountToConvert) {\n                assetsReserves[underlyingAsset] -= balanceOfUnderlyingAsset;\n                poolsAssetsReserves[comptroller][underlyingAsset] -= balanceOfUnderlyingAsset;\n\n                if (underlyingAsset != convertibleBaseAsset) {\n                    require(path[0] == underlyingAsset, \"RiskFund: swap path must start with the underlying asset\");\n                    require(\n                        path[path.length - 1] == convertibleBaseAsset,\n                        \"RiskFund: finally path must be convertible base asset\"\n                    );\n                    IERC20Upgradeable(underlyingAsset).safeApprove(pancakeSwapRouter, 0);\n                    IERC20Upgradeable(underlyingAsset).safeApprove(pancakeSwapRouter, balanceOfUnderlyingAsset);\n                    uint256[] memory amounts = IPancakeswapV2Router(pancakeSwapRouter).swapExactTokensForTokens(\n                        balanceOfUnderlyingAsset,\n                        amountOutMin,\n                        path,\n                        address(this),\n                        block.timestamp\n                    );\n                    totalAmount = amounts[path.length - 1];\n                } else {\n                    totalAmount = balanceOfUnderlyingAsset;\n                }\n            }\n        }\n\n        return totalAmount;\n    }\n}"
    },
    {
      "filename": "contracts/RiskFund/RiskFund.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../VToken.sol\";\nimport \"../Pool/PoolRegistry.sol\";\nimport \"../IPancakeswapV2Router.sol\";\nimport \"./ReserveHelpers.sol\";\nimport \"./IRiskFund.sol\";\nimport \"../Shortfall/IShortfall.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport \"../MaxLoopsLimitHelper.sol\";\n\n/**\n * @dev This contract does not support BNB.\n */\ncontract RiskFund is\n    Ownable2StepUpgradeable,\n    AccessControlledV8,\n    ExponentialNoError,\n    ReserveHelpers,\n    MaxLoopsLimitHelper,\n    IRiskFund\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address private pancakeSwapRouter;\n    uint256 private minAmountToConvert;\n    address private convertibleBaseAsset;\n    address private shortfall;\n\n    // Store base asset's reserve for specific pool\n    mapping(address => uint256) public poolReserves;\n\n    /// @notice Emitted when pool registry address is updated\n    event PoolRegistryUpdated(address indexed oldPoolRegistry, address indexed newPoolRegistry);\n\n    /// @notice Emitted when shortfall contract address is updated\n    event ShortfallContractUpdated(address indexed oldShortfallContract, address indexed newShortfallContract);\n\n    /// @notice Emitted when PancakeSwap router contract address is updated\n    event PancakeSwapRouterUpdated(address indexed oldPancakeSwapRouter, address indexed newPancakeSwapRouter);\n\n    /// @notice Emitted when min amount out for PancakeSwap is updated\n    event AmountOutMinUpdated(uint256 oldAmountOutMin, uint256 newAmountOutMin);\n\n    /// @notice Emitted when minimum amount to convert is updated\n    event MinAmountToConvertUpdated(uint256 oldMinAmountToConvert, uint256 newMinAmountToConvert);\n\n    /// @notice Emitted when pools assets are swapped\n    event SwappedPoolsAssets(address[] markets, uint256[] amountsOutMin, uint256 totalAmount);\n\n    /// @notice Emitted when reserves are transferred for auction\n    event TransferredReserveForAuction(address comptroller, uint256 amount);\n\n    /// @dev Note that the contract is upgradeable. Use initialize() or reinitializers\n    ///      to set the state variables.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes the deployer to owner.\n     * @param pancakeSwapRouter_ Address of the PancakeSwap router\n     * @param minAmountToConvert_ Minimum amount assets must be worth to convert into base asset\n     * @param convertibleBaseAsset_ Address of the base asset\n     * @param accessControlManager_ Address of the access control contract\n     * @param loopsLimit_ Limit for the loops in the contract to avoid DOS\n     */\n    function initialize(\n        address pancakeSwapRouter_,\n        uint256 minAmountToConvert_,\n        address convertibleBaseAsset_,\n        address accessControlManager_,\n        uint256 loopsLimit_\n    ) external initializer {\n        require(pancakeSwapRouter_ != address(0), \"Risk Fund: Pancake swap address invalid\");\n        require(convertibleBaseAsset_ != address(0), \"Risk Fund: Base asset address invalid\");\n        require(minAmountToConvert_ > 0, \"Risk Fund: Invalid min amount to convert\");\n        require(loopsLimit_ > 0, \"Risk Fund: Loops limit can not be zero\");\n\n        __Ownable2Step_init();\n        __AccessControlled_init_unchained(accessControlManager_);\n\n        pancakeSwapRouter = pancakeSwapRouter_;\n        minAmountToConvert = minAmountToConvert_;\n        convertibleBaseAsset = convertibleBaseAsset_;\n\n        _setMaxLoopsLimit(loopsLimit_);\n    }\n\n    /**\n     * @dev Pool registry setter\n     * @param _poolRegistry Address of the pool registry.\n     */\n    function setPoolRegistry(address _poolRegistry) external onlyOwner {\n        require(_poolRegistry != address(0), \"Risk Fund: Pool registry address invalid\");\n        address oldPoolRegistry = poolRegistry;\n        poolRegistry = _poolRegistry;\n        emit PoolRegistryUpdated(oldPoolRegistry, _poolRegistry);\n    }\n\n    /**\n     * @dev Shortfall contract address setter\n     * @param shortfallContractAddress_ Address of the auction contract.\n     */\n    function setShortfallContractAddress(address shortfallContractAddress_) external onlyOwner {\n        require(shortfallContractAddress_ != address(0), \"Risk Fund: Shortfall contract address invalid\");\n        require(\n            IShortfall(shortfallContractAddress_).convertibleBaseAsset() == convertibleBaseAsset,\n            \"Risk Fund: Base asset doesn't match\"\n        );\n\n        address oldShortfallContractAddress = shortfall;\n        shortfall = shortfallContractAddress_;\n        emit ShortfallContractUpdated(oldShortfallContractAddress, shortfallContractAddress_);\n    }\n\n    /**\n     * @dev PancakeSwap router address setter\n     * @param pancakeSwapRouter_ Address of the PancakeSwap router.\n     */\n    function setPancakeSwapRouter(address pancakeSwapRouter_) external onlyOwner {\n        require(pancakeSwapRouter_ != address(0), \"Risk Fund: PancakeSwap address invalid\");\n        address oldPancakeSwapRouter = pancakeSwapRouter;\n        pancakeSwapRouter = pancakeSwapRouter_;\n        emit PancakeSwapRouterUpdated(oldPancakeSwapRouter, pancakeSwapRouter_);\n    }\n\n    /**\n     * @dev Min amount to convert setter\n     * @param minAmountToConvert_ Min amount to convert.\n     */\n    function setMinAmountToConvert(uint256 minAmountToConvert_) external {\n        _checkAccessAllowed(\"setMinAmountToConvert(uint256)\");\n        require(minAmountToConvert_ > 0, \"Risk Fund: Invalid min amount to convert\");\n        uint256 oldMinAmountToConvert = minAmountToConvert;\n        minAmountToConvert = minAmountToConvert_;\n        emit MinAmountToConvertUpdated(oldMinAmountToConvert, minAmountToConvert_);\n    }\n\n    /**\n     * @notice Swap array of pool assets into base asset's tokens of at least a mininum amount.\n     * @param markets Array of vTokens whose assets to swap for base asset\n     * @param amountsOutMin Minimum amount to recieve for swap\n     * @return Number of swapped tokens.\n     */\n    function swapPoolsAssets(\n        address[] calldata markets,\n        uint256[] calldata amountsOutMin,\n        address[][] calldata paths\n    ) external override returns (uint256) {\n        _checkAccessAllowed(\"swapPoolsAssets(address[],uint256[],address[][])\");\n        require(poolRegistry != address(0), \"Risk fund: Invalid pool registry.\");\n        require(markets.length == amountsOutMin.length, \"Risk fund: markets and amountsOutMin are unequal lengths\");\n        require(markets.length == paths.length, \"Risk fund: markets and paths are unequal lengths\");\n\n        uint256 totalAmount;\n        uint256 marketsCount = markets.length;\n\n        _ensureMaxLoops(marketsCount);\n\n        for (uint256 i; i < marketsCount; ++i) {\n            VToken vToken = VToken(markets[i]);\n            address comptroller = address(vToken.comptroller());\n\n            PoolRegistry.VenusPool memory pool = PoolRegistry(poolRegistry).getPoolByComptroller(comptroller);\n            require(pool.comptroller == comptroller, \"comptroller doesn't exist pool registry\");\n            require(Comptroller(comptroller).isMarketListed(vToken), \"market is not listed\");\n\n            uint256 swappedTokens = _swapAsset(vToken, comptroller, amountsOutMin[i], paths[i]);\n            poolReserves[comptroller] = poolReserves[comptroller] + swappedTokens;\n            totalAmount = totalAmount + swappedTokens;\n        }\n\n        emit SwappedPoolsAssets(markets, amountsOutMin, totalAmount);\n\n        return totalAmount;\n    }\n\n    /**\n     * @dev Transfer tokens for auction.\n     * @param comptroller Comptroller of the pool.\n     * @param amount Amount to be transferred to auction contract.\n     * @return Number reserved tokens.\n     */\n    function transferReserveForAuction(address comptroller, uint256 amount) external override returns (uint256) {\n        require(msg.sender == shortfall, \"Risk fund: Only callable by Shortfall contract\");\n        require(amount <= poolReserves[comptroller], \"Risk Fund: Insufficient pool reserve.\");\n        poolReserves[comptroller] = poolReserves[comptroller] - amount;\n        IERC20Upgradeable(convertibleBaseAsset).safeTransfer(shortfall, amount);\n\n        emit TransferredReserveForAuction(comptroller, amount);\n\n        return amount;\n    }\n\n    /**\n     * @notice Set the limit for the loops can iterate to avoid the DOS\n     * @param limit Limit for the max loops can execute at a time\n     */\n    function setMaxLoopsLimit(uint256 limit) external onlyOwner {\n        _setMaxLoopsLimit(limit);\n    }\n\n    /**\n     * @dev Update the reserve of the asset for the specific pool after transferring to risk fund.\n     * @param comptroller  Comptroller address(pool).\n     * @param asset Asset address.\n     */\n    function updateAssetsState(address comptroller, address asset) public override(IRiskFund, ReserveHelpers) {\n        super.updateAssetsState(comptroller, asset);\n    }\n\n    /**\n     * @dev Swap single asset to base asset.\n     * @param vToken VToken\n     * @param comptroller Comptroller address\n     * @param amountOutMin Minimum amount to receive for swap\n     * @return Number of swapped tokens.\n     */\n    function _swapAsset(\n        VToken vToken,\n        address comptroller,\n        uint256 amountOutMin,\n        address[] calldata path\n    ) internal returns (uint256) {\n        require(amountOutMin != 0, \"RiskFund: amountOutMin must be greater than 0 to swap vToken\");\n        require(amountOutMin >= minAmountToConvert, \"RiskFund: amountOutMin should be greater than minAmountToConvert\");\n        uint256 totalAmount;\n\n        address underlyingAsset = VTokenInterface(address(vToken)).underlying();\n        uint256 balanceOfUnderlyingAsset = poolsAssetsReserves[comptroller][underlyingAsset];\n\n        ComptrollerViewInterface(comptroller).oracle().updatePrice(address(vToken));\n\n        uint256 underlyingAssetPrice = ComptrollerViewInterface(comptroller).oracle().getUnderlyingPrice(\n            address(vToken)\n        );\n\n        if (balanceOfUnderlyingAsset > 0) {\n            Exp memory oraclePrice = Exp({ mantissa: underlyingAssetPrice });\n            uint256 amountInUsd = mul_ScalarTruncate(oraclePrice, balanceOfUnderlyingAsset);\n\n            if (amountInUsd >= minAmountToConvert) {\n                assetsReserves[underlyingAsset] -= balanceOfUnderlyingAsset;\n                poolsAssetsReserves[comptroller][underlyingAsset] -= balanceOfUnderlyingAsset;\n\n                if (underlyingAsset != convertibleBaseAsset) {\n                    require(path[0] == underlyingAsset, \"RiskFund: swap path must start with the underlying asset\");\n                    require(\n                        path[path.length - 1] == convertibleBaseAsset,\n                        \"RiskFund: finally path must be convertible base asset\"\n                    );\n                    IERC20Upgradeable(underlyingAsset).safeApprove(pancakeSwapRouter, 0);\n                    IERC20Upgradeable(underlyingAsset).safeApprove(pancakeSwapRouter, balanceOfUnderlyingAsset);\n                    uint256[] memory amounts = IPancakeswapV2Router(pancakeSwapRouter).swapExactTokensForTokens(\n                        balanceOfUnderlyingAsset,\n                        amountOutMin,\n                        path,\n                        address(this),\n                        block.timestamp\n                    );\n                    totalAmount = amounts[path.length - 1];\n                } else {\n                    totalAmount = balanceOfUnderlyingAsset;\n                }\n            }\n        }\n\n        return totalAmount;\n    }\n}"
    },
    {
      "filename": "contracts/Oracle/PriceOracle.sol",
      "content": "pragma solidity ^0.5.16;\n\nimport \"../Tokens/VTokens/VToken.sol\";\n\ncontract PriceOracle {\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\n    bool public constant isPriceOracle = true;\n\n    /**\n     * @notice Get the underlying price of a vToken asset\n     * @param vToken The vToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18).\n     *  Zero means the price is unavailable.\n     */\n    function getUnderlyingPrice(VToken vToken) external view returns (uint);\n}"
    }
  ]
}